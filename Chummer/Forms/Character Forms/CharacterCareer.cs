/*  This file is part of Chummer5a.
 *
 *  Chummer5a is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Chummer5a is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Chummer5a.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  You can obtain the full source code for Chummer5a at
 *  https://github.com/chummer5a/chummer5a
 */

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Xml;
using System.Xml.XPath;
using Chummer.Backend.Attributes;
using Chummer.Backend.Enums;
using Chummer.Backend.Equipment;
using Chummer.Backend.Skills;
using Chummer.Backend.Uniques;
using LiveCharts.Defaults;
using NLog;

namespace Chummer
{
    [DesignerCategory("Form")]
    public partial class CharacterCareer : CharacterShared
    {
        private static readonly Lazy<Logger> s_ObjLogger = new Lazy<Logger>(LogManager.GetCurrentClassLogger);
        private static Logger Log => s_ObjLogger.Value;

        private bool _blnReapplyImprovements;
        private int _intDragLevel;

        private readonly ListViewColumnSorter _lvwKarmaColumnSorter;
        private readonly ListViewColumnSorter _lvwNuyenColumnSorter;
        private DebuggableSemaphoreSlim _objKarmaChartSemaphore = new DebuggableSemaphoreSlim();
        private DebuggableSemaphoreSlim _objNuyenChartSemaphore = new DebuggableSemaphoreSlim();

        public TabControl TabCharacterTabs => tabCharacterTabs;

        private readonly Font _fntNormal;
        private readonly Font _fntStrikeout;

        #region Form Events

        private void ConstructorCommon()
        {
            InitializeComponent();
            tabSkillsUc.MyToken = GenericToken;
            tabPowerUc.MyToken = GenericToken;
        }

        [Obsolete("This constructor is for use by form designers only.", true)]
        public CharacterCareer()
        {
            ConstructorCommon();
            _fntNormal = new Font(treQualities.Font, FontStyle.Regular);
            _fntStrikeout = new Font(treQualities.Font, FontStyle.Strikeout);
        }

        public CharacterCareer(Character objCharacter) : base(objCharacter)
        {
            ConstructorCommon();
            _fntNormal = new Font(treQualities.Font, FontStyle.Regular);
            _fntStrikeout = new Font(treQualities.Font, FontStyle.Strikeout);
            tabSkillsUc.CachedCharacter = objCharacter;
            tabPowerUc.CachedCharacter = objCharacter;
            this.UpdateLightDarkMode();
            this.TranslateWinForm();
            this.UpdateParentForToolTipControls();

            ContextMenuStrip[] lstCMSToTranslate =
            {
                cmsAdvancedLifestyle,
                cmsAdvancedProgram,
                cmsAmmoExpense,
                cmsArmor,
                cmsArmorGear,
                cmsArmorLocation,
                cmsArmorMod,
                cmsBioware,
                cmsComplexForm,
                cmsCritterPowers,
                cmsCyberware,
                cmsCyberwareGear,
                cmsVehicleCyberware,
                cmsVehicleCyberwareGear,
                cmsDeleteArmor,
                cmsDeleteCyberware,
                cmsDeleteGear,
                cmsDeleteVehicle,
                cmsDeleteWeapon,
                cmsGear,
                cmsGearButton,
                cmsGearLocation,
                cmsGearPlugin,
                cmsImprovement,
                cmsImprovementLocation,
                cmsInitiationNotes,
                cmsLifestyle,
                cmsLifestyleNotes,
                cmsMartialArts,
                cmsMetamagic,
                cmsQuality,
                cmsSpell,
                cmsSpellButton,
                cmsTechnique,
                cmsUndoKarmaExpense,
                cmsUndoNuyenExpense,
                cmsVehicle,
                cmsVehicleGear,
                cmsVehicleLocation,
                cmsVehicleWeapon,
                cmsVehicleWeaponAccessory,
                cmsVehicleWeaponAccessoryGear,
                cmsWeapon,
                cmsWeaponAccessory,
                cmsWeaponAccessoryGear,
                cmsWeaponLocation,
                cmsWeaponMount
            };
            // Update the text in the Menus so they can be merged with frmMain properly.
            foreach (ToolStripMenuItem tssItem in mnuCreateMenu.Items.OfType<ToolStripMenuItem>())
            {
                tssItem.UpdateLightDarkMode();
                tssItem.TranslateToolStripItemsRecursively();
            }

            foreach (ContextMenuStrip objCMS in lstCMSToTranslate)
            {
                if (objCMS == null)
                    continue;
                foreach (ToolStripMenuItem tssItem in objCMS.Items.OfType<ToolStripMenuItem>())
                {
                    tssItem.UpdateLightDarkMode();
                    tssItem.TranslateToolStripItemsRecursively();
                }
            }

            _lvwKarmaColumnSorter = new ListViewColumnSorter
            {
                SortColumn = 0,
                Order = SortOrder.Descending
            };
            lstKarma.ListViewItemSorter = _lvwKarmaColumnSorter;
            _lvwNuyenColumnSorter = new ListViewColumnSorter
            {
                SortColumn = 0,
                Order = SortOrder.Descending
            };
            lstNuyen.ListViewItemSorter = _lvwNuyenColumnSorter;

            tabCharacterTabs.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabInfo.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabLongTexts.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabPeople.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabStreetGearTabs.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabArmorCM.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabCyberwareCM.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabGearCM.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            panVehicleCM.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabWeaponCM.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabSkillsUc.MakeDirtyWithCharacterUpdate += MakeDirtyWithCharacterUpdate;
            lmtControl.MakeDirty += MakeDirty;
        }

        private async void TreeView_KeyDown(object sender, KeyEventArgs e)
        {
            if (sender is TreeView treView && e.KeyCode == Keys.Delete)
            {
                try
                {
                    await RemoveSelectedObject(
                        await treView.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }
                catch (OperationCanceledException)
                {
                    //swallow this
                }
            }
        }

        private void TreeView_ItemDrag(object sender, ItemDragEventArgs e)
        {
            if (!(sender is TreeView treView))
                return;
            TreeNode nodSelected = treView.SelectedNode;
            object objTag = nodSelected?.Tag;
            if (objTag == null || (objTag is string strTag && (string.IsNullOrEmpty(strTag) || strTag.StartsWith("Node_"))))
                return;
            int intDragLevel = nodSelected.Level;
            if (treView == treGear)
            {
                switch (e.Button)
                {
                    case MouseButtons.Left:
                        if (intDragLevel < 0 || intDragLevel > 1)
                            return;
                        break;
                    case MouseButtons.Right:
                        if (intDragLevel == 0)
                            return;
                        break;
                    default:
                        return;
                }
            }
            else if (treView == treVehicles)
            {
                DraggingGear = objTag is Gear;
            }
            else if (intDragLevel != 1)
                return;
            _intDragLevel = intDragLevel;
            DragButton = e.Button;
            DoDragDrop(e.Item, DragDropEffects.Move);
        }

        private async void TreeView_DragDrop(object sender, DragEventArgs e)
        {
            if (!(sender is TreeView treView))
                return;
            ItemTreeViewTypes eType = ItemTreeViewTypes.Misc;
            if (treView == treWeapons)
                eType = ItemTreeViewTypes.Weapons;
            else if (treView == treArmor)
                eType = ItemTreeViewTypes.Armor;
            else if (treView == treGear)
                eType = ItemTreeViewTypes.Gear;
            else if (treView == treVehicles)
                eType = ItemTreeViewTypes.Vehicles;
            else if (treView == treImprovements)
                eType = ItemTreeViewTypes.Improvements;
            try
            {
                await DoTreeDragDrop(sender, e, eType, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void TreeView_MouseDown(object sender, MouseEventArgs e)
        {
            // Generic event for all TreeViews to allow right-clicking to select a TreeNode so the proper ContextMenu is shown.
            //if (e.Button == System.Windows.Forms.MouseButtons.Right)
            //{
            if (!(sender is TreeView treView))
                return;
            TreeNode nodSelected = treView.SelectedNode = treView.HitTest(e.X, e.Y).Node;
            //}
            if (ModifierKeys != Keys.Control)
                return;
            if (nodSelected != null)
            {
                if (!nodSelected.IsExpanded)
                {
                    foreach (TreeNode objNode in nodSelected.Nodes)
                    {
                        objNode.ExpandAll();
                    }
                }
                else
                {
                    foreach (TreeNode objNode in nodSelected.Nodes)
                    {
                        objNode.Collapse();
                    }
                }
            }
        }

        private void TreeView_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private void TreeView_DragOver(object sender, DragEventArgs e)
        {
            if (!(sender is TreeView treView))
                return;
            Point pt = treView.PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = treView.GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (DragButton == MouseButtons.Left)
            {
                if (objNode.Level <= _intDragLevel)
                    objNode.BackColor = ColorManager.ControlDarker;
            }
            else
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background color for all other Nodes.
            treView.ClearNodeBackground(objNode);
        }

        private async void CharacterCareer_Load(object sender, EventArgs e)
        {
            try
            {
                try
                {
                    CursorWait objCursorWait =
                        await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                    try
                    {
                        Task tskAutosave = Task.CompletedTask; // Separate out the autosave task so that we can work on it while the UI is drawing
                        using (CustomActivity op_load_frm_career = Timekeeper.StartSyncron(
                                   "load_frm_career", null, CustomActivity.OperationType.RequestOperation,
                                   CharacterObject != null ? await CharacterObject.GetFileNameAsync(GenericToken).ConfigureAwait(false) : string.Empty))
                        {
                            await this.DoThreadSafeAsync(x => x.SuspendLayout(), GenericToken).ConfigureAwait(false);
                            try
                            {
                                try
                                {
                                    if (CharacterObject == null)
                                    {
                                        // Stupid hack to get the MDI icon to show up properly.
                                        await this.DoThreadSafeFuncAsync(x => x.Icon = x.Icon.Clone() as Icon,
                                            GenericToken).ConfigureAwait(false);
                                        return;
                                    }

                                    using (Timekeeper.StartSyncron("load_frm_career_databinding", op_load_frm_career))
                                    {
                                        // Set the visibility of the Bioware Suites menu options.
                                        await mnuCreateMenu.DoThreadSafeAsync(
                                                () => mnuSpecialAddBiowareSuite.Visible
                                                    = CharacterObjectSettings.AllowBiowareSuites,
                                                GenericToken)
                                            .ConfigureAwait(false);

                                        await txtGroupName.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.GroupName),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetGroupNameAsync(GenericToken),
                                            (x, y) => x.SetGroupNameAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtGroupNotes.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.GroupNotes),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetGroupNotesAsync(GenericToken),
                                            (x, y) => x.SetGroupNotesAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);

                                        await txtCharacterName.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Name),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetNameAsync(GenericToken),
                                            (x, y) => x.SetNameAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtGender.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Gender),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetGenderAsync(GenericToken),
                                            (x, y) => x.SetGenderAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtAge.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Age),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetAgeAsync(GenericToken),
                                            (x, y) => x.SetAgeAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtEyes.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Eyes),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetEyesAsync(GenericToken),
                                            (x, y) => x.SetEyesAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtHeight.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Height),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetHeightAsync(GenericToken),
                                            (x, y) => x.SetHeightAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtWeight.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Weight),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetWeightAsync(GenericToken),
                                            (x, y) => x.SetWeightAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtSkin.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Skin),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetSkinAsync(GenericToken),
                                            (x, y) => x.SetSkinAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtHair.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Hair),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetHairAsync(GenericToken),
                                            (x, y) => x.SetHairAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await rtfDescription.RegisterAsyncDataBindingWithDelayAsync(x => x.Rtf, (x, y) => x.Rtf = y,
                                            CharacterObject,
                                            nameof(Character.Description),
                                            (x, y) => x.RtfContentChanged += y,
                                            x => x.GetDescriptionAsync(GenericToken),
                                            (x, y) => x.SetDescriptionAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await rtfBackground.RegisterAsyncDataBindingWithDelayAsync(x => x.Rtf, (x, y) => x.Rtf = y,
                                            CharacterObject,
                                            nameof(Character.Background),
                                            (x, y) => x.RtfContentChanged += y,
                                            x => x.GetBackgroundAsync(GenericToken),
                                            (x, y) => x.SetBackgroundAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await rtfConcept.RegisterAsyncDataBindingWithDelayAsync(x => x.Rtf, (x, y) => x.Rtf = y,
                                            CharacterObject,
                                            nameof(Character.Concept),
                                            (x, y) => x.RtfContentChanged += y,
                                            x => x.GetConceptAsync(GenericToken),
                                            (x, y) => x.SetConceptAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await rtfNotes.RegisterAsyncDataBindingWithDelayAsync(x => x.Rtf, (x, y) => x.Rtf = y,
                                            CharacterObject,
                                            nameof(Character.Notes),
                                            (x, y) => x.RtfContentChanged += y,
                                            x => x.GetNotesAsync(GenericToken),
                                            (x, y) => x.SetNotesAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await rtfGameNotes.RegisterAsyncDataBindingWithDelayAsync(x => x.Rtf, (x, y) => x.Rtf = y,
                                            CharacterObject,
                                            nameof(Character.GameNotes),
                                            (x, y) => x.RtfContentChanged += y,
                                            x => x.GetGameNotesAsync(GenericToken),
                                            (x, y) => x.SetGameNotesAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtAlias.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Alias),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetAliasAsync(GenericToken),
                                            (x, y) => x.SetAliasAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtPlayerName.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.PlayerName),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetPlayerNameAsync(GenericToken),
                                            (x, y) => x.SetPlayerNameAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);

                                        bool blnGroupMember = await CharacterObject.GetGroupMemberAsync(GenericToken).ConfigureAwait(false);
                                        await chkJoinGroup.DoThreadSafeAsync(
                                                x => x.Checked = blnGroupMember, GenericToken)
                                            .ConfigureAwait(false);
                                        await chkInitiationGroup.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Enabled = y, CharacterObject,
                                                nameof(Character.GroupMember),
                                                x => x.GetGroupMemberAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        // If the character has a mugshot, decode it and put it in the PictureBox.
                                        int intMugshotCount =
                                            await (await CharacterObject.GetMugshotsAsync(GenericToken).ConfigureAwait(false)).GetCountAsync(GenericToken).ConfigureAwait(false);
                                        if (intMugshotCount > 0)
                                        {
                                            int intMainMugshotIndex =
                                                await CharacterObject.GetMainMugshotIndexAsync(GenericToken).ConfigureAwait(false);
                                            await nudMugshotIndex.DoThreadSafeAsync(x =>
                                            {
                                                x.Minimum = 1;
                                                x.Maximum = intMugshotCount;
                                                x.Value = Math.Max(intMainMugshotIndex, 0) + 1;
                                            }, GenericToken).ConfigureAwait(false);
                                        }
                                        else
                                        {
                                            await nudMugshotIndex.DoThreadSafeAsync(x =>
                                            {
                                                x.Minimum = 0;
                                                x.Maximum = 0;
                                                x.Value = 0;
                                            }, GenericToken).ConfigureAwait(false);
                                        }

                                        string strNumMugshots =
                                            await LanguageManager.GetStringAsync("String_Of", token: GenericToken)
                                                .ConfigureAwait(false) +
                                            intMugshotCount.ToString(GlobalSettings.CultureInfo);
                                        await lblNumMugshots
                                            .DoThreadSafeAsync(x => x.Text = strNumMugshots, GenericToken)
                                            .ConfigureAwait(false);

                                        await nudStreetCred.RegisterAsyncDataBindingWithDelayAsync(x => x.ValueAsInt,
                                            (x, y) => x.ValueAsInt = y,
                                            CharacterObject,
                                            nameof(Character.StreetCred),
                                            (x, y) => x.ValueChanged += y,
                                            x => x.GetStreetCredAsync(GenericToken),
                                            (x, y) => x.SetStreetCredAsync(y, GenericToken), 250, GenericToken,
                                            GenericToken).ConfigureAwait(false);
                                        await nudNotoriety.RegisterAsyncDataBindingWithDelayAsync(x => x.ValueAsInt,
                                            (x, y) => x.ValueAsInt = y,
                                            CharacterObject,
                                            nameof(Character.Notoriety),
                                            (x, y) => x.ValueChanged += y,
                                            x => x.GetNotorietyAsync(GenericToken),
                                            (x, y) => x.SetNotorietyAsync(y, GenericToken), 250, GenericToken,
                                            GenericToken).ConfigureAwait(false);
                                        await nudPublicAware.RegisterAsyncDataBindingWithDelayAsync(x => x.ValueAsInt,
                                            (x, y) => x.ValueAsInt = y,
                                            CharacterObject,
                                            nameof(Character.PublicAwareness),
                                            (x, y) => x.ValueChanged += y,
                                            x => x.GetPublicAwarenessAsync(GenericToken),
                                            (x, y) => x.SetPublicAwarenessAsync(y, GenericToken), 250, GenericToken,
                                            GenericToken).ConfigureAwait(false);
                                        await nudAstralReputation.RegisterAsyncDataBindingWithDelayAsync(x => x.ValueAsInt,
                                            (x, y) => x.ValueAsInt = y,
                                            CharacterObject,
                                            nameof(Character.AstralReputation),
                                            (x, y) => x.ValueChanged += y,
                                            x => x.GetAstralReputationAsync(GenericToken),
                                            (x, y) => x.SetAstralReputationAsync(y, GenericToken), 250, GenericToken,
                                            GenericToken).ConfigureAwait(false);
                                        await nudWildReputation.RegisterAsyncDataBindingWithDelayAsync(x => x.ValueAsInt,
                                            (x, y) => x.ValueAsInt = y,
                                            CharacterObject,
                                            nameof(Character.WildReputation),
                                            (x, y) => x.ValueChanged += y,
                                            x => x.GetWildReputationAsync(GenericToken),
                                            (x, y) => x.SetWildReputationAsync(y, GenericToken), 250, GenericToken,
                                            GenericToken).ConfigureAwait(false);
                                        await cmdAddMetamagic.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Enabled = y, CharacterObject,
                                                nameof(Character.AddInitiationsAllowed),
                                                x => x.GetAddInitiationsAllowedAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblPossessed.RegisterOneWayAsyncDataBindingAsync((x, y) => x.Visible = y,
                                                CharacterObject,
                                                nameof(Character.Possessed), x => x.GetPossessedAsync(GenericToken),
                                                GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMetatype.RegisterOneWayAsyncDataBindingAsync((x, y) => x.Text = y,
                                                CharacterObject,
                                                nameof(Character.FormattedMetatype),
                                                x => x.GetFormattedMetatypeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await chkPsycheActiveMagician.RegisterAsyncDataBindingAsync(x => x.Checked, (x, y) => x.Checked = y,
                                            CharacterObject,
                                            nameof(Character.PsycheActive),
                                            (x, y) => x.CheckedChanged += y,
                                            x => x.GetPsycheActiveAsync(GenericToken),
                                            (x, y) => x.SetPsycheActiveAsync(y, GenericToken),
                                            GenericToken,
                                            GenericToken).ConfigureAwait(false);
                                        await chkPsycheActiveTechnomancer.RegisterAsyncDataBindingAsync(x => x.Checked, (x, y) => x.Checked = y,
                                            CharacterObject,
                                            nameof(Character.PsycheActive),
                                            (x, y) => x.CheckedChanged += y,
                                            x => x.GetPsycheActiveAsync(GenericToken),
                                            (x, y) => x.SetPsycheActiveAsync(y, GenericToken),
                                            GenericToken,
                                            GenericToken).ConfigureAwait(false);
                                    }

                                    if (!await CharacterObjectSettings.BookEnabledAsync("RF", GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await cmdAddLifestyle
                                            .DoThreadSafeAsync(x => x.SplitMenuStrip = null, GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    if (!await CharacterObjectSettings.BookEnabledAsync("FA", GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await lblWildReputation.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                            .ConfigureAwait(false);
                                        await nudWildReputation.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                            .ConfigureAwait(false);
                                        await lblWildReputationTotal.DoThreadSafeAsync(
                                            x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                        if (!await CharacterObjectSettings.BookEnabledAsync("SG", GenericToken)
                                                .ConfigureAwait(false))
                                        {
                                            await lblAstralReputation.DoThreadSafeAsync(
                                                x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                            await nudAstralReputation.DoThreadSafeAsync(
                                                x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                            await lblAstralReputationTotal.DoThreadSafeAsync(
                                                x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                        }
                                    }

                                    if (!await CharacterObjectSettings.GetEnableEnemyTrackingAsync(GenericToken).ConfigureAwait(false))
                                    {
                                        await tabPeople.DoThreadSafeAsync(x => x.TabPages.Remove(tabEnemies),
                                                GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    await splitKarmaNuyen.DoThreadSafeAsync(
                                        x => x.SplitterDistance
                                            = Math.Max(x.SplitterDistance, (x.Width - x.SplitterWidth).DivAwayFromZero(2)),
                                        GenericToken).ConfigureAwait(false);
                                    await splitMagician.DoThreadSafeAsync(x => x.SplitterDistance
                                        = Math.Max(x.SplitterDistance, ((x.Height - x.SplitterWidth) * 2).DivAwayFromZero(3)),
                                            GenericToken).ConfigureAwait(false);
                                    await splitTechnomancer.DoThreadSafeAsync(
                                        x => x.SplitterDistance
                                            = Math.Max(x.SplitterDistance, ((x.Height - x.SplitterWidth) * 2).DivAwayFromZero(3)),
                                        GenericToken).ConfigureAwait(false);

                                    Tradition objTradition = await CharacterObject
                                        .GetMagicTraditionAsync(GenericToken).ConfigureAwait(false);

                                    using (Timekeeper.StartSyncron("load_frm_career_magictradition",
                                               op_load_frm_career))
                                    {
                                        objTradition.PropertyChangedAsync += TraditionOnPropertyChanged;
                                        // Populate the Magician Traditions list.
                                        XPathNavigator xmlTraditionsBaseChummerNode =
                                            (await CharacterObject.LoadDataXPathAsync(
                                                "traditions.xml", token: GenericToken).ConfigureAwait(false))
                                            .SelectSingleNodeAndCacheExpression("/chummer", GenericToken);
                                        using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                                   Utils.ListItemListPool, out List<ListItem> lstTraditions))
                                        {
                                            if (xmlTraditionsBaseChummerNode != null)
                                            {
                                                foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode
                                                             .Select(
                                                                 "traditions/tradition["
                                                                 + await CharacterObjectSettings
                                                                     .BookXPathAsync(token: GenericToken)
                                                                     .ConfigureAwait(false)
                                                                 + "]"))
                                                {
                                                    string strName
                                                        = xmlTradition.SelectSingleNodeAndCacheExpression(
                                                                "name", GenericToken)
                                                            ?.Value;
                                                    if (!string.IsNullOrEmpty(strName))
                                                        lstTraditions.Add(new ListItem(
                                                            xmlTradition
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "id", GenericToken)
                                                                ?.Value ?? strName,
                                                            xmlTradition
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "translate", GenericToken)
                                                                ?.Value ?? strName));
                                                }
                                            }

                                            if (lstTraditions.Count > 1)
                                            {
                                                lstTraditions.Sort(CompareListItems.CompareNames);
                                                lstTraditions.Insert(0,
                                                    new ListItem(
                                                        "None",
                                                        await LanguageManager
                                                            .GetStringAsync("String_None", token: GenericToken)
                                                            .ConfigureAwait(false)));
                                                await cboTradition
                                                    .PopulateWithListItemsAsync(lstTraditions, GenericToken)
                                                    .ConfigureAwait(false);
                                            }
                                            else
                                            {
                                                await this.DoThreadSafeAsync(() =>
                                                {
                                                    cboTradition.Visible = false;
                                                    lblTraditionLabel.Visible = false;
                                                }, GenericToken).ConfigureAwait(false);
                                            }
                                        }

                                        // Populate the Magician Custom Drain Options list.
                                        using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                                   Utils.ListItemListPool, out List<ListItem> lstDrainAttributes))
                                        {
                                            if (xmlTraditionsBaseChummerNode != null)
                                            {
                                                foreach (XPathNavigator xmlDrain in xmlTraditionsBaseChummerNode
                                                             .SelectAndCacheExpression(
                                                                 "drainattributes/drainattribute", GenericToken))
                                                {
                                                    string strName
                                                        = xmlDrain.SelectSingleNodeAndCacheExpression("name",
                                                                GenericToken)
                                                            ?.Value;
                                                    if (!string.IsNullOrEmpty(strName)
                                                        && (lstDrainAttributes.Count == 0 || lstDrainAttributes.TrueForAll(x =>
                                                            x.Value?.ToString() != strName)))
                                                    {
                                                        string strTranslatedName = xmlDrain
                                                            .SelectSingleNodeAndCacheExpression(
                                                                "translate", GenericToken)?.Value ?? strName;
                                                        lstDrainAttributes.Add(new ListItem(strName,
                                                            strTranslatedName));
                                                    }
                                                }
                                            }

                                            lstDrainAttributes.Sort(CompareListItems.CompareNames);
                                            lstDrainAttributes.Insert(0, ListItem.Blank);
                                            await cboDrain.PopulateWithListItemsAsync(lstDrainAttributes, GenericToken)
                                                .ConfigureAwait(false);
                                            await cboDrain.RegisterAsyncDataBindingWithDelayAsync(
                                                x => x.SelectedValue?.ToString() ?? string.Empty,
                                                (x, y) =>
                                                {
                                                    if (!string.IsNullOrEmpty(y))
                                                        x.SelectedValue = y;
                                                    else
                                                        x.SelectedIndex = -1;
                                                }, objTradition,
                                                nameof(Tradition.DrainExpression),
                                                (x, y) => x.SelectedValueChanged += y,
                                                x => x.GetDrainExpressionAsync(GenericToken),
                                                (x, y) => x.SetDrainExpressionAsync(y, GenericToken),
                                                1000,
                                                GenericToken,
                                                GenericToken).ConfigureAwait(false);
                                        }

                                        decimal decDicePool = await objTradition.GetDrainValueAsync(GenericToken).ConfigureAwait(false);
                                        switch (await objTradition.GetTypeAsync(GenericToken).ConfigureAwait(false))
                                        {
                                            case TraditionType.MAG:
                                                await dpcDrainAttributes.SetDicePoolAsync(decDicePool, GenericToken).ConfigureAwait(false);
                                                break;
                                            case TraditionType.RES:
                                                await dpcFadingAttributes.SetDicePoolAsync(decDicePool, GenericToken).ConfigureAwait(false);
                                                break;
                                        }

                                        await lblDrainAttributes.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y,
                                                objTradition,
                                                nameof(Tradition.DisplayDrainExpression),
                                                x => x.GetDisplayDrainExpressionAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await dpcDrainAttributes.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y,
                                                objTradition,
                                                nameof(Tradition.DrainValueToolTip),
                                                x => x.GetDrainValueToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await objTradition.SetSourceDetailAsync(
                                            lblTraditionSource, GenericToken).ConfigureAwait(false);

                                        await lblFadingAttributes.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y,
                                                objTradition,
                                                nameof(Tradition.DisplayDrainExpression),
                                                x => x.GetDisplayDrainExpressionAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await dpcFadingAttributes.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y,
                                                objTradition,
                                                nameof(Tradition.DrainValueToolTip),
                                                x => x.GetDrainValueToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                   out HashSet<string> limit))
                                        {
                                            foreach (Improvement improvement in await ImprovementManager
                                                         .GetCachedImprovementListForValueOfAsync(
                                                             CharacterObject,
                                                             Improvement.ImprovementType.LimitSpiritCategory,
                                                             token: GenericToken)
                                                         .ConfigureAwait(false))
                                            {
                                                limit.Add(improvement.ImprovedName);
                                            }

                                            // Populate the Magician Custom Spirits lists - Combat.
                                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                                       Utils.ListItemListPool, out List<ListItem> lstSpirit))
                                            {
                                                if (xmlTraditionsBaseChummerNode != null)
                                                {
                                                    foreach (XPathNavigator xmlSpirit in xmlTraditionsBaseChummerNode
                                                                 .SelectAndCacheExpression("spirits/spirit",
                                                                     GenericToken))
                                                    {
                                                        string strSpiritName
                                                            = xmlSpirit.SelectSingleNodeAndCacheExpression(
                                                                    "name", GenericToken)
                                                                ?.Value;
                                                        if (!string.IsNullOrEmpty(strSpiritName)
                                                            && (limit.Count == 0 || limit.Contains(strSpiritName)))
                                                        {
                                                            lstSpirit.Add(new ListItem(strSpiritName,
                                                                xmlSpirit
                                                                    .SelectSingleNodeAndCacheExpression(
                                                                        "translate", GenericToken)
                                                                    ?.Value
                                                                ?? strSpiritName));
                                                        }
                                                    }
                                                }

                                                lstSpirit.Sort(CompareListItems.CompareNames);
                                                lstSpirit.Insert(0, ListItem.Blank);

                                                async ValueTask BindSpiritVisibility(ElasticComboBox cboBox,
                                                    Label lblName,
                                                    string strSpirit, Func<Tradition, Task<string>> funcSpiritGetter, Func<Tradition, string, Task> funcSpiritSetter)
                                                {
                                                    await cboBox.PopulateWithListItemsAsync(lstSpirit, GenericToken)
                                                        .ConfigureAwait(false);
                                                    await cboBox.RegisterAsyncDataBindingWithDelayAsync(
                                                        x => x.SelectedValue?.ToString() ?? string.Empty,
                                                        (x, y) =>
                                                        {
                                                            if (!string.IsNullOrEmpty(y))
                                                                x.SelectedValue = y;
                                                            else
                                                                x.SelectedIndex = -1;
                                                        }, objTradition,
                                                        strSpirit,
                                                        (x, y) => x.SelectedValueChanged += y,
                                                        funcSpiritGetter,
                                                        funcSpiritSetter,
                                                        1000,
                                                        GenericToken,
                                                        GenericToken).ConfigureAwait(false);
                                                    bool blnIsMag =
                                                        await objTradition.GetTypeAsync(GenericToken)
                                                            .ConfigureAwait(false) == TraditionType.MAG;
                                                    bool blnCustomTradition = await objTradition
                                                        .GetIsCustomTraditionAsync(GenericToken).ConfigureAwait(false);
                                                    await lblName
                                                        .DoThreadSafeAsync(x => x.Visible = blnIsMag, GenericToken)
                                                        .ConfigureAwait(false);
                                                    await cboBox.DoThreadSafeAsync(x =>
                                                    {
                                                        x.Visible = blnIsMag;
                                                        x.Enabled = blnCustomTradition;
                                                    }, GenericToken).ConfigureAwait(false);
                                                }

                                                await BindSpiritVisibility(cboSpiritCombat, lblSpiritCombat,
                                                        nameof(Tradition.SpiritCombat),
                                                        x => x.GetSpiritCombatAsync(GenericToken),
                                                        (x, y) => x.SetSpiritCombatAsync(y, GenericToken))
                                                    .ConfigureAwait(false);
                                                await BindSpiritVisibility(cboSpiritDetection, lblSpiritDetection,
                                                        nameof(Tradition.SpiritDetection),
                                                        x => x.GetSpiritDetectionAsync(GenericToken),
                                                        (x, y) => x.SetSpiritDetectionAsync(y, GenericToken))
                                                    .ConfigureAwait(false);
                                                await BindSpiritVisibility(cboSpiritHealth, lblSpiritHealth,
                                                        nameof(Tradition.SpiritHealth),
                                                        x => x.GetSpiritHealthAsync(GenericToken),
                                                        (x, y) => x.SetSpiritHealthAsync(y, GenericToken))
                                                    .ConfigureAwait(false);
                                                await BindSpiritVisibility(cboSpiritIllusion, lblSpiritIllusion,
                                                        nameof(Tradition.SpiritIllusion),
                                                        x => x.GetSpiritIllusionAsync(GenericToken),
                                                        (x, y) => x.SetSpiritIllusionAsync(y, GenericToken))
                                                    .ConfigureAwait(false);
                                                await BindSpiritVisibility(cboSpiritManipulation, lblSpiritManipulation,
                                                        nameof(Tradition.SpiritManipulation),
                                                        x => x.GetSpiritManipulationAsync(GenericToken),
                                                        (x, y) => x.SetSpiritManipulationAsync(y, GenericToken))
                                                    .ConfigureAwait(false);
                                            }
                                        }

                                        // Populate the Technomancer Streams list.
                                        xmlTraditionsBaseChummerNode =
                                            (await CharacterObject.LoadDataXPathAsync(
                                                "streams.xml", token: GenericToken).ConfigureAwait(false))
                                            .SelectSingleNodeAndCacheExpression("/chummer", GenericToken);
                                        using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                                   Utils.ListItemListPool, out List<ListItem> lstStreams))
                                        {
                                            if (xmlTraditionsBaseChummerNode != null)
                                            {
                                                foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode
                                                             .Select(
                                                                 "traditions/tradition["
                                                                 + await CharacterObjectSettings
                                                                     .BookXPathAsync(token: GenericToken)
                                                                     .ConfigureAwait(false)
                                                                 + "]"))
                                                {
                                                    string strName
                                                        = xmlTradition.SelectSingleNodeAndCacheExpression(
                                                                "name", GenericToken)
                                                            ?.Value;
                                                    if (!string.IsNullOrEmpty(strName))
                                                        lstStreams.Add(new ListItem(
                                                            xmlTradition
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "id", GenericToken)
                                                                ?.Value
                                                            ?? strName,
                                                            xmlTradition
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "translate", GenericToken)
                                                                ?.Value ?? strName));
                                                }
                                            }

                                            if (lstStreams.Count > 1)
                                            {
                                                lstStreams.Sort(CompareListItems.CompareNames);
                                                lstStreams.Insert(0,
                                                    new ListItem(
                                                        "None",
                                                        await LanguageManager.GetStringAsync("String_None",
                                                                token: GenericToken)
                                                            .ConfigureAwait(false)));
                                                await cboStream.PopulateWithListItemsAsync(lstStreams, GenericToken)
                                                    .ConfigureAwait(false);
                                            }
                                            else
                                            {
                                                await cboStream.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                                    .ConfigureAwait(false);
                                                await lblStreamLabel.DoThreadSafeAsync(
                                                    x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                            }
                                        }
                                    }

                                    using (Timekeeper.StartSyncron("load_frm_career_shapeshifter", op_load_frm_career))
                                    {
                                        if (await CharacterObject.GetMetatypeCategoryAsync(GenericToken).ConfigureAwait(false) == "Shapeshifter")
                                        {
                                            await cboAttributeCategory.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                            XPathNavigator objDoc
                                                = await CharacterObject.LoadDataXPathAsync(
                                                    "metatypes.xml", token: GenericToken).ConfigureAwait(false);
                                            XPathNavigator node =
                                                objDoc.SelectSingleNode(
                                                    "/chummer/metatypes/metatype[name = "
                                                    + CharacterObject.Metatype.CleanXPath()
                                                    + "]");
                                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                                       Utils.ListItemListPool,
                                                       out List<ListItem> lstAttributeCategories))
                                            {
                                                lstAttributeCategories.Add(new ListItem("Standard",
                                                    node?
                                                        .SelectSingleNodeAndCacheExpression(
                                                            "name/@translate", GenericToken)?.Value
                                                    ?? await CharacterObject
                                                        .DisplayMetatypeAsync(GlobalSettings.Language, GenericToken)
                                                        .ConfigureAwait(false)));

                                                node = node?.SelectSingleNode(
                                                    "metavariants/metavariant[name = "
                                                    + (await CharacterObject.GetMetavariantAsync(GenericToken).ConfigureAwait(false)).CleanXPath()
                                                    + "]/name/@translate");

                                                //The Shapeshifter attribute category is treated as the METAHUMAN form of a shapeshifter.
                                                lstAttributeCategories.Add(new ListItem("Shapeshifter",
                                                    node?.Value ?? await CharacterObject
                                                        .DisplayMetavariantAsync(GlobalSettings.Language, GenericToken)
                                                        .ConfigureAwait(false)));

                                                lstAttributeCategories.Sort(CompareListItems.CompareNames);
                                                await cboAttributeCategory.PopulateWithListItemsAsync(
                                                    lstAttributeCategories, GenericToken).ConfigureAwait(false);
                                                await cboAttributeCategory.DoThreadSafeAsync(
                                                        x => x.SelectedValue = "Standard", GenericToken)
                                                    .ConfigureAwait(false);
                                            }
                                        }
                                        else
                                            await cboAttributeCategory.DoThreadSafeAsync(
                                                x => x.Visible = false,
                                                GenericToken).ConfigureAwait(false);

                                        await lblMysticAdeptMAGAdept.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.MysticAdeptPowerPoints),
                                                x => x.GetMysticAdeptPowerPointsAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await cmdIncreasePowerPoints.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Enabled = y,
                                                CharacterObject,
                                                nameof(Character.CanAffordCareerPP),
                                                x => x.GetCanAffordCareerPPAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    using (Timekeeper.StartSyncron("load_frm_career_vehicle", op_load_frm_career))
                                    {
                                        // Populate vehicle weapon fire mode list.
                                        using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                                   Utils.ListItemListPool, out List<ListItem> lstFireModes))
                                        {
                                            foreach (FiringMode mode in
                                                     Enum.GetValues(typeof(FiringMode)))
                                            {
                                                if (mode == FiringMode.NumFiringModes)
                                                    continue;
                                                lstFireModes.Add(new ListItem(mode,
                                                    await LanguageManager
                                                        .GetStringAsync("Enum_" + mode, token: GenericToken)
                                                        .ConfigureAwait(false)));
                                            }

                                            await cboVehicleWeaponFiringMode.PopulateWithListItemsAsync(
                                                lstFireModes, GenericToken).ConfigureAwait(false);
                                        }
                                    }

                                    using (Timekeeper.StartSyncron("load_frm_career_selectStuff", op_load_frm_career))
                                    {
                                        TraditionType eTraditionType = await objTradition.GetTypeAsync(GenericToken)
                                            .ConfigureAwait(false);
                                        string strTraditionSourceIdString =
                                            await objTradition.GetSourceIDStringAsync(GenericToken)
                                                .ConfigureAwait(false);
                                        await cboTradition.DoThreadSafeAsync(x =>
                                        {
                                            if (eTraditionType == TraditionType.MAG && !string.IsNullOrEmpty(strTraditionSourceIdString))
                                                x.SelectedValue = strTraditionSourceIdString;
                                            if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                x.SelectedIndex = 0;
                                        }, GenericToken).ConfigureAwait(false);
                                        await cboStream.DoThreadSafeAsync(x =>
                                        {
                                            if (eTraditionType == TraditionType.RES && !string.IsNullOrEmpty(strTraditionSourceIdString))
                                                x.SelectedValue = strTraditionSourceIdString;
                                            if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                x.SelectedIndex = 0;
                                        }, GenericToken).ConfigureAwait(false);
                                        await txtTraditionName.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            objTradition,
                                            nameof(Tradition.Name),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetNameAsync(GenericToken),
                                            (x, y) => x.SetNameAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                    }

                                    using (Timekeeper.StartSyncron("load_frm_career_databindingCallbacks2",
                                               op_load_frm_career))
                                    {
                                        await lblCMPenalty.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.WoundModifier),
                                                x => x.GetWoundModifierAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMPhysical.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y,
                                                CharacterObject,
                                                nameof(Character.PhysicalCMToolTip),
                                                x => x.GetPhysicalCMToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMPhysical.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.PhysicalCM),
                                                x => x.GetPhysicalCMAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMPhysicalLabel.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y,
                                                CharacterObject,
                                                nameof(Character.PhysicalCMLabelText),
                                                x => x.GetPhysicalCMLabelTextAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMStun.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y,
                                                CharacterObject,
                                                nameof(Character.DisplayStunCM),
                                                x => x.GetDisplayStunCMAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMStun.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.StunCMToolTip),
                                                x => x.GetStunCMToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMStunLabel.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.StunCMLabelText),
                                                x => x.GetStunCMLabelTextAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblESSMax.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayEssence),
                                                x => x.GetDisplayEssenceAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCyberwareESS.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayCyberwareEssence),
                                                x => x.GetDisplayCyberwareEssenceAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblBiowareESS.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayBiowareEssence),
                                                x => x.GetDisplayBiowareEssenceAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblEssenceHoleESS.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayEssenceHole),
                                                x => x.GetDisplayEssenceHoleAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblArmor.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.TotalArmorRating),
                                                x => x.GetTotalArmorRatingAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblArmor.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.TotalArmorRatingToolTip),
                                                x => x.GetTotalArmorRatingToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMArmor.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.TotalArmorRating),
                                                x => x.GetTotalArmorRatingAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMArmor.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.TotalArmorRatingToolTip),
                                                x => x.GetTotalArmorRatingToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblDodge.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayDodge),
                                                x => x.GetDisplayDodgeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblDodge.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.DodgeToolTip),
                                                x => x.GetDodgeToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMDodge.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayDodge),
                                                x => x.GetDisplayDodgeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMDodge.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.DodgeToolTip),
                                                x => x.GetDodgeToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblSpellDefenseIndirectDodge.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseIndirectDodge),
                                            x => x.GetDisplaySpellDefenseIndirectDodgeAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIndirectDodge.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseIndirectDodgeToolTip),
                                            x => x.GetSpellDefenseIndirectDodgeToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIndirectSoak.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseIndirectSoak),
                                            x => x.GetDisplaySpellDefenseIndirectSoakAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIndirectSoak.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseIndirectSoakToolTip),
                                            x => x.GetSpellDefenseIndirectSoakToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDirectSoakMana.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDirectSoakMana),
                                            x => x.GetDisplaySpellDefenseDirectSoakManaAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDirectSoakMana.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDirectSoakManaToolTip),
                                            x => x.GetSpellDefenseDirectSoakManaToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDirectSoakPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDirectSoakPhysical),
                                            x => x.GetDisplaySpellDefenseDirectSoakPhysicalAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDirectSoakPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDirectSoakPhysicalToolTip),
                                            x => x.GetSpellDefenseDirectSoakPhysicalToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDetection.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDetection),
                                            x => x.GetDisplaySpellDefenseDetectionAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDetection.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDetectionToolTip),
                                            x => x.GetSpellDefenseDetectionToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttBOD.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseBOD),
                                            x => x.GetDisplaySpellDefenseDecreaseBODAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttBOD.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseBODToolTip),
                                            x => x.GetSpellDefenseDecreaseBODToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttAGI.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseAGI),
                                            x => x.GetDisplaySpellDefenseDecreaseAGIAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttAGI.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseAGIToolTip),
                                            x => x.GetSpellDefenseDecreaseAGIToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttREA.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseREA),
                                            x => x.GetDisplaySpellDefenseDecreaseREAAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttREA.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseREAToolTip),
                                            x => x.GetSpellDefenseDecreaseREAToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttSTR.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseSTR),
                                            x => x.GetDisplaySpellDefenseDecreaseSTRAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttSTR.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseSTRToolTip),
                                            x => x.GetSpellDefenseDecreaseSTRToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttCHA.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseCHA),
                                            x => x.GetDisplaySpellDefenseDecreaseCHAAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttCHA.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseCHAToolTip),
                                            x => x.GetSpellDefenseDecreaseCHAToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttINT.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseINT),
                                            x => x.GetDisplaySpellDefenseDecreaseINTAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttINT.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseINTToolTip),
                                            x => x.GetSpellDefenseDecreaseINTToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttLOG.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseLOG),
                                            x => x.GetDisplaySpellDefenseDecreaseLOGAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttLOG.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseLOGToolTip),
                                            x => x.GetSpellDefenseDecreaseLOGToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttWIL.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseWIL),
                                            x => x.GetDisplaySpellDefenseDecreaseWILAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttWIL.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseWILToolTip),
                                            x => x.GetSpellDefenseDecreaseWILToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIllusionMana.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseIllusionMana),
                                            x => x.GetDisplaySpellDefenseIllusionManaAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIllusionMana.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseIllusionManaToolTip),
                                            x => x.GetSpellDefenseIllusionManaToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIllusionPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseIllusionPhysical),
                                            x => x.GetDisplaySpellDefenseIllusionPhysicalAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIllusionPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseIllusionPhysicalToolTip),
                                            x => x.GetSpellDefenseIllusionPhysicalToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseManipMental.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseManipulationMental),
                                            x => x.GetDisplaySpellDefenseManipulationMentalAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseManipMental.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseManipulationMentalToolTip),
                                            x => x.GetSpellDefenseManipulationMentalToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseManipPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseManipulationPhysical),
                                            x => x.GetDisplaySpellDefenseManipulationPhysicalAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseManipPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseManipulationPhysicalToolTip),
                                            x => x.GetSpellDefenseManipulationPhysicalToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await nudCounterspellingDice.RegisterAsyncDataBindingWithDelayAsync(x => x.ValueAsInt,
                                            (x, y) => x.ValueAsInt = y,
                                            CharacterObject,
                                            nameof(Character.CurrentCounterspellingDice),
                                            (x, y) => x.ValueChanged += y,
                                            x => x.GetCurrentCounterspellingDiceAsync(GenericToken),
                                            (x, y) => x.SetCurrentCounterspellingDiceAsync(y, GenericToken), 250, GenericToken,
                                            GenericToken).ConfigureAwait(false);

                                        await nudLiftCarryHits.RegisterAsyncDataBindingWithDelayAsync(x => x.ValueAsInt,
                                            (x, y) => x.ValueAsInt = y,
                                            CharacterObject,
                                            nameof(Character.CurrentLiftCarryHits),
                                            (x, y) => x.ValueChanged += y,
                                            x => x.GetCurrentLiftCarryHitsAsync(GenericToken),
                                            (x, y) => x.SetCurrentLiftCarryHitsAsync(y, GenericToken), 250, GenericToken,
                                            GenericToken).ConfigureAwait(false);

                                        await lblMovement.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayMovement),
                                                x => x.GetDisplayMovementAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblSwim.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplaySwim),
                                                x => x.GetDisplaySwimAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblFly.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayFly),
                                                x => x.GetDisplayFlyAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblRemainingNuyen.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayNuyen),
                                                x => x.GetDisplayNuyenAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCareerKarma.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayCareerKarma),
                                                x => x.GetDisplayCareerKarmaAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCareerNuyen.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayCareerNuyen),
                                                x => x.GetDisplayCareerNuyenAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblStreetCredTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                                nameof(Character.TotalStreetCred),
                                                x => x.GetTotalStreetCredAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblStreetCredTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.StreetCredTooltip),
                                                x => x.GetStreetCredTooltipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblNotorietyTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                                nameof(Character.TotalNotoriety),
                                                x => x.GetTotalNotorietyAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblNotorietyTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.NotorietyTooltip),
                                                x => x.GetNotorietyTooltipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblPublicAwareTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                                nameof(Character.TotalPublicAwareness),
                                                x => x.GetTotalPublicAwarenessAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblPublicAwareTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.PublicAwarenessTooltip),
                                                x => x.GetPublicAwarenessTooltipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblAstralReputationTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.TotalAstralReputation),
                                                x => x.GetTotalAstralReputationAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblAstralReputationTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.AstralReputationTooltip),
                                                x => x.GetAstralReputationTooltipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblWildReputationTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.TotalWildReputation),
                                                x => x.GetTotalWildReputationAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblWildReputationTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.WildReputationTooltip),
                                                x => x.GetWildReputationTooltipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblMentorSpirit.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.FirstMentorSpiritDisplayName),
                                                x => x.GetFirstMentorSpiritDisplayNameAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMentorSpiritInformation.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.FirstMentorSpiritDisplayInformation),
                                            x => x.GetFirstMentorSpiritDisplayInformationAsync(GenericToken),
                                            GenericToken).ConfigureAwait(false);
                                        await lblParagon.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.FirstMentorSpiritDisplayName),
                                                x => x.GetFirstMentorSpiritDisplayNameAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblParagonInformation.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.FirstMentorSpiritDisplayInformation),
                                            x => x.GetFirstMentorSpiritDisplayInformationAsync(GenericToken),
                                            GenericToken).ConfigureAwait(false);

                                        await lblSurprise.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.SurpriseToolTip),
                                                x => x.GetSurpriseToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblSurprise.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                            nameof(Character.Surprise),
                                            x => x.GetSurpriseAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblComposure.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.ComposureToolTip),
                                                x => x.GetComposureToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblComposure.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                            nameof(Character.Composure),
                                            x => x.GetComposureAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblJudgeIntentions.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.JudgeIntentionsToolTip),
                                                x => x.GetJudgeIntentionsToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblJudgeIntentions.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.JudgeIntentions),
                                                x => x.GetJudgeIntentionsAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblLiftCarry.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.LiftAndCarryToolTip),
                                                x => x.GetLiftAndCarryToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblLiftCarry.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.LiftAndCarry),
                                                x => x.GetLiftAndCarryAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMemory.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.MemoryToolTip),
                                                x => x.GetMemoryToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMemory.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                            nameof(Character.Memory),
                                            x => x.GetMemoryAsync(GenericToken), GenericToken).ConfigureAwait(false);

                                        await lblLiftCarryLimits.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.LiftAndCarryLimits),
                                                x => x.GetLiftAndCarryLimitsAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.InitiativeToolTip),
                                                x => x.GetInitiativeToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.Initiative),
                                                x => x.GetInitiativeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblAstralINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.AstralInitiativeToolTip),
                                                x => x.GetAstralInitiativeToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblAstralINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.AstralInitiative),
                                                x => x.GetAstralInitiativeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.MatrixInitiativeToolTip),
                                                x => x.GetMatrixInitiativeToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.MatrixInitiative),
                                                x => x.GetMatrixInitiativeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINICold.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.MatrixInitiativeColdToolTip),
                                                x => x.GetMatrixInitiativeColdToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINICold.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.MatrixInitiativeCold),
                                                x => x.GetMatrixInitiativeColdAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINIHot.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.MatrixInitiativeHotToolTip),
                                                x => x.GetMatrixInitiativeHotToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINIHot.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.MatrixInitiativeHot),
                                                x => x.GetMatrixInitiativeHotAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblRiggingINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.InitiativeToolTip),
                                                x => x.GetInitiativeToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblRiggingINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.Initiative),
                                                x => x.GetInitiativeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await cmdBurnStreetCred.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Enabled = y, CharacterObject,
                                                nameof(Character.CanBurnStreetCred),
                                                x => x.GetCanBurnStreetCredAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblEDGInfo.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.EdgeRemainingString),
                                                x => x.GetEdgeRemainingStringAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblCMDamageResistancePool.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.DamageResistancePoolToolTip),
                                                x => x.GetDamageResistancePoolToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMDamageResistancePool.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.DamageResistancePool),
                                                x => x.GetDamageResistancePoolAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMPhysicalRecoveryPool.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.PhysicalCMNaturalRecovery),
                                                x => x.GetPhysicalCMNaturalRecoveryAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMStunRecoveryPool.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.StunCMNaturalRecovery),
                                                x => x.GetStunCMNaturalRecoveryAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    using (Timekeeper.StartSyncron("load_frm_career_miscstuff", op_load_frm_career))
                                    {
                                        await SetTooltips(GenericToken).ConfigureAwait(false);

                                        await RefreshAttributes(pnlAttributes, null, lblAttributes, -1, -1,
                                                await lblAttributesAug.DoThreadSafeFuncAsync(
                                                        x => x.PreferredWidth, GenericToken)
                                                    .ConfigureAwait(false),
                                                await lblAttributesMetatype.DoThreadSafeFuncAsync(
                                                        x => x.PreferredWidth, GenericToken)
                                                    .ConfigureAwait(false), GenericToken)
                                            .ConfigureAwait(false);

                                        CharacterObject.AttributeSection.Attributes.BeforeClearCollectionChangedAsync
                                            += AttributeBeforeClearCollectionChanged;
                                        CharacterObject.AttributeSection.Attributes.CollectionChangedAsync
                                            += AttributeCollectionChanged;

                                        // Condition Monitor.
                                        await ProcessCharacterConditionMonitorBoxDisplays(
                                            panPhysicalCM,
                                            await CharacterObject.GetPhysicalCMAsync(GenericToken)
                                                .ConfigureAwait(false),
                                            await CharacterObject.GetCMThresholdAsync(GenericToken)
                                                .ConfigureAwait(false),
                                            await CharacterObject.GetPhysicalCMThresholdOffsetAsync(GenericToken)
                                                .ConfigureAwait(false),
                                            await CharacterObject.GetCMOverflowAsync(GenericToken)
                                                .ConfigureAwait(false),
                                            chkPhysicalCM_CheckedChanged, true,
                                            await CharacterObject.GetPhysicalCMFilledAsync(GenericToken).ConfigureAwait(false),
                                            GenericToken).ConfigureAwait(false);
                                        await ProcessCharacterConditionMonitorBoxDisplays(
                                                panStunCM,
                                                await CharacterObject.GetStunCMAsync(GenericToken)
                                                    .ConfigureAwait(false),
                                                await CharacterObject.GetCMThresholdAsync(GenericToken)
                                                    .ConfigureAwait(false),
                                                await CharacterObject.GetStunCMThresholdOffsetAsync(GenericToken)
                                                    .ConfigureAwait(false), 0,
                                                chkStunCM_CheckedChanged, true,
                                                await CharacterObject.GetStunCMFilledAsync(GenericToken).ConfigureAwait(false),
                                                GenericToken)
                                            .ConfigureAwait(false);

                                        await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
                                        await ProcessMugshot(GenericToken).ConfigureAwait(false);
                                        // Stupid hack to get the MDI icon to show up properly.
                                        await this.DoThreadSafeFuncAsync(x => x.Icon = x.Icon.Clone() as Icon,
                                                GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    using (CustomActivity op_load_frm_career_longloads
                                           = Timekeeper.StartSyncron("load_frm_career_longloads",
                                               op_load_frm_career))
                                    {
                                        using (Timekeeper.StartSyncron(
                                                   "load_frm_career_Run through all appropriate property changers",
                                                   op_load_frm_career_longloads))
                                        {
                                            // Run through all appropriate property changers
                                            await OnCharacterPropertyChanged(this,
                                                new MultiplePropertiesChangedEventArgs(typeof(Character).GetProperties()
                                                    .Select(x => x.Name)), GenericToken).ConfigureAwait(false);
                                        }

                                        using (Timekeeper.StartSyncron(
                                                   "load_frm_career_tabPowerUc.RealLoad()",
                                                   op_load_frm_career_longloads))
                                        {
                                            await tabPowerUc.RealLoad(GenericToken, GenericToken).ConfigureAwait(false);
                                        }

                                        using (Timekeeper.StartSyncron(
                                                   "load_frm_career_tabSkillsUc.RealLoad()",
                                                   op_load_frm_career_longloads))
                                        {
                                            await tabSkillsUc.RealLoad(GenericToken, GenericToken)
                                                .ConfigureAwait(false);
                                        }
                                    }

                                    using (Timekeeper.StartSyncron(
                                               "load_frm_career_refresh", op_load_frm_career))
                                    {
                                        await RefreshQualities(treQualities, cmsQuality, _fntNormal, _fntStrikeout,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshSpirits(panSpirits, panSprites, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshSustainedSpells(flpSustainedSpells, flpSustainedComplexForms,
                                                flpSustainedCritterPowers, chkPsycheActiveMagician,
                                                chkPsycheActiveTechnomancer, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm,
                                                cmsInitiationNotes, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshPowerCollectionListChanged(
                                                treMetamagic, cmsMetamagic, cmsInitiationNotes, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshCritterPowers(treCritterPowers, cmsCritterPowers,
                                                token: GenericToken)
                                            .ConfigureAwait(false);
                                        bool blnTemp = await CharacterObject.CritterPowers
                                            .AnyAsync(x => x.Name == "Inhabitation"
                                                           || x.Name == "Possession", GenericToken)
                                            .ConfigureAwait(false);
                                        await mnuCreateMenu.DoThreadSafeAsync(
                                                () => mnuSpecialPossess.Visible = blnTemp, GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshCustomImprovements(treImprovements, lmtControl.LimitTreeView,
                                            cmsImprovementLocation,
                                            cmsImprovement, lmtControl.LimitContextMenuStrip,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshCalendar(lstCalendar, token: GenericToken).ConfigureAwait(false);
                                        await RefreshContacts(panContacts, panEnemies, panPets, token: GenericToken)
                                            .ConfigureAwait(false);

                                        await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod,
                                            cmsArmorGear,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshGears(treGear, cmsGearLocation, cmsGear, null,
                                            await chkCommlinks.DoThreadSafeFuncAsync(
                                                x => x.Checked, GenericToken).ConfigureAwait(false),
                                            await chkHideLoadedAmmo.DoThreadSafeFuncAsync(
                                                x => x.Checked, GenericToken).ConfigureAwait(false),
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshFociFromGear(treFoci, null, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon,
                                                cmsWeaponAccessory,
                                                cmsWeaponAccessoryGear, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle,
                                            cmsVehicleWeapon,
                                            cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear,
                                            cmsVehicleGear,
                                            cmsWeaponMount,
                                            cmsVehicleCyberware, cmsVehicleCyberwareGear,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshDrugs(treCustomDrugs, token: GenericToken).ConfigureAwait(false);

                                        await DoExpenseEntriesCollectionChanged(null, GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    using (Timekeeper.StartSyncron("load_frm_career_sortAndCallbacks",
                                               op_load_frm_career))
                                    {
                                        await treWeapons.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treArmor.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treGear.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treLifestyles.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treCustomDrugs.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treCyberware.DoThreadSafeAsync(x => x.SortCustomOrder(true), GenericToken)
                                            .ConfigureAwait(false);
                                        await treVehicles.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treCritterPowers.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treImprovements
                                            .DoThreadSafeAsync(x => x.SortCustomOrder(true), GenericToken)
                                            .ConfigureAwait(false);

                                        // Set up events linked to character changes
                                        GlobalSettings.ClipboardChangedAsync += DoRefreshPasteStatus;
                                        CharacterObject.MultiplePropertiesChangedAsync += OnCharacterPropertyChanged;
                                        CharacterObject.SettingsMultiplePropertiesChangedAsync += OnCharacterSettingsPropertyChanged;
                                        CharacterObject.AttributeSection.PropertyChangedAsync += MakeDirtyWithCharacterUpdate;
                                        CharacterObject.Spells.CollectionChangedAsync += SpellCollectionChanged;
                                        CharacterObject.ComplexForms.CollectionChangedAsync +=
                                            ComplexFormCollectionChanged;
                                        CharacterObject.Arts.CollectionChangedAsync += ArtCollectionChanged;
                                        CharacterObject.Enhancements.CollectionChangedAsync +=
                                            EnhancementCollectionChanged;
                                        CharacterObject.Metamagics.CollectionChangedAsync += MetamagicCollectionChanged;
                                        CharacterObject.InitiationGrades.CollectionChangedAsync
                                            += InitiationGradeCollectionChanged;
                                        CharacterObject.Powers.ListChangedAsync += PowersListChanged;
                                        CharacterObject.Powers.BeforeRemoveAsync += PowersBeforeRemove;
                                        CharacterObject.AIPrograms.CollectionChangedAsync += AIProgramCollectionChanged;
                                        CharacterObject.CritterPowers.CollectionChangedAsync +=
                                            CritterPowerCollectionChanged;
                                        CharacterObject.Qualities.CollectionChangedAsync += QualityCollectionChanged;
                                        CharacterObject.MartialArts.BeforeClearCollectionChangedAsync +=
                                            MartialArtBeforeClearCollectionChanged;
                                        CharacterObject.MartialArts.CollectionChangedAsync +=
                                            MartialArtCollectionChanged;
                                        CharacterObject.Lifestyles.CollectionChangedAsync +=
                                            LifestylesCollectionChanged;
                                        CharacterObject.Contacts.BeforeClearCollectionChangedAsync +=
                                            ContactBeforeClearCollectionChanged;
                                        CharacterObject.Contacts.CollectionChangedAsync += ContactCollectionChanged;
                                        CharacterObject.Spirits.BeforeClearCollectionChangedAsync +=
                                            SpiritBeforeClearCollectionChanged;
                                        CharacterObject.Spirits.CollectionChangedAsync += SpiritCollectionChanged;
                                        CharacterObject.Armor.BeforeClearCollectionChangedAsync +=
                                            ArmorBeforeClearCollectionChanged;
                                        CharacterObject.Armor.CollectionChangedAsync += ArmorCollectionChanged;
                                        CharacterObject.ArmorLocations.CollectionChangedAsync +=
                                            ArmorLocationCollectionChanged;
                                        CharacterObject.Weapons.BeforeClearCollectionChangedAsync +=
                                            WeaponBeforeClearCollectionChanged;
                                        CharacterObject.Weapons.CollectionChangedAsync += WeaponCollectionChanged;
                                        CharacterObject.WeaponLocations.CollectionChangedAsync
                                            += WeaponLocationCollectionChanged;
                                        CharacterObject.Gear.BeforeClearCollectionChangedAsync +=
                                            GearBeforeClearCollectionChanged;
                                        CharacterObject.Gear.CollectionChangedAsync += GearCollectionChanged;
                                        CharacterObject.GearLocations.CollectionChangedAsync +=
                                            GearLocationCollectionChanged;
                                        CharacterObject.Drugs.CollectionChangedAsync += DrugCollectionChanged;
                                        CharacterObject.Cyberware.BeforeClearCollectionChangedAsync +=
                                            CyberwareBeforeClearCollectionChanged;
                                        CharacterObject.Cyberware.CollectionChangedAsync += CyberwareCollectionChanged;
                                        CharacterObject.Vehicles.BeforeClearCollectionChangedAsync +=
                                            VehicleBeforeClearCollectionChanged;
                                        CharacterObject.Vehicles.CollectionChangedAsync += VehicleCollectionChanged;
                                        CharacterObject.VehicleLocations.CollectionChangedAsync
                                            += VehicleLocationCollectionChanged;
                                        CharacterObject.Spirits.CollectionChangedAsync += SpiritCollectionChanged;
                                        (await CharacterObject.GetImprovementsAsync(GenericToken).ConfigureAwait(false)).CollectionChangedAsync +=
                                            ImprovementCollectionChanged;
                                        (await CharacterObject.GetImprovementGroupsAsync(GenericToken).ConfigureAwait(false)).CollectionChangedAsync
                                            += ImprovementGroupCollectionChanged;
                                        (await CharacterObject.GetCalendarAsync(GenericToken).ConfigureAwait(false)).ListChangedAsync += CalendarWeekListChanged;
                                        CharacterObject.Drugs.CollectionChangedAsync += DrugCollectionChanged;
                                        CharacterObject.SustainedCollection.BeforeClearCollectionChangedAsync +=
                                            SustainedSpellBeforeClearCollectionChanged;
                                        CharacterObject.SustainedCollection.CollectionChangedAsync
                                            += SustainedSpellCollectionChanged;
                                        CharacterObject.ExpenseEntries.CollectionChangedAsync +=
                                            ExpenseEntriesCollectionChanged;

                                        SetupCommonCollectionDatabindings(true);
                                    }
                                }
                                finally
                                {
                                    IsLoading = false;
                                }

                                using (CustomActivity op_load_frm_career_finishingStuff =
                                       Timekeeper.StartSyncron("load_frm_career_finishingStuff", op_load_frm_career))
                                {
                                    // Directly awaiting here so that we can properly unset the dirty flag after the update
                                    await RequestAndProcessCharacterUpdate(GenericToken).ConfigureAwait(false);
                                    
                                    // Update tradition UI after character loading is complete
                                    Tradition objTradition = await CharacterObject.GetMagicTraditionAsync(GenericToken).ConfigureAwait(false);
                                    if (objTradition != null && objTradition.IsCustomTradition)
                                    {
                                        // Just update UI visibility without recreating the tradition
                                        await lblTraditionName.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await txtTraditionName.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await cboSpiritCombat.DoThreadSafeAsync(x => { x.Enabled = true; x.Visible = true; }, GenericToken).ConfigureAwait(false);
                                        await cboSpiritDetection.DoThreadSafeAsync(x => { x.Enabled = true; x.Visible = true; }, GenericToken).ConfigureAwait(false);
                                        await cboSpiritHealth.DoThreadSafeAsync(x => { x.Enabled = true; x.Visible = true; }, GenericToken).ConfigureAwait(false);
                                        await cboSpiritIllusion.DoThreadSafeAsync(x => { x.Enabled = true; x.Visible = true; }, GenericToken).ConfigureAwait(false);
                                        await cboSpiritManipulation.DoThreadSafeAsync(x => { x.Enabled = true; x.Visible = true; }, GenericToken).ConfigureAwait(false);
                                    }
 
                                    // Clear the Dirty flag which gets set when creating a new Character.
                                    if (!await CharacterObject.GetLoadAsDirtyAsync(GenericToken).ConfigureAwait(false))
                                        IsDirty = false;

                                    await Program.PluginLoader.CallPlugins(this, op_load_frm_career_finishingStuff,
                                            GenericToken)
                                        .ConfigureAwait(false);
                                }

                                ConcurrentBag<string> lstInternalIdsNeedingReapplyImprovements
                                    = await CharacterObject.TakeInternalIdsNeedingReapplyImprovementsAsync(GenericToken)
                                        .ConfigureAwait(false);
                                if (lstInternalIdsNeedingReapplyImprovements?.Count > 0 && !Utils.IsUnitTest)
                                {
                                    string strListFriendlyNames;
                                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdListFriendlyNames))
                                    {
                                        foreach (IHasInternalId objSource in await CharacterObject.GetItemsByInternalIdsAsync(lstInternalIdsNeedingReapplyImprovements, true, GenericToken).ConfigureAwait(false))
                                        {
                                            string strToAdd;
                                            if (objSource is IHasCustomName objCustomNameItem)
                                                strToAdd = objCustomNameItem.CustomName;
                                            else if (objSource is Improvement objImprovement)
                                                strToAdd = await CharacterObject.GetObjectNameAsync(objImprovement, token: GenericToken).ConfigureAwait(false);
                                            else if (objSource is IHasName objNamedItem)
                                                strToAdd = await objNamedItem.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                                            else
                                                strToAdd = objSource.InternalId;
                                            sbdListFriendlyNames.AppendLine(strToAdd);
                                        }
                                        strListFriendlyNames = sbdListFriendlyNames.ToString();
                                    }
                                    string strDescription = await LanguageManager.GetStringAsync("Message_ImprovementLoadError", token: GenericToken).ConfigureAwait(false);
                                    if (!string.IsNullOrEmpty(strListFriendlyNames))
                                    {
                                        strDescription += await LanguageManager.GetStringAsync("Message_ImprovementLoadErrorPart2", token: GenericToken).ConfigureAwait(false) + strListFriendlyNames;
                                    }
                                    if (await Program.ShowScrollableMessageBoxAsync(
                                        this, strDescription,
                                        await LanguageManager.GetStringAsync("MessageTitle_ImprovementLoadError", token: GenericToken).ConfigureAwait(false),
                                        MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false) == DialogResult.Yes)
                                    {
                                        await DoReapplyImprovements(lstInternalIdsNeedingReapplyImprovements,
                                            GenericToken).ConfigureAwait(false);
                                    }
                                }

                                // If we end up with a character who is flagged as dirty after loading, immediately autosave them
                                if (IsDirty)
                                    tskAutosave = AutoSaveCharacter(GenericToken);

                                op_load_frm_career.SetSuccess(true);
                            }
                            catch (OperationCanceledException)
                            {
                                //swallow this
                                op_load_frm_career?.SetSuccess(false);
                            }
                            catch (Exception ex)
                            {
                                ex = ex.Demystify();
                                if (op_load_frm_career != null)
                                {
                                    op_load_frm_career.SetSuccess(false);
                                    op_load_frm_career.MyTelemetryClient.TrackException(ex);
                                }

                                Log.Error(ex);
                                throw;
                            }
                            finally
                            {
                                await this.DoThreadSafeAsync(x => x.ResumeLayout(true), GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }

                        await tskAutosave.ConfigureAwait(false);
                    }
                    finally
                    {
                        await objCursorWait.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsFinishedInitializing = true;
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async Task TraditionOnPropertyChanged(object sender, PropertyChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                if (e.PropertyName == nameof(Tradition.DrainValue))
                {
                    Tradition objTradition = await CharacterObject.GetMagicTraditionAsync(token).ConfigureAwait(false);
                    decimal decDicePool = await objTradition.GetDrainValueAsync(token).ConfigureAwait(false);
                    switch (await objTradition.GetTypeAsync(token).ConfigureAwait(false))
                    {
                        case TraditionType.MAG:
                            await dpcDrainAttributes.SetDicePoolAsync(decDicePool, token).ConfigureAwait(false);
                            break;
                        case TraditionType.RES:
                            await dpcFadingAttributes.SetDicePoolAsync(decDicePool, token).ConfigureAwait(false);
                            break;
                    }
                }
                await MakeDirtyWithCharacterUpdate(token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task PowersBeforeRemove(object sender, RemovingOldEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshPowerCollectionBeforeRemove(treMetamagic, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task PowersListChanged(object sender, ListChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshPowerCollectionListChanged(treMetamagic, cmsMetamagic, cmsInitiationNotes, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task SpellCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ComplexFormCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm, cmsInitiationNotes, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ArtCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshArtCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task EnhancementCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshEnhancementCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task MetamagicCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshMetamagicCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task InitiationGradeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task AIProgramCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task CritterPowerCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshCritterPowers(treCritterPowers, cmsCritterPowers, e, token).ConfigureAwait(false);
                bool blnVisible
                    = await CharacterObject.CritterPowers
                                           .AnyAsync(x => x.Name == "Inhabitation" || x.Name == "Possession",
                                                     token).ConfigureAwait(false);
                await mnuCreateMenu.DoThreadSafeAsync(() => mnuSpecialPossess.Visible = blnVisible, token)
                                   .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task QualityCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshQualities(treQualities, cmsQuality, _fntNormal, _fntStrikeout, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task MartialArtBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshMartialArtsClearBindings(treMartialArts, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task MartialArtCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task LifestylesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ImprovementCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshCustomImprovements(treImprovements, lmtControl.LimitTreeView, cmsImprovementLocation,
                                                cmsImprovement, lmtControl.LimitContextMenuStrip, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ImprovementGroupCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshCustomImprovementLocations(treImprovements, cmsImprovementLocation, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task CalendarWeekListChanged(object sender, ListChangedEventArgs listChangedEventArgs, CancellationToken token = default)
        {
            try
            {
                await RefreshCalendar(lstCalendar, listChangedEventArgs, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ContactBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshContactsClearBindings(panContacts, panEnemies, panPets, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ContactCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshContacts(panContacts, panEnemies, panPets, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task SpiritBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshSpiritsClearBindings(panSpirits, panSprites, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task SpiritCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshSpirits(panSpirits, panSprites, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task SustainedSpellBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshSustainedSpellsClearBindings(flpSustainedSpells, flpSustainedComplexForms, flpSustainedCritterPowers, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task SustainedSpellCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshSustainedSpells(flpSustainedSpells, flpSustainedComplexForms, flpSustainedCritterPowers,
                                             chkPsycheActiveMagician, chkPsycheActiveTechnomancer, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task AttributeBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshAttributesClearBindings(pnlAttributes, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task AttributeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshAttributes(pnlAttributes, e, lblAttributes, -1, -1,
                                        await lblAttributesAug
                                              .DoThreadSafeFuncAsync(x => x.PreferredWidth, token)
                                              .ConfigureAwait(false),
                                        await lblAttributesMetatype
                                              .DoThreadSafeFuncAsync(x => x.PreferredWidth, token)
                                              .ConfigureAwait(false), token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ArmorBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshArmorClearBindings(treArmor, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ArmorCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod, cmsArmorGear, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ArmorLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshArmorLocations(treArmor, cmsArmorLocation, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task WeaponBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshWeaponsClearBindings(treWeapons, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task WeaponCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon, cmsWeaponAccessory,
                                     cmsWeaponAccessoryGear, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task WeaponLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshWeaponLocations(treWeapons, cmsWeaponLocation, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task GearBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshGearsClearBindings(treGear, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task GearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshGears(treGear, cmsGearLocation, cmsGear, null,
                                   await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, token)
                                                     .ConfigureAwait(false),
                                   await chkHideLoadedAmmo.DoThreadSafeFuncAsync(x => x.Checked, token)
                                                          .ConfigureAwait(false),
                                   e, token).ConfigureAwait(false);
                await RefreshFociFromGear(treFoci, null, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DrugCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshDrugs(treCustomDrugs, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task GearLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshGearLocations(treGear, cmsGearLocation, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task CyberwareBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshCyberwareClearBindings(treCyberware, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task CyberwareCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task VehicleBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshVehiclesClearBindings(treMartialArts, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task VehicleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle, cmsVehicleWeapon,
                                      cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear, cmsVehicleGear,
                                      cmsWeaponMount, cmsVehicleCyberware, cmsVehicleCyberwareGear, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task VehicleLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshVehicleLocations(treVehicles, cmsVehicleLocation, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private DebuggableSemaphoreSlim _objFormClosingSemaphore = new DebuggableSemaphoreSlim();

        private async void CharacterCareer_FormClosing(object sender, FormClosingEventArgs e)
        {
            try
            {
                DebuggableSemaphoreSlim objSemaphore = _objFormClosingSemaphore;
                if (objSemaphore?.IsDisposed != false)
                    return;
                await objSemaphore.WaitAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    Form frmSender = sender as Form;
                    if (frmSender != null)
                    {
                        e.Cancel = true; // Always have to cancel because of issues with async FormClosing events
                        await frmSender.DoThreadSafeAsync(x => x.Enabled = false, GenericToken).ConfigureAwait(false); // Disable the form to make sure we can't interract with it anymore
                    }

                    try
                    {
                        CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                        try
                        {
                            bool blnDoClose = false;
                            IsLoading = true;
                            try
                            {
                                // Caller returns and form stays open (weird async FormClosing event issue workaround)
                                await Task.Yield();

                                // If there are unsaved changes to the character, as the user if they would like to save their changes.
                                if (IsDirty && !Utils.IsUnitTest)
                                {
                                    string strCharacterName = await CharacterObject.GetCharacterNameAsync(GenericToken)
                                                                                   .ConfigureAwait(false);
                                    DialogResult eResult = await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        string.Format(GlobalSettings.CultureInfo,
                                            await LanguageManager
                                                .GetStringAsync("Message_UnsavedChanges", token: GenericToken)
                                                .ConfigureAwait(false),
                                            strCharacterName),
                                        await LanguageManager.GetStringAsync("MessageTitle_UnsavedChanges", token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.YesNoCancel, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false);
                                    switch (eResult)
                                    {
                                        case DialogResult.Yes:
                                            {
                                                // Attempt to save the Character. If the user cancels the Save As dialogue that may open, cancel the closing event so that changes are not lost.
                                                bool blnResult = await SaveCharacter(token: GenericToken).ConfigureAwait(false);
                                                if (!blnResult)
                                                    return;
                                                break;
                                            }
                                        case DialogResult.Cancel:
                                            return;
                                    }
                                }

                                await this.DoThreadSafeAsync(x => x.UseWaitCursor = true, GenericToken).ConfigureAwait(false);
                                CancelGenericToken();

                                // Unsubscribe from events.
                                Tradition objTradition = await CharacterObject.GetMagicTraditionAsync(CancellationToken.None).ConfigureAwait(false);
                                objTradition.PropertyChangedAsync -= TraditionOnPropertyChanged;
                                GlobalSettings.ClipboardChangedAsync -= DoRefreshPasteStatus;
                                CharacterObject.MultiplePropertiesChangedAsync -= OnCharacterPropertyChanged;
                                CharacterObject.SettingsMultiplePropertiesChangedAsync -= OnCharacterSettingsPropertyChanged;
                                CharacterObject.AttributeSection.PropertyChangedAsync -= MakeDirtyWithCharacterUpdate;
                                CharacterObject.AttributeSection.Attributes.BeforeClearCollectionChangedAsync
                                    -= AttributeBeforeClearCollectionChanged;
                                CharacterObject.AttributeSection.Attributes.CollectionChangedAsync -= AttributeCollectionChanged;
                                CharacterObject.Spells.CollectionChangedAsync -= SpellCollectionChanged;
                                CharacterObject.ComplexForms.CollectionChangedAsync -= ComplexFormCollectionChanged;
                                CharacterObject.Arts.CollectionChangedAsync -= ArtCollectionChanged;
                                CharacterObject.Enhancements.CollectionChangedAsync -= EnhancementCollectionChanged;
                                CharacterObject.Metamagics.CollectionChangedAsync -= MetamagicCollectionChanged;
                                CharacterObject.InitiationGrades.CollectionChangedAsync -= InitiationGradeCollectionChanged;
                                CharacterObject.Powers.ListChangedAsync -= PowersListChanged;
                                CharacterObject.Powers.BeforeRemoveAsync -= PowersBeforeRemove;
                                CharacterObject.AIPrograms.CollectionChangedAsync -= AIProgramCollectionChanged;
                                CharacterObject.CritterPowers.CollectionChangedAsync -= CritterPowerCollectionChanged;
                                CharacterObject.Qualities.CollectionChangedAsync -= QualityCollectionChanged;
                                CharacterObject.MartialArts.BeforeClearCollectionChangedAsync -=
                                    MartialArtBeforeClearCollectionChanged;
                                CharacterObject.MartialArts.CollectionChangedAsync -= MartialArtCollectionChanged;
                                CharacterObject.Lifestyles.CollectionChangedAsync -= LifestylesCollectionChanged;
                                CharacterObject.Contacts.BeforeClearCollectionChangedAsync -= ContactBeforeClearCollectionChanged;
                                CharacterObject.Contacts.CollectionChangedAsync -= ContactCollectionChanged;
                                CharacterObject.Spirits.BeforeClearCollectionChangedAsync -= SpiritBeforeClearCollectionChanged;
                                CharacterObject.Spirits.CollectionChangedAsync -= SpiritCollectionChanged;
                                CharacterObject.Armor.BeforeClearCollectionChangedAsync -=
                                    ArmorBeforeClearCollectionChanged;
                                CharacterObject.Armor.CollectionChangedAsync -= ArmorCollectionChanged;
                                CharacterObject.ArmorLocations.CollectionChangedAsync -= ArmorLocationCollectionChanged;
                                CharacterObject.Weapons.BeforeClearCollectionChangedAsync -=
                                    WeaponBeforeClearCollectionChanged;
                                CharacterObject.Weapons.CollectionChangedAsync -= WeaponCollectionChanged;
                                CharacterObject.Drugs.CollectionChangedAsync -= DrugCollectionChanged;
                                CharacterObject.WeaponLocations.CollectionChangedAsync -= WeaponLocationCollectionChanged;
                                CharacterObject.Gear.BeforeClearCollectionChangedAsync -=
                                    GearBeforeClearCollectionChanged;
                                CharacterObject.Gear.CollectionChangedAsync -= GearCollectionChanged;
                                CharacterObject.GearLocations.CollectionChangedAsync -= GearLocationCollectionChanged;
                                CharacterObject.Cyberware.BeforeClearCollectionChangedAsync -=
                                    CyberwareBeforeClearCollectionChanged;
                                CharacterObject.Cyberware.CollectionChangedAsync -= CyberwareCollectionChanged;
                                CharacterObject.Vehicles.BeforeClearCollectionChangedAsync -=
                                    VehicleBeforeClearCollectionChanged;
                                CharacterObject.Vehicles.CollectionChangedAsync -= VehicleCollectionChanged;
                                CharacterObject.VehicleLocations.CollectionChangedAsync -= VehicleLocationCollectionChanged;
                                CharacterObject.Spirits.CollectionChangedAsync -= SpiritCollectionChanged;
                                (await CharacterObject.GetImprovementsAsync(CancellationToken.None).ConfigureAwait(false)).CollectionChangedAsync -= ImprovementCollectionChanged;
                                (await CharacterObject.GetImprovementGroupsAsync(CancellationToken.None).ConfigureAwait(false)).CollectionChangedAsync -= ImprovementGroupCollectionChanged;
                                (await CharacterObject.GetCalendarAsync(CancellationToken.None).ConfigureAwait(false)).ListChangedAsync -= CalendarWeekListChanged;
                                CharacterObject.Drugs.CollectionChangedAsync -= DrugCollectionChanged;
                                CharacterObject.SustainedCollection.BeforeClearCollectionChangedAsync -=
                                    SustainedSpellBeforeClearCollectionChanged;
                                CharacterObject.SustainedCollection.CollectionChangedAsync -= SustainedSpellCollectionChanged;
                                CharacterObject.ExpenseEntries.CollectionChangedAsync -= ExpenseEntriesCollectionChanged;

                                SetupCommonCollectionDatabindings(false);

                                // Clear the mugshot image so that we don't get crashes from disposal ordering (image can get disposed before its picturebox does)
                                await picMugshot.DoThreadSafeAsync(x => x.Image = null, CancellationToken.None).ConfigureAwait(false);

                                await Task.WhenAll(RefreshAttributesClearBindings(pnlAttributes, CancellationToken.None),
                                    RefreshMartialArtsClearBindings(treMartialArts, CancellationToken.None),
                                    RefreshArmorClearBindings(treArmor, CancellationToken.None),
                                    RefreshWeaponsClearBindings(treWeapons, CancellationToken.None),
                                    RefreshGearsClearBindings(treGear, CancellationToken.None),
                                    RefreshCyberwareClearBindings(treCyberware, CancellationToken.None),
                                    RefreshVehiclesClearBindings(treVehicles, CancellationToken.None),
                                    RefreshContactsClearBindings(panContacts, panEnemies, panPets,
                                        CancellationToken.None),
                                    RefreshSpiritsClearBindings(panSpirits, panSprites,
                                        CancellationToken.None),
                                    RefreshSustainedSpellsClearBindings(flpSustainedSpells, flpSustainedComplexForms,
                                        flpSustainedCritterPowers,
                                        CancellationToken.None)).ConfigureAwait(false);
                                try
                                {
                                    await UpdateCharacterInfoTask.ConfigureAwait(false);
                                }
                                catch (OperationCanceledException)
                                {
                                    //swallow this
                                }

                                blnDoClose = true;
                            }
                            finally
                            {
                                if (!blnDoClose)
                                    IsLoading = false;
                            }
                        }
                        finally
                        {
                            await objCursorWait.DisposeAsync().ConfigureAwait(false);
                        }

                        // Now we close the original caller (weird async FormClosing event issue workaround)
                        if (frmSender != null)
                        {
                            await frmSender.DoThreadSafeAsync(x =>
                            {
                                x.FormClosing -= CharacterCareer_FormClosing;
                                try
                                {
                                    x.Close();
                                }
                                catch
                                {
                                    // Ignore disposal errors if we are quitting the program anyway
                                    if (Program.MainForm.IsNullOrDisposed() || Program.MainForm.IsClosing)
                                        return;
                                    throw;
                                }
                            }, CancellationToken.None).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        if (frmSender != null)
                            await frmSender.DoThreadSafeAsync(x => x.Enabled = true, CancellationToken.None).ConfigureAwait(false); // Doesn't matter if we're closed
                    }
                }
                finally
                {
                    if (!objSemaphore.IsDisposed)
                        objSemaphore.Release();
                }
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private void CharacterCareer_Activated(object sender, EventArgs e)
        {
            ToolStripManager.Merge(tsMain, Program.MainForm.MainToolStrip);
        }

        private void CharacterCareer_Deactivate(object sender, EventArgs e)
        {
            ToolStripManager.RevertMerge(Program.MainForm.MainToolStrip, tsMain);
        }

        #endregion Form Events

        #region Character Events

        private async Task OnCharacterPropertyChanged(object sender, MultiplePropertiesChangedEventArgs e,
            CancellationToken token = default)
        {
            if (_blnReapplyImprovements)
                return;
            await SetDirty(true, token).ConfigureAwait(false);
            try
            {
                if (e.PropertyNames.Contains(nameof(Character.CharacterName)))
                {
                    await UpdateWindowTitleAsync(false, token).ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.DisplayNuyen)))
                {
                    string strDisplayNuyen = await CharacterObject.GetDisplayNuyenAsync(token).ConfigureAwait(false);
                    await StatusStrip
                        .DoThreadSafeAsync(() => tslNuyen.Text = strDisplayNuyen, token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.DisplayKarma)))
                {
                    string strDisplayKarma = await CharacterObject.GetDisplayKarmaAsync(token).ConfigureAwait(false);
                    await StatusStrip
                        .DoThreadSafeAsync(() => tslKarma.Text = strDisplayKarma, token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.DisplayEssence)))
                {
                    string strDisplayEssence =
                        await CharacterObject.GetDisplayEssenceAsync(token).ConfigureAwait(false);
                    await StatusStrip
                        .DoThreadSafeAsync(() => tslEssence.Text = strDisplayEssence, token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.DisplayTotalCarriedWeight)))
                {
                    string strDisplayTotalCarriedWeight = await CharacterObject.GetDisplayTotalCarriedWeightAsync(token)
                        .ConfigureAwait(false);
                    await StatusStrip.DoThreadSafeAsync(
                            () => tslCarriedWeight.Text = strDisplayTotalCarriedWeight,
                            token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.Encumbrance)))
                {
                    bool blnHasEncumbrance = await CharacterObject.GetEncumbranceAsync(token).ConfigureAwait(false) > 0;
                    await StatusStrip.DoThreadSafeAsync(() => tslCarriedWeight.ForeColor
                            = blnHasEncumbrance
                                ? ColorManager.ErrorColor
                                : ColorManager.ControlText, token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.Source)) ||
                    e.PropertyNames.Contains(nameof(Character.Page)))
                {
                    await CharacterObject.SetSourceDetailAsync(lblMetatypeSource, token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.CMOverflow)) ||
                    e.PropertyNames.Contains(nameof(Character.CMThreshold)) ||
                    e.PropertyNames.Contains(nameof(Character.CMThresholdOffsets)))
                {
                    await ProcessCharacterConditionMonitorBoxDisplays(
                            panPhysicalCM, await CharacterObject.GetPhysicalCMAsync(token).ConfigureAwait(false),
                            await CharacterObject.GetCMThresholdAsync(token).ConfigureAwait(false),
                            await CharacterObject.GetPhysicalCMThresholdOffsetAsync(token).ConfigureAwait(false),
                            await CharacterObject.GetCMOverflowAsync(token).ConfigureAwait(false),
                            chkPhysicalCM_CheckedChanged, true,
                            await CharacterObject.GetPhysicalCMFilledAsync(token).ConfigureAwait(false), token)
                        .ConfigureAwait(false);
                    await ProcessCharacterConditionMonitorBoxDisplays(
                            panStunCM, await CharacterObject.GetStunCMAsync(token).ConfigureAwait(false),
                            await CharacterObject.GetCMThresholdAsync(token).ConfigureAwait(false),
                            await CharacterObject.GetStunCMThresholdOffsetAsync(token).ConfigureAwait(false),
                            0,
                            chkStunCM_CheckedChanged, true,
                            await CharacterObject.GetStunCMFilledAsync(token).ConfigureAwait(false), token)
                        .ConfigureAwait(false);
                }
                else
                {
                    if (e.PropertyNames.Contains(nameof(Character.StunCM)) ||
                        e.PropertyNames.Contains(nameof(Character.StunCMFilled)) ||
                        e.PropertyNames.Contains(nameof(Character.StunCMThresholdOffset)))
                    {
                        await ProcessCharacterConditionMonitorBoxDisplays(
                                panStunCM, await CharacterObject.GetStunCMAsync(token).ConfigureAwait(false),
                                await CharacterObject.GetCMThresholdAsync(token).ConfigureAwait(false),
                                await CharacterObject.GetStunCMThresholdOffsetAsync(token).ConfigureAwait(false),
                                0,
                                chkStunCM_CheckedChanged, true,
                                await CharacterObject.GetStunCMFilledAsync(token).ConfigureAwait(false), token)
                            .ConfigureAwait(false);
                    }

                    if (e.PropertyNames.Contains(nameof(Character.PhysicalCM)) ||
                        e.PropertyNames.Contains(nameof(Character.PhysicalCMFilled)) ||
                        e.PropertyNames.Contains(nameof(Character.PhysicalCMThresholdOffset)))
                    {
                        await ProcessCharacterConditionMonitorBoxDisplays(
                                panPhysicalCM, await CharacterObject.GetPhysicalCMAsync(token).ConfigureAwait(false),
                                await CharacterObject.GetCMThresholdAsync(token).ConfigureAwait(false),
                                await CharacterObject.GetPhysicalCMThresholdOffsetAsync(token).ConfigureAwait(false),
                                await CharacterObject.GetCMOverflowAsync(token).ConfigureAwait(false),
                                chkPhysicalCM_CheckedChanged, true,
                                await CharacterObject.GetPhysicalCMFilledAsync(token).ConfigureAwait(false), token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.MAGEnabled)))
                {
                    if (await CharacterObject.GetMAGEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabInitiation))
                                x.TabPages.Insert(3, tabInitiation);
                        }, token).ConfigureAwait(false);

                        await UpdateInitiationCost(token).ConfigureAwait(false);

                        string strTemp1 = await LanguageManager
                            .GetStringAsync("Tab_Initiation", token: token)
                            .ConfigureAwait(false);
                        await tabInitiation.DoThreadSafeAsync(x => x.Text = strTemp1, token)
                            .ConfigureAwait(false);
                        string strTemp2 = await LanguageManager
                            .GetStringAsync("Button_AddMetamagic", token: token)
                            .ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(() => tsMetamagicAddMetamagic.Text = strTemp2,
                            token).ConfigureAwait(false);
                        string strTemp3 = await LanguageManager
                            .GetStringAsync("Button_AddInitiateGrade", token: token)
                            .ConfigureAwait(false);
                        await cmdAddMetamagic.DoThreadSafeAsync(x => x.Text = strTemp3, token)
                            .ConfigureAwait(false);
                        string strTemp4 = await LanguageManager
                            .GetStringAsync("Button_RemoveInitiateGrade", token: token)
                            .ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x => x.Text = strTemp4, token)
                            .ConfigureAwait(false);
                        string strTemp5 = await LanguageManager
                            .GetStringAsync("String_InitiationType", token: token)
                            .ConfigureAwait(false);
                        await gpbInitiationType.DoThreadSafeAsync(x => x.Text = strTemp5, token)
                            .ConfigureAwait(false);
                        string strTemp6 = await LanguageManager
                            .GetStringAsync("String_InitiationGroup", token: token)
                            .ConfigureAwait(false);
                        await gpbInitiationGroup.DoThreadSafeAsync(x => x.Text = strTemp6, token)
                            .ConfigureAwait(false);
                        string strText1 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_InitiationOrdeal", token: token).ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaMAGInitiationOrdealPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        await chkInitiationOrdeal.DoThreadSafeAsync(x => x.Text = strText1, token)
                            .ConfigureAwait(false);
                        string strText2 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_InitiationGroup", token: token).ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaMAGInitiationGroupPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        await chkInitiationGroup.DoThreadSafeAsync(x => x.Text = strText2, token)
                            .ConfigureAwait(false);
                        string strText3 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_InitiationSchooling", token: token)
                                .ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaMAGInitiationSchoolingPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        await chkInitiationSchooling.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText3;
                            x.Enabled = true;
                        }, token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(() =>
                        {
                            tsMetamagicAddArt.Visible = true;
                            tsMetamagicAddEnchantment.Visible = true;
                            tsMetamagicAddEnhancement.Visible = true;
                            tsMetamagicAddRitual.Visible = true;
                        }, token).ConfigureAwait(false);
                        int intGrade = await CharacterObject.GetInitiateGradeAsync(token).ConfigureAwait(false);
                        string strInitTip = string.Format(GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Tip_ImproveInitiateGrade", token: token).ConfigureAwait(false),
                            intGrade + 1,
                            await CharacterObjectSettings.GetKarmaInitiationFlatAsync(token).ConfigureAwait(false) + (intGrade + 1) *
                            await CharacterObjectSettings.GetKarmaInitiationAsync(token).ConfigureAwait(false));
                        await cmdAddMetamagic.SetToolTipTextAsync(strInitTip, token).ConfigureAwait(false);
                        string strTemp7 = await LanguageManager
                            .GetStringAsync("Checkbox_JoinedGroup", token: token)
                            .ConfigureAwait(false);
                        await chkJoinGroup.DoThreadSafeAsync(x => x.Text = strTemp7, token)
                            .ConfigureAwait(false);

                        await gpbGearBondedFoci
                            .DoThreadSafeAsync(x => x.Visible = true, token)
                            .ConfigureAwait(false);
                        await lblAstralINI.DoThreadSafeAsync(x => x.Visible = true, token)
                            .ConfigureAwait(false);
                    }
                    else
                    {
                        if (!await CharacterObject.GetRESEnabledAsync(token).ConfigureAwait(false))
                            await tabCharacterTabs
                                .DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation), token)
                                .ConfigureAwait(false);

                        await gpbGearBondedFoci
                            .DoThreadSafeAsync(x => x.Visible = false, token)
                            .ConfigureAwait(false);
                        await lblAstralINI.DoThreadSafeAsync(x => x.Visible = false, token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.RESEnabled)))
                {
                    if (await CharacterObject.GetRESEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabInitiation))
                                x.TabPages.Insert(3, tabInitiation);
                        }, token).ConfigureAwait(false);

                        /*
                        int intEssenceLoss = 0;
                        if (!CharacterObjectSettings.ESSLossReducesMaximumOnly)
                            intEssenceLoss = _objCharacter.EssencePenalty;
                        // If the character options permit submersion in create mode, show the Initiation page.
                        */
                        await UpdateInitiationCost(token).ConfigureAwait(false);

                        string strTemp1 = await LanguageManager
                            .GetStringAsync("Tab_Submersion", token: token)
                            .ConfigureAwait(false);
                        await tabInitiation.DoThreadSafeAsync(x => x.Text = strTemp1, token)
                            .ConfigureAwait(false);
                        string strTemp2 = await LanguageManager
                            .GetStringAsync("Button_AddEcho", token: token)
                            .ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(() => tsMetamagicAddMetamagic.Text = strTemp2,
                            token).ConfigureAwait(false);
                        string strTemp3 = await LanguageManager
                            .GetStringAsync("Button_AddSubmersionGrade", token: token)
                            .ConfigureAwait(false);
                        await cmdAddMetamagic.DoThreadSafeAsync(x => x.Text = strTemp3, token)
                            .ConfigureAwait(false);
                        string strTemp4 = await LanguageManager
                            .GetStringAsync("Button_RemoveSubmersionGrade", token: token)
                            .ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x => x.Text = strTemp4, token)
                            .ConfigureAwait(false);
                        string strTemp5 = await LanguageManager
                            .GetStringAsync("String_SubmersionType", token: token)
                            .ConfigureAwait(false);
                        await gpbInitiationType.DoThreadSafeAsync(x => x.Text = strTemp5, token)
                            .ConfigureAwait(false);
                        string strTemp6 = await LanguageManager
                            .GetStringAsync("String_SubmersionNetwork", token: token)
                            .ConfigureAwait(false);
                        await gpbInitiationGroup.DoThreadSafeAsync(x => x.Text = strTemp6, token)
                            .ConfigureAwait(false);
                        string strText1 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_SubmersionTask", token: token).ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaRESInitiationOrdealPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        await chkInitiationOrdeal.DoThreadSafeAsync(x => x.Text = strText1, token)
                            .ConfigureAwait(false);
                        string strText2 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_NetworkSubmersion", token: token).ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaRESInitiationGroupPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        await chkInitiationGroup.DoThreadSafeAsync(x => x.Text = strText2, token)
                            .ConfigureAwait(false);
                        string strText3 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_InitiationSchooling", token: token)
                                .ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaRESInitiationSchoolingPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        bool blnEnabled = await CharacterObjectSettings.GetAllowTechnomancerSchoolingAsync(token).ConfigureAwait(false);
                        await chkInitiationSchooling.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText3;
                            x.Enabled = blnEnabled;
                        }, token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(() =>
                        {
                            tsMetamagicAddArt.Visible = false;
                            tsMetamagicAddEnchantment.Visible = false;
                            tsMetamagicAddEnhancement.Visible = false;
                            tsMetamagicAddRitual.Visible = false;
                        }, token).ConfigureAwait(false);
                        int intGrade = await CharacterObject.GetSubmersionGradeAsync(token).ConfigureAwait(false);
                        string strInitTip = string.Format(GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Tip_ImproveSubmersionGrade", token: token).ConfigureAwait(false),
                            intGrade + 1,
                            await CharacterObjectSettings.GetKarmaInitiationFlatAsync(token).ConfigureAwait(false) + (intGrade + 1) *
                            await CharacterObjectSettings.GetKarmaInitiationAsync(token).ConfigureAwait(false));
                        await cmdAddMetamagic.SetToolTipTextAsync(strInitTip, token).ConfigureAwait(false);
                        string strTemp7 = await LanguageManager
                            .GetStringAsync("Checkbox_JoinedNetwork", token: token)
                            .ConfigureAwait(false);
                        await chkJoinGroup.DoThreadSafeAsync(x => x.Text = strTemp7, token)
                            .ConfigureAwait(false);
                    }
                    else
                    {
                        if (!await CharacterObject.GetMAGEnabledAsync(token).ConfigureAwait(false))
                            await tabCharacterTabs
                                .DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation), token)
                                .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.Ambidextrous)))
                {
                    using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                               Utils.ListItemListPool, out List<ListItem> lstPrimaryArm))
                    {
                        if (await CharacterObject.GetAmbidextrousAsync(token).ConfigureAwait(false))
                        {
                            lstPrimaryArm.Add(new ListItem("Ambidextrous",
                                await LanguageManager.GetStringAsync(
                                    "String_Ambidextrous", token: token).ConfigureAwait(false)));
                            await cboPrimaryArm.DoThreadSafeAsync(x => x.Enabled = false, token)
                                .ConfigureAwait(false);
                        }
                        else
                        {
                            //Create the dropdown for the character's primary arm.
                            lstPrimaryArm.Add(new ListItem(
                                "Left",
                                await LanguageManager.GetStringAsync(
                                    "String_Improvement_SideLeft", token: token).ConfigureAwait(false)));
                            lstPrimaryArm.Add(new ListItem(
                                "Right",
                                await LanguageManager.GetStringAsync(
                                    "String_Improvement_SideRight", token: token).ConfigureAwait(false)));
                            lstPrimaryArm.Sort(CompareListItems.CompareNames);
                            await cboPrimaryArm.DoThreadSafeAsync(x => x.Enabled = true, token)
                                .ConfigureAwait(false);
                        }

                        string strPrimaryArm = await CharacterObject.GetPrimaryArmAsync(token).ConfigureAwait(false);

                        await cboPrimaryArm.PopulateWithListItemsAsync(lstPrimaryArm, token)
                            .ConfigureAwait(false);
                        await cboPrimaryArm.DoThreadSafeAsync(x =>
                        {
                            if (!string.IsNullOrEmpty(strPrimaryArm))
                                x.SelectedValue = strPrimaryArm;
                            if (x.SelectedIndex == -1)
                                x.SelectedIndex = 0;
                        }, token).ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.MagicianEnabled)))
                {
                    // Change to the status of Magician being enabled.
                    bool blnMagicianEnabled =
                        await CharacterObject.GetMagicianEnabledAsync(token).ConfigureAwait(false);
                    if (blnMagicianEnabled ||
                        await CharacterObject.GetAdeptEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabMagician))
                                x.TabPages.Insert(3, tabMagician);
                        }, token).ConfigureAwait(false);
                        await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, token)
                            .ConfigureAwait(false);
                    }
                    else
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabMagician), token)
                            .ConfigureAwait(false);
                        await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = false, token)
                            .ConfigureAwait(false);
                    }

                    await cmdAddSpirit
                        .DoThreadSafeAsync(x => x.Visible = blnMagicianEnabled, token)
                        .ConfigureAwait(false);
                    await panSpirits
                            .DoThreadSafeAsync(x => x.Visible = blnMagicianEnabled, token)
                            .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.AdeptEnabled)))
                {
                    // Change to the status of Adept being enabled.
                    if (await CharacterObject.GetAdeptEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabMagician))
                                x.TabPages.Insert(3, tabMagician);
                        }, token).ConfigureAwait(false);
                        await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, token)
                            .ConfigureAwait(false);

                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabAdept))
                                x.TabPages.Insert(3, tabAdept);
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        if (!await CharacterObject.GetMagicianEnabledAsync(token).ConfigureAwait(false))
                        {
                            await tabCharacterTabs
                                .DoThreadSafeAsync(x => x.TabPages.Remove(tabMagician), token)
                                .ConfigureAwait(false);
                            await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = false, token)
                                .ConfigureAwait(false);
                        }
                        else
                            await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, token)
                                .ConfigureAwait(false);

                        await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabAdept), token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.TechnomancerEnabled)))
                {
                    // Change to the status of Technomancer being enabled.
                    if (await CharacterObject.GetTechnomancerEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabTechnomancer))
                                x.TabPages.Insert(3, tabTechnomancer);
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await tabCharacterTabs
                            .DoThreadSafeAsync(x => x.TabPages.Remove(tabTechnomancer), token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.AdvancedProgramsEnabled)))
                {
                    // Change to the status of Advanced Programs being enabled.
                    if (await CharacterObject.GetAdvancedProgramsEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabAdvancedPrograms))
                                x.TabPages.Insert(3, tabAdvancedPrograms);
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await tabCharacterTabs
                            .DoThreadSafeAsync(x => x.TabPages.Remove(tabAdvancedPrograms), token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.CritterEnabled)))
                {
                    // Change the status of Critter being enabled.
                    if (await CharacterObject.GetCritterEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabCritter))
                                x.TabPages.Insert(3, tabCritter);
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabCritter), token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.AddBiowareEnabled)) && !await CharacterObject.GetAddBiowareEnabledAsync(token).ConfigureAwait(false))
                {
                    string strBiowareDisabledSource = string.Empty;
                    Improvement objDisablingImprovement = (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                CharacterObject,
                                Improvement.ImprovementType.DisableBioware, token: token)
                            .ConfigureAwait(false))
                        .FirstOrDefault();
                    if (objDisablingImprovement != null)
                    {
                        strBiowareDisabledSource =
                            await LanguageManager.GetStringAsync("String_Space", token: token)
                                .ConfigureAwait(false) + "(" +
                            await CharacterObject
                                .GetObjectNameAsync(objDisablingImprovement, token: token)
                                .ConfigureAwait(false) + ")" +
                            await LanguageManager.GetStringAsync("String_Space", token: token)
                                .ConfigureAwait(false);
                    }

                    foreach (Cyberware objCyberware in await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).DeepWhereAsync(
                                     x => x.GetChildrenAsync(token), async x =>
                                     {
                                         if (x.SourceType != Improvement.ImprovementSource.Bioware)
                                             return false;
                                         Guid guidSourceId = await x.GetSourceIDAsync(token).ConfigureAwait(false);
                                         return guidSourceId != Cyberware.EssenceHoleGUID
                                                && guidSourceId != Cyberware.EssenceAntiHoleGUID
                                                && await x.GetIsModularCurrentlyEquippedAsync(token)
                                                    .ConfigureAwait(false)
                                                && (!string.IsNullOrEmpty(await x.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false))
                                                    || await x.GetCanRemoveThroughImprovementsAsync(token)
                                                        .ConfigureAwait(false));
                                     }, token)
                                 .ConfigureAwait(false))
                    {
                        if (!string.IsNullOrEmpty(await objCyberware.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false)))
                        {
                            if (!await objCyberware.GetCanRemoveThroughImprovementsAsync(token)
                                    .ConfigureAwait(false))
                                continue;
                            Cyberware objParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false);
                            if (objParent != null)
                                await (await objParent.GetChildrenAsync(token).ConfigureAwait(false)).RemoveAsync(objCyberware, token)
                                    .ConfigureAwait(false);
                            await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).AddAsync(objCyberware, token)
                                .ConfigureAwait(false);
                            await objCyberware.ChangeModularEquipAsync(false, token: token)
                                .ConfigureAwait(false);
                        }
                        else
                        {
                            await objCyberware.DeleteCyberwareAsync(token: token).ConfigureAwait(false);
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            string strEntry = await LanguageManager
                                .GetStringAsync(
                                    "String_ExpenseSoldBioware", token: token)
                                .ConfigureAwait(false);
                            objExpense.Create(0,
                                strEntry + strBiowareDisabledSource +
                                await objCyberware.GetCurrentDisplayNameShortAsync(token)
                                    .ConfigureAwait(false),
                                ExpenseType.Nuyen,
                                DateTime.Now);
                            await CharacterObject.ExpenseEntries
                                .AddWithSortAsync(objExpense, token: token)
                                .ConfigureAwait(false);
                        }
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.AddCyberwareEnabled)) && !await CharacterObject.GetAddCyberwareEnabledAsync(token).ConfigureAwait(false))
                {
                    string strCyberwareDisabledSource = string.Empty;
                    Improvement objDisablingImprovement = (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                CharacterObject,
                                Improvement.ImprovementType
                                    .DisableCyberware, token: token)
                            .ConfigureAwait(false))
                        .FirstOrDefault();
                    if (objDisablingImprovement != null)
                    {
                        strCyberwareDisabledSource =
                            await LanguageManager.GetStringAsync("String_Space", token: token)
                                .ConfigureAwait(false) + "(" +
                            await CharacterObject
                                .GetObjectNameAsync(objDisablingImprovement, token: token)
                                .ConfigureAwait(false) + ")" +
                            await LanguageManager.GetStringAsync("String_Space", token: token)
                                .ConfigureAwait(false);
                    }

                    foreach (Cyberware objCyberware in await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).DeepWhereAsync(
                                     x => x.GetChildrenAsync(token), async x =>
                                     {
                                         if (x.SourceType != Improvement.ImprovementSource.Cyberware)
                                             return false;
                                         Guid guidSourceId = await x.GetSourceIDAsync(token).ConfigureAwait(false);
                                         return guidSourceId != Cyberware.EssenceHoleGUID
                                                && guidSourceId != Cyberware.EssenceAntiHoleGUID
                                                && await x.GetIsModularCurrentlyEquippedAsync(token)
                                                    .ConfigureAwait(false)
                                                && (!string.IsNullOrEmpty(await x.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false))
                                                    || await x.GetCanRemoveThroughImprovementsAsync(token)
                                                        .ConfigureAwait(false));
                                     }, token)
                                 .ConfigureAwait(false))
                    {
                        if (!string.IsNullOrEmpty(await objCyberware.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false)))
                        {
                            if (!await objCyberware.GetCanRemoveThroughImprovementsAsync(token)
                                    .ConfigureAwait(false))
                                continue;
                            Cyberware objParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false);
                            if (objParent != null)
                                await (await objParent.GetChildrenAsync(token).ConfigureAwait(false)).RemoveAsync(objCyberware, token)
                                    .ConfigureAwait(false);
                            await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).AddAsync(objCyberware, token).ConfigureAwait(false);
                            await objCyberware.ChangeModularEquipAsync(false, token: token).ConfigureAwait(false);
                        }
                        else
                        {
                            await objCyberware.DeleteCyberwareAsync(token: token).ConfigureAwait(false);
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            string strEntry
                                = await LanguageManager.GetStringAsync("String_ExpenseSoldCyberware", token: token)
                                    .ConfigureAwait(false);
                            objExpense.Create(0,
                                strEntry + strCyberwareDisabledSource +
                                await objCyberware
                                    .GetCurrentDisplayNameShortAsync(token: token)
                                    .ConfigureAwait(false),
                                ExpenseType.Nuyen,
                                DateTime.Now);
                            await CharacterObject.ExpenseEntries
                                .AddWithSortAsync(objExpense, token: token)
                                .ConfigureAwait(false);
                        }
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.ExCon)) && await CharacterObject.GetExConAsync(token).ConfigureAwait(false))
                {
                    string strExConString = string.Empty;
                    Improvement objExConImprovement = (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                CharacterObject,
                                Improvement.ImprovementType.ExCon, token: token)
                            .ConfigureAwait(false))
                        .FirstOrDefault();
                    if (objExConImprovement != null)
                    {
                        strExConString
                            = await LanguageManager.GetStringAsync("String_Space", token: token)
                                  .ConfigureAwait(false) + "(" +
                              await CharacterObject.GetObjectNameAsync(objExConImprovement, token: token)
                                  .ConfigureAwait(false) + ")" +
                              await LanguageManager.GetStringAsync("String_Space", token: token)
                                  .ConfigureAwait(false);
                    }

                    foreach (Cyberware objCyberware in await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).DeepWhereAsync(
                                     x => x.GetChildrenAsync(token), async x =>
                                     {
                                         Guid guidSourceId = await x.GetSourceIDAsync(token).ConfigureAwait(false);
                                         return guidSourceId != Cyberware.EssenceHoleGUID
                                                && guidSourceId != Cyberware.EssenceAntiHoleGUID
                                                && (await x.GetGradeAsync(token).ConfigureAwait(false)).Name != "None"
                                                && await x.GetIsModularCurrentlyEquippedAsync(token)
                                                    .ConfigureAwait(false)
                                                && (!string.IsNullOrEmpty(await x.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false))
                                                    || await x.GetCanRemoveThroughImprovementsAsync(token)
                                                        .ConfigureAwait(false));
                                     }, token)
                                 .ConfigureAwait(false))
                    {
                        char chrAvail = (await objCyberware.TotalAvailTupleAsync(false, token)
                            .ConfigureAwait(false)).Suffix;
                        if (chrAvail != 'R' && chrAvail != 'F')
                            continue;
                        if (!string.IsNullOrEmpty(await objCyberware.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false)))
                        {
                            if (!await objCyberware.GetCanRemoveThroughImprovementsAsync(token)
                                    .ConfigureAwait(false))
                                continue;
                            Cyberware objParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false);
                            if (objParent != null)
                                await (await objParent.GetChildrenAsync(token).ConfigureAwait(false)).RemoveAsync(objCyberware, token)
                                    .ConfigureAwait(false);
                            await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).AddAsync(objCyberware, token)
                                .ConfigureAwait(false);
                            await objCyberware.ChangeModularEquipAsync(false, token: token)
                                .ConfigureAwait(false);
                        }
                        else
                        {
                            await objCyberware.DeleteCyberwareAsync(token: token).ConfigureAwait(false);
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            string strEntry = await LanguageManager.GetStringAsync(
                                await objCyberware.GetSourceTypeAsync(token).ConfigureAwait(false) ==
                                Improvement.ImprovementSource.Cyberware
                                    ? "String_ExpenseSoldCyberware"
                                    : "String_ExpenseSoldBioware", token: token).ConfigureAwait(false);
                            objExpense.Create(0,
                                strEntry + strExConString
                                         + await objCyberware
                                             .GetCurrentDisplayNameShortAsync(token)
                                             .ConfigureAwait(false),
                                ExpenseType.Nuyen, DateTime.Now);
                            await CharacterObject.ExpenseEntries
                                .AddWithSortAsync(objExpense, token: token)
                                .ConfigureAwait(false);
                        }
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.InitiationEnabled)))
                {
                    // Change the status of the Initiation tab being show.
                    if (await CharacterObject.GetInitiationEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabInitiation))
                                x.TabPages.Insert(3, tabInitiation);
                        }, token).ConfigureAwait(false);
                        await gpbInitiationType
                            .DoThreadSafeAsync(x => x.Visible = true, token)
                            .ConfigureAwait(false);
                        await gpbInitiationGroup
                            .DoThreadSafeAsync(x => x.Visible = true, token)
                            .ConfigureAwait(false);
                    }
                    else
                    {
                        await tabCharacterTabs
                            .DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation), token)
                            .ConfigureAwait(false);
                        await gpbInitiationType
                            .DoThreadSafeAsync(x => x.Visible = false, token)
                            .ConfigureAwait(false);
                        await gpbInitiationGroup
                            .DoThreadSafeAsync(x => x.Visible = false, token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.QuickeningEnabled)))
                {
                    bool blnVisible = await CharacterObject.GetQuickeningEnabledAsync(token).ConfigureAwait(false);
                    await cmdQuickenSpell
                        .DoThreadSafeAsync(x => x.Visible = blnVisible, token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.FirstMentorSpiritDisplayName)))
                {
                    MentorSpirit objMentor = await CharacterObject.MentorSpirits.FirstOrDefaultAsync(token)
                        .ConfigureAwait(false);
                    if (objMentor != null)
                    {
                        await objMentor.SetSourceDetailAsync(lblMentorSpiritSource, token)
                            .ConfigureAwait(false);
                        await objMentor.SetSourceDetailAsync(lblParagonSource, token).ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.HasMentorSpirit)))
                {
                    bool blnHasMentor = await CharacterObject.GetHasMentorSpiritAsync(token).ConfigureAwait(false);
                    await gpbMagicianMentorSpirit.DoThreadSafeAsync(
                        x => x.Visible = blnHasMentor, token).ConfigureAwait(false);
                    await gpbTechnomancerParagon.DoThreadSafeAsync(
                        x => x.Visible = blnHasMentor, token).ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.UseMysticAdeptPPs)))
                {
                    bool blnUseMysticAdeptPPs =
                        await CharacterObject.GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false);
                    await lblMysticAdeptAssignment.DoThreadSafeAsync(
                        x => x.Visible = blnUseMysticAdeptPPs, token).ConfigureAwait(false);
                    await lblMysticAdeptMAGAdept.DoThreadSafeAsync(
                        x => x.Visible = blnUseMysticAdeptPPs, token).ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.MysAdeptAllowPPCareer)))
                {
                    bool blnMysAdeptAllowPPCareer =
                        await CharacterObject.GetMysAdeptAllowPPCareerAsync(token).ConfigureAwait(false);
                    await cmdIncreasePowerPoints.DoThreadSafeAsync(
                        x => x.Visible = blnMysAdeptAllowPPCareer, token).ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.MetatypeCategory)))
                {
                    bool blnIsCyberzombie =
                        await CharacterObject.GetMetatypeCategoryAsync(token).ConfigureAwait(false) == "Cyberzombie";
                    if (e.PropertyNames.Contains(nameof(Character.IsSprite)))
                    {
                        await mnuCreateMenu.DoThreadSafeAsync(
                                () =>
                                {
                                    mnuSpecialCyberzombie.Visible = !blnIsCyberzombie;
                                    mnuSpecialConvertToFreeSprite.Visible = CharacterObject.IsSprite;
                                },
                                token)
                            .ConfigureAwait(false);
                    }
                    else
                        await mnuCreateMenu.DoThreadSafeAsync(
                            () => mnuSpecialCyberzombie.Visible = !blnIsCyberzombie,
                            token).ConfigureAwait(false);
                }
                else if (e.PropertyNames.Contains(nameof(Character.IsSprite)))
                {
                    await mnuCreateMenu.DoThreadSafeAsync(
                            () => mnuSpecialConvertToFreeSprite.Visible = CharacterObject.IsSprite,
                            token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.NuyenBP))
                    || e.PropertyNames.Contains(nameof(Character.MetatypeBP))
                    || e.PropertyNames.Contains(nameof(Character.ContactPoints))
                    || e.PropertyNames.Contains(nameof(Character.FreeSpells))
                    || e.PropertyNames.Contains(nameof(Character.CFPLimit))
                    || e.PropertyNames.Contains(nameof(Character.AIAdvancedProgramLimit))
                    || e.PropertyNames.Contains(nameof(Character.SpellKarmaCost))
                    || e.PropertyNames.Contains(nameof(Character.ComplexFormKarmaCost))
                    || e.PropertyNames.Contains(nameof(Character.AIProgramKarmaCost))
                    || e.PropertyNames.Contains(nameof(Character.AIAdvancedProgramKarmaCost))
                    || e.PropertyNames.Contains(nameof(Character.MysticAdeptPowerPoints))
                    || e.PropertyNames.Contains(nameof(Character.MagicTradition))
                    || e.PropertyNames.Contains(nameof(Character.HomeNode))
                    || e.PropertyNames.Contains(nameof(Character.ActiveCommlink))
                    || e.PropertyNames.Contains(nameof(Character.Nuyen))
                    || e.PropertyNames.Contains(nameof(Character.Karma))
                    || e.PropertyNames.Contains(nameof(Character.MAGEnabled))
                    || e.PropertyNames.Contains(nameof(Character.RESEnabled))
                    || e.PropertyNames.Contains(nameof(Character.DEPEnabled))
                    || e.PropertyNames.Contains(nameof(Character.MetatypeCategory))
                    || e.PropertyNames.Contains(nameof(Character.IsSprite)))
                {
                    RequestCharacterUpdate(token);
                }

                if (e.PropertyNames.Contains(nameof(Character.Settings)) && !IsLoading)
                {
                    await OnCharacterSettingsPropertyChanged(this,
                        new MultiplePropertiesChangedEventArgs(typeof(CharacterSettings).GetProperties()
                            .Select(x => x.Name)), token).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task OnCharacterSettingsPropertyChanged(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                token.ThrowIfCancellationRequested();
                CursorWait objCursorWait
                    = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
                try
                {
                    if (e.PropertyNames.Contains(nameof(CharacterSettings.ArmorDegradation)))
                    {
                        bool blnVisible = await CharacterObjectSettings.GetArmorDegradationAsync(token).ConfigureAwait(false);
                        await this.DoThreadSafeAsync(() =>
                        {
                            cmdArmorDecrease.Visible = blnVisible;
                            cmdArmorIncrease.Visible = blnVisible;
                        }, token).ConfigureAwait(false);
                    }

                    if (e.PropertyNames.Contains(nameof(CharacterSettings.Books)) && !IsLoading)
                    {
                        await this.DoThreadSafeAsync(x => x.SuspendLayout(), token)
                            .ConfigureAwait(false);
                        try
                        {
                            if (await CharacterObjectSettings.BookEnabledAsync("RF", token)
                                    .ConfigureAwait(false))
                            {
                                await cmdAddLifestyle
                                    .DoThreadSafeAsync(x => x.SplitMenuStrip = cmsAdvancedLifestyle,
                                        token)
                                    .ConfigureAwait(false);
                            }
                            else
                            {
                                await cmdAddLifestyle
                                    .DoThreadSafeAsync(x => x.SplitMenuStrip = null,
                                        token)
                                    .ConfigureAwait(false);
                            }

                            if (!await CharacterObjectSettings.BookEnabledAsync("FA", token)
                                    .ConfigureAwait(false))
                            {
                                await this.DoThreadSafeAsync(() =>
                                {
                                    lblWildReputation.Visible = false;
                                    nudWildReputation.Visible = false;
                                    lblWildReputationTotal.Visible = false;
                                }, token).ConfigureAwait(false);
                                if (!await CharacterObjectSettings.BookEnabledAsync("SG", token)
                                        .ConfigureAwait(false))
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        lblAstralReputation.Visible = false;
                                        nudAstralReputation.Visible = false;
                                        lblAstralReputationTotal.Visible = false;
                                    }, token).ConfigureAwait(false);
                                }
                                else
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        lblAstralReputation.Visible = true;
                                        nudAstralReputation.Visible = true;
                                        lblAstralReputationTotal.Visible = true;
                                    }, token).ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                await this.DoThreadSafeAsync(() =>
                                {
                                    lblWildReputation.Visible = true;
                                    nudWildReputation.Visible = true;
                                    lblWildReputationTotal.Visible = true;
                                    lblAstralReputation.Visible = true;
                                    nudAstralReputation.Visible = true;
                                    lblAstralReputationTotal.Visible = true;
                                }, token).ConfigureAwait(false);
                            }

                            // Refresh all trees because enabled sources can change the nodes that are visible
                            await RefreshQualities(treQualities, cmsQuality, _fntNormal, _fntStrikeout,
                                token: token).ConfigureAwait(false);
                            await RefreshSpirits(panSpirits, panSprites, token: token)
                                .ConfigureAwait(false);
                            await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes,
                                token: token).ConfigureAwait(false);
                            await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm,
                                    cmsInitiationNotes, token: token)
                                .ConfigureAwait(false);
                            await RefreshPowerCollectionListChanged(
                                    treMetamagic, cmsMetamagic, cmsInitiationNotes, token: token)
                                .ConfigureAwait(false);
                            await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes,
                                token: token).ConfigureAwait(false);
                            await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram, token: token)
                                .ConfigureAwait(false);
                            await RefreshCritterPowers(treCritterPowers, cmsCritterPowers, token: token)
                                .ConfigureAwait(false);
                            await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique,
                                token: token).ConfigureAwait(false);
                            await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle,
                                token: token).ConfigureAwait(false);
                            await RefreshContacts(panContacts, panEnemies, panPets, token: token)
                                .ConfigureAwait(false);
                            await RefreshSustainedSpells(flpSustainedSpells, flpSustainedComplexForms,
                                    flpSustainedCritterPowers, chkPsycheActiveMagician,
                                    chkPsycheActiveTechnomancer, token: token)
                                .ConfigureAwait(false);

                            await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod, cmsArmorGear,
                                token: token).ConfigureAwait(false);
                            await RefreshGears(treGear, cmsGearLocation, cmsGear, null,
                                await chkCommlinks.DoThreadSafeFuncAsync(
                                    x => x.Checked, token).ConfigureAwait(false),
                                await chkHideLoadedAmmo.DoThreadSafeFuncAsync(
                                    x => x.Checked, token).ConfigureAwait(false),
                                token: token).ConfigureAwait(false);
                            await RefreshFociFromGear(treFoci, null, token: token).ConfigureAwait(false);
                            await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear,
                                token: token).ConfigureAwait(false);
                            await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon, cmsWeaponAccessory,
                                    cmsWeaponAccessoryGear, token: token)
                                .ConfigureAwait(false);
                            await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle, cmsVehicleWeapon,
                                cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear,
                                cmsVehicleGear,
                                cmsWeaponMount,
                                cmsVehicleCyberware, cmsVehicleCyberwareGear,
                                token: token).ConfigureAwait(false);
                            await RefreshDrugs(treCustomDrugs, token: token).ConfigureAwait(false);
                            await this.DoThreadSafeAsync(() =>
                            {
                                treWeapons.SortCustomOrder();
                                treArmor.SortCustomOrder();
                                treGear.SortCustomOrder();
                                treLifestyles.SortCustomOrder();
                                treCustomDrugs.SortCustomOrder();
                                treCyberware.SortCustomOrder(true);
                                treVehicles.SortCustomOrder();
                                treCritterPowers.SortCustomOrder();
                                treImprovements.SortCustomOrder(true);
                            }, token).ConfigureAwait(false);

                            XPathNavigator xmlTraditionsBaseChummerNode =
                                (await CharacterObject.LoadDataXPathAsync(
                                    "traditions.xml", token: token).ConfigureAwait(false))
                                .SelectSingleNodeAndCacheExpression("/chummer", token);
                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstTraditions))
                            {
                                if (xmlTraditionsBaseChummerNode != null)
                                {
                                    foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                 "traditions/tradition["
                                                 + await CharacterObjectSettings
                                                     .BookXPathAsync(token: token)
                                                     .ConfigureAwait(false)
                                                 + "]"))
                                    {
                                        string strName
                                            = xmlTradition.SelectSingleNodeAndCacheExpression(
                                                    "name", token)
                                                ?.Value;
                                        if (!string.IsNullOrEmpty(strName))
                                            lstTraditions.Add(new ListItem(
                                                xmlTradition
                                                    .SelectSingleNodeAndCacheExpression(
                                                        "id", token)
                                                    ?.Value ?? strName,
                                                xmlTradition
                                                    .SelectSingleNodeAndCacheExpression(
                                                        "translate", token)
                                                    ?.Value ?? strName));
                                    }
                                }

                                if (lstTraditions.Count > 1)
                                {
                                    lstTraditions.Sort(CompareListItems.CompareNames);
                                    lstTraditions.Insert(
                                        0,
                                        new ListItem(
                                            "None",
                                            await LanguageManager.GetStringAsync("String_None", token: token)
                                                .ConfigureAwait(false)));
                                    if (!lstTraditions.SequenceEqual(
                                            await cboTradition.DoThreadSafeFuncAsync(
                                                    x => x.Items.Cast<ListItem>(), token)
                                                .ConfigureAwait(false)))
                                    {
                                        await cboTradition.PopulateWithListItemsAsync(
                                            lstTraditions, token).ConfigureAwait(false);
                                        Tradition objTradition =
                                            await CharacterObject.GetMagicTraditionAsync(token).ConfigureAwait(false);
                                        TraditionType eTraditionType = await objTradition.GetTypeAsync(token)
                                            .ConfigureAwait(false);
                                        string strTraditionSourceIdString =
                                            await objTradition.GetSourceIDStringAsync(token)
                                                .ConfigureAwait(false);
                                        await cboTradition.DoThreadSafeAsync(x =>
                                        {
                                            if (eTraditionType == TraditionType.MAG)
                                                x.SelectedValue
                                                    = strTraditionSourceIdString;
                                            else if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                x.SelectedIndex = 0;
                                        }, token).ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        cboTradition.Visible = false;
                                        lblTraditionLabel.Visible = false;
                                    }, token).ConfigureAwait(false);
                                }
                            }

                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstDrainAttributes))
                            {
                                if (xmlTraditionsBaseChummerNode != null)
                                {
                                    foreach (XPathNavigator xmlDrain in xmlTraditionsBaseChummerNode
                                                 .SelectAndCacheExpression(
                                                     "drainattributes/drainattribute", token))
                                    {
                                        string strName
                                            = xmlDrain
                                                .SelectSingleNodeAndCacheExpression(
                                                    "name", token)
                                                ?.Value;
                                        if (!string.IsNullOrEmpty(strName)
                                            && (lstDrainAttributes.Count == 0 || lstDrainAttributes.TrueForAll(x =>
                                                            x.Value?.ToString() != strName)))
                                        {
                                            string strTranslatedName = xmlDrain
                                                .SelectSingleNodeAndCacheExpression(
                                                    "translate", token)?.Value ?? strName;
                                            lstDrainAttributes.Add(new ListItem(strName, strTranslatedName));
                                        }
                                    }
                                }

                                lstDrainAttributes.Sort(CompareListItems.CompareNames);
                                lstDrainAttributes.Insert(0, ListItem.Blank);
                                await cboDrain.PopulateWithListItemsAsync(lstDrainAttributes, token)
                                    .ConfigureAwait(false);
                            }

                            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                       out HashSet<string> limit))
                            {
                                foreach (Improvement improvement in await ImprovementManager
                                             .GetCachedImprovementListForValueOfAsync(
                                                 CharacterObject,
                                                 Improvement.ImprovementType.LimitSpiritCategory, token: token)
                                             .ConfigureAwait(false))
                                {
                                    limit.Add(improvement.ImprovedName);
                                }

                                using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstSpirit))
                                {
                                    lstSpirit.Add(ListItem.Blank);
                                    if (xmlTraditionsBaseChummerNode != null)
                                    {
                                        foreach (XPathNavigator xmlSpirit in xmlTraditionsBaseChummerNode
                                                     .SelectAndCacheExpression("spirits/spirit", token))
                                        {
                                            string strSpiritName
                                                = xmlSpirit.SelectSingleNodeAndCacheExpression(
                                                        "name", token)
                                                    ?.Value;
                                            if (!string.IsNullOrEmpty(strSpiritName)
                                                && (limit.Count == 0 || limit.Contains(strSpiritName)))
                                            {
                                                lstSpirit.Add(new ListItem(strSpiritName,
                                                    xmlSpirit
                                                        .SelectSingleNodeAndCacheExpression(
                                                            "translate", token)
                                                        ?.Value
                                                    ?? strSpiritName));
                                            }
                                        }
                                    }

                                    lstSpirit.Sort(CompareListItems.CompareNames);
                                    await cboSpiritCombat.PopulateWithListItemsAsync(lstSpirit, token)
                                        .ConfigureAwait(false);
                                    await cboSpiritDetection
                                        .PopulateWithListItemsAsync(lstSpirit, token)
                                        .ConfigureAwait(false);
                                    await cboSpiritHealth.PopulateWithListItemsAsync(lstSpirit, token)
                                        .ConfigureAwait(false);
                                    await cboSpiritIllusion.PopulateWithListItemsAsync(lstSpirit, token)
                                        .ConfigureAwait(false);
                                    await cboSpiritManipulation.PopulateWithListItemsAsync(
                                        lstSpirit, token).ConfigureAwait(false);
                                }
                            }

                            // Populate the Technomancer Streams list.
                            xmlTraditionsBaseChummerNode =
                                (await CharacterObject.LoadDataXPathAsync(
                                    "streams.xml", token: token).ConfigureAwait(false))
                                .SelectSingleNodeAndCacheExpression("/chummer", token);
                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstStreams))
                            {
                                if (xmlTraditionsBaseChummerNode != null)
                                {
                                    foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                 "traditions/tradition["
                                                 + await CharacterObjectSettings
                                                     .BookXPathAsync(token: token)
                                                     .ConfigureAwait(false)
                                                 + "]"))
                                    {
                                        string strName
                                            = xmlTradition.SelectSingleNodeAndCacheExpression(
                                                    "name", token)
                                                ?.Value;
                                        if (!string.IsNullOrEmpty(strName))
                                            lstStreams.Add(new ListItem(
                                                xmlTradition
                                                    .SelectSingleNodeAndCacheExpression(
                                                        "id", token)
                                                    ?.Value ?? strName,
                                                xmlTradition
                                                    .SelectSingleNodeAndCacheExpression(
                                                        "translate", token)
                                                    ?.Value ?? strName));
                                    }
                                }

                                if (lstStreams.Count > 1)
                                {
                                    lstStreams.Sort(CompareListItems.CompareNames);
                                    lstStreams.Insert(
                                        0,
                                        new ListItem(
                                            "None",
                                            await LanguageManager.GetStringAsync("String_None", token: token)
                                                .ConfigureAwait(false)));
                                    if (!lstStreams.SequenceEqual(
                                            await cboStream.DoThreadSafeFuncAsync(
                                                    x => x.Items.Cast<ListItem>(), token)
                                                .ConfigureAwait(false)))
                                    {
                                        await cboStream.PopulateWithListItemsAsync(lstStreams, token)
                                            .ConfigureAwait(false);
                                        Tradition objTradition =
                                            await CharacterObject.GetMagicTraditionAsync(token).ConfigureAwait(false);
                                        TraditionType eTraditionType = await objTradition.GetTypeAsync(token)
                                            .ConfigureAwait(false);
                                        string strTraditionSourceIdString =
                                            await objTradition.GetSourceIDStringAsync(token)
                                                .ConfigureAwait(false);
                                        await cboStream.DoThreadSafeAsync(x =>
                                        {
                                            if (eTraditionType == TraditionType.RES && !string.IsNullOrEmpty(strTraditionSourceIdString))
                                                x.SelectedValue = strTraditionSourceIdString;
                                            if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                x.SelectedIndex = 0;
                                        }, token).ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        cboStream.Visible = false;
                                        lblStreamLabel.Visible = false;
                                    }, token).ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await this.DoThreadSafeAsync(x => x.ResumeLayout(), token)
                                .ConfigureAwait(false);
                        }
                    }

                    if (e.PropertyNames.Contains(nameof(CharacterSettings.AllowFreeGrids)) &&
                        !await CharacterObjectSettings.BookEnabledAsync("HT", token).ConfigureAwait(false))
                    {
                        await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle,
                                    token: token)
                                .ConfigureAwait(false);
                        await treLifestyles.DoThreadSafeAsync(x => x.SortCustomOrder(), token)
                                .ConfigureAwait(false);
                    }

                    if (e.PropertyNames.Contains(nameof(CharacterSettings.EnableEnemyTracking)))
                    {
                        bool blnTracking = await CharacterObjectSettings.GetEnableEnemyTrackingAsync(token).ConfigureAwait(false);
                        await this.DoThreadSafeAsync(x =>
                        {
                            x.SuspendLayout();
                            try
                            {
                                if (blnTracking)
                                {
                                    if (!tabPeople.TabPages.Contains(tabEnemies))
                                        tabPeople.TabPages.Insert(
                                            tabPeople.TabPages.IndexOf(tabContacts) + 1,
                                            tabEnemies);
                                }
                                else
                                {
                                    tabPeople.TabPages.Remove(tabEnemies);
                                }
                            }
                            finally
                            {
                                x.ResumeLayout();
                            }
                        }, token).ConfigureAwait(false);
                        await RefreshContacts(panContacts, panEnemies, panPets, token: token)
                            .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }

                RequestCharacterUpdate(token);
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        /*
        //TODO: UpdatePowerRelatedInfo method? Powers hook into so much stuff that it may need to wait for outbound improvement events?
        private readonly Stopwatch PowerPropertyChanged_StopWatch = Stopwatch.StartNew();
        private void PowerPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            await SetDirty(true);

            if (PowerPropertyChanged_StopWatch.ElapsedMilliseconds < 4) return;
            PowerPropertyChanged_StopWatch.Restart();
            tabPowerUc.CalculatePowerPoints();
            await RequestCharacterUpdate();
        }

        private readonly Stopwatch SkillPropertyChanged_StopWatch = Stopwatch.StartNew();
        private void SkillPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            //HACK PERFORMANCE
            //So, skills tell if anything maybe interesting have happened, but this don't have any way to see if it is relevant. Instead of redrawing EVERY FYCKING THING we do it only every 5 ms
            if (SkillPropertyChanged_StopWatch.ElapsedMilliseconds < 4) return;
            SkillPropertyChanged_StopWatch.Restart();

            await RequestCharacterUpdate();

            await SetDirty(true);
        }
        */

        #endregion Character Events

        #region Menu Events

        private async void mnuFileSave_Click(object sender, EventArgs e)
        {
            try
            {
                await SaveCharacter(token: GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuFileSaveAs_Click(object sender, EventArgs e)
        {
            try
            {
                await SaveCharacterAs(token: GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void mnuFileClose_Click(object sender, EventArgs e)
        {
            Close();
        }

        private async void mnuFilePrint_Click(object sender, EventArgs e)
        {
            try
            {
                await DoPrint(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuFileExport_Click(object sender, EventArgs e)
        {
            try
            {
                await DoExport(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialCyberzombie_Click(object sender, EventArgs e)
        {
            try
            {
                await CharacterObject.ConvertCyberzombie(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialReduceAttribute_Click(object sender, EventArgs e)
        {
            try
            {
                List<string> lstAbbrevs = new List<string>(AttributeSection.AttributeStrings);
                lstAbbrevs.Remove("ESS");

                if (!await CharacterObject.GetMAGEnabledAsync(GenericToken).ConfigureAwait(false))
                {
                    lstAbbrevs.Remove("MAG");
                    lstAbbrevs.Remove("MAGAdept");
                }
                else if (!await CharacterObject.GetIsMysticAdeptAsync(GenericToken).ConfigureAwait(false) || !await CharacterObjectSettings.GetMysAdeptSecondMAGAttributeAsync(GenericToken).ConfigureAwait(false))
                    lstAbbrevs.Remove("MAGAdept");

                if (!await CharacterObject.GetRESEnabledAsync(GenericToken).ConfigureAwait(false))
                    lstAbbrevs.Remove("RES");
                if (!await CharacterObject.GetDEPEnabledAsync(GenericToken).ConfigureAwait(false))
                    lstAbbrevs.Remove("DEP");

                string strDescription
                    = await LanguageManager.GetStringAsync("String_CyberzombieReduceAttribute", token: GenericToken)
                                           .ConfigureAwait(false);
                // Display the Select CharacterAttribute window and record which Skill was selected.
                using (ThreadSafeForm<SelectAttribute> frmPickAttribute
                       = await ThreadSafeForm<SelectAttribute>.GetAsync(() => new SelectAttribute(lstAbbrevs.ToArray())
                       {
                           Description = strDescription,
                           ShowMetatypeMaximum = true
                       }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickAttribute.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    // Create an Improvement to reduce the CharacterAttribute's Metatype Maximum.
                    if (!frmPickAttribute.MyForm.DoNotAffectMetatypeMaximum)
                    {
                        try
                        {
                            await ImprovementManager.CreateImprovementAsync(
                                                        CharacterObject, frmPickAttribute.MyForm.SelectedAttribute,
                                                        Improvement.ImprovementSource.AttributeLoss, string.Empty,
                                                        Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0,
                                                        -1, token: GenericToken)
                                                    .ConfigureAwait(false);
                        }
                        catch
                        {
                            await ImprovementManager.RollbackAsync(CharacterObject, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        await ImprovementManager.CommitAsync(CharacterObject, GenericToken).ConfigureAwait(false);
                    }

                    // Permanently reduce the CharacterAttribute's value.
                    await (await CharacterObject.GetAttributeAsync(frmPickAttribute.MyForm.SelectedAttribute, token: GenericToken)
                                                .ConfigureAwait(false)).Degrade(token: GenericToken).ConfigureAwait(false);
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialCloningMachine_Click(object sender, EventArgs e)
        {
            try
            {
                string strDescription = await LanguageManager
                                              .GetStringAsync("String_CloningMachineNumber", token: GenericToken)
                                              .ConfigureAwait(false);
                int intClones;
                using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                           () => new SelectNumber(0)
                           {
                               Description = strDescription,
                               Minimum = 1
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickNumber.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    intClones = frmPickNumber.MyForm.SelectedValue.ToInt32();
                }

                if (intClones <= 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_CloningMachineNumberRequired", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CloningMachineNumberRequired", token: GenericToken)
                            .ConfigureAwait(false), MessageBoxButtons.OK, MessageBoxIcon.Error, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    Character[] lstClones = new Character[intClones];
                    string strAlias = await CharacterObject.GetAliasAsync(GenericToken).ConfigureAwait(false);
                    string strFileName = await CharacterObject.GetFileNameAsync(GenericToken).ConfigureAwait(false);
                    using (ThreadSafeForm<LoadingBar> frmLoadingBar
                           = await Program.CreateAndShowProgressBarAsync(
                                              strAlias,
                                              Character.NumLoadingSections * intClones,
                                              GenericToken)
                                          .ConfigureAwait(false))
                    {
                        string strSpace = await LanguageManager.GetStringAsync("String_Space", token: GenericToken).ConfigureAwait(false);
                        // Await structure prevents UI thread lock-ups if the LoadCharacter() function shows any messages
                        await ParallelExtensions.ForAsync(0, intClones, async i =>
                        {
                            string strNewName = strAlias + strSpace + i.ToString(GlobalSettings.CultureInfo);
                            lstClones[i] = await Program.LoadCharacterAsync(strFileName, strNewName, true,
                                                                     // ReSharper disable once AccessToDisposedClosure
                                                                     frmLoadingBar: frmLoadingBar.MyForm,
                                                                     token: GenericToken).ConfigureAwait(false);
                        }, GenericToken).ConfigureAwait(false);
                    }

                    await Program.OpenCharacterList(lstClones, false, GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                // This only re-applies the Improvements for everything the character has. If a match is not found in the data files, the current Improvement information is left as-is.
                // Verify that the user wants to go through with it.
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_ConfirmReapplyImprovements", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager
                            .GetStringAsync("MessageTitle_ConfirmReapplyImprovements", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                    return;
                await DoReapplyImprovements(token: GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsQualityReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                    .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                      .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                   .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMartialArtsReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                          .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsSpellReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                     .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsComplexFormReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                           .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAIProgramReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                         .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCritterPowersReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        internal async Task ReapplySpecificImprovements(string strSelectedId, string strSelectedName,
                                                             CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (string.IsNullOrEmpty(strSelectedId))
                return;
            string strName = !string.IsNullOrEmpty(strSelectedName)
                ? strSelectedName
                : await LanguageManager.GetStringAsync("String_SelectedItem", token: token).ConfigureAwait(false);
            // This only re-applies the Improvements for everything the character has. If a match is not found in the data files, the current Improvement information is left as-is.
            // Verify that the user wants to go through with it.
            if (await Program.ShowScrollableMessageBoxAsync(
                    this,
                    string.Format(GlobalSettings.CultureInfo,
                        await LanguageManager
                            .GetStringAsync("Message_ConfirmReapplySpecificImprovements", token: token)
                            .ConfigureAwait(false), strName),
                    await LanguageManager
                        .GetStringAsync("MessageTitle_ConfirmReapplySpecificImprovements", token: token)
                        .ConfigureAwait(false),
                    MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: token).ConfigureAwait(false) == DialogResult.No)
                return;
            using (TemporaryStringArray eParam = strSelectedId.YieldAsPooled())
                await DoReapplyImprovements(eParam, token: token).ConfigureAwait(false);
        }

        private async Task DoReapplyImprovements(IReadOnlyCollection<string> lstInternalIdFilter = null,
                                                      CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker
                    = await CharacterObject.LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdOutdatedItems))
                    {
                        // Record the status of any flags that normally trigger character events.
                        bool blnMAGEnabled = await CharacterObject.GetMAGEnabledAsync(token).ConfigureAwait(false);
                        bool blnRESEnabled = await CharacterObject.GetRESEnabledAsync(token).ConfigureAwait(false);
                        bool blnDEPEnabled = await CharacterObject.GetDEPEnabledAsync(token).ConfigureAwait(false);
                        decimal decEssenceAtSpecialStart = await CharacterObject.GetEssenceAtSpecialStartAsync(token).ConfigureAwait(false);

                        bool blnOldReapplyImprovements = _blnReapplyImprovements;
                        _blnReapplyImprovements = true;

                        try
                        {
                            // Wipe all improvements that we will reapply, this is mainly to eliminate orphaned improvements caused by certain bugs and also for a performance increase
                            if (lstInternalIdFilter == null)
                                await ImprovementManager.RemoveImprovementsAsync(
                                    CharacterObject,
                                    await (await CharacterObject.GetImprovementsAsync(token).ConfigureAwait(false))
                                          .ToListAsync(
                                              x => x.ImproveSource == Improvement.ImprovementSource.AIProgram
                                                   || x.ImproveSource == Improvement.ImprovementSource.Armor
                                                   || x.ImproveSource == Improvement.ImprovementSource.ArmorMod
                                                   || x.ImproveSource == Improvement.ImprovementSource.Bioware
                                                   || x.ImproveSource == Improvement.ImprovementSource.ComplexForm
                                                   || x.ImproveSource == Improvement.ImprovementSource.CritterPower
                                                   || x.ImproveSource == Improvement.ImprovementSource.Cyberware
                                                   || x.ImproveSource == Improvement.ImprovementSource.Echo
                                                   || x.ImproveSource == Improvement.ImprovementSource.Gear
                                                   || x.ImproveSource == Improvement.ImprovementSource.MartialArt
                                                   || x.ImproveSource == Improvement.ImprovementSource
                                                       .MartialArtTechnique
                                                   || x.ImproveSource == Improvement.ImprovementSource.Metamagic
                                                   || x.ImproveSource == Improvement.ImprovementSource.Power
                                                   || x.ImproveSource == Improvement.ImprovementSource.Quality
                                                   || x.ImproveSource == Improvement.ImprovementSource.Spell
                                                   || x.ImproveSource == Improvement.ImprovementSource.StackedFocus,
                                              token)
                                          .ConfigureAwait(false),
                                    true, token: token).ConfigureAwait(false);
                            else
                                await ImprovementManager.RemoveImprovementsAsync(
                                    CharacterObject,
                                    await (await CharacterObject.GetImprovementsAsync(token).ConfigureAwait(false))
                                          .ToListAsync(
                                              x => lstInternalIdFilter.Contains(x.SourceName) &&
                                                   (x.ImproveSource == Improvement.ImprovementSource.AIProgram
                                                    || x.ImproveSource == Improvement.ImprovementSource.Armor
                                                    || x.ImproveSource == Improvement.ImprovementSource.ArmorMod
                                                    || x.ImproveSource == Improvement.ImprovementSource.Bioware
                                                    || x.ImproveSource == Improvement.ImprovementSource.ComplexForm
                                                    || x.ImproveSource == Improvement.ImprovementSource.CritterPower
                                                    || x.ImproveSource == Improvement.ImprovementSource.Cyberware
                                                    || x.ImproveSource == Improvement.ImprovementSource.Echo
                                                    || x.ImproveSource == Improvement.ImprovementSource.Gear
                                                    || x.ImproveSource == Improvement.ImprovementSource.MartialArt
                                                    || x.ImproveSource == Improvement.ImprovementSource
                                                        .MartialArtTechnique
                                                    || x.ImproveSource == Improvement.ImprovementSource.Metamagic
                                                    || x.ImproveSource == Improvement.ImprovementSource.Power
                                                    || x.ImproveSource == Improvement.ImprovementSource.Quality
                                                    || x.ImproveSource == Improvement.ImprovementSource.Spell
                                                    || x.ImproveSource == Improvement.ImprovementSource.StackedFocus),
                                              token).ConfigureAwait(false),
                                    true, token: token).ConfigureAwait(false);

                            // Refresh Qualities.
                            // We cannot use foreach because qualities can add more qualities
                            for (int j = 0; j < await CharacterObject.Qualities.GetCountAsync(token).ConfigureAwait(false); j++)
                            {
                                Quality objQuality = await CharacterObject.Qualities.GetValueAtAsync(j, token).ConfigureAwait(false);
                                QualitySource eOriginSource = await objQuality.GetOriginSourceAsync(token).ConfigureAwait(false);
                                if (eOriginSource == QualitySource.Improvement
                                    || eOriginSource == QualitySource.MetatypeRemovedAtChargen)
                                    continue;
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objQuality.InternalId) == false)
                                    continue;

                                XmlNode objNode = await objQuality.GetNodeAsync(token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    string strSelected = objQuality.Extra;
                                    objQuality.Bonus = objNode["bonus"];
                                    if (objQuality.Bonus != null)
                                    {
                                        ImprovementManager.SetForcedValue(strSelected, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.Quality,
                                            objQuality.InternalId,
                                            objQuality.Bonus, 1,
                                            await objQuality.GetCurrentDisplayNameShortAsync(token)
                                                            .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objQuality.Extra = strSelectedValue;
                                            string strName = await objQuality.GetCurrentDisplayNameAsync(token)
                                                                             .ConfigureAwait(false);
                                            await treQualities.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                                if (objTreeNode != null)
                                                    objTreeNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }

                                    objQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                    if (objQuality.FirstLevelBonus?.HasChildNodes == true)
                                    {
                                        string strCheckExtra = await objQuality.GetExtraAsync(token).ConfigureAwait(false);
                                        string strCheckSourceName = await objQuality.GetSourceNameAsync(token).ConfigureAwait(false);
                                        bool blnDoFirstLevel = true;
                                        for (int k = 0; k < await CharacterObject.Qualities.GetCountAsync(token).ConfigureAwait(false); ++k)
                                        {
                                            Quality objCheckQuality = await CharacterObject.Qualities.GetValueAtAsync(k, token).ConfigureAwait(false);
                                            if (j != k
                                                && objCheckQuality.SourceID == objQuality.SourceID
                                                && await objCheckQuality.GetExtraAsync(token).ConfigureAwait(false) == strCheckExtra
                                                && await objCheckQuality.GetSourceNameAsync(token).ConfigureAwait(false) == strCheckSourceName
                                                && (k < j
                                                    || await objCheckQuality.GetOriginSourceAsync(token).ConfigureAwait(false) == QualitySource.Improvement
                                                    || lstInternalIdFilter?.Contains(objCheckQuality.InternalId)
                                                    == false))
                                            {
                                                blnDoFirstLevel = false;
                                                break;
                                            }
                                        }

                                        if (blnDoFirstLevel)
                                        {
                                            ImprovementManager.SetForcedValue(strSelected, CharacterObject);
                                            await ImprovementManager.CreateImprovementsAsync(
                                                                        CharacterObject,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        objQuality.FirstLevelBonus, 1,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                            string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                            if (!string.IsNullOrEmpty(strSelectedValue))
                                            {
                                                await objQuality.SetExtraAsync(strSelectedValue, token).ConfigureAwait(false);
                                                string strName = await objQuality.GetCurrentDisplayNameAsync(token)
                                                    .ConfigureAwait(false);
                                                await treQualities.DoThreadSafeAsync(x =>
                                                {
                                                    TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                                    if (objTreeNode != null)
                                                        objTreeNode.Text = strName;
                                                }, token).ConfigureAwait(false);
                                            }
                                        }
                                    }

                                    objQuality.NaturalWeaponsNode = objNode["naturalweapons"];
                                    if (objQuality.NaturalWeaponsNode != null)
                                    {
                                        ImprovementManager.SetForcedValue(strSelected, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.Quality,
                                            objQuality.InternalId,
                                            objQuality.NaturalWeaponsNode, 1,
                                            await objQuality.GetCurrentDisplayNameShortAsync(token)
                                                            .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            await objQuality.SetExtraAsync(strSelectedValue, token).ConfigureAwait(false);
                                            string strName = await objQuality.GetCurrentDisplayNameAsync(token)
                                                                             .ConfigureAwait(false);
                                            await treQualities.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                                if (objTreeNode != null)
                                                    objTreeNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objQuality.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }

                            // Refresh Martial Art Techniques.
                            await CharacterObject.MartialArts.ForEachWithSideEffectsAsync(async objMartialArt =>
                            {
                                XmlNode objMartialArtNode
                                    = await objMartialArt.GetNodeAsync(token).ConfigureAwait(false);
                                if (objMartialArtNode != null)
                                {
                                    // We're only re-apply improvements a list of items, not all of them
                                    if (lstInternalIdFilter?.Contains(objMartialArt.InternalId) != false
                                        && objMartialArtNode["bonus"] != null)
                                    {
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.MartialArt,
                                            objMartialArt.InternalId, objMartialArtNode["bonus"], 1,
                                            await objMartialArt.GetCurrentDisplayNameAsync(token).ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objMartialArt.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }

                                await objMartialArt.Techniques.ForEachWithSideEffectsAsync(async objTechnique =>
                                {
                                    if (lstInternalIdFilter?.Contains(objTechnique.InternalId) == false)
                                        return;
                                    XmlNode objNode = await objTechnique.GetNodeAsync(token).ConfigureAwait(false);
                                    if (objNode != null)
                                    {
                                        if (objNode["bonus"] != null)
                                            await ImprovementManager.CreateImprovementsAsync(
                                                CharacterObject, Improvement.ImprovementSource.MartialArtTechnique,
                                                objTechnique.InternalId, objNode["bonus"], 1,
                                                await objTechnique.GetCurrentDisplayNameAsync(token)
                                                                  .ConfigureAwait(false),
                                                token: token).ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        sbdOutdatedItems.AppendLine(
                                            await objTechnique.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                    }
                                }, token).ConfigureAwait(false);
                            }, token).ConfigureAwait(false);

                            // Refresh Spells.
                            await CharacterObject.Spells.ForEachWithSideEffectsAsync(async objSpell =>
                            {
                                if (lstInternalIdFilter?.Contains(objSpell.InternalId) == false)
                                    return;
                                XmlNode objNode = await objSpell.GetNodeAsync(token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    if (objNode["bonus"] != null)
                                    {
                                        ImprovementManager.SetForcedValue(objSpell.Extra, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.Spell, objSpell.InternalId,
                                            objNode["bonus"], 1,
                                            await objSpell.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objSpell.Extra = strSelectedValue;
                                            string strName = await objSpell.GetCurrentDisplayNameAsync(token)
                                                                           .ConfigureAwait(false);
                                            await treSpells.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objSpellNode = x.FindNode(objSpell.InternalId);
                                                if (objSpellNode != null)
                                                    objSpellNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objSpell.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }, token).ConfigureAwait(false);

                            // Refresh Adept Powers.
                            await CharacterObject.Powers.ForEachWithSideEffectsAsync(async objPower =>
                            {
                                if (lstInternalIdFilter?.Contains(objPower.InternalId) == false)
                                    return;
                                XmlNode objNode = await objPower.GetNodeAsync(token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    objPower.Bonus = objNode["bonus"];
                                    if (objPower.Bonus != null)
                                    {
                                        ImprovementManager.SetForcedValue(objPower.Extra, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.Power, objPower.InternalId,
                                            objPower.Bonus,
                                            await objPower.GetTotalRatingAsync(token).ConfigureAwait(false),
                                            await objPower.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objPower.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }, token).ConfigureAwait(false);

                            // Refresh Complex Forms.
                            await CharacterObject.ComplexForms.ForEachWithSideEffectsAsync(async objComplexForm =>
                            {
                                if (lstInternalIdFilter?.Contains(objComplexForm.InternalId) == false)
                                    return;
                                XmlNode objNode = await objComplexForm.GetNodeAsync(token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    if (objNode["bonus"] != null)
                                    {
                                        ImprovementManager.SetForcedValue(objComplexForm.Extra, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(
                                                                    CharacterObject,
                                                                    Improvement.ImprovementSource.ComplexForm,
                                                                    objComplexForm.InternalId, objNode["bonus"], 1,
                                                                    await objComplexForm
                                                                          .GetCurrentDisplayNameShortAsync(token)
                                                                          .ConfigureAwait(false), token: token)
                                                                .ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objComplexForm.Extra = strSelectedValue;
                                            string strName = await objComplexForm.GetCurrentDisplayNameAsync(token)
                                                .ConfigureAwait(false);
                                            await treComplexForms.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objCFNode = x.FindNode(objComplexForm.InternalId);
                                                if (objCFNode != null)
                                                    objCFNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objComplexForm.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }, token).ConfigureAwait(false);

                            // Refresh AI Programs and Advanced Programs
                            await CharacterObject.AIPrograms.ForEachWithSideEffectsAsync(async objProgram =>
                            {
                                if (lstInternalIdFilter?.Contains(objProgram.InternalId) == false)
                                    return;
                                XmlNode objNode = await objProgram.GetNodeAsync(token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    if (objNode["bonus"] != null)
                                    {
                                        ImprovementManager.SetForcedValue(objProgram.Extra, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.AIProgram,
                                            objProgram.InternalId,
                                            objNode["bonus"], 1,
                                            await objProgram.GetCurrentDisplayNameShortAsync(token)
                                                            .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objProgram.Extra = strSelectedValue;
                                            string strName = await objProgram.GetCurrentDisplayNameShortAsync(token)
                                                                             .ConfigureAwait(false);
                                            await treAIPrograms.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objProgramNode = x.FindNode(objProgram.InternalId);
                                                if (objProgramNode != null)
                                                    objProgramNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objProgram.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false));
                                }
                            }, token).ConfigureAwait(false);

                            // Refresh Critter Powers.
                            await CharacterObject.CritterPowers.ForEachWithSideEffectsAsync(async objPower =>
                            {
                                if (lstInternalIdFilter?.Contains(objPower.InternalId) == false)
                                    return;
                                XmlNode objNode = await objPower.GetNodeAsync(token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    objPower.Bonus = objNode["bonus"];
                                    if (objPower.Bonus != null)
                                    {
                                        string strSelected = objPower.Extra;
                                        if (!int.TryParse(strSelected, out int intRating))
                                        {
                                            intRating = 1;
                                            ImprovementManager.SetForcedValue(strSelected, CharacterObject);
                                        }

                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.CritterPower,
                                            objPower.InternalId, objPower.Bonus, intRating,
                                            await objPower.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objPower.Extra = strSelectedValue;
                                            string strName = await objPower.GetCurrentDisplayNameAsync(token)
                                                                           .ConfigureAwait(false);
                                            await treCritterPowers.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objPowerNode = x.FindNode(objPower.InternalId);
                                                if (objPowerNode != null)
                                                    objPowerNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objPower.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }, token).ConfigureAwait(false);

                            // Refresh Metamagics and Echoes.
                            // We cannot use foreach because metamagics/echoes can add more metamagics/echoes
                            // ReSharper disable once ForCanBeConvertedToForeach
                            for (int j = 0; j < await CharacterObject.Metamagics.GetCountAsync(token).ConfigureAwait(false); j++)
                            {
                                Metamagic objMetamagic = await CharacterObject.Metamagics.GetValueAtAsync(j, token).ConfigureAwait(false);
                                if (objMetamagic.Grade < 0)
                                    continue;
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objMetamagic.InternalId) == false)
                                    continue;
                                XmlNode objNode = await objMetamagic.GetNodeAsync(token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    objMetamagic.Bonus = objNode["bonus"];
                                    if (objMetamagic.Bonus != null)
                                    {
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, objMetamagic.SourceType, objMetamagic.InternalId,
                                            objMetamagic.Bonus, 1,
                                            await objMetamagic.GetCurrentDisplayNameShortAsync(token)
                                                              .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objMetamagic.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }

                            // Refresh Cyberware and Bioware.
                            Dictionary<Cyberware, int> dicPairableCyberwares
                                = new Dictionary<Cyberware, int>(await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).GetCountAsync(token).ConfigureAwait(false));
                            foreach (Cyberware objCyberware in await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).GetAllDescendantsAsync(
                                         x => x.GetChildrenAsync(token), token).ConfigureAwait(false))
                            {
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objCyberware.InternalId) != false)
                                {
                                    XmlNode objNode = await objCyberware.GetNodeAsync(token).ConfigureAwait(false);
                                    if (objNode != null)
                                    {
                                        objCyberware.Bonus = objNode["bonus"];
                                        objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                        objCyberware.PairBonus = objNode["pairbonus"];
                                        if (!string.IsNullOrEmpty(objCyberware.Forced) && objCyberware.Forced != "Right"
                                            && objCyberware.Forced != "Left")
                                            ImprovementManager.SetForcedValue(objCyberware.Forced, CharacterObject);
                                        if (objCyberware.Bonus != null)
                                        {
                                            await ImprovementManager.CreateImprovementsAsync(
                                                                        CharacterObject, objCyberware.SourceType,
                                                                        objCyberware.InternalId,
                                                                        objCyberware.Bonus,
                                                                        await objCyberware.GetRatingAsync(token)
                                                                            .ConfigureAwait(false),
                                                                        await objCyberware
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                            string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                            if (!string.IsNullOrEmpty(strSelectedValue))
                                                objCyberware.Extra = strSelectedValue;
                                        }

                                        if (!await objCyberware.GetIsModularCurrentlyEquippedAsync(token).ConfigureAwait(false))
                                            await objCyberware.ChangeModularEquipAsync(false, token: token)
                                                              .ConfigureAwait(false);
                                        else
                                        {
                                            await objCyberware.RefreshWirelessBonusesAsync(token).ConfigureAwait(false);
                                            if (objCyberware.PairBonus != null)
                                            {
                                                Cyberware objMatchingCyberware
                                                    = dicPairableCyberwares.Keys.FirstOrDefault(
                                                        x => objCyberware.IncludePair.Contains(x.Name)
                                                             && x.Extra == objCyberware.Extra);
                                                if (objMatchingCyberware != null)
                                                    ++dicPairableCyberwares[objMatchingCyberware];
                                                else
                                                    dicPairableCyberwares.Add(objCyberware, 1);
                                            }
                                        }

                                        Guid guidSourceId = await objCyberware.GetSourceIDAsync(token).ConfigureAwait(false);
                                        TreeNode objWareNode = guidSourceId == Cyberware.EssenceHoleGUID
                                                               || guidSourceId == Cyberware.EssenceAntiHoleGUID
                                            ? await treCyberware.DoThreadSafeFuncAsync(
                                                                    x => x.FindNode(guidSourceId.ToString("D", GlobalSettings.InvariantCultureInfo)), token)
                                                                .ConfigureAwait(false)
                                            : await treCyberware.DoThreadSafeFuncAsync(
                                                x => x.FindNode(objCyberware.InternalId), token).ConfigureAwait(false);
                                        if (objWareNode != null)
                                        {
                                            string strText = await objCyberware.GetCurrentDisplayNameAsync(token)
                                                                               .ConfigureAwait(false);
                                            await treCyberware.DoThreadSafeAsync(
                                                                  () => objWareNode.Text = strText,
                                                                  token)
                                                              .ConfigureAwait(false);
                                        }
                                    }
                                    else
                                    {
                                        sbdOutdatedItems.AppendLine(
                                            await objCyberware.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                    }
                                }

                                await objCyberware.GearChildren.ForEachWithSideEffectsAsync(
                                    objGear => objGear.ReaddImprovements(
                                        treCyberware, sbdOutdatedItems, lstInternalIdFilter,
                                        token: token), token).ConfigureAwait(false);
                            }

                            // Separate Pass for PairBonuses
                            foreach (KeyValuePair<Cyberware, int> objItem in dicPairableCyberwares)
                            {
                                Cyberware objCyberware = objItem.Key;
                                int intCyberwaresCount = objItem.Value;
                                List<Cyberware> lstPairableCyberwares = await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false))
                                    .DeepWhereAsync(x => x.GetChildrenAsync(token),
                                                    async x => objCyberware.IncludePair.Contains(x.Name)
                                                               && x.Extra == objCyberware.Extra
                                                               && await x.GetIsModularCurrentlyEquippedAsync(token)
                                                                         .ConfigureAwait(false), token)
                                    .ConfigureAwait(false);
                                // Need to use slightly different logic if this cyberware has a location (Left or Right) and only pairs with itself because Lefts can only be paired with Rights and Rights only with Lefts
                                if (!string.IsNullOrEmpty(objCyberware.Location)
                                    && objCyberware.IncludePair.All(x => x == objCyberware.Name))
                                {
                                    int intMatchLocationCount = 0;
                                    int intNotMatchLocationCount = 0;
                                    foreach (Cyberware objPairableCyberware in lstPairableCyberwares)
                                    {
                                        if (objPairableCyberware.Location != objCyberware.Location)
                                            ++intNotMatchLocationCount;
                                        else
                                            ++intMatchLocationCount;
                                    }

                                    // Set the count to the total number of cyberwares in matching pairs, which would mean 2x the number of whichever location contains the fewest members (since every single one of theirs would have a pair)
                                    intCyberwaresCount = Math.Min(intNotMatchLocationCount, intMatchLocationCount) * 2;
                                }

                                if (intCyberwaresCount > 0)
                                {
                                    foreach (Cyberware objLoopCyberware in lstPairableCyberwares)
                                    {
                                        if ((intCyberwaresCount & 1) == 0)
                                        {
                                            if (!string.IsNullOrEmpty(objCyberware.Forced)
                                                && objCyberware.Forced != "Right"
                                                && objCyberware.Forced != "Left")
                                                ImprovementManager.SetForcedValue(objCyberware.Forced, CharacterObject);
                                            await ImprovementManager.CreateImprovementsAsync(
                                                                        CharacterObject, objLoopCyberware.SourceType,
                                                                        objLoopCyberware.InternalId + "Pair",
                                                                        objLoopCyberware.PairBonus,
                                                                        await objLoopCyberware.GetRatingAsync(token)
                                                                            .ConfigureAwait(false),
                                                                        await objLoopCyberware
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                            string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                            if (!string.IsNullOrEmpty(strSelectedValue) && string.IsNullOrEmpty(objCyberware.Extra))
                                                objCyberware.Extra = strSelectedValue;
                                            TreeNode objNode = await objLoopCyberware.GetSourceIDAsync(token).ConfigureAwait(false) == Cyberware.EssenceHoleGUID
                                                               || await objCyberware.GetSourceIDAsync(token).ConfigureAwait(false) == Cyberware.EssenceAntiHoleGUID
                                                ? await treCyberware.DoThreadSafeFuncAsync(
                                                                        x => x.FindNode(objCyberware.SourceIDString),
                                                                        token)
                                                                    .ConfigureAwait(false)
                                                : await treCyberware.DoThreadSafeFuncAsync(
                                                                        x => x.FindNode(objLoopCyberware.InternalId),
                                                                        token)
                                                                    .ConfigureAwait(false);
                                            if (objNode != null)
                                            {
                                                string strName = await objLoopCyberware
                                                                       .GetCurrentDisplayNameAsync(token)
                                                                       .ConfigureAwait(false);
                                                await treCyberware
                                                      .DoThreadSafeAsync(() => objNode.Text = strName, token)
                                                      .ConfigureAwait(false);
                                            }
                                        }

                                        --intCyberwaresCount;
                                        if (intCyberwaresCount <= 0)
                                            break;
                                    }
                                }
                            }

                            // Refresh Armors.
                            await CharacterObject.Armor.ForEachWithSideEffectsAsync(async objArmor =>
                            {
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objArmor.InternalId) != false)
                                {
                                    XmlNode objNode = await objArmor.GetNodeAsync(token).ConfigureAwait(false);
                                    if (objNode != null)
                                    {
                                        objArmor.Bonus = objNode["bonus"];
                                        if (objArmor.Bonus != null && objArmor.Equipped)
                                        {
                                            ImprovementManager.SetForcedValue(objArmor.Extra, CharacterObject);
                                            await ImprovementManager.CreateImprovementsAsync(
                                                CharacterObject, Improvement.ImprovementSource.Armor,
                                                objArmor.InternalId,
                                                objArmor.Bonus, await objArmor.GetRatingAsync(token).ConfigureAwait(false),
                                                await objArmor.GetCurrentDisplayNameShortAsync(token)
                                                              .ConfigureAwait(false),
                                                token: token).ConfigureAwait(false);
                                            string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                            if (!string.IsNullOrEmpty(strSelectedValue))
                                            {
                                                objArmor.Extra = strSelectedValue;
                                                string strName = await objArmor.GetCurrentDisplayNameAsync(token)
                                                                               .ConfigureAwait(false);
                                                await treArmor.DoThreadSafeAsync(x =>
                                                {
                                                    TreeNode objArmorNode = x.FindNode(objArmor.InternalId);
                                                    if (objArmorNode != null)
                                                        objArmorNode.Text = strName;
                                                }, token).ConfigureAwait(false);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        sbdOutdatedItems.AppendLine(
                                            await objArmor.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                    }
                                }

                                await objArmor.ArmorMods.ForEachWithSideEffectsAsync(async objMod =>
                                {
                                    // We're only re-apply improvements a list of items, not all of them
                                    if (lstInternalIdFilter?.Contains(objMod.InternalId) != false)
                                    {
                                        XmlNode objChild = await objMod.GetNodeAsync(token).ConfigureAwait(false);

                                        if (objChild != null)
                                        {
                                            objMod.Bonus = objChild["bonus"];
                                            if (objMod.Bonus != null && objMod.Equipped)
                                            {
                                                ImprovementManager.SetForcedValue(objMod.Extra, CharacterObject);
                                                await ImprovementManager.CreateImprovementsAsync(
                                                                            CharacterObject,
                                                                            Improvement.ImprovementSource.ArmorMod,
                                                                            objMod.InternalId, objMod.Bonus,
                                                                            await objMod.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                                            await objMod
                                                                                .GetCurrentDisplayNameShortAsync(token)
                                                                                .ConfigureAwait(false), token: token)
                                                                        .ConfigureAwait(false);
                                                string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                                if (!string.IsNullOrEmpty(strSelectedValue))
                                                {
                                                    objMod.Extra = strSelectedValue;
                                                    string strName = await objMod.GetCurrentDisplayNameAsync(token)
                                                        .ConfigureAwait(false);
                                                    await treArmor.DoThreadSafeAsync(x =>
                                                    {
                                                        TreeNode objPluginNode = x.FindNode(objMod.InternalId);
                                                        if (objPluginNode != null)
                                                            objPluginNode.Text = strName;
                                                    }, token).ConfigureAwait(false);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            sbdOutdatedItems.AppendLine(
                                                await objMod.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                        }
                                    }

                                    await objMod.GearChildren.ForEachWithSideEffectsAsync(objGear => objGear
                                                                               .ReaddImprovements(
                                                                                   treArmor, sbdOutdatedItems,
                                                                                   lstInternalIdFilter, token: token),
                                                                           token).ConfigureAwait(false);
                                }, token).ConfigureAwait(false);

                                await objArmor.GearChildren.ForEachWithSideEffectsAsync(objGear => objGear
                                                                             .ReaddImprovements(
                                                                                 treArmor, sbdOutdatedItems,
                                                                                 lstInternalIdFilter, token: token),
                                                                         token).ConfigureAwait(false);

                                await objArmor.RefreshWirelessBonusesAsync(token).ConfigureAwait(false);
                            }, token).ConfigureAwait(false);

                            // Refresh Gear.
                            await CharacterObject.Gear.ForEachWithSideEffectsAsync(async objGear =>
                            {
                                await objGear
                                      .ReaddImprovements(treGear, sbdOutdatedItems, lstInternalIdFilter, token: token)
                                      .ConfigureAwait(false);
                                await objGear.RefreshWirelessBonusesAsync(token).ConfigureAwait(false);
                            }, token).ConfigureAwait(false);

                            // Refresh Weapons Gear
                            await CharacterObject.Weapons.ForEachWithSideEffectsAsync(async objWeapon =>
                            {
                                await objWeapon.WeaponAccessories.ForEachWithSideEffectsAsync(
                                                   objAccessory => objAccessory.GearChildren.ForEachWithSideEffectsAsync(objGear =>
                                                       objGear
                                                           .ReaddImprovements(
                                                               treWeapons, sbdOutdatedItems, lstInternalIdFilter,
                                                               token: token), token), token)
                                               .ConfigureAwait(false);

                                await objWeapon.RefreshWirelessBonusesAsync(token).ConfigureAwait(false);
                            }, token).ConfigureAwait(false);
                        }
                        finally
                        {
                            _blnReapplyImprovements = blnOldReapplyImprovements;
                        }

                        // If the status of any Character Event flags has changed, manually trigger those events.
                        List<string> lstTemp = new List<string>(3);
                        if (blnMAGEnabled != await CharacterObject.GetMAGEnabledAsync(token).ConfigureAwait(false))
                            lstTemp.Add(nameof(Character.MAGEnabled));
                        if (blnRESEnabled != await CharacterObject.GetRESEnabledAsync(token).ConfigureAwait(false))
                            lstTemp.Add(nameof(Character.RESEnabled));
                        if (blnDEPEnabled != await CharacterObject.GetDEPEnabledAsync(token).ConfigureAwait(false))
                            lstTemp.Add(nameof(Character.DEPEnabled));
                        if (lstTemp.Count > 0)
                        {
                            await CharacterObject.SetEssenceAtSpecialStartAsync(decEssenceAtSpecialStart, token)
                                .ConfigureAwait(false);
                            await OnCharacterPropertyChanged(this, new MultiplePropertiesChangedEventArgs(lstTemp),
                                token).ConfigureAwait(false);
                        }

                        // Immediately await character update because it re-applies essence loss improvements
                        try
                        {
                            await RequestAndProcessCharacterUpdate(token).ConfigureAwait(false);
                        }
                        catch (OperationCanceledException)
                        {
                            return;
                        }

                        if (sbdOutdatedItems.Length > 0 && !Utils.IsUnitTest)
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this, await LanguageManager.GetStringAsync(
                                              "Message_ReapplyImprovementsFoundOutdatedItems_Top",
                                              token: token)
                                          .ConfigureAwait(false) +
                                      sbdOutdatedItems.Append(
                                      await LanguageManager.GetStringAsync(
                                              "Message_ReapplyImprovementsFoundOutdatedItems_Bottom",
                                              token: token)
                                          .ConfigureAwait(false)).ToString(),
                                await LanguageManager
                                    .GetStringAsync("MessageTitle_ConfirmReapplyImprovements", token: token)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error, token: token).ConfigureAwait(false);
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }

            await SetDirty(true, token).ConfigureAwait(false);
        }

        private async void mnuSpecialPossess_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure the Spirit has been saved first.
                if (IsDirty && await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_PossessionSave", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_Possession", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                    return;

                if (Utils.IsUnitTest)
                {
                    Utils.BreakIfDebug();
                    return;
                }

                string strFileName = string.Empty;
                string strFilter = await LanguageManager.GetStringAsync("DialogFilter_Chummer", token: GenericToken).ConfigureAwait(false)
                                   + "|" +
                                   await LanguageManager.GetStringAsync("DialogFilter_Chum5", token: GenericToken).ConfigureAwait(false)
                                   + "|" +
                                   await LanguageManager.GetStringAsync("DialogFilter_Chum5lz", token: GenericToken).ConfigureAwait(false)
                                   + "|" +
                                   await LanguageManager.GetStringAsync("DialogFilter_All", token: GenericToken).ConfigureAwait(false);
                // Prompt the user to select a save file to possess.
                DialogResult eResult = await this.DoThreadSafeFuncAsync(x =>
                {
                    using (OpenFileDialog dlgOpenFile = new OpenFileDialog())
                    {
                        dlgOpenFile.Filter = strFilter;
                        DialogResult eReturn = dlgOpenFile.ShowDialog(x);
                        strFileName = dlgOpenFile.FileName;
                        return eReturn;
                    }
                }, GenericToken).ConfigureAwait(false);
                if (eResult != DialogResult.OK)
                    return;

                string strOpenFile = string.Empty;
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    Character objMerge = new Character();
                    try
                    {
                        await objMerge.SetFileNameAsync(await CharacterObject.GetFileNameAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                        Character objVessel = new Character();
                        try
                        {
                            await objVessel.SetFileNameAsync(strFileName, GenericToken).ConfigureAwait(false);
                            using (ThreadSafeForm<LoadingBar> frmLoadingBar
                                   = await Program.CreateAndShowProgressBarAsync(
                                       Path.GetFileName(objVessel.FileName), Character.NumLoadingSections * 2 + 7,
                                       GenericToken).ConfigureAwait(false))
                            {
                                bool blnSuccess = await objVessel
                                                        .LoadAsync(frmLoadingForm: frmLoadingBar.MyForm,
                                                                   token: GenericToken).ConfigureAwait(false);
                                if (!blnSuccess)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(this,
                                        await LanguageManager.GetStringAsync(
                                            "Message_Load_Error_Warning", token: GenericToken).ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("String_Error", token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK,
                                        MessageBoxIcon.Error, token: GenericToken).ConfigureAwait(false);
                                    return;
                                }

                                // Make sure the Vessel is in Career Mode.
                                if (!await objVessel.GetCreatedAsync(GenericToken).ConfigureAwait(false))
                                {
                                    await Program.ShowScrollableMessageBoxAsync(this,
                                        await LanguageManager.GetStringAsync(
                                            "Message_VesselInCareerMode", token: GenericToken).ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync(
                                            "MessageTitle_Possession", token: GenericToken).ConfigureAwait(false),
                                        MessageBoxButtons.OK,
                                        MessageBoxIcon.Error, token: GenericToken).ConfigureAwait(false);
                                    return;
                                }

                                // Load the Spirit's save file into a new Merge character.
                                await frmLoadingBar.MyForm.SetCharacterFileAsync(await objMerge.GetFileNameAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                blnSuccess = await objMerge
                                                   .LoadAsync(frmLoadingForm: frmLoadingBar.MyForm, token: GenericToken)
                                                   .ConfigureAwait(false);
                                if (!blnSuccess)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(this,
                                        await LanguageManager.GetStringAsync(
                                            "Message_Load_Error_Warning", token: GenericToken).ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("String_Error", token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK,
                                        MessageBoxIcon.Error, token: GenericToken).ConfigureAwait(false);
                                    return;
                                }

                                await objMerge.SetPossessedAsync(true, GenericToken).ConfigureAwait(false);
                                await objMerge.SetAliasAsync(await objVessel.GetCharacterNameAsync(GenericToken).ConfigureAwait(false)
                                                 + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                                                        .ConfigureAwait(false) + "("
                                                 + await LanguageManager.GetStringAsync("String_Possessed", token: GenericToken)
                                                                        .ConfigureAwait(false) + ")", GenericToken).ConfigureAwait(false);

                                // Give the Critter the Immunity to Normal Weapons Power if they don't already have it.
                                bool blnHasImmunity =
                                    await objMerge.CritterPowers.FirstOrDefaultAsync(x =>
                                        x.Name == "Immunity" && x.Extra == "Normal Weapons", GenericToken).ConfigureAwait(false) != null;

                                if (!blnHasImmunity)
                                {
                                    XmlDocument objPowerDoc
                                        = await CharacterObject.LoadDataAsync("critterpowers.xml", token: GenericToken)
                                                               .ConfigureAwait(false);
                                    XmlNode objPower
                                        = objPowerDoc.SelectSingleNode("/chummer/powers/power[name = \"Immunity\"]");

                                    CritterPower objCritterPower = new CritterPower(objMerge);
                                    await objCritterPower.CreateAsync(objPower, 0, "Normal Weapons", token: GenericToken).ConfigureAwait(false);
                                    await objMerge.CritterPowers.AddAsync(objCritterPower, GenericToken).ConfigureAwait(false);
                                }

                                //TOD: Implement Possession attribute bonuses.
                                /*
                            // Add the Vessel's Physical Attributes to the Spirit's Force.
                            objMerge.BOD.MetatypeMaximum = objVessel.BOD.Value + objMerge.MAG.TotalValue;
                            objMerge.BOD.Value = objVessel.BOD.Value + objMerge.MAG.TotalValue;
                            objMerge.AGI.MetatypeMaximum = objVessel.AGI.Value + objMerge.MAG.TotalValue;
                            objMerge.AGI.Value = objVessel.AGI.Value + objMerge.MAG.TotalValue;
                            objMerge.REA.MetatypeMaximum = objVessel.REA.Value + objMerge.MAG.TotalValue;
                            objMerge.REA.Value = objVessel.REA.Value + objMerge.MAG.TotalValue;
                            objMerge.STR.MetatypeMaximum = objVessel.STR.Value + objMerge.MAG.TotalValue;
                            objMerge.STR.Value = objVessel.STR.Value + objMerge.MAG.TotalValue;
                            */

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("String_SelectPACKSKit_Lifestyles", token: GenericToken)
                                                         .ConfigureAwait(false),
                                    token: GenericToken).ConfigureAwait(false);
                                // Copy any Lifestyles the Vessel has.
                                await objVessel.Lifestyles.ForEachWithSideEffectsAsync(objLifestyle =>
                                    objMerge.Lifestyles.AddAsync(objLifestyle, GenericToken), GenericToken).ConfigureAwait(false);

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("Tab_Armor", token: GenericToken).ConfigureAwait(false),
                                    token: GenericToken).ConfigureAwait(false);
                                // Copy any Armor the Vessel has.
                                await objVessel.Armor.ForEachWithSideEffectsAsync(async objArmor =>
                                {
                                    await objMerge.Armor.AddAsync(objArmor, GenericToken).ConfigureAwait(false);
                                    await CopyArmorImprovements(objVessel, objMerge, objArmor, GenericToken).ConfigureAwait(false);
                                }, GenericToken).ConfigureAwait(false);

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("Tab_Gear", token: GenericToken).ConfigureAwait(false),
                                    token: GenericToken).ConfigureAwait(false);
                                // Copy any Gear the Vessel has.
                                await objVessel.Gear.ForEachWithSideEffectsAsync(async objGear =>
                                {
                                    await objMerge.Gear.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                                    await CopyGearImprovements(objVessel, objMerge, objGear, GenericToken).ConfigureAwait(false);
                                }, GenericToken).ConfigureAwait(false);

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("Tab_Cyberware", token: GenericToken).ConfigureAwait(false),
                                    token: GenericToken).ConfigureAwait(false);
                                // Copy any Cyberware/Bioware the Vessel has.
                                await objVessel.Cyberware.ForEachWithSideEffectsAsync(async objCyberware =>
                                {
                                    await objMerge.Cyberware.AddAsync(objCyberware, GenericToken).ConfigureAwait(false);
                                    await CopyCyberwareImprovements(objVessel, objMerge, objCyberware, GenericToken).ConfigureAwait(false);
                                }, GenericToken).ConfigureAwait(false);

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("Tab_Weapons", token: GenericToken).ConfigureAwait(false),
                                    token: GenericToken).ConfigureAwait(false);
                                // Copy any Weapons the Vessel has.
                                await objVessel.Weapons.ForEachWithSideEffectsAsync(objWeapon =>
                                    objMerge.Weapons.AddAsync(objWeapon, GenericToken), GenericToken).ConfigureAwait(false);

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("Tab_Vehicles", token: GenericToken).ConfigureAwait(false),
                                    token: GenericToken).ConfigureAwait(false);
                                // Copy and Vehicles the Vessel has.
                                await objVessel.Vehicles.ForEachWithSideEffectsAsync(objVehicle =>
                                    objMerge.Vehicles.AddAsync(objVehicle, GenericToken), GenericToken).ConfigureAwait(false);

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("String_Settings", token: GenericToken).ConfigureAwait(false),
                                    token: GenericToken).ConfigureAwait(false);
                                // Copy the character info.
                                await objMerge.SetGenderAsync(await objVessel.GetGenderAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objMerge.SetAgeAsync(await objVessel.GetAgeAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objMerge.SetEyesAsync(await objVessel.GetEyesAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objMerge.SetHairAsync(await objVessel.GetHairAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objMerge.SetHeightAsync(await objVessel.GetHeightAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objMerge.SetWeightAsync(await objVessel.GetWeightAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objMerge.SetSkinAsync(await objVessel.GetSkinAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objMerge.SetNameAsync(await objVessel.GetNameAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objMerge.SetStreetCredAsync(await objVessel.GetStreetCredAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objMerge.SetBurntStreetCredAsync(await objVessel.GetBurntStreetCredAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objMerge.SetNotorietyAsync(await objVessel.GetNotorietyAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objMerge.SetPublicAwarenessAsync(await objVessel.GetPublicAwarenessAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                ThreadSafeList<Image> lstMergeMugshots = await objMerge.GetMugshotsAsync(GenericToken).ConfigureAwait(false);
                                await (await objVessel.GetMugshotsAsync(GenericToken).ConfigureAwait(false)).ForEachWithSideEffectsAsync(objMugshot =>
                                    lstMergeMugshots.AddAsync(objMugshot, GenericToken), GenericToken).ConfigureAwait(false);
                            }
                        }
                        finally
                        {
                            await objVessel.DisposeAsync().ConfigureAwait(false);
                        }

                        string strShowFileName = Path.GetFileName(objMerge.FileName);
                        if (string.IsNullOrEmpty(strShowFileName))
                            strShowFileName = objMerge.CharacterName;
                        strShowFileName = strShowFileName.TrimEndOnce(".chum5").TrimEndOnce(".chum5lz")
                                          + await LanguageManager.GetStringAsync("String_Space", token: GenericToken).ConfigureAwait(false)
                                          + "("
                                          + await LanguageManager.GetStringAsync("String_Possessed", token: GenericToken)
                                                                 .ConfigureAwait(false) + ")";

                        // Now that everything is done, save the merged character and open them.
                        dlgSaveFile.FileName = strShowFileName;
                        if (await this.DoThreadSafeFuncAsync(x => dlgSaveFile.ShowDialog(x), GenericToken)
                                      .ConfigureAwait(false)
                            != DialogResult.OK)
                            return;
                        using (ThreadSafeForm<LoadingBar> frmLoadingBar
                               = await Program.CreateAndShowProgressBarAsync(token: GenericToken).ConfigureAwait(false))
                        {
                            await frmLoadingBar.MyForm.PerformStepAsync(objMerge.CharacterName,
                                                                        LoadingBar.ProgressBarTextPatterns.Saving,
                                                                        token: GenericToken).ConfigureAwait(false);
                            objMerge.FileName = dlgSaveFile.FileName;
                            if (await objMerge.SaveAsync(token: GenericToken).ConfigureAwait(false))
                            {
                                // Get the name of the file and destroy the references to the Vessel and the merged character.
                                strOpenFile = objMerge.FileName;
                            }
                        }
                    }
                    finally
                    {
                        await objMerge
                              .DisposeAsync()
                              .ConfigureAwait(
                                  false); // Fine here because Dispose()/DisposeAsync() code is skipped if the character is open in a form
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }

                if (!string.IsNullOrEmpty(strOpenFile))
                {
                    objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                    try
                    {
                        Character objOpenCharacter;
                        using (ThreadSafeForm<LoadingBar> frmLoadingBar
                               = await Program
                                       .CreateAndShowProgressBarAsync(strOpenFile, Character.NumLoadingSections,
                                                                      GenericToken).ConfigureAwait(false))
                            objOpenCharacter
                                = await Program.LoadCharacterAsync(strOpenFile, frmLoadingBar: frmLoadingBar.MyForm,
                                                                   token: GenericToken).ConfigureAwait(false);
                        await Program.OpenCharacter(objOpenCharacter, token: GenericToken).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objCursorWait.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialPossessInanimate_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure the Spirit has been saved first.
                if (IsDirty && await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_PossessionSave", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_Possession", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                    return;

                if (Utils.IsUnitTest)
                {
                    Utils.BreakIfDebug();
                    return;
                }

                string strSelectedVessel;
                // Prompt the user to select an inanimate Vessel.
                XPathNavigator xmlVesselsNavigator = await CharacterObject
                                                           .LoadDataXPathAsync("vessels.xml", token: GenericToken)
                                                           .ConfigureAwait(false);
                using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(Utils.ListItemListPool, out List<ListItem> lstMetatype))
                {
                    foreach (XPathNavigator xmlMetatype in xmlVesselsNavigator.SelectAndCacheExpression(
                                 "/chummer/metatypes/metatype", GenericToken))
                    {
                        string strName = xmlMetatype.SelectSingleNodeAndCacheExpression("name", GenericToken)?.Value;
                        if (!string.IsNullOrEmpty(strName))
                        {
                            ListItem objItem
                                = new ListItem(
                                    strName,
                                    xmlMetatype.SelectSingleNodeAndCacheExpression("translate", GenericToken)?.Value ?? strName);
                            lstMetatype.Add(objItem);
                        }
                    }

                    using (ThreadSafeForm<SelectItem> frmSelectVessel = await ThreadSafeForm<SelectItem>
                                                                              .GetAsync(() => new SelectItem(),
                                                                                  GenericToken).ConfigureAwait(false))
                    {
                        frmSelectVessel.MyForm.SetGeneralItemsMode(lstMetatype);

                        if (await frmSelectVessel.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        strSelectedVessel = await frmSelectVessel.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, GenericToken).ConfigureAwait(false);
                    }
                }

                // Get the Node for the selected Vessel.
                XmlDocument xmlVessels = await CharacterObject.LoadDataAsync("vessels.xml", token: GenericToken)
                                                              .ConfigureAwait(false);
                XmlNode objSelected
                    = xmlVessels.TryGetNodeByNameOrId("/chummer/metatypes/metatype", strSelectedVessel);
                if (objSelected == null)
                    return;

                string strOpenFile = string.Empty;
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    // Load the Spirit's save file into a new Merge character.
                    Character objMerge = new Character();
                    try
                    {
                        IAsyncDisposable objMergeLocker = await objMerge.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            await objMerge.SetFileNameAsync(await CharacterObject.GetFileNameAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                            using (ThreadSafeForm<LoadingBar> frmLoadingBar
                                    = await Program.CreateAndShowProgressBarAsync(
                                                        await objMerge.GetFileNameAsync(GenericToken).ConfigureAwait(false),
                                                        Character.NumLoadingSections + 1, GenericToken)
                                                    .ConfigureAwait(false))
                            {
                                await objMerge.LoadAsync(frmLoadingForm: frmLoadingBar.MyForm, token: GenericToken)
                                                .ConfigureAwait(false);
                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("String_UI", token: GenericToken).ConfigureAwait(false),
                                    token: GenericToken).ConfigureAwait(false);
                                await objMerge.SetPossessedAsync(true, GenericToken).ConfigureAwait(false);
                                await objMerge.SetAliasAsync(strSelectedVessel
                                                    + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                                                        .ConfigureAwait(false) + "("
                                                    + await LanguageManager.GetStringAsync("String_Possessed", token: GenericToken)
                                                                        .ConfigureAwait(false) + ")", GenericToken).ConfigureAwait(false);

                                int intHalfMAGRoundedUp
                                    = (await (await CharacterObject.GetAttributeAsync("MAG", token: GenericToken)
                                                                    .ConfigureAwait(false))
                                                .GetTotalValueAsync(GenericToken).ConfigureAwait(false)).DivAwayFromZero(2);
                                try
                                {
                                    await ImprovementManager.CreateImprovementAsync(
                                                                objMerge, "BOD", Improvement.ImprovementSource.Metatype,
                                                                "Possession",
                                                                Improvement.ImprovementType.Attribute, string.Empty,
                                                                intHalfMAGRoundedUp, 1, 0, 0,
                                                                intHalfMAGRoundedUp, intHalfMAGRoundedUp,
                                                                token: GenericToken)
                                                            .ConfigureAwait(false);
                                    await ImprovementManager.CreateImprovementAsync(
                                                                objMerge, "AGI", Improvement.ImprovementSource.Metatype,
                                                                "Possession",
                                                                Improvement.ImprovementType.Attribute, string.Empty,
                                                                intHalfMAGRoundedUp, 1, 0, 0,
                                                                intHalfMAGRoundedUp, intHalfMAGRoundedUp,
                                                                token: GenericToken)
                                                            .ConfigureAwait(false);
                                    await ImprovementManager.CreateImprovementAsync(
                                                                objMerge, "STR", Improvement.ImprovementSource.Metatype,
                                                                "Possession",
                                                                Improvement.ImprovementType.Attribute, string.Empty,
                                                                intHalfMAGRoundedUp, 1, 0, 0,
                                                                intHalfMAGRoundedUp, intHalfMAGRoundedUp,
                                                                token: GenericToken)
                                                            .ConfigureAwait(false);
                                    await ImprovementManager.CreateImprovementAsync(
                                                                objMerge, "REA", Improvement.ImprovementSource.Metatype,
                                                                "Possession",
                                                                Improvement.ImprovementType.Attribute, string.Empty,
                                                                intHalfMAGRoundedUp, 1, 0, 0,
                                                                intHalfMAGRoundedUp, intHalfMAGRoundedUp,
                                                                token: GenericToken)
                                                            .ConfigureAwait(false);
                                    CharacterAttrib objInt = await CharacterObject.GetAttributeAsync("INT", token: GenericToken)
                                        .ConfigureAwait(false);
                                    await ImprovementManager.CreateImprovementAsync(
                                                                objMerge, "INT", Improvement.ImprovementSource.Metatype,
                                                                "Possession",
                                                                Improvement.ImprovementType.ReplaceAttribute, string.Empty,
                                                                0,
                                                                1,
                                                                await objInt.GetMetatypeMinimumAsync(GenericToken).ConfigureAwait(false),
                                                                await objInt.GetMetatypeMaximumAsync(GenericToken).ConfigureAwait(false), 0,
                                                                await objInt.GetMetatypeAugmentedMaximumAsync(GenericToken).ConfigureAwait(false),
                                                                token: GenericToken)
                                                            .ConfigureAwait(false);
                                    CharacterAttrib objWil = await CharacterObject.GetAttributeAsync("WIL", token: GenericToken)
                                        .ConfigureAwait(false);
                                    await ImprovementManager.CreateImprovementAsync(
                                                                objMerge, "WIL", Improvement.ImprovementSource.Metatype,
                                                                "Possession",
                                                                Improvement.ImprovementType.ReplaceAttribute, string.Empty,
                                                                0,
                                                                1,
                                                                await objWil.GetMetatypeMinimumAsync(GenericToken).ConfigureAwait(false),
                                                                await objWil.GetMetatypeMaximumAsync(GenericToken).ConfigureAwait(false), 0,
                                                                await objWil.GetMetatypeAugmentedMaximumAsync(GenericToken).ConfigureAwait(false),
                                                                token: GenericToken)
                                                            .ConfigureAwait(false);
                                    CharacterAttrib objLog = await CharacterObject.GetAttributeAsync("LOG", token: GenericToken)
                                        .ConfigureAwait(false);
                                    await ImprovementManager.CreateImprovementAsync(
                                                                objMerge, "LOG", Improvement.ImprovementSource.Metatype,
                                                                "Possession",
                                                                Improvement.ImprovementType.ReplaceAttribute, string.Empty,
                                                                0,
                                                                1,
                                                                await objLog.GetMetatypeMinimumAsync(GenericToken).ConfigureAwait(false),
                                                                await objLog.GetMetatypeMaximumAsync(GenericToken).ConfigureAwait(false), 0,
                                                                await objLog.GetMetatypeAugmentedMaximumAsync(GenericToken).ConfigureAwait(false),
                                                                token: GenericToken)
                                                            .ConfigureAwait(false);
                                    CharacterAttrib objCha = await CharacterObject.GetAttributeAsync("CHA", token: GenericToken)
                                        .ConfigureAwait(false);
                                    await ImprovementManager.CreateImprovementAsync(
                                                                objMerge, "CHA", Improvement.ImprovementSource.Metatype,
                                                                "Possession",
                                                                Improvement.ImprovementType.ReplaceAttribute, string.Empty,
                                                                0,
                                                                1,
                                                                await objCha.GetMetatypeMinimumAsync(GenericToken).ConfigureAwait(false),
                                                                await objCha.GetMetatypeMaximumAsync(GenericToken).ConfigureAwait(false), 0,
                                                                await objCha.GetMetatypeAugmentedMaximumAsync(GenericToken).ConfigureAwait(false),
                                                                token: GenericToken)
                                                            .ConfigureAwait(false);
                                }
                                catch
                                {
                                    await ImprovementManager.RollbackAsync(CharacterObject, CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }

                                await ImprovementManager.CommitAsync(objMerge, GenericToken).ConfigureAwait(false);
                                XmlDocument xmlPowerDoc
                                    = await CharacterObject.LoadDataAsync("critterpowers.xml", token: GenericToken)
                                                            .ConfigureAwait(false);

                                // Update the Movement if the Vessel has one.
                                string strMovement = objSelected["movement"]?.InnerTextViaPool(GenericToken);
                                if (!string.IsNullOrEmpty(strMovement))
                                    objMerge.Movement = strMovement;

                                // Add any additional Critter Powers the Vessel grants.
                                XmlElement xmlPowersNode = objSelected["powers"];
                                if (xmlPowersNode != null)
                                {
                                    using (XmlNodeList xmlPowerList = xmlPowersNode.SelectNodes("power"))
                                    {
                                        if (xmlPowerList?.Count > 0)
                                        {
                                            foreach (XmlNode objXmlPower in xmlPowerList)
                                            {
                                                XmlNode objXmlCritterPower
                                                    = xmlPowerDoc.TryGetNodeByNameOrId(
                                                        "/chummer/powers/power", objXmlPower.InnerTextViaPool(GenericToken));
                                                CritterPower objPower = new CritterPower(objMerge);
                                                string strSelect = objXmlPower.Attributes?["select"]?.InnerTextViaPool(GenericToken)
                                                                    ?? string.Empty;
                                                int.TryParse(objXmlPower.Attributes?["rating"]?.InnerTextViaPool(GenericToken), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intRating);

                                                await objPower.CreateAsync(objXmlCritterPower, intRating, strSelect, GenericToken).ConfigureAwait(false);

                                                await objMerge.CritterPowers.AddAsync(objPower, GenericToken)
                                                                .ConfigureAwait(false);
                                            }
                                        }
                                    }
                                }

                                // Give the Critter the Immunity to Normal Weapons Power if they don't already have it.
                                if (!await objMerge.CritterPowers.AnyAsync(objCritterPower =>
                                                                                objCritterPower.Name == "Immunity"
                                                                                && objCritterPower.Extra == "Normal Weapons",
                                                                            GenericToken).ConfigureAwait(false))
                                {
                                    XmlNode objPower
                                        = xmlPowerDoc.SelectSingleNode("/chummer/powers/power[name = \"Immunity\"]");

                                    CritterPower objCritterPower = new CritterPower(objMerge);
                                    await objCritterPower.CreateAsync(objPower, 0, "Normal Weapons", token: GenericToken).ConfigureAwait(false);
                                    await objMerge.CritterPowers.AddAsync(objCritterPower, GenericToken)
                                                    .ConfigureAwait(false);
                                }

                                // Add any Improvements the Vessel grants.
                                if (objSelected["bonus"] != null)
                                {
                                    await ImprovementManager.CreateImprovementsAsync(
                                        objMerge, Improvement.ImprovementSource.Metatype, strSelectedVessel,
                                        objSelected["bonus"], 1, strSelectedVessel, token: GenericToken).ConfigureAwait(false);
                                }
                            }

                            // Now that everything is done, save the merged character and open them.
                            string strShowFileName = Path.GetFileName(await objMerge.GetFileNameAsync(GenericToken).ConfigureAwait(false));

                            if (string.IsNullOrEmpty(strShowFileName))
                            {
                                strShowFileName = (await objMerge.GetCharacterNameAsync(GenericToken).ConfigureAwait(false)).CleanForFileName();
                            }

                            strShowFileName = strShowFileName.TrimEndOnce(".chum5").TrimEndOnce(".chum5lz");

                            strShowFileName += await LanguageManager.GetStringAsync("String_Space", token: GenericToken).ConfigureAwait(false)
                                                + "("
                                                + await LanguageManager.GetStringAsync("String_Possessed", token: GenericToken)
                                                                        .ConfigureAwait(false) + ")";
                            dlgSaveFile.FileName = strShowFileName;
                            if (await this.DoThreadSafeFuncAsync(x => dlgSaveFile.ShowDialog(x), GenericToken)
                                            .ConfigureAwait(false)
                                != DialogResult.OK)
                                return;
                            using (ThreadSafeForm<LoadingBar> frmLoadingBar
                                    = await Program.CreateAndShowProgressBarAsync(token: GenericToken).ConfigureAwait(false))
                            {
                                await frmLoadingBar.MyForm.PerformStepAsync(objMerge.CharacterName,
                                                                            LoadingBar.ProgressBarTextPatterns.Saving,
                                                                            token: GenericToken).ConfigureAwait(false);
                                await objMerge.SetFileNameAsync(dlgSaveFile.FileName, GenericToken).ConfigureAwait(false);
                                if (await objMerge.SaveAsync(token: GenericToken).ConfigureAwait(false))
                                {
                                    // Get the name of the file and destroy the references to the Vessel and the merged character.
                                    strOpenFile = await objMerge.GetFileNameAsync(GenericToken).ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await objMergeLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objMerge
                              .DisposeAsync()
                              .ConfigureAwait(
                                  false); // Fine here because Dispose()/DisposeAsync() code is skipped if the character is open in a form
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }

                if (!string.IsNullOrEmpty(strOpenFile))
                {
                    objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                    try
                    {
                        Character objOpenCharacter;
                        using (ThreadSafeForm<LoadingBar> frmLoadingBar
                               = await Program.CreateAndShowProgressBarAsync(
                                   strOpenFile, Character.NumLoadingSections, GenericToken).ConfigureAwait(false))
                            objOpenCharacter
                                = await Program.LoadCharacterAsync(strOpenFile, frmLoadingBar: frmLoadingBar.MyForm,
                                                                   token: GenericToken).ConfigureAwait(false);
                        await Program.OpenCharacter(objOpenCharacter, token: GenericToken).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objCursorWait.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuEditCopy_Click(object sender, EventArgs e)
        {
            try
            {
                if (tabCharacterTabs != null)
                {
                    object objSelectedObject = await tabCharacterTabs.DoThreadSafeFuncAsync(x =>
                    {
                        if (x.SelectedTab == tabStreetGear && tabStreetGearTabs != null)
                        {
                            if (tabStreetGearTabs.SelectedTab == tabArmor)
                            {
                                return treArmor.SelectedNode?.Tag;
                            }

                            if (tabStreetGearTabs.SelectedTab == tabWeapons)
                            {
                                return treWeapons.SelectedNode?.Tag;
                            }

                            if (tabStreetGearTabs.SelectedTab == tabGear)
                            {
                                return treGear.SelectedNode?.Tag;
                            }

                            if (tabStreetGearTabs.SelectedTab == tabLifestyle)
                            {
                                return treLifestyles.SelectedNode?.Tag;
                            }

                            Utils.BreakIfDebug();
                            return null;
                        }

                        if (x.SelectedTab == tabVehicles)
                        {
                            return treVehicles.SelectedNode?.Tag;
                        }

                        if (x.SelectedTab == tabCyberware)
                        {
                            return treCyberware.SelectedNode?.Tag;
                        }

                        Utils.BreakIfDebug();
                        return null;
                    }, GenericToken).ConfigureAwait(false);

                    if (objSelectedObject != null)
                        await CopyObject(objSelectedObject, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialConvertToFreeSprite_Click(object sender, EventArgs e)
        {
            try
            {
                XmlDocument objXmlDocument
                    = await CharacterObject.LoadDataAsync("critterpowers.xml", token: GenericToken)
                                           .ConfigureAwait(false);
                XmlNode objXmlPower = objXmlDocument.SelectSingleNode("/chummer/powers/power[name = \"Denial\"]");
                CritterPower objPower = new CritterPower(CharacterObject);
                await objPower.CreateAsync(objXmlPower, token: GenericToken).ConfigureAwait(false);
                objPower.CountTowardsLimit = false;
                if (objPower.InternalId.IsEmptyGuid())
                    return;

                await CharacterObject.CritterPowers.AddAsync(objPower, GenericToken).ConfigureAwait(false);

                await CharacterObject.SetMetatypeCategoryAsync("Free Sprite", GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialAddCyberwareSuite_Click(object sender, EventArgs e)
        {
            try
            {
                await AddCyberwareSuite(Improvement.ImprovementSource.Cyberware, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialAddBiowareSuite_Click(object sender, EventArgs e)
        {
            try
            {
                await AddCyberwareSuite(Improvement.ImprovementSource.Bioware, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Menu Events

        #region Martial Tab Control Events

        private async void treMartialArts_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedMartialArt(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedMartialArt(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                object objSelectedNodeTag = await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token)
                                                                .ConfigureAwait(false);
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblMartialArtSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                    await lblMartialArtSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    await objSelected.SetSourceDetailAsync(lblMartialArtSource, token).ConfigureAwait(false);
                }
                else
                {
                    await lblMartialArtSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                    await lblMartialArtSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                }

                switch (objSelectedNodeTag)
                {
                    case MartialArt objMartialArt:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = !objMartialArt.IsQuality, token)
                                                 .ConfigureAwait(false);
                        break;

                    case ICanRemove _:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        break;

                    default:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                 .ConfigureAwait(false);
                        await SourceString.Blank.SetControlAsync(lblMartialArtSource, this, token).ConfigureAwait(false);
                        break;
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        #endregion Martial Tab Control Events

        #region Button Events

        private void panContacts_DragDrop(object sender, DragEventArgs e)
        {
            Point mousePosition = panContacts.PointToClient(new Point(e.X, e.Y));
            Control destination = panContacts.GetChildAtPoint(mousePosition);

            if (destination != null)
            {
                TransportWrapper wrapper = (TransportWrapper) e.Data.GetData(typeof(TransportWrapper));
                Control source = wrapper.Control;
                int indexDestination = panContacts.Controls.IndexOf(destination);
                if (panContacts.Controls.IndexOf(source) < indexDestination)
                    indexDestination--;

                panContacts.Controls.SetChildIndex(source, indexDestination);
            }

            foreach (ContactControl objControl in panContacts.Controls)
            {
                objControl.BackColor = ColorManager.Control;
            }
        }

        private void panContacts_DragOver(object sender, DragEventArgs e)
        {
            Point mousePosition = panContacts.PointToClient(new Point(e.X, e.Y));
            Control destination = panContacts.GetChildAtPoint(mousePosition);

            if (destination == null)
                return;

            destination.BackColor = ColorManager.ControlDarker;
            foreach (ContactControl objControl in panContacts.Controls)
            {
                if (objControl != destination as ContactControl)
                {
                    objControl.BackColor = ColorManager.Control;
                }
            }
            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
        }

        private void panContacts_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private async void cmdAddSpell_Click(object sender, EventArgs e)
        {
            try
            {
                // Open the Spells XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("spells.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                bool blnAddAgain;

                do
                {
                    (bool blnCanTouchOnlySpellBeFree, bool blnCanGenericSpellBeFree)
                        = await CharacterObject.AllowFreeSpellsAsync(GenericToken).ConfigureAwait(false);
                    int intSpellKarmaCost = await CharacterObject.SpellKarmaCostAsync("Spells", GenericToken)
                                                                 .ConfigureAwait(false);
                    int intKarma = await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false);
                    // Make sure the character has enough Karma before letting them select a Spell.
                    if (intKarma < intSpellKarmaCost
                        && !(blnCanTouchOnlySpellBeFree || blnCanGenericSpellBeFree))
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                            this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        break;
                    }

                    int intInitialCost = intSpellKarmaCost;
                    using (ThreadSafeForm<SelectSpell> frmPickSpell = await ThreadSafeForm<SelectSpell>.GetAsync(
                               () => new SelectSpell(CharacterObject)
                               {
                                   FreeOnly = intKarma < intInitialCost &&
                                              (blnCanTouchOnlySpellBeFree || blnCanGenericSpellBeFree)
                               }, GenericToken).ConfigureAwait(false))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickSpell.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickSpell.MyForm.AddAgain;

                        XmlNode objXmlSpell = objXmlDocument.TryGetNodeByNameOrId("/chummer/spells/spell", frmPickSpell.MyForm.SelectedSpell);

                        Spell objSpell = new Spell(CharacterObject);
                        try
                        {
                            await objSpell.CreateAsync(objXmlSpell, string.Empty, frmPickSpell.MyForm.Limited,
                                frmPickSpell.MyForm.Extended, frmPickSpell.MyForm.Alchemical, token: GenericToken).ConfigureAwait(false);
                            if (objSpell.Alchemical)
                            {
                                intSpellKarmaCost = await CharacterObject
                                                          .SpellKarmaCostAsync("Preparations", GenericToken)
                                                          .ConfigureAwait(false);
                            }
                            else if (objSpell.Category == "Rituals")
                            {
                                intSpellKarmaCost = await CharacterObject.SpellKarmaCostAsync("Rituals", GenericToken)
                                                                         .ConfigureAwait(false);
                            }

                            if (objSpell.InternalId.IsEmptyGuid())
                            {
                                await objSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                continue;
                            }

                            if (frmPickSpell.MyForm.FreeBonus)
                            {
                                objSpell.FreeBonus = true;
                                // Barehanded Adept
                                if (await CharacterObject.GetAdeptEnabledAsync(GenericToken).ConfigureAwait(false)
                                    && !await CharacterObject.GetMagicianEnabledAsync(GenericToken).ConfigureAwait(false)
                                    && (objSpell.Range == "T" || objSpell.Range == "T (A)"))
                                {
                                    objSpell.BarehandedAdept = true;
                                }
                            }
                            else
                            {
                                if (await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false)
                                    < intSpellKarmaCost)
                                {
                                    await objSpell.DisposeAsync().ConfigureAwait(false);
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                    break;
                                }

                                if (!await CommonFunctions.ConfirmKarmaExpenseAsync(
                                                              string.Format(GlobalSettings.CultureInfo,
                                                                            await LanguageManager.GetStringAsync(
                                                                                    "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                                                                .ConfigureAwait(false),
                                                                            await objSpell
                                                                                .GetCurrentDisplayNameAsync(
                                                                                    GenericToken)
                                                                                .ConfigureAwait(false),
                                                                            intSpellKarmaCost.ToString(GlobalSettings.CultureInfo)), token: GenericToken)
                                                          .ConfigureAwait(false))
                                {
                                    await objSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                    continue;
                                }

                                // Create the Expense Log Entry.
                                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                objExpense.Create(-intSpellKarmaCost,
                                                  await LanguageManager.GetStringAsync("String_ExpenseLearnSpell", token: GenericToken)
                                                                       .ConfigureAwait(false)
                                                  + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                                                         .ConfigureAwait(false)
                                                  + await objSpell.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                  .ConfigureAwait(false),
                                                  ExpenseType.Karma, DateTime.Now);
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                                     .ConfigureAwait(false);
                                await CharacterObject.ModifyKarmaAsync(-intSpellKarmaCost, GenericToken)
                                                     .ConfigureAwait(false);

                                ExpenseUndo objUndo = new ExpenseUndo();
                                objUndo.CreateKarma(KarmaExpenseType.AddSpell, objSpell.InternalId);
                                objExpense.Undo = objUndo;
                            }

                            await CharacterObject.Spells.AddAsync(objSpell, GenericToken).ConfigureAwait(false);
                        }
                        catch
                        {
                            await objSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteSpell_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddSpirit_Click(object sender, EventArgs e)
        {
            try
            {
                await AddSpirit(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddSprite_Click(object sender, EventArgs e)
        {
            try
            {
                await AddSprite(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddContact_Click(object sender, EventArgs e)
        {
            try
            {
                await AddContact(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddEnemy_Click(object sender, EventArgs e)
        {
            try
            {
                await AddEnemy(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddPet_Click(object sender, EventArgs e)
        {
            try
            {
                await AddPet(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAddFromFile_Click(object sender, EventArgs e)
        {
            try
            {
                await AddContactsFromFile(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddCyberware_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickCyberware(null, Improvement.ImprovementSource.Cyberware, token: GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteCyberware_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddComplexForm_Click(object sender, EventArgs e)
        {
            try
            {
                XmlDocument objXmlDocument
                    = await CharacterObject.LoadDataAsync("complexforms.xml", token: GenericToken)
                                           .ConfigureAwait(false);
                bool blnAddAgain;

                do
                {
                    // The number of Complex Forms cannot exceed twice the character's RES.
                    if (await CharacterObject.ComplexForms.GetCountAsync(GenericToken).ConfigureAwait(false)
                        >= await (await CharacterObject.GetAttributeAsync("RES", token: GenericToken).ConfigureAwait(false)).GetTotalValueAsync(GenericToken).ConfigureAwait(false) * 2
                        + await ImprovementManager.ValueOfAsync(CharacterObject,
                                                                Improvement.ImprovementType.ComplexFormLimit, token: GenericToken)
                                                  .ConfigureAwait(false)
                        && !await CharacterObjectSettings.GetIgnoreComplexFormLimitAsync(GenericToken).ConfigureAwait(false))
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_ComplexFormLimit", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_ComplexFormLimit", token: GenericToken).ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        break;
                    }

                    int intComplexFormKarmaCost = await CharacterObject.GetComplexFormKarmaCostAsync(GenericToken).ConfigureAwait(false);

                    // Make sure the character has enough Karma before letting them select a Complex Form.
                    if (await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false)
                        < intComplexFormKarmaCost)
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                            this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        break;
                    }

                    XmlNode objXmlComplexForm;
                    // Let the user select a Program.
                    using (ThreadSafeForm<SelectComplexForm> frmPickComplexForm
                           = await ThreadSafeForm<SelectComplexForm>.GetAsync(
                               () => new SelectComplexForm(CharacterObject), GenericToken).ConfigureAwait(false))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickComplexForm.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickComplexForm.MyForm.AddAgain;

                        objXmlComplexForm = objXmlDocument.TryGetNodeByNameOrId("/chummer/complexforms/complexform", frmPickComplexForm.MyForm.SelectedComplexForm);
                    }

                    if (objXmlComplexForm == null)
                        continue;
                    ComplexForm objComplexForm = new ComplexForm(CharacterObject);
                    try
                    {
                        await objComplexForm.CreateAsync(objXmlComplexForm, token: GenericToken).ConfigureAwait(false);
                        if (objComplexForm.InternalId.IsEmptyGuid())
                        {
                            await objComplexForm.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            continue;
                        }

                        await CharacterObject.ComplexForms.AddAsync(objComplexForm, GenericToken).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objComplexForm.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }

                    if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(GlobalSettings.CultureInfo,
                                                                            await LanguageManager.GetStringAsync(
                                                                                    "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                                                                .ConfigureAwait(false),
                                                                            await objComplexForm
                                                                                .GetCurrentDisplayNameShortAsync(GenericToken)
                                                                                .ConfigureAwait(false),
                                                                            intComplexFormKarmaCost.ToString(
                                                                                GlobalSettings.CultureInfo)), token: GenericToken)
                                              .ConfigureAwait(false))
                    {
                        await objComplexForm.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                        continue;
                    }

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(intComplexFormKarmaCost * -1,
                                      await LanguageManager.GetStringAsync("String_ExpenseLearnComplexForm", token: GenericToken)
                                                           .ConfigureAwait(false)
                                      + await LanguageManager.GetStringAsync("String_Space", token: GenericToken).ConfigureAwait(false)
                                      + await objComplexForm.GetCurrentDisplayNameShortAsync(GenericToken)
                                                            .ConfigureAwait(false), ExpenseType.Karma, DateTime.Now);
                    await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                         .ConfigureAwait(false);
                    await CharacterObject.ModifyKarmaAsync(-intComplexFormKarmaCost, GenericToken)
                                         .ConfigureAwait(false);

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.AddComplexForm, objComplexForm.InternalId);
                    objExpense.Undo = objUndo;
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddArmor_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickArmor(token: GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteArmor_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteCustomDrug_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddBioware_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickCyberware(null, Improvement.ImprovementSource.Bioware, GenericToken)
                        .ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task<bool> PickWeapon(object destObject, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>
                               .GetAsync(() => new SelectWeapon(CharacterObject),
                                   token).ConfigureAwait(false))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickWeapon.ShowDialogSafeAsync(this, token).ConfigureAwait(false) ==
                            DialogResult.Cancel)
                            return false;

                        // Open the Weapons XML file and locate the selected piece.
                        XmlDocument objXmlDocument
                            = await CharacterObject.LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false);

                        XmlNode objXmlWeapon = objXmlDocument.TryGetNodeByNameOrId("/chummer/weapons/weapon",
                            frmPickWeapon.MyForm.SelectedWeapon);

                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        Weapon objWeapon = new Weapon(CharacterObject);
                        try
                        {
                            await objWeapon.CreateAsync(objXmlWeapon, lstWeapons, token: token).ConfigureAwait(false);
                            objWeapon.DiscountCost = frmPickWeapon.MyForm.BlackMarketDiscount;

                            // Check the item's Cost and make sure the character can afford it.
                            if (!frmPickWeapon.MyForm.FreeCost)
                            {
                                decimal decCost = await objWeapon.GetTotalCostAsync(token).ConfigureAwait(false);
                                // Apply a markup if applicable.
                                if (frmPickWeapon.MyForm.Markup != 0)
                                {
                                    decCost *= 1 + frmPickWeapon.MyForm.Markup / 100.0m;
                                }

                                // Multiply the cost if applicable.
                                char chrAvail = (await objWeapon.TotalAvailTupleAsync(token: token).ConfigureAwait(false))
                                    .Suffix;
                                switch (chrAvail)
                                {
                                    case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                        decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                        break;

                                    case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                        decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                        break;
                                }

                                if (decCost > await CharacterObject.GetNuyenAsync(token).ConfigureAwait(false))
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: token)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen", token: token)
                                            .ConfigureAwait(false), MessageBoxButtons.OK,
                                        MessageBoxIcon.Information, token: token).ConfigureAwait(false);
                                    return frmPickWeapon.MyForm.AddAgain;
                                }

                                // Create the Expense Log Entry.
                                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                objExpense.Create(decCost * -1,
                                    await LanguageManager.GetStringAsync("String_ExpensePurchaseWeapon", token: token)
                                        .ConfigureAwait(false)
                                    + await LanguageManager.GetStringAsync("String_Space", token: token)
                                        .ConfigureAwait(false)
                                    + await objWeapon.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                    ExpenseType.Nuyen,
                                    DateTime.Now);
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: token)
                                    .ConfigureAwait(false);
                                await CharacterObject.ModifyNuyenAsync(-decCost, token).ConfigureAwait(false);

                                ExpenseUndo objUndo = new ExpenseUndo();
                                objUndo.CreateNuyen(NuyenExpenseType.AddWeapon, objWeapon.InternalId);
                                objExpense.Undo = objUndo;
                            }

                            if (destObject is Location objLocation)
                            {
                                objWeapon.Location = objLocation;
                                foreach (Weapon objExtraWeapon in lstWeapons)
                                {
                                    objExtraWeapon.Location = objLocation;
                                }
                            }

                            foreach (Weapon objExtraWeapon in lstWeapons)
                            {
                                await CharacterObject.Weapons.AddAsync(objExtraWeapon, token).ConfigureAwait(false);
                            }

                            await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);

                            return frmPickWeapon.MyForm.AddAgain;
                        }
                        catch
                        {
                            foreach (Weapon objLoopWeapon in lstWeapons)
                                await objLoopWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                            await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async void cmdAddWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickWeapon(string.Empty, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddLifestyle_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        Lifestyle objLifestyle = new Lifestyle(CharacterObject);
                        try
                        {
                            await objLifestyle.SetStyleTypeAsync(LifestyleType.Standard, GenericToken).ConfigureAwait(false);
                            using (ThreadSafeForm<SelectLifestyle> frmPickLifestyle
                                   = await ThreadSafeForm<SelectLifestyle>.GetAsync(
                                           () => new SelectLifestyle(
                                               CharacterObject, objLifestyle),
                                           GenericToken)
                                       .ConfigureAwait(false))
                            {
                                // Make sure the dialogue window was not canceled.
                                if (await frmPickLifestyle.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                {
                                    //And if it was, remove Improvements that was already added based on the lifestyle
                                    await objLifestyle.RemoveAsync(false, GenericToken).ConfigureAwait(false);
                                    return;
                                }

                                blnAddAgain = frmPickLifestyle.MyForm.AddAgain;

                                Lifestyle objNewLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;

                                await CharacterObject.Lifestyles.AddAsync(objNewLifestyle, GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }
                        catch
                        {
                            await objLifestyle.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteLifestyle_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickGear(
                        null,
                        await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag as Location, GenericToken)
                                     .ConfigureAwait(false), token: GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteGear_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task<bool> AddVehicle(Location objLocation = null, CancellationToken token = default)
        {
            using (ThreadSafeForm<SelectVehicle> frmPickVehicle = await ThreadSafeForm<SelectVehicle>
                                                                        .GetAsync(
                                                                            () => new SelectVehicle(CharacterObject),
                                                                            token).ConfigureAwait(false))
            {
                // Make sure the dialogue window was not canceled.
                if (await frmPickVehicle.ShowDialogSafeAsync(this, token).ConfigureAwait(false) == DialogResult.Cancel)
                    return false;

                // Open the Vehicles XML file and locate the selected piece.
                XmlDocument objXmlDocument
                    = await CharacterObject.LoadDataAsync("vehicles.xml", token: token).ConfigureAwait(false);

                XmlNode objXmlVehicle = objXmlDocument.TryGetNodeByNameOrId("/chummer/vehicles/vehicle", frmPickVehicle.MyForm.SelectedVehicle);
                Vehicle objVehicle = new Vehicle(CharacterObject);
                try
                {
                    await objVehicle.CreateAsync(objXmlVehicle, token: token).ConfigureAwait(false);
                    // Update the Used Vehicle information if applicable.
                    if (frmPickVehicle.MyForm.UsedVehicle)
                    {
                        objVehicle.Avail = frmPickVehicle.MyForm.UsedAvail;
                        objVehicle.Cost = frmPickVehicle.MyForm.UsedCost.ToString(GlobalSettings.InvariantCultureInfo);
                    }

                    objVehicle.DiscountCost = frmPickVehicle.MyForm.BlackMarketDiscount;

                    // Check the item's Cost and make sure the character can afford it.
                    if (!frmPickVehicle.MyForm.FreeCost)
                    {
                        decimal decCost = await objVehicle.GetTotalCostAsync(token).ConfigureAwait(false);
                        // Apply a markup if applicable.
                        if (frmPickVehicle.MyForm.Markup != 0)
                        {
                            decCost *= 1 + frmPickVehicle.MyForm.Markup / 100.0m;
                        }

                        // Multiply the cost if applicable.
                        char chrAvail = (await objVehicle.TotalAvailTupleAsync(token: token).ConfigureAwait(false)).Suffix;
                        switch (chrAvail)
                        {
                            case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                break;

                            case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                break;
                        }

                        if (decCost > await CharacterObject.GetNuyenAsync(token).ConfigureAwait(false))
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: token)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen", token: token)
                                    .ConfigureAwait(false), MessageBoxButtons.OK,
                                MessageBoxIcon.Information, token: token).ConfigureAwait(false);
                            return frmPickVehicle.MyForm.AddAgain;
                        }

                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(decCost * -1,
                                          await LanguageManager
                                                .GetStringAsync("String_ExpensePurchaseVehicle", token: token)
                                                .ConfigureAwait(false)
                                          + await LanguageManager.GetStringAsync("String_Space", token: token)
                                                                 .ConfigureAwait(false)
                                          + await objVehicle.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                          ExpenseType.Nuyen,
                                          DateTime.Now);
                        await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: token)
                                             .ConfigureAwait(false);
                        await CharacterObject.ModifyNuyenAsync(-decCost, token).ConfigureAwait(false);

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateNuyen(NuyenExpenseType.AddVehicle, objVehicle.InternalId);
                        objExpense.Undo = objUndo;
                    }

                    objVehicle.DiscountCost = frmPickVehicle.MyForm.BlackMarketDiscount;

                    //objVehicle.Location = objLocation;
                    if (objLocation != null)
                        await objLocation.Children.AddAsync(objVehicle, token).ConfigureAwait(false);
                    await CharacterObject.Vehicles.AddAsync(objVehicle, token).ConfigureAwait(false);

                    return frmPickVehicle.MyForm.AddAgain;
                }
                catch
                {
                    await objVehicle.DeleteVehicleAsync(CancellationToken.None).ConfigureAwait(false);
                    throw;
                }
            }
        }

        private async void cmdAddVehicle_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddVehicle(
                        await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                         .ConfigureAwait(false) as Location,
                        GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteVehicle_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddMartialArt_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    await MartialArt.Purchase(CharacterObject, GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdDeleteMartialArt_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddMugshot_Click(object sender, EventArgs e)
        {
            try
            {
                if (!await AddMugshot(GenericToken).ConfigureAwait(false))
                    return;

                int intMugshotCount =
                    await (await CharacterObject.GetMugshotsAsync(GenericToken).ConfigureAwait(false)).GetCountAsync(GenericToken).ConfigureAwait(false);
                string strText = await LanguageManager.GetStringAsync("String_Of", token: GenericToken).ConfigureAwait(false)
                                 + intMugshotCount.ToString(GlobalSettings.CultureInfo);
                await lblNumMugshots.DoThreadSafeAsync(x => x.Text = strText, GenericToken).ConfigureAwait(false);
                await nudMugshotIndex.DoThreadSafeAsync(x =>
                {
                    ++x.Maximum;
                    x.Value = intMugshotCount;
                }, GenericToken).ConfigureAwait(false);
                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteMugshot_Click(object sender, EventArgs e)
        {
            try
            {
                int intMugshotCount =
                    await (await CharacterObject.GetMugshotsAsync(GenericToken).ConfigureAwait(false)).GetCountAsync(GenericToken).ConfigureAwait(false);
                if (intMugshotCount == 0)
                    return;
                await RemoveMugshot(await nudMugshotIndex.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken).ConfigureAwait(false) - 1, GenericToken).ConfigureAwait(false);
                --intMugshotCount;
                string strText = await LanguageManager.GetStringAsync("String_Of", token: GenericToken).ConfigureAwait(false)
                                 + intMugshotCount.ToString(GlobalSettings.CultureInfo);
                await lblNumMugshots.DoThreadSafeAsync(x => x.Text = strText, GenericToken).ConfigureAwait(false);
                (bool blnDoExtra, int intMugshotIndex) = await nudMugshotIndex.DoThreadSafeFuncAsync(x =>
                {
                    --x.Maximum;
                    if (x.Value <= x.Maximum)
                    {
                        return new ValueTuple<bool, int>(true, x.ValueAsInt);
                    }

                    x.Value = x.Maximum;
                    return new ValueTuple<bool, int>(false, x.ValueAsInt);
                }, GenericToken).ConfigureAwait(false);
                if (blnDoExtra)
                {
                    int intMainMugshotIndex = await CharacterObject.GetMainMugshotIndexAsync(GenericToken).ConfigureAwait(false);
                    await chkIsMainMugshot.DoThreadSafeAsync(y =>
                    {
                        if (intMugshotIndex - 1 == intMainMugshotIndex)
                            y.Checked = true;
                        else if (y.Checked)
                            y.Checked = false;
                    }, GenericToken).ConfigureAwait(false);

                    await UpdateMugshot(picMugshot, intMugshotIndex - 1, GenericToken).ConfigureAwait(false);
                }
                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudMugshotIndex_ValueChanged(object sender, EventArgs e)
        {
            try
            {
                if (await (await CharacterObject.GetMugshotsAsync(GenericToken).ConfigureAwait(false)).GetCountAsync(GenericToken).ConfigureAwait(false) == 0)
                {
                    await nudMugshotIndex.DoThreadSafeAsync(x =>
                    {
                        x.Minimum = 0;
                        x.Maximum = 0;
                        x.Value = 0;
                    }, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await nudMugshotIndex.DoThreadSafeAsync(x =>
                    {
                        x.Minimum = 1;
                        if (x.Value < x.Minimum)
                            x.Value = x.Maximum;
                        else if (x.Value > x.Maximum)
                            x.Value = x.Minimum;
                    }, GenericToken).ConfigureAwait(false);
                }

                int intMainMugshotIndex = await CharacterObject.GetMainMugshotIndexAsync(GenericToken).ConfigureAwait(false);
                int intCurrentMugshotIndex =
                    await nudMugshotIndex.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken).ConfigureAwait(false);
                if (intCurrentMugshotIndex - 1 == intMainMugshotIndex)
                    await chkIsMainMugshot.DoThreadSafeAsync(x => x.Checked = true, GenericToken).ConfigureAwait(false);
                else
                {
                    await chkIsMainMugshot.DoThreadSafeAsync(x =>
                    {
                        if (x.Checked)
                            x.Checked = false;
                    }, GenericToken).ConfigureAwait(false);
                }

                await UpdateMugshot(picMugshot, intCurrentMugshotIndex - 1, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkIsMainMugshot_CheckedChanged(object sender, EventArgs e)
        {
            bool blnStatusChanged = false;
            try
            {
                int intSelectedIndex = await nudMugshotIndex.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                            .ConfigureAwait(false);
                switch (await chkIsMainMugshot.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                              .ConfigureAwait(false))
                {
                    case true when CharacterObject.MainMugshotIndex != intSelectedIndex - 1:
                        CharacterObject.MainMugshotIndex = intSelectedIndex - 1;
                        blnStatusChanged = true;
                        break;

                    case false when intSelectedIndex - 1 == CharacterObject.MainMugshotIndex:
                        CharacterObject.MainMugshotIndex = -1;
                        blnStatusChanged = true;
                        break;
                }

                if (blnStatusChanged)
                {
                    await SetDirty(true).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddMetamagic_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker =
                        await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        if (await CharacterObject.GetMAGEnabledAsync(GenericToken).ConfigureAwait(false))
                        {
                            // Make sure that the Initiate Grade is not attempting to go above the character's MAG CharacterAttribute.
                            int intGrade = await CharacterObject.GetInitiateGradeAsync(GenericToken).ConfigureAwait(false);
                            if (intGrade + 1 >
                                await (await CharacterObject.GetAttributeAsync("MAG", token: GenericToken)
                                    .ConfigureAwait(false)).GetTotalValueAsync(GenericToken).ConfigureAwait(false) ||
                                await CharacterObjectSettings.GetMysAdeptSecondMAGAttributeAsync(GenericToken)
                                    .ConfigureAwait(false) &&
                                await CharacterObject.GetIsMysticAdeptAsync(GenericToken).ConfigureAwait(false) &&
                                intGrade + 1 >
                                await (await CharacterObject.GetAttributeAsync("MAGAdept", token: GenericToken)
                                    .ConfigureAwait(false)).GetTotalValueAsync(GenericToken).ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager
                                        .GetStringAsync("Message_CannotIncreaseInitiateGrade", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync("MessageTitle_CannotIncreaseInitiateGrade",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                return;
                            }

                            // Make sure the character has enough Karma.
                            decimal decMultiplier = 1.0m;
                            if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false))
                                decMultiplier -= await CharacterObjectSettings.GetKarmaMAGInitiationGroupPercentAsync(GenericToken).ConfigureAwait(false);
                            if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false))
                                decMultiplier -= await CharacterObjectSettings.GetKarmaMAGInitiationOrdealPercentAsync(GenericToken).ConfigureAwait(false);
                            if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false))
                                decMultiplier -= await CharacterObjectSettings.GetKarmaMAGInitiationSchoolingPercentAsync(GenericToken).ConfigureAwait(false);

                            int intKarmaExpense
                                = ((await CharacterObjectSettings.GetKarmaInitiationFlatAsync(GenericToken).ConfigureAwait(false) + (intGrade + 1)
                                    * await CharacterObjectSettings.GetKarmaInitiationAsync(GenericToken).ConfigureAwait(false)) * decMultiplier).StandardRound();

                            if (intKarmaExpense >
                                await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                return;
                            }

                            if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false))
                            {
                                if (await CharacterObject.GetNuyenAsync(GenericToken).ConfigureAwait(false) < 10000)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_NotEnoughNuyen",
                                                token: GenericToken)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen",
                                                token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                    return;
                                }

                                if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(
                                                GlobalSettings.CultureInfo,
                                                await LanguageManager.GetStringAsync(
                                                        "Message_ConfirmKarmaandNuyenExpense",
                                                        token: GenericToken)
                                                    .ConfigureAwait(false),
                                                await LanguageManager.GetStringAsync(
                                                        "String_InitiateGrade",
                                                        token: GenericToken)
                                                    .ConfigureAwait(false),
                                                (intGrade + 1)
                                                .ToString(GlobalSettings.CultureInfo),
                                                intKarmaExpense.ToString(
                                                    GlobalSettings.CultureInfo),
                                                10000.ToString(
                                                    await CharacterObjectSettings.GetNuyenFormatAsync(GenericToken).ConfigureAwait(false),
                                                    GlobalSettings.CultureInfo)
                                                + await LanguageManager
                                                    .GetStringAsync(
                                                        "String_NuyenSymbol",
                                                        token: GenericToken)
                                                    .ConfigureAwait(false)),
                                            token: GenericToken)
                                        .ConfigureAwait(false))
                                    return;
                            }
                            else if (!await CommonFunctions.ConfirmKarmaExpenseAsync(
                                         string.Format(GlobalSettings.CultureInfo,
                                             await LanguageManager
                                                 .GetStringAsync("Message_ConfirmKarmaExpense", token: GenericToken)
                                                 .ConfigureAwait(false),
                                             await LanguageManager
                                                 .GetStringAsync("String_InitiateGrade", token: GenericToken)
                                                 .ConfigureAwait(false),
                                             (intGrade + 1).ToString(GlobalSettings.CultureInfo),
                                             intKarmaExpense.ToString(GlobalSettings.CultureInfo)),
                                         token: GenericToken).ConfigureAwait(false))
                                return;

                            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                .ConfigureAwait(false);

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(intKarmaExpense * -1,
                                await LanguageManager.GetStringAsync("String_ExpenseInitiateGrade", token: GenericToken)
                                    .ConfigureAwait(false)
                                + strSpace + intGrade.ToString(GlobalSettings.CultureInfo)
                                + strSpace + "->" + strSpace
                                + (intGrade + 1).ToString(GlobalSettings.CultureInfo),
                                ExpenseType.Karma, DateTime.Now);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                .ConfigureAwait(false);
                            await CharacterObject.ModifyKarmaAsync(-intKarmaExpense, GenericToken)
                                .ConfigureAwait(false);

                            // Create the Initiate Grade object.
                            InitiationGrade objGrade = new InitiationGrade(CharacterObject);
                            await objGrade.CreateAsync(intGrade + 1, false,
                                await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false),
                                await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false),
                                await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                            await CharacterObject.InitiationGrades.AddWithSortAsync(objGrade, token: GenericToken)
                                .ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateKarma(KarmaExpenseType.ImproveInitiateGrade, objGrade.InternalId);
                            objExpense.Undo = objUndo;

                            if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false))
                            {
                                ExpenseLogEntry objNuyenExpense = new ExpenseLogEntry(CharacterObject);
                                objNuyenExpense.Create(
                                    -10000, await LanguageManager
                                                .GetStringAsync("String_ExpenseInitiateGrade", token: GenericToken)
                                                .ConfigureAwait(false)
                                            + strSpace + intGrade.ToString(GlobalSettings.CultureInfo)
                                            + strSpace + "->" + strSpace
                                            + (intGrade + 1).ToString(GlobalSettings.CultureInfo),
                                    ExpenseType.Nuyen, DateTime.Now);
                                await CharacterObject.ExpenseEntries
                                    .AddWithSortAsync(objNuyenExpense, token: GenericToken)
                                    .ConfigureAwait(false);
                                await CharacterObject.ModifyNuyenAsync(-10000, GenericToken).ConfigureAwait(false);

                                ExpenseUndo objNuyenUndo = new ExpenseUndo();
                                objNuyenUndo.CreateNuyen(NuyenExpenseType.ImproveInitiateGrade, objGrade.InternalId,
                                    10000);
                                objNuyenExpense.Undo = objNuyenUndo;
                            }

                            int intAmount
                                = ((await CharacterObjectSettings.GetKarmaInitiationFlatAsync(GenericToken).ConfigureAwait(false) + (intGrade + 1)
                                    * await CharacterObjectSettings.GetKarmaInitiationAsync(GenericToken).ConfigureAwait(false)) * decMultiplier).StandardRound();

                            string strInitTip = string.Format(GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Tip_ImproveInitiateGrade", token: GenericToken)
                                    .ConfigureAwait(false),
                                (intGrade + 1).ToString(
                                    GlobalSettings.CultureInfo),
                                intAmount.ToString(GlobalSettings.CultureInfo));
                            await cmdAddMetamagic.SetToolTipTextAsync(strInitTip, GenericToken).ConfigureAwait(false);
                        }
                        else if (await CharacterObject.GetRESEnabledAsync(GenericToken).ConfigureAwait(false))
                        {
                            int intGrade = await CharacterObject.GetSubmersionGradeAsync(GenericToken).ConfigureAwait(false);
                            // Make sure that the Initiate Grade is not attempting to go above the character's RES CharacterAttribute.
                            if (intGrade + 1
                                > await (await CharacterObject.GetAttributeAsync("RES", token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken).ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager.GetStringAsync("Message_CannotIncreaseSubmersionGrade",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync("MessageTitle_CannotIncreaseSubmersionGrade",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                return;
                            }

                            // Make sure the character has enough Karma.
                            decimal decMultiplier = 1.0m;
                            if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false))
                                decMultiplier -= await CharacterObjectSettings.GetKarmaRESInitiationGroupPercentAsync(GenericToken).ConfigureAwait(false);
                            if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false))
                                decMultiplier -= await CharacterObjectSettings.GetKarmaRESInitiationOrdealPercentAsync(GenericToken).ConfigureAwait(false);
                            if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false))
                                decMultiplier -= await CharacterObjectSettings.GetKarmaRESInitiationSchoolingPercentAsync(GenericToken).ConfigureAwait(false);

                            int intKarmaExpense
                                = ((await CharacterObjectSettings.GetKarmaInitiationFlatAsync(GenericToken).ConfigureAwait(false) + (intGrade + 1)
                                    * await CharacterObjectSettings.GetKarmaInitiationAsync(GenericToken).ConfigureAwait(false)) * decMultiplier).StandardRound();

                            if (intKarmaExpense >
                                await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                return;
                            }

                            if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(
                                            GlobalSettings.CultureInfo,
                                            await LanguageManager.GetStringAsync(
                                                    "Message_ConfirmKarmaExpense",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync(
                                                    "String_SubmersionGrade",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            (intGrade + 1)
                                            .ToString(GlobalSettings.CultureInfo),
                                            intKarmaExpense.ToString(
                                                GlobalSettings.CultureInfo)),
                                        token: GenericToken)
                                    .ConfigureAwait(false))
                                return;

                            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                .ConfigureAwait(false);

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(intKarmaExpense * -1,
                                await LanguageManager
                                    .GetStringAsync("String_ExpenseSubmersionGrade", token: GenericToken)
                                    .ConfigureAwait(false)
                                + strSpace + intGrade.ToString(GlobalSettings.CultureInfo)
                                + strSpace + "->" + strSpace
                                + (intGrade + 1).ToString(GlobalSettings.CultureInfo),
                                ExpenseType.Karma, DateTime.Now);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                .ConfigureAwait(false);
                            await CharacterObject.ModifyKarmaAsync(-intKarmaExpense, GenericToken)
                                .ConfigureAwait(false);

                            // Create the Initiate Grade object.
                            InitiationGrade objGrade = new InitiationGrade(CharacterObject);
                            await objGrade.CreateAsync(intGrade + 1, true,
                                await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false),
                                await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false),
                                await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                            await CharacterObject.InitiationGrades.AddWithSortAsync(objGrade, token: GenericToken)
                                .ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateKarma(KarmaExpenseType.ImproveInitiateGrade, objGrade.InternalId);
                            objExpense.Undo = objUndo;

                            int intAmount
                                = ((await CharacterObjectSettings.GetKarmaInitiationFlatAsync(GenericToken).ConfigureAwait(false) + (intGrade + 1)
                                    * await CharacterObjectSettings.GetKarmaInitiationAsync(GenericToken).ConfigureAwait(false)) * decMultiplier).StandardRound();

                            string strInitTip = string.Format(GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Tip_ImproveSubmersionGrade", token: GenericToken)
                                    .ConfigureAwait(false),
                                (intGrade + 1).ToString(
                                    GlobalSettings.CultureInfo),
                                intAmount.ToString(GlobalSettings.CultureInfo));
                            await cmdAddMetamagic.SetToolTipTextAsync(strInitTip, GenericToken).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteMetamagic_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdKarmaGained_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    string strText = await LanguageManager
                        .GetStringAsync("String_WorkingForThePeople", token: GenericToken)
                        .ConfigureAwait(false);
                    IAsyncDisposable objLocker =
                        await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken)
                            .ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        using (ThreadSafeForm<CreateExpense> frmNewExpense = await ThreadSafeForm<CreateExpense>
                                   .GetAsync(
                                       () => new CreateExpense(CharacterObjectSettings)
                                       {
                                           KarmaNuyenExchangeString = strText
                                       }, GenericToken).ConfigureAwait(false))
                        {
                            if (await frmNewExpense.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                return;

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(frmNewExpense.MyForm.Amount, frmNewExpense.MyForm.Reason,
                                ExpenseType.Karma,
                                frmNewExpense.MyForm.SelectedDate, frmNewExpense.MyForm.Refund);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                .ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateKarma(KarmaExpenseType.ManualAdd, string.Empty);
                            objExpense.Undo = objUndo;

                            // Adjust the character's Karma total.
                            await CharacterObject.ModifyKarmaAsync(frmNewExpense.MyForm.Amount.ToInt32(), GenericToken)
                                .ConfigureAwait(false);

                            if (frmNewExpense.MyForm.KarmaNuyenExchange)
                            {
                                // Create the Expense Log Entry.
                                objExpense = new ExpenseLogEntry(CharacterObject);
                                objExpense.Create(-frmNewExpense.MyForm.Amount * await CharacterObjectSettings.GetNuyenPerBPWftPAsync(GenericToken).ConfigureAwait(false),
                                    frmNewExpense.MyForm.Reason, ExpenseType.Nuyen,
                                    frmNewExpense.MyForm.SelectedDate);
                                objExpense.ForceCareerVisible = frmNewExpense.MyForm.ForceCareerVisible;
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                    .ConfigureAwait(false);

                                objUndo = new ExpenseUndo();
                                objUndo.CreateNuyen(NuyenExpenseType.ManualSubtract, string.Empty);
                                objExpense.Undo = objUndo;

                                // Adjust the character's Nuyen total.
                                await CharacterObject
                                    .ModifyNuyenAsync(
                                        -frmNewExpense.MyForm.Amount * await CharacterObjectSettings.GetNuyenPerBPWftMAsync(GenericToken).ConfigureAwait(false),
                                        GenericToken).ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdKarmaSpent_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    string strText = await LanguageManager
                        .GetStringAsync("String_WorkingForTheMan", token: GenericToken).ConfigureAwait(false);
                    IAsyncDisposable objLocker =
                        await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken)
                            .ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        using (ThreadSafeForm<CreateExpense> frmNewExpense = await ThreadSafeForm<CreateExpense>
                                   .GetAsync(
                                       () => new CreateExpense(CharacterObjectSettings)
                                       {
                                           KarmaNuyenExchangeString = strText
                                       }, GenericToken).ConfigureAwait(false))
                        {
                            if (await frmNewExpense.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                return;

                            // Make sure the Karma expense would not put the character's remaining Karma amount below 0.
                            if (await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false)
                                < frmNewExpense.MyForm.Amount)
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager
                                        .GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                return;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(frmNewExpense.MyForm.Amount * -1, frmNewExpense.MyForm.Reason,
                                ExpenseType.Karma,
                                frmNewExpense.MyForm.SelectedDate, frmNewExpense.MyForm.Refund);
                            objExpense.ForceCareerVisible = frmNewExpense.MyForm.ForceCareerVisible;
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                .ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateKarma(KarmaExpenseType.ManualSubtract, string.Empty);
                            objExpense.Undo = objUndo;

                            // Adjust the character's Karma total.
                            await CharacterObject.ModifyKarmaAsync(-frmNewExpense.MyForm.Amount.ToInt32(), GenericToken)
                                .ConfigureAwait(false);

                            if (frmNewExpense.MyForm.KarmaNuyenExchange)
                            {
                                // Create the Expense Log Entry.
                                objExpense = new ExpenseLogEntry(CharacterObject);
                                objExpense.Create(frmNewExpense.MyForm.Amount * await CharacterObjectSettings.GetNuyenPerBPWftMAsync(GenericToken).ConfigureAwait(false),
                                    frmNewExpense.MyForm.Reason, ExpenseType.Nuyen,
                                    frmNewExpense.MyForm.SelectedDate);
                                objExpense.ForceCareerVisible = frmNewExpense.MyForm.ForceCareerVisible;
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                    .ConfigureAwait(false);

                                objUndo = new ExpenseUndo();
                                objUndo.CreateNuyen(NuyenExpenseType.ManualSubtract, string.Empty);
                                objExpense.Undo = objUndo;

                                // Adjust the character's Nuyen total.
                                await CharacterObject
                                    .ModifyNuyenAsync(
                                        frmNewExpense.MyForm.Amount * await CharacterObjectSettings.GetNuyenPerBPWftMAsync(GenericToken).ConfigureAwait(false),
                                        GenericToken).ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdNuyenGained_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    string strText = await LanguageManager
                        .GetStringAsync("String_WorkingForTheMan", token: GenericToken).ConfigureAwait(false);
                    IAsyncDisposable objLocker =
                        await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        using (ThreadSafeForm<CreateExpense> frmNewExpense = await ThreadSafeForm<CreateExpense>
                                   .GetAsync(
                                       () => new CreateExpense(CharacterObjectSettings)
                                       {
                                           KarmaNuyenExchangeString = strText
                                       }, GenericToken).ConfigureAwait(false))
                        {
                            await frmNewExpense.MyForm.SetModeAsync(ExpenseType.Nuyen, GenericToken).ConfigureAwait(false);
                            if (await frmNewExpense.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                return;

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(frmNewExpense.MyForm.Amount, frmNewExpense.MyForm.Reason,
                                ExpenseType.Nuyen,
                                frmNewExpense.MyForm.SelectedDate);
                            await objExpense.SetRefundAsync(frmNewExpense.MyForm.Refund, GenericToken).ConfigureAwait(false);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                .ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.ManualAdd, string.Empty);
                            objExpense.Undo = objUndo;

                            // Adjust the character's Nuyen total.
                            await CharacterObject.ModifyNuyenAsync(frmNewExpense.MyForm.Amount, GenericToken).ConfigureAwait(false);

                            if (frmNewExpense.MyForm.KarmaNuyenExchange)
                            {
                                // Create the Expense Log Entry.
                                objExpense = new ExpenseLogEntry(CharacterObject);
                                int intAmount = (frmNewExpense.MyForm.Amount / await CharacterObjectSettings.GetNuyenPerBPWftMAsync(GenericToken).ConfigureAwait(false))
                                    .ToInt32();
                                objExpense.Create(-intAmount, frmNewExpense.MyForm.Reason, ExpenseType.Karma,
                                    frmNewExpense.MyForm.SelectedDate, frmNewExpense.MyForm.Refund);
                                objExpense.ForceCareerVisible = frmNewExpense.MyForm.ForceCareerVisible;
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                    .ConfigureAwait(false);

                                objUndo = new ExpenseUndo();
                                objUndo.CreateKarma(KarmaExpenseType.ManualSubtract, string.Empty);
                                objExpense.Undo = objUndo;

                                // Adjust the character's Karma total.
                                await CharacterObject.ModifyKarmaAsync(-intAmount, GenericToken).ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdNuyenSpent_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    string strText = await LanguageManager
                        .GetStringAsync("String_WorkingForThePeople", token: GenericToken)
                        .ConfigureAwait(false);
                    IAsyncDisposable objLocker =
                        await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        using (ThreadSafeForm<CreateExpense> frmNewExpense = await ThreadSafeForm<CreateExpense>
                                   .GetAsync(
                                       () => new CreateExpense(CharacterObjectSettings)
                                       {
                                           KarmaNuyenExchangeString = strText
                                       }, GenericToken).ConfigureAwait(false))
                        {
                            await frmNewExpense.MyForm.SetModeAsync(ExpenseType.Nuyen, GenericToken).ConfigureAwait(false);
                            if (await frmNewExpense.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                return;

                            // Make sure the Nuyen expense would not put the character's remaining Nuyen amount below 0.
                            if (await CharacterObject.GetNuyenAsync(GenericToken).ConfigureAwait(false) < frmNewExpense.MyForm.Amount)
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager
                                        .GetStringAsync("MessageTitle_NotEnoughNuyen", token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                return;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(frmNewExpense.MyForm.Amount * -1, frmNewExpense.MyForm.Reason,
                                ExpenseType.Nuyen,
                                frmNewExpense.MyForm.SelectedDate);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                .ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.ManualSubtract, string.Empty);
                            objExpense.Undo = objUndo;

                            // Adjust the character's Nuyen total.
                            await CharacterObject.ModifyNuyenAsync(-frmNewExpense.MyForm.Amount, GenericToken).ConfigureAwait(false);

                            if (frmNewExpense.MyForm.KarmaNuyenExchange)
                            {
                                // Create the Expense Log Entry.
                                objExpense = new ExpenseLogEntry(CharacterObject);
                                int intAmount = (frmNewExpense.MyForm.Amount / await CharacterObjectSettings.GetNuyenPerBPWftPAsync(GenericToken).ConfigureAwait(false))
                                    .ToInt32();
                                objExpense.Create(intAmount, frmNewExpense.MyForm.Reason, ExpenseType.Karma,
                                    frmNewExpense.MyForm.SelectedDate, frmNewExpense.MyForm.Refund);
                                objExpense.ForceCareerVisible = frmNewExpense.MyForm.ForceCareerVisible;
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                    .ConfigureAwait(false);

                                objUndo = new ExpenseUndo();
                                objUndo.CreateKarma(KarmaExpenseType.ManualSubtract, string.Empty);
                                objExpense.Undo = objUndo;

                                // Adjust the character's Karma total.
                                await CharacterObject.ModifyKarmaAsync(intAmount, GenericToken).ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdDecreaseLifestyleMonths_Click(object sender, EventArgs e)
        {
            try
            {
                // Locate the selected Lifestyle.
                if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                         .ConfigureAwait(false) is Lifestyle objLifestyle))
                    return;

                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(
                    0,
                    await LanguageManager.GetStringAsync("String_ExpenseDecreaseLifestyle", token: GenericToken)
                                         .ConfigureAwait(false)
                    + await LanguageManager.GetStringAsync("String_Space", token: GenericToken).ConfigureAwait(false)
                    + await objLifestyle.GetCurrentDisplayNameShortAsync(GenericToken).ConfigureAwait(false),
                    ExpenseType.Nuyen, DateTime.Now);
                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken).ConfigureAwait(false);

                await objLifestyle.ModifyIncrementsAsync(-1, GenericToken).ConfigureAwait(false);

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdIncreaseLifestyleMonths_Click(object sender, EventArgs e)
        {
            try
            {
                // Locate the selected Lifestyle.
                if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                         .ConfigureAwait(false) is Lifestyle objLifestyle))
                    return;

                await objLifestyle.BuyExtraMonth(GenericToken).ConfigureAwait(false);

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdAddCritterPower_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure the Critter is allowed to have Optional Powers.
                XmlDocument objXmlDocument = await CharacterObject
                                                   .LoadDataAsync("critterpowers.xml", token: GenericToken)
                                                   .ConfigureAwait(false);

                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectCritterPower> frmPickCritterPower
                           = await ThreadSafeForm<SelectCritterPower>
                                   .GetAsync(() => new SelectCritterPower(CharacterObject), GenericToken)
                                   .ConfigureAwait(false))
                    {
                        if (await frmPickCritterPower.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickCritterPower.MyForm.AddAgain;

                        XmlNode objXmlPower = objXmlDocument.TryGetNodeByNameOrId("/chummer/powers/power", frmPickCritterPower.MyForm.SelectedPower);
                        CritterPower objPower = new CritterPower(CharacterObject);
                        await objPower.CreateAsync(objXmlPower, frmPickCritterPower.MyForm.SelectedRating, token: GenericToken).ConfigureAwait(false);
                        objPower.PowerPoints = frmPickCritterPower.MyForm.PowerPoints;
                        if (objPower.InternalId.IsEmptyGuid())
                            continue;

                        if (objPower.Karma > await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false))
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                    .ConfigureAwait(false), MessageBoxButtons.OK,
                                MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            continue;
                        }

                        if (!await CommonFunctions.ConfirmKarmaExpenseAsync(
                                                      string.Format(GlobalSettings.CultureInfo,
                                                                    await LanguageManager
                                                                          .GetStringAsync(
                                                                              "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                                                          .ConfigureAwait(false),
                                                                    await objPower
                                                                            .GetCurrentDisplayNameAsync(GenericToken)
                                                                            .ConfigureAwait(false),
                                                                    objPower.Karma.ToString(GlobalSettings.CultureInfo)), token: GenericToken)
                                                  .ConfigureAwait(false))
                            continue;

                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(objPower.Karma * -1,
                                          await LanguageManager.GetStringAsync("String_ExpensePurchaseCritterPower", token: GenericToken)
                                                               .ConfigureAwait(false)
                                          + await LanguageManager.GetStringAsync("String_Space", token: GenericToken).ConfigureAwait(false)
                                          + await objPower.GetCurrentDisplayNameShortAsync(GenericToken)
                                                          .ConfigureAwait(false),
                                          ExpenseType.Karma,
                                          DateTime.Now);
                        await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                             .ConfigureAwait(false);

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateKarma(KarmaExpenseType.AddCritterPower, objPower.InternalId);
                        objExpense.Undo = objUndo;

                        await CharacterObject.ModifyKarmaAsync(-objPower.Karma, GenericToken).ConfigureAwait(false);
                        await CharacterObject.CritterPowers.AddAsync(objPower, GenericToken).ConfigureAwait(false);
                    }
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdDeleteCritterPower_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteComplexForm_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdGearReduceQty_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Gear objGear))
                    return;

                int intDecimalPlaces = 0;
                if (objGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
                {
                    intDecimalPlaces = await CharacterObjectSettings.GetMaxNuyenDecimalsAsync(GenericToken).ConfigureAwait(false);
                }
                else if (objGear.Category == "Currency")
                {
                    intDecimalPlaces = 2;
                }

                decimal decSelectedValue;
                string strDescription = await LanguageManager.GetStringAsync("String_ReduceGear", token: GenericToken)
                                                             .ConfigureAwait(false);
                using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                           () => new SelectNumber(intDecimalPlaces)
                           {
                               Minimum = 0,
                               Maximum = objGear.Quantity,
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickNumber.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    decSelectedValue = frmPickNumber.MyForm.SelectedValue;
                }

                if (objGear.Quantity > decSelectedValue)
                {
                    if (!await CommonFunctions.ConfirmDeleteAsync(string.Format(GlobalSettings.CultureInfo,
                                                                            await LanguageManager.GetStringAsync(
                                                                                    "Message_ReduceQty",
                                                                                    token: GenericToken)
                                                                                .ConfigureAwait(false),
                                                                            decSelectedValue.ToString(
                                                                                GlobalSettings.CultureInfo)), GenericToken)
                                          .ConfigureAwait(false))
                        return;
                    await objGear.SetQuantityAsync(objGear.Quantity - decSelectedValue, GenericToken).ConfigureAwait(false);
                    string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                    await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                 .ConfigureAwait(false);
                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await RemoveSelectedObject(objGear, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdGearSplitQty_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Gear objSelectedGear))
                    return;

                decimal decMinimumAmount = 1.0m;
                int intDecimalPlaces = 0;
                if (objSelectedGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
                {
                    intDecimalPlaces = Math.Max(0, await CharacterObjectSettings.GetMaxNuyenDecimalsAsync(GenericToken).ConfigureAwait(false));
                    // Need a for loop instead of a power system to maintain exact precision
                    for (int i = 0; i < intDecimalPlaces; ++i)
                        decMinimumAmount /= 10.0m;
                }
                else if (objSelectedGear.Category == "Currency")
                {
                    intDecimalPlaces = 2;
                    decMinimumAmount = 0.01m;
                }

                // Cannot split a stack of 1 item.
                if (objSelectedGear.Quantity <= decMinimumAmount)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_CannotSplitGear", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotSplitGear", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Error, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription = await LanguageManager.GetStringAsync("String_SplitGear", token: GenericToken)
                                                             .ConfigureAwait(false);
                using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                           () => new SelectNumber(intDecimalPlaces)
                           {
                               Minimum = decMinimumAmount,
                               Maximum = objSelectedGear.Quantity - decMinimumAmount,
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickNumber.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    // Create a new piece of Gear.
                    Gear objGear = new Gear(CharacterObject);

                    await objGear.CopyAsync(objSelectedGear, GenericToken).ConfigureAwait(false);

                    await objGear.SetQuantityAsync(frmPickNumber.MyForm.SelectedValue, GenericToken).ConfigureAwait(false);
                    await objGear.SetEquippedAsync(objSelectedGear.Equipped, GenericToken).ConfigureAwait(false);
                    objGear.Location = objSelectedGear.Location;
                    await objGear.SetNotesAsync(await objSelectedGear.GetNotesAsync(GenericToken), GenericToken).ConfigureAwait(false);

                    // Update the selected item.
                    await objSelectedGear.SetQuantityAsync(objSelectedGear.Quantity - objGear.Quantity, GenericToken).ConfigureAwait(false);
                    string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                    await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                 .ConfigureAwait(false);

                    await CharacterObject.Gear.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdGearMergeQty_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Gear objGear))
                    return;
                List<Gear> lstGear = new List<Gear>(await CharacterObject.Gear.GetCountAsync(GenericToken).ConfigureAwait(false));

                await CharacterObject.Gear.ForEachAsync(objCharacterGear =>
                {
                    if (objCharacterGear.InternalId != objGear.InternalId
                        && objCharacterGear.IsIdenticalToOtherGear(objGear, true))
                        lstGear.Add(objCharacterGear);
                }, GenericToken).ConfigureAwait(false);

                // If there were no matches, don't try to merge anything.
                if (lstGear.Count == 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_CannotMergeGear", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotMergeGear", token: GenericToken)
                            .ConfigureAwait(false), MessageBoxButtons.OK, MessageBoxIcon.Error, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                Gear objSelectedGear;
                // Show the Select Item window.
                using (ThreadSafeForm<SelectItem> frmPickItem = await ThreadSafeForm<SelectItem>
                                                                      .GetAsync(() => new SelectItem(), GenericToken)
                                                                      .ConfigureAwait(false))
                {
                    frmPickItem.MyForm.SetGearMode(lstGear);

                    if (await frmPickItem.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objSelectedGear = await CharacterObject.Gear.DeepFindByIdAsync(await frmPickItem.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }

                decimal decMinimumAmount = 1.0m;
                int intDecimalPlaces = 0;
                if (objSelectedGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
                {
                    intDecimalPlaces = Math.Max(0, await CharacterObjectSettings.GetMaxNuyenDecimalsAsync(GenericToken).ConfigureAwait(false));
                    // Need a for loop instead of a power system to maintain exact precision
                    for (int i = 0; i < intDecimalPlaces; ++i)
                        decMinimumAmount /= 10.0m;
                }
                else if (objSelectedGear.Category == "Currency")
                {
                    intDecimalPlaces = 2;
                    decMinimumAmount = 0.01m;
                }

                string strDescription = await LanguageManager.GetStringAsync("String_MergeGear", token: GenericToken)
                                                             .ConfigureAwait(false);
                using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                           () => new SelectNumber(intDecimalPlaces)
                           {
                               Minimum = decMinimumAmount,
                               Maximum = objGear.Quantity,
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickNumber.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    // Increase the quantity for the selected item.
                    await objSelectedGear.SetQuantityAsync(objSelectedGear.Quantity + frmPickNumber.MyForm.SelectedValue, GenericToken).ConfigureAwait(false);
                    string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                    await treGear.DoThreadSafeAsync(x =>
                    {
                        // Located the item in the Tree and update its display information.
                        TreeNode objNode = x.FindNode(objSelectedGear.InternalId);
                        if (objNode != null)
                            objNode.Text = strText;
                    }, GenericToken).ConfigureAwait(false);

                    // Reduce the quantity for the selected item.
                    await objGear.SetQuantityAsync(objGear.Quantity - frmPickNumber.MyForm.SelectedValue, GenericToken).ConfigureAwait(false);
                }

                // If the quantity has reached 0, delete the item and any Weapons it created.
                if (objGear.Quantity <= 0)
                {
                    // Remove the Gear if its quantity has been reduced to 0.
                    await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                }
                else
                {
                    string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                    await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                 .ConfigureAwait(false);
                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdGearMoveToVehicle_Click(object sender, EventArgs e)
        {
            try
            {
                Vehicle objVehicle;
                using (ThreadSafeForm<SelectItem> frmPickItem = await ThreadSafeForm<SelectItem>
                                                                      .GetAsync(() => new SelectItem(), GenericToken)
                                                                      .ConfigureAwait(false))
                {
                    frmPickItem.MyForm.SetVehiclesMode(CharacterObject.Vehicles);

                    if (await frmPickItem.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    // Locate the selected Vehicle.
                    string strItem = await frmPickItem.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, GenericToken).ConfigureAwait(false);
                    objVehicle = await CharacterObject.Vehicles
                                                      .FirstOrDefaultAsync(x => x.InternalId == strItem, GenericToken)
                                                      .ConfigureAwait(false);
                }

                if (objVehicle == null)
                    return;

                TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Gear objSelectedGear))
                    return;

                decimal decMinimumAmount = 1.0m;
                int intDecimalPlaces = 0;
                if (objSelectedGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
                {
                    intDecimalPlaces = Math.Max(0, await CharacterObjectSettings.GetMaxNuyenDecimalsAsync(GenericToken).ConfigureAwait(false));
                    // Need a for loop instead of a power system to maintain exact precision
                    for (int i = 0; i < intDecimalPlaces; ++i)
                        decMinimumAmount /= 10.0m;
                }
                else if (objSelectedGear.Category == "Currency")
                {
                    intDecimalPlaces = 2;
                    decMinimumAmount = 0.01m;
                }

                decimal decMove;
                if (objSelectedGear.Quantity == decMinimumAmount)
                    decMove = decMinimumAmount;
                else
                {
                    string strDescription
                        = await LanguageManager.GetStringAsync("String_MoveGear", token: GenericToken).ConfigureAwait(false);
                    using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                               () => new SelectNumber(intDecimalPlaces)
                               {
                                   Minimum = decMinimumAmount,
                                   Maximum = objSelectedGear.Quantity,
                                   Description = strDescription
                               }, GenericToken).ConfigureAwait(false))
                    {
                        if (await frmPickNumber.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        decMove = frmPickNumber.MyForm.SelectedValue;
                    }
                }

                // See if the Vehicle already has a matching piece of Gear.
                Gear objFoundGear
                    = objVehicle.GearChildren.FirstOrDefault(x => x.IsIdenticalToOtherGear(objSelectedGear));

                if (objFoundGear == null)
                {
                    // Create a new piece of Gear.
                    Gear objGear = new Gear(CharacterObject);

                    await objGear.CopyAsync(objSelectedGear, GenericToken).ConfigureAwait(false);

                    await objGear.SetQuantityAsync(decMove, GenericToken).ConfigureAwait(false);
                    objGear.Location = null;
                    await objGear.SetParentAsync(objVehicle, GenericToken).ConfigureAwait(false);
                    await objVehicle.GearChildren.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    // Everything matches up, so just increase the quantity.
                    await objFoundGear.SetQuantityAsync(objFoundGear.Quantity + decMove, GenericToken).ConfigureAwait(false);
                    string strText = await objFoundGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                    await treVehicles.DoThreadSafeAsync(x =>
                    {
                        TreeNode objFoundNode = x.FindNode(objFoundGear.InternalId);
                        if (objFoundNode != null)
                            objFoundNode.Text = strText;
                    }, GenericToken).ConfigureAwait(false);
                }

                // Update the selected item.
                await objSelectedGear.SetQuantityAsync(objSelectedGear.Quantity - decMove, GenericToken).ConfigureAwait(false);
                if (objSelectedGear.Quantity <= 0)
                {
                    await objSelectedGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                }
                else
                {
                    string strText = await objSelectedGear.GetCurrentDisplayNameAsync(GenericToken)
                                                          .ConfigureAwait(false);
                    await treVehicles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                     .ConfigureAwait(false);
                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdVehicleMoveToInventory_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false);
                if (objSelectedNode == null)
                    return;
                switch (objSelectedNode.Tag)
                {
                    // Locate the selected Weapon.
                    case Weapon objWeapon:
                    {
                        (_ , Vehicle objVehicle, WeaponMount objMount, VehicleMod objMod) = await CharacterObject.Vehicles.FindVehicleWeaponAsync(objWeapon.InternalId, GenericToken).ConfigureAwait(false);
                        // Move the Weapons from the Vehicle Mod (or Vehicle) to the character.
                        Weapon objParent = objWeapon.Parent;
                        if (objParent != null)
                            await objParent.Children.RemoveAsync(objWeapon, GenericToken).ConfigureAwait(false);
                        else if (objMount != null)
                            await objMount.Weapons.RemoveAsync(objWeapon, GenericToken).ConfigureAwait(false);
                        else if (objMod != null)
                            await objMod.Weapons.RemoveAsync(objWeapon, GenericToken).ConfigureAwait(false);
                        else
                            await objVehicle.Weapons.RemoveAsync(objWeapon, GenericToken).ConfigureAwait(false);

                        await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);

                        await objWeapon.SetParentVehicleAsync(null, GenericToken).ConfigureAwait(false);

                        List<Gear> lstGearToMove = new List<Gear>(objWeapon.Clips.Count);
                        foreach (Clip objClip in objWeapon.Clips)
                        {
                            if (objClip.AmmoGear != null)
                            {
                                lstGearToMove.Add(objClip.AmmoGear);
                            }
                        }

                        foreach (Clip objClip in (await objWeapon.Children.GetAllDescendantsAsync(x => x.Children, GenericToken).ConfigureAwait(false))
                                 .SelectMany(x => x.Clips))
                        {
                            if (objClip.AmmoGear != null)
                            {
                                lstGearToMove.Add(objClip.AmmoGear);
                            }
                        }

                        foreach (Gear objGear in lstGearToMove)
                        {
                            switch (objGear.Parent)
                            {
                                case IHasGear objHasChildren:
                                    await objHasChildren.GearChildren.RemoveAsync(objGear, GenericToken).ConfigureAwait(false);
                                    break;

                                case IHasChildren<Gear> objHasChildren:
                                    await objHasChildren.Children.RemoveAsync(objGear, GenericToken).ConfigureAwait(false);
                                    break;

                                default:
                                    continue;
                            }

                            await CharacterObject.Gear.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                        }

                        break;
                    }
                    case Gear objSelectedGear:
                    {
                        decimal decMinimumAmount = 1.0m;
                        int intDecimalPlaces = 0;
                        if (objSelectedGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
                        {
                            intDecimalPlaces = Math.Max(0, await CharacterObjectSettings.GetMaxNuyenDecimalsAsync(GenericToken).ConfigureAwait(false));
                            // Need a for loop instead of a power system to maintain exact precision
                            for (int i = 0; i < intDecimalPlaces; ++i)
                                decMinimumAmount /= 10.0m;
                        }
                        else if (objSelectedGear.Category == "Currency")
                        {
                            intDecimalPlaces = 2;
                            decMinimumAmount = 0.01m;
                        }

                        decimal decMove;
                        if (objSelectedGear.Quantity == decMinimumAmount)
                            decMove = decMinimumAmount;
                        else
                        {
                            string strDescription = await LanguageManager.GetStringAsync("String_MoveGear", token: GenericToken)
                                                                         .ConfigureAwait(false);
                            using (ThreadSafeForm<SelectNumber> frmPickNumber
                                   = await ThreadSafeForm<SelectNumber>.GetAsync(
                                       () => new SelectNumber(intDecimalPlaces)
                                       {
                                           Minimum = decMinimumAmount,
                                           Maximum = objSelectedGear.Quantity,
                                           Description = strDescription
                                       }, GenericToken).ConfigureAwait(false))
                            {
                                if (await frmPickNumber.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    return;

                                decMove = frmPickNumber.MyForm.SelectedValue;
                            }
                        }

                        // See if the character already has a matching piece of Gear.
                        Gear objFoundGear
                            = CharacterObject.Gear.FirstOrDefault(x => objSelectedGear.IsIdenticalToOtherGear(x));

                        if (objFoundGear == null)
                        {
                            // Create a new piece of Gear.
                            Gear objGear = new Gear(CharacterObject);

                            await objGear.CopyAsync(objSelectedGear, GenericToken).ConfigureAwait(false);

                            await objGear.SetQuantityAsync(decMove, GenericToken).ConfigureAwait(false);

                            await CharacterObject.Gear.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                            await objGear.AddGearImprovements(GenericToken).ConfigureAwait(false);
                        }
                        else
                        {
                            // Everything matches up, so just increase the quantity.
                            await objFoundGear.SetQuantityAsync(objFoundGear.Quantity + decMove, GenericToken).ConfigureAwait(false);
                            string strText = await objFoundGear.GetCurrentDisplayNameAsync(token: GenericToken)
                                                               .ConfigureAwait(false);
                            await treGear.DoThreadSafeAsync(x =>
                            {
                                TreeNode objFoundNode = x.FindNode(objFoundGear.InternalId);
                                if (objFoundNode != null)
                                    objFoundNode.Text = strText;
                            }, GenericToken).ConfigureAwait(false);
                        }

                        // Update the selected item.
                        await objSelectedGear.SetQuantityAsync(objSelectedGear.Quantity - decMove, GenericToken).ConfigureAwait(false);
                        if (objSelectedGear.Quantity <= 0)
                        {
                            await objSelectedGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                        }
                        else
                        {
                            string strText = await objSelectedGear.GetCurrentDisplayNameAsync(token: GenericToken)
                                                                  .ConfigureAwait(false);
                            await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken).ConfigureAwait(false);
                            await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                        }

                        break;
                    }
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdGearIncreaseQty_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is Gear objGear))
                    return;
                bool blnAddAgain;
                do
                {
                    // Select the root Gear node then open the Select Gear window.
                    blnAddAgain = await PickGear(objGear.Parent as IHasChildren<Gear>, objGear.Location, objGear,
                                                 await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                                              .ConfigureAwait(false), token: GenericToken)
                        .ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdVehicleGearReduceQty_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Gear objGear))
                    return;
                int intDecimalPlaces = 0;
                if (objGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
                {
                    intDecimalPlaces = Math.Max(0, await CharacterObjectSettings.GetMaxNuyenDecimalsAsync(GenericToken).ConfigureAwait(false));
                }
                else if (objGear.Category == "Currency")
                {
                    intDecimalPlaces = 2;
                }

                decimal decSelectedValue;
                string strDescription = await LanguageManager.GetStringAsync("String_ReduceGear", token: GenericToken)
                                                             .ConfigureAwait(false);
                using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                           () => new SelectNumber(intDecimalPlaces)
                           {
                               Minimum = 0,
                               Maximum = objGear.Quantity,
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickNumber.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    decSelectedValue = frmPickNumber.MyForm.SelectedValue;
                }

                if (!await CommonFunctions
                           .ConfirmDeleteAsync(string.Format(GlobalSettings.CultureInfo,
                                                             await LanguageManager
                                                                   .GetStringAsync(
                                                                       "Message_ReduceQty", token: GenericToken)
                                                                   .ConfigureAwait(false),
                                                             decSelectedValue.ToString(GlobalSettings.CultureInfo)), token: GenericToken)
                           .ConfigureAwait(false))
                    return;

                await objGear.SetQuantityAsync(objGear.Quantity - decSelectedValue, GenericToken).ConfigureAwait(false);

                if (objGear.Quantity > 0)
                {
                    string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                    await treVehicles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                     .ConfigureAwait(false);
                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                else
                {
                    // Remove the Gear if its quantity has been reduced to 0.
                    await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdAddQuality_Click(object sender, EventArgs e)
        {
            try
            {
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("qualities.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                bool blnAddAgain;
                do
                {
                    bool blnFreeCost;
                    XmlNode objXmlQuality;
                    int intRatingToAdd;
                    using (ThreadSafeForm<SelectQuality> frmPickQuality = await ThreadSafeForm<SelectQuality>
                               .GetAsync(() => new SelectQuality(CharacterObject), GenericToken).ConfigureAwait(false))
                    {
                        // Don't do anything else if the form was canceled.
                        if (await frmPickQuality.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickQuality.MyForm.AddAgain;
                        blnFreeCost = frmPickQuality.MyForm.FreeCost;

                        objXmlQuality = objXmlDocument.TryGetNodeByNameOrId("/chummer/qualities/quality", frmPickQuality.MyForm.SelectedQuality);
                        intRatingToAdd = frmPickQuality.MyForm.SelectedRating;
                        int intDummy = 0;
                        if (objXmlQuality != null && objXmlQuality["nolevels"] == null
                                                  && objXmlQuality.TryGetInt32FieldQuickly("limit", ref intDummy))
                        {
                            string strQuality = frmPickQuality.MyForm.SelectedQuality;
                            intRatingToAdd -= await (await CharacterObject.GetQualitiesAsync(GenericToken).ConfigureAwait(false))
                                .CountAsync(async x =>
                                    (await x.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false))
                                        .Equals(strQuality, StringComparison.OrdinalIgnoreCase)
                                    && string.IsNullOrEmpty(await x.GetSourceNameAsync(GenericToken).ConfigureAwait(false)), GenericToken).ConfigureAwait(false);
                        }
                    }

                    if (objXmlQuality == null)
                        continue;

                    QualityType eQualityType = QualityType.Positive;
                    string strTemp = string.Empty;
                    if (objXmlQuality.TryGetStringFieldQuickly("category", ref strTemp))
                        eQualityType = Quality.ConvertToQualityType(strTemp);

                    // Helps to capture a write lock here for performance purposes
                    IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken)
                                                                      .ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        for (int i = 1; i <= intRatingToAdd; ++i)
                        {
                            // Positive Metagenetic Qualities are free if you're a Changeling.
                            if (CharacterObject.MetagenicLimit > 0
                                && objXmlQuality["metagenic"]?.InnerTextIsTrueString() == true)
                                blnFreeCost = true;
                            // The Beast's Way and the Spiritual Way get the Mentor Spirit for free.
                            else if (objXmlQuality["name"]?.InnerTextViaPool(GenericToken) == "Mentor Spirit" &&
                                     await CharacterObject.Qualities.AnyAsync(x =>
                                                                                  x.Name == "The Beast's Way"
                                                                                  || x.Name == "The Spiritual Way",
                                                                              GenericToken).ConfigureAwait(false))
                                blnFreeCost = true;

                            int intQualityBP = 0;
                            if (!blnFreeCost)
                            {
                                objXmlQuality.TryGetInt32FieldQuickly("karma", ref intQualityBP);
                                XmlElement xmlDiscountNode = objXmlQuality["costdiscount"];
                                if (xmlDiscountNode != null && await xmlDiscountNode.CreateNavigator().RequirementsMetAsync(CharacterObject, token: GenericToken).ConfigureAwait(false))
                                {
                                    int intTemp = 0;
                                    xmlDiscountNode.TryGetInt32FieldQuickly("value", ref intTemp);
                                    switch (eQualityType)
                                    {
                                        case QualityType.Positive:
                                            intQualityBP += intTemp;
                                            break;

                                        case QualityType.Negative:
                                            intQualityBP -= intTemp;
                                            break;
                                    }
                                }
                            }

                            int intKarmaCost = intQualityBP * await CharacterObjectSettings.GetKarmaQualityAsync(GenericToken).ConfigureAwait(false);
                            if (!await CharacterObjectSettings.GetDontDoubleQualityPurchasesAsync(GenericToken).ConfigureAwait(false) &&
                                objXmlQuality["doublecareer"]?.InnerTextViaPool(GenericToken) != bool.FalseString)
                                intKarmaCost *= 2;

                            // Make sure the character has enough Karma to pay for the Quality.
                            if (eQualityType == QualityType.Positive)
                            {
                                if (!blnFreeCost)
                                {
                                    if (intKarmaCost > await CharacterObject.GetKarmaAsync(GenericToken)
                                                                            .ConfigureAwait(false) &&
                                        objXmlQuality["stagedpurchase"]?.InnerTextViaPool(GenericToken) != bool.TrueString)
                                    {
                                        await Program.ShowScrollableMessageBoxAsync(this,
                                            await LanguageManager
                                                .GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager
                                                .GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                                .ConfigureAwait(false), MessageBoxButtons.OK,
                                            MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        break;
                                    }

                                    string strDisplayName = objXmlQuality["translate"]?.InnerTextViaPool(GenericToken) ??
                                                            objXmlQuality["name"]?.InnerTextViaPool(GenericToken) ??
                                                            await LanguageManager.GetStringAsync("String_Unknown", token: GenericToken)
                                                                .ConfigureAwait(false);
                                    if (!await CommonFunctions.ConfirmKarmaExpenseAsync(
                                                                  string.Format(GlobalSettings.CultureInfo,
                                                                      await LanguageManager
                                                                            .GetStringAsync(
                                                                                "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                                                            .ConfigureAwait(false), strDisplayName,
                                                                      intKarmaCost.ToString(GlobalSettings
                                                                          .CultureInfo)), token: GenericToken)
                                                              .ConfigureAwait(false))
                                        break;
                                }
                            }
                            else if (await Program.ShowScrollableMessageBoxAsync(this,
                                         await LanguageManager
                                             .GetStringAsync("Message_AddNegativeQuality", token: GenericToken)
                                             .ConfigureAwait(false),
                                         await LanguageManager
                                             .GetStringAsync("MessageTitle_AddNegativeQuality", token: GenericToken)
                                             .ConfigureAwait(false), MessageBoxButtons.YesNo,
                                         MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                                break;

                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            Quality objQuality = new Quality(CharacterObject);
                            try
                            {
                                await objQuality.CreateAsync(objXmlQuality, QualitySource.Selected, lstWeapons, token: GenericToken).ConfigureAwait(false);
                                if (objQuality.InternalId.IsEmptyGuid())
                                {
                                    await objQuality.DeleteQualityAsync(token: GenericToken).ConfigureAwait(false);
                                    break;
                                }

                                // Make sure the character has enough Karma to pay for the Quality.
                                if (await objQuality.GetTypeAsync(GenericToken).ConfigureAwait(false) == QualityType.Positive)
                                {
                                    if (await objQuality.GetContributeToBPAsync(GenericToken).ConfigureAwait(false))
                                    {
                                        // Create the Karma expense.
                                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                        objExpense.Create(intKarmaCost * -1,
                                                          await LanguageManager
                                                                .GetStringAsync(
                                                                    "String_ExpenseAddPositiveQuality",
                                                                    token: GenericToken)
                                                                .ConfigureAwait(false) +
                                                          await LanguageManager
                                                                .GetStringAsync("String_Space", token: GenericToken)
                                                                .ConfigureAwait(false) +
                                                          await objQuality.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                          .ConfigureAwait(false), ExpenseType.Karma,
                                                          DateTime.Now);
                                        await CharacterObject.ExpenseEntries
                                                             .AddWithSortAsync(objExpense, token: GenericToken)
                                                             .ConfigureAwait(false);
                                        await CharacterObject.ModifyKarmaAsync(-intKarmaCost, GenericToken)
                                                             .ConfigureAwait(false);

                                        ExpenseUndo objUndo = new ExpenseUndo();
                                        objUndo.CreateKarma(KarmaExpenseType.AddQuality, objQuality.InternalId);
                                        objExpense.Undo = objUndo;
                                    }
                                }
                                else
                                {
                                    // Create a Karma Expense for the Negative Quality.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(0,
                                                      await LanguageManager
                                                            .GetStringAsync("String_ExpenseAddNegativeQuality",
                                                                            token: GenericToken).ConfigureAwait(false) +
                                                      await LanguageManager
                                                            .GetStringAsync("String_Space", token: GenericToken)
                                                            .ConfigureAwait(false) +
                                                      await objQuality.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                      .ConfigureAwait(false), ExpenseType.Karma,
                                                      DateTime.Now);
                                    await CharacterObject
                                          .ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                          .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateKarma(KarmaExpenseType.AddQuality, objQuality.InternalId);
                                    objExpense.Undo = objUndo;
                                }

                                await CharacterObject.Qualities.AddAsync(objQuality, GenericToken).ConfigureAwait(false);

                                // Add any created Weapons to the character.
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                                }
                            }
                            catch
                            {
                                await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdDeleteQuality_Click(object sender, EventArgs e)
        {
            try
            {
                await DoDeleteQuality(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async Task DoDeleteQuality(CancellationToken token = default)
        {
            // Locate the selected Quality.
            if (!(await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                    Quality objSelectedQuality))
                return;
            string strInternalIDToRemove = objSelectedQuality.InternalId;
            // Can't do a foreach because we're removing items, this is the next best thing
            Quality objQualityToRemove =
                CharacterObject.Qualities.LastOrDefault(x => x.InternalId == strInternalIDToRemove);
            await RemoveQuality(objQualityToRemove, token: token).ConfigureAwait(false);
        }

        private async void cmdSwapQuality_Click(object sender, EventArgs e)
        {
            try
            {
                // Locate the selected Quality.
                Quality objQuality = await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                                       .ConfigureAwait(false) as Quality;
                if (objQuality?.InternalId.IsEmptyGuid() != false)
                    return;

                switch (objQuality.OriginSource)
                {
                    // Qualities that come from a Metatype cannot be removed.
                    case QualitySource.Metatype:
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_MetavariantQualitySwap", token: GenericToken)
                                .ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_MetavariantQualitySwap", token: GenericToken)
                                .ConfigureAwait(false), MessageBoxButtons.OK,
                            MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                    // Neither can qualities from Improvements
                    case QualitySource.Improvement:
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            string.Format(GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_ImprovementQuality", token: GenericToken)
                                    .ConfigureAwait(false),
                                await objQuality.DisplaySourceNameAsync(GlobalSettings.Language, GenericToken)
                                    .ConfigureAwait(false)),
                            await LanguageManager.GetStringAsync("MessageTitle_MetavariantQuality", token: GenericToken)
                                .ConfigureAwait(false), MessageBoxButtons.OK,
                            MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                }

                XmlNode objXmlQuality;
                int intRatingToAdd;
                using (ThreadSafeForm<SelectQuality> frmPickQuality = await ThreadSafeForm<SelectQuality>.GetAsync(
                           () => new SelectQuality(CharacterObject)
                           {
                               ForceCategory = objQuality.Type.ToString(),
                               IgnoreQuality = objQuality.Name
                           }, GenericToken).ConfigureAwait(false))
                {
                    // Don't do anything else if the form was canceled.
                    if (await frmPickQuality.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objXmlQuality
                        = (await CharacterObject.LoadDataAsync("qualities.xml", token: GenericToken)
                                                .ConfigureAwait(false))
                        .TryGetNodeByNameOrId("/chummer/qualities/quality", frmPickQuality.MyForm.SelectedQuality);
                    intRatingToAdd = frmPickQuality.MyForm.SelectedRating;
                    int intDummy = 0;
                    if (objXmlQuality != null && objXmlQuality["nolevels"] == null
                                              && objXmlQuality.TryGetInt32FieldQuickly("limit", ref intDummy))
                    {
                        string strQuality = frmPickQuality.MyForm.SelectedQuality;
                        intRatingToAdd -= await (await CharacterObject.GetQualitiesAsync(GenericToken).ConfigureAwait(false))
                                .CountAsync(async x =>
                                    (await x.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false))
                                        .Equals(strQuality, StringComparison.OrdinalIgnoreCase)
                                    && string.IsNullOrEmpty(await x.GetSourceNameAsync(GenericToken).ConfigureAwait(false)), GenericToken).ConfigureAwait(false);
                    }
                }

                if (intRatingToAdd > 0)
                {
                    bool blnAdded;
                    Quality objNewQuality = new Quality(CharacterObject);
                    try
                    {
                        blnAdded = await objNewQuality.Swap(objQuality, objXmlQuality, intRatingToAdd, GenericToken)
                                                      .ConfigureAwait(false);
                    }
                    catch
                    {
                        await objNewQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }

                    if (!blnAdded)
                        await objNewQuality.DeleteQualityAsync(token: GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async Task<bool> RemoveQuality(Quality objSelectedQuality, bool blnConfirmDelete = true,
                                                    bool blnCompleteDelete = true, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await objSelectedQuality.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                XPathNavigator objXmlDeleteQuality
                    = await objSelectedQuality.GetNodeXPathAsync(token).ConfigureAwait(false);
                bool blnMetatypeQuality = false;

                switch (objSelectedQuality.OriginSource)
                {
                    // Qualities that come from a Metatype cannot be removed.
                    case QualitySource.Metatype:
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_MetavariantQuality", token: token)
                                .ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_MetavariantQuality", token: token)
                                .ConfigureAwait(false), MessageBoxButtons.OK,
                            MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return false;

                    case QualitySource.Improvement:
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            string.Format(GlobalSettings.CultureInfo,
                                await LanguageManager
                                    .GetStringAsync("Message_ImprovementQuality", token: token)
                                    .ConfigureAwait(false),
                                await objSelectedQuality.DisplaySourceNameAsync(GlobalSettings.Language, token)
                                    .ConfigureAwait(false)),
                            await LanguageManager.GetStringAsync("MessageTitle_MetavariantQuality", token: token)
                                .ConfigureAwait(false), MessageBoxButtons.OK,
                            MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return false;

                    case QualitySource.MetatypeRemovable:
                    {
                        // Look up the cost of the Quality.
                        int intBP = 0;
                        if (await objSelectedQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.Negative
                            || objXmlDeleteQuality?.SelectSingleNodeAndCacheExpression("refundkarmaonremove", token: token) != null)
                        {
                            int.TryParse(objXmlDeleteQuality?.SelectSingleNodeAndCacheExpression("karma", token: token)?.Value, NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out intBP);
                            intBP *= await CharacterObjectSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);
                            if (blnCompleteDelete)
                                intBP *= await objSelectedQuality.GetLevelsAsync(token).ConfigureAwait(false);
                            if (!await CharacterObjectSettings.GetDontDoubleQualityPurchasesAsync(token).ConfigureAwait(false) && objSelectedQuality.DoubleCost)
                            {
                                intBP *= 2;
                            }

                            if (objSelectedQuality.Type == QualityType.Positive)
                                intBP *= -1;
                        }

                        string strBP = intBP.ToString(GlobalSettings.CultureInfo)
                                       + await LanguageManager.GetStringAsync("String_Space", token: token)
                                           .ConfigureAwait(false) + await LanguageManager
                                           .GetStringAsync("String_Karma", token: token).ConfigureAwait(false);

                        if (blnConfirmDelete && !await CommonFunctions.ConfirmDeleteAsync(
                                string.Format(GlobalSettings.CultureInfo,
                                    await LanguageManager
                                        .GetStringAsync(
                                            blnCompleteDelete
                                                ? "Message_DeleteMetatypeQuality"
                                                : "Message_LowerMetatypeQualityLevel", token: token)
                                        .ConfigureAwait(false), strBP), token).ConfigureAwait(false))
                            return false;

                        blnMetatypeQuality = true;
                        break;
                    }
                }

                // Helps to capture a write lock here for performance purposes
                IAsyncDisposable objLocker2 = await CharacterObject.LockObject.EnterWriteLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    if (objSelectedQuality.Type == QualityType.Positive)
                    {
                        if (objXmlDeleteQuality?.SelectSingleNodeAndCacheExpression("refundkarmaonremove", token: token) != null)
                        {
                            int intKarmaCost = objSelectedQuality.BP * await CharacterObjectSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);

                            if (!await CharacterObjectSettings.GetDontDoubleQualityPurchasesAsync(token).ConfigureAwait(false) && objSelectedQuality.DoubleCost)
                            {
                                intKarmaCost *= 2;
                            }

                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(intKarmaCost, string.Format(GlobalSettings.CultureInfo,
                                    await LanguageManager
                                        .GetStringAsync(
                                            "String_ExpenseSwapPositiveQuality",
                                            token: token).ConfigureAwait(false),
                                    await objSelectedQuality
                                        .GetCurrentDisplayNameShortAsync(token)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync("String_Karma", token: token)
                                        .ConfigureAwait(false)),
                                ExpenseType.Karma, DateTime.Now, true);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: token)
                                .ConfigureAwait(false);
                            await CharacterObject.ModifyKarmaAsync(intKarmaCost, token).ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateKarma(KarmaExpenseType.RemoveQuality, objSelectedQuality.SourceIDString);
                            objUndo.Extra = objSelectedQuality.Extra;
                            objExpense.Undo = objUndo;
                        }
                        else if (!blnMetatypeQuality && blnConfirmDelete && !await CommonFunctions.ConfirmDeleteAsync(
                                     blnCompleteDelete
                                         ? await LanguageManager
                                             .GetStringAsync("Message_DeletePositiveQualityCareer", token: token)
                                             .ConfigureAwait(false)
                                         : await LanguageManager
                                             .GetStringAsync("Message_LowerPositiveQualityLevelCareer",
                                                 token: token)
                                             .ConfigureAwait(false), token).ConfigureAwait(false))
                            return false;
                    }
                    else
                    {
                        // Make sure the character has enough Karma to buy off the Quality.
                        int intKarmaCost = -(objSelectedQuality.BP * await CharacterObjectSettings.GetKarmaQualityAsync(token).ConfigureAwait(false));
                        if (!await CharacterObjectSettings.GetDontDoubleQualityRefundsAsync(token).ConfigureAwait(false))
                        {
                            intKarmaCost *= 2;
                        }

                        int intTotalKarmaCost = intKarmaCost;
                        if (blnCompleteDelete)
                            intTotalKarmaCost *= await objSelectedQuality.GetLevelsAsync(token).ConfigureAwait(false);
                        if (intTotalKarmaCost > await CharacterObject.GetKarmaAsync(token).ConfigureAwait(false))
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: token)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: token)
                                    .ConfigureAwait(false), MessageBoxButtons.OK,
                                MessageBoxIcon.Information, token: token).ConfigureAwait(false);
                            return false;
                        }

                        if (!blnMetatypeQuality && blnConfirmDelete && !await CommonFunctions.ConfirmKarmaExpenseAsync(
                                    string.Format(GlobalSettings.CultureInfo, blnCompleteDelete
                                            ? await LanguageManager
                                                .GetStringAsync(
                                                    "Message_ConfirmKarmaExpenseRemove", token: token)
                                                .ConfigureAwait(false)
                                            : await LanguageManager
                                                .GetStringAsync("Message_ConfirmKarmaExpenseLowerLevel",
                                                    token: token).ConfigureAwait(false),
                                        await objSelectedQuality.GetCurrentDisplayNameShortAsync(token)
                                            .ConfigureAwait(false), intTotalKarmaCost),
                                    token)
                                .ConfigureAwait(false))
                            return false;

                        // Create the Karma expense.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(-intTotalKarmaCost,
                            await LanguageManager
                                .GetStringAsync("String_ExpenseRemoveNegativeQuality", token: token)
                                .ConfigureAwait(false)
                            + await LanguageManager.GetStringAsync("String_Space", token: token)
                                .ConfigureAwait(false)
                            + await objSelectedQuality.GetCurrentDisplayNameShortAsync(token)
                                .ConfigureAwait(false), ExpenseType.Karma,
                            DateTime.Now);
                        await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: token)
                            .ConfigureAwait(false);
                        await CharacterObject.ModifyKarmaAsync(-intTotalKarmaCost, token).ConfigureAwait(false);

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateKarma(KarmaExpenseType.RemoveQuality, objSelectedQuality.SourceIDString);
                        objUndo.Extra = objSelectedQuality.Extra;
                        objExpense.Undo = objUndo;
                    }

                    // Remove any Critter Powers that are gained through the Quality (Infected).
                    if (objXmlDeleteQuality?.SelectSingleNodeAndCacheExpression("powers/power", token: token) != null)
                    {
                        foreach (XPathNavigator objXmlPower in (await CharacterObject
                                     .LoadDataXPathAsync(
                                         "critterpowers.xml", token: token)
                                     .ConfigureAwait(false))
                                 .SelectAndCacheExpression(
                                     "optionalpowers/optionalpower", token: token))
                        {
                            string strExtra = objXmlPower
                                .SelectSingleNodeAndCacheExpression("@select", token: token)?.Value ?? string.Empty;

                            CritterPower objRemovePower
                                = await CharacterObject.CritterPowers.FirstOrDefaultAsync(
                                        x => x.Name == objXmlPower.Value && x.Extra == strExtra,
                                        token)
                                    .ConfigureAwait(false);
                            if (objRemovePower != null)
                            {
                                // Remove any Improvements created by the Critter Power.
                                await ImprovementManager
                                    .RemoveImprovementsAsync(CharacterObject,
                                        Improvement.ImprovementSource.CritterPower,
                                        objRemovePower.InternalId, token).ConfigureAwait(false);

                                // Remove the Critter Power from the character.
                                await CharacterObject.CritterPowers.RemoveAsync(objRemovePower, token)
                                    .ConfigureAwait(false);
                            }
                        }
                    }

                    // Fix for legacy characters with old addqualities improvements.
                    if (objXmlDeleteQuality != null)
                        await RemoveAddedQualities(
                                objXmlDeleteQuality.SelectAndCacheExpression("addqualities/addquality", token), token)
                            .ConfigureAwait(false);
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            // Perform removal
            await objSelectedQuality.DeleteQualityAsync(blnCompleteDelete, token).ConfigureAwait(false);

            return true;
        }

        private async Task UpdateQualityLevelValue(Quality objSelectedQuality = null,
                                                        CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objSelectedQuality == null)
            {
                await nudQualityLevel.DoThreadSafeAsync(x =>
                {
                    Interlocked.Increment(ref _intSkipQualityLevelChanged);
                    try
                    {
                        x.Value = 1;
                        x.Enabled = false;
                    }
                    finally
                    {
                        Interlocked.Decrement(ref _intSkipQualityLevelChanged);
                    }
                }, token).ConfigureAwait(false);
                return;
            }

            IAsyncDisposable objLocker = await objSelectedQuality.LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await objSelectedQuality.GetOriginSourceAsync(token).ConfigureAwait(false) == QualitySource.Improvement
                    || await objSelectedQuality.GetOriginSourceAsync(token).ConfigureAwait(false) == QualitySource.Metatype
                    || await objSelectedQuality.GetLevelsAsync(token).ConfigureAwait(false) == 0)
                {
                    await nudQualityLevel.DoThreadSafeAsync(x =>
                    {
                        Interlocked.Increment(ref _intSkipQualityLevelChanged);
                        try
                        {
                            x.Value = 1;
                            x.Enabled = false;
                        }
                        finally
                        {
                            Interlocked.Decrement(ref _intSkipQualityLevelChanged);
                        }
                    }, token).ConfigureAwait(false);
                    return;
                }

                token.ThrowIfCancellationRequested();
                XPathNavigator objQualityNode = await objSelectedQuality.GetNodeXPathAsync(token).ConfigureAwait(false);
                string strLimitString = objQualityNode?.SelectSingleNodeAndCacheExpression("limit", token: token)?.Value ?? string.Empty;
                token.ThrowIfCancellationRequested();
                if (!string.IsNullOrWhiteSpace(strLimitString)
                    && objQualityNode.SelectSingleNodeAndCacheExpression("nolevels", token: token) == null
                    && int.TryParse(strLimitString, out int intMaxRating))
                {
                    int intLevels = await objSelectedQuality.GetLevelsAsync(token).ConfigureAwait(false);
                    await nudQualityLevel.DoThreadSafeAsync(x =>
                    {
                        Interlocked.Increment(ref _intSkipQualityLevelChanged);
                        try
                        {
                            x.Maximum = intMaxRating;
                            x.Value = intLevels;
                            x.Enabled = true;
                        }
                        finally
                        {
                            Interlocked.Decrement(ref _intSkipQualityLevelChanged);
                        }
                    }, token).ConfigureAwait(false);
                }
                else
                {
                    await nudQualityLevel.DoThreadSafeAsync(x =>
                    {
                        Interlocked.Increment(ref _intSkipQualityLevelChanged);
                        try
                        {
                            x.Value = 1;
                            x.Enabled = false;
                        }
                        finally
                        {
                            Interlocked.Decrement(ref _intSkipQualityLevelChanged);
                        }
                    }, token).ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intSkipQualityLevelChanged;

        private async void nudQualityLevel_ValueChanged(object sender, EventArgs e)
        {
            if (_intSkipQualityLevelChanged > 0)
                return;
            try
            {
                // Locate the selected Quality.
                if (!(await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is Quality
                        objSelectedQuality))
                    return;

                bool blnDoRemoveQuality = false;
                IAsyncDisposable objLocker = await objSelectedQuality.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    int intCurrentLevels = await objSelectedQuality.GetLevelsAsync(GenericToken).ConfigureAwait(false);
                    int intSelectedLevels
                        = await nudQualityLevel.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                            .ConfigureAwait(false);

                    // Helps to capture a write lock here for performance purposes
                    IAsyncDisposable objLocker2 = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken)
                        .ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        // Adding a new level
                        for (; intSelectedLevels > intCurrentLevels; ++intCurrentLevels)
                        {
                            XPathNavigator objXmlSelectedQuality
                                = await objSelectedQuality.GetNodeXPathAsync(GenericToken).ConfigureAwait(false);
                            if (!await objXmlSelectedQuality.RequirementsMetAsync(CharacterObject,
                                    strLocalName: await LanguageManager.GetStringAsync(
                                            "String_Quality", token: GenericToken)
                                        .ConfigureAwait(false), token: GenericToken).ConfigureAwait(false))
                            {
                                await UpdateQualityLevelValue(objSelectedQuality, GenericToken).ConfigureAwait(false);
                                break;
                            }

                            bool blnFreeCost = await objSelectedQuality.GetBPAsync(GenericToken).ConfigureAwait(false) == 0 || !await objSelectedQuality.GetContributeToBPAsync(GenericToken).ConfigureAwait(false);

                            QualityType eQualityType = await objSelectedQuality.GetTypeAsync(GenericToken).ConfigureAwait(false);

                            int intQualityBP = 0;
                            if (!blnFreeCost)
                            {
                                objXmlSelectedQuality.TryGetInt32FieldQuickly("karma", ref intQualityBP);
                                XPathNavigator xpnDiscountNode
                                    = objXmlSelectedQuality
                                        .SelectSingleNodeAndCacheExpression("costdiscount", GenericToken);
                                if (xpnDiscountNode != null && await xpnDiscountNode
                                        .RequirementsMetAsync(CharacterObject, token: GenericToken)
                                        .ConfigureAwait(false))
                                {
                                    int intTemp = 0;
                                    xpnDiscountNode.TryGetInt32FieldQuickly("value", ref intTemp);
                                    switch (eQualityType)
                                    {
                                        case QualityType.Positive:
                                            intQualityBP += intTemp;
                                            break;

                                        case QualityType.Negative:
                                            intQualityBP -= intTemp;
                                            break;
                                    }
                                }
                            }

                            int intKarmaCost = intQualityBP * await CharacterObjectSettings.GetKarmaQualityAsync(GenericToken).ConfigureAwait(false);
                            if (!await CharacterObjectSettings.GetDontDoubleQualityPurchasesAsync(GenericToken).ConfigureAwait(false) && objSelectedQuality.DoubleCost)
                                intKarmaCost *= 2;

                            // Make sure the character has enough Karma to pay for the Quality.
                            if (eQualityType == QualityType.Positive)
                            {
                                if (!blnFreeCost)
                                {
                                    if (intKarmaCost
                                        > await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false)
                                        && !objSelectedQuality.StagedPurchase)
                                    {
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager
                                                .GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync(
                                                    "MessageTitle_NotEnoughKarma", token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK,
                                            MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        await UpdateQualityLevelValue(objSelectedQuality, GenericToken)
                                            .ConfigureAwait(false);
                                        break;
                                    }

                                    string strDisplayName
                                        = objXmlSelectedQuality
                                              .SelectSingleNodeAndCacheExpression("translate", GenericToken)
                                          ?.Value
                                          ?? objXmlSelectedQuality
                                              .SelectSingleNodeAndCacheExpression("name", GenericToken)
                                          ?.Value
                                          ?? await LanguageManager.GetStringAsync("String_Unknown", token: GenericToken)
                                              .ConfigureAwait(false);
                                    if (!await CommonFunctions.ConfirmKarmaExpenseAsync(
                                                string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync(
                                                            "Message_ConfirmKarmaExpenseSpend",
                                                            token: GenericToken)
                                                        .ConfigureAwait(false),
                                                    strDisplayName,
                                                    intKarmaCost.ToString(GlobalSettings.CultureInfo)),
                                                token: GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await UpdateQualityLevelValue(objSelectedQuality, GenericToken)
                                            .ConfigureAwait(false);
                                        break;
                                    }
                                }
                            }
                            else if (await Program.ShowScrollableMessageBoxAsync(
                                         this,
                                         await LanguageManager.GetStringAsync("Message_AddNegativeQuality",
                                                 token: GenericToken)
                                             .ConfigureAwait(false),
                                         await LanguageManager.GetStringAsync("MessageTitle_AddNegativeQuality",
                                                 token: GenericToken)
                                             .ConfigureAwait(false),
                                         MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                            {
                                await UpdateQualityLevelValue(objSelectedQuality, GenericToken).ConfigureAwait(false);
                                break;
                            }

                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            Quality objQuality = new Quality(CharacterObject);
                            try
                            {
                                await objQuality.CreateAsync(
                                    await objSelectedQuality.GetNodeAsync(GenericToken).ConfigureAwait(false),
                                    QualitySource.Selected,
                                    lstWeapons, objSelectedQuality.Extra, token: GenericToken).ConfigureAwait(false);
                                if (objQuality.InternalId.IsEmptyGuid())
                                {
                                    await objQuality.DeleteQualityAsync(token: GenericToken).ConfigureAwait(false);
                                    await UpdateQualityLevelValue(objSelectedQuality, GenericToken)
                                        .ConfigureAwait(false);
                                    break;
                                }

                                await objQuality.SetBPAsync(await objSelectedQuality.GetBPAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objQuality.SetContributeToLimitAsync(await objSelectedQuality.GetContributeToLimitAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                                // Make sure the character has enough Karma to pay for the Quality.
                                if (await objQuality.GetTypeAsync(GenericToken).ConfigureAwait(false) == QualityType.Positive)
                                {
                                    // Create the Karma expense.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(intKarmaCost * -1,
                                        await LanguageManager.GetStringAsync(
                                                "String_ExpenseAddPositiveQuality",
                                                token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await LanguageManager
                                            .GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objQuality.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Karma,
                                        DateTime.Now);
                                    await CharacterObject
                                        .ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                        .ConfigureAwait(false);
                                    await CharacterObject.ModifyKarmaAsync(-intKarmaCost, GenericToken)
                                        .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateKarma(KarmaExpenseType.AddQuality, objQuality.InternalId);
                                    objExpense.Undo = objUndo;
                                }
                                else
                                {
                                    // Create a Karma Expense for the Negative Quality.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(
                                        0,
                                        await LanguageManager.GetStringAsync("String_ExpenseAddNegativeQuality",
                                            token: GenericToken).ConfigureAwait(false)
                                        + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objQuality.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false),
                                        ExpenseType.Karma, DateTime.Now);
                                    await CharacterObject.ExpenseEntries
                                        .AddWithSortAsync(objExpense, token: GenericToken)
                                        .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateKarma(KarmaExpenseType.AddQuality, objQuality.InternalId);
                                    objExpense.Undo = objUndo;
                                }

                                // Add the Quality to the appropriate parent node.
                                //to avoid an System.InvalidOperationException: Cannot change ObservableCollection during a CollectionChanged event.
                                Interlocked.Increment(ref _intSkipQualityLevelChanged);
                                try
                                {
                                    await CharacterObject.Qualities.AddAsync(objQuality, GenericToken)
                                        .ConfigureAwait(false);
                                }
                                finally
                                {
                                    Interlocked.Decrement(ref _intSkipQualityLevelChanged);
                                }

                                // Add any created Weapons to the character.
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                                }
                            }
                            catch
                            {
                                await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }

                        // Removing a level
                        Guid guiSourceID = objSelectedQuality.SourceID;
                        string strExtra = await objSelectedQuality.GetExtraAsync(GenericToken).ConfigureAwait(false);
                        string strSourceName = await objSelectedQuality.GetSourceNameAsync(GenericToken).ConfigureAwait(false);
                        string strInternalId = objSelectedQuality.InternalId;
                        for (; intSelectedLevels < intCurrentLevels; --intCurrentLevels)
                        {
                            Quality objInvisibleQuality = await CharacterObject.Qualities.FirstOrDefaultAsync(
                                async x => x.SourceID == guiSourceID
                                     && await x.GetExtraAsync(GenericToken).ConfigureAwait(false) == strExtra
                                     && await x.GetSourceNameAsync(GenericToken).ConfigureAwait(false) == strSourceName
                                     && x.InternalId != strInternalId
                                     && !ReferenceEquals(x, objSelectedQuality), GenericToken).ConfigureAwait(false);
                            if (objInvisibleQuality == null
                                || !await RemoveQuality(objInvisibleQuality, false, false, GenericToken)
                                    .ConfigureAwait(false))
                            {
                                blnDoRemoveQuality = true;
                                break;
                            }
                        }
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                if (blnDoRemoveQuality && !await RemoveQuality(objSelectedQuality, false, false, GenericToken)
                        .ConfigureAwait(false))
                {
                    await UpdateQualityLevelValue(objSelectedQuality, GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdAddLocation_Click(object sender, EventArgs e)
        {
            try
            {
                string strDescription = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken)
                                                             .ConfigureAwait(false);
                // Add a new location to the Gear Tree.
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                        return;

                    Location objLocation = new Location(CharacterObject, CharacterObject.GearLocations,
                                                        frmPickText.MyForm.SelectedValue);
                    await CharacterObject.GearLocations.AddAsync(objLocation, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdAddWeaponLocation_Click(object sender, EventArgs e)
        {
            try
            {
                string strDescription = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken)
                                                             .ConfigureAwait(false);
                // Add a new location to the Gear Tree.
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                        return;

                    Location objLocation = new Location(CharacterObject, CharacterObject.WeaponLocations,
                                                        frmPickText.MyForm.SelectedValue);
                    await CharacterObject.WeaponLocations.AddAsync(objLocation, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdAddWeek_Click(object sender, EventArgs e)
        {
            try
            {
                CalendarWeek objWeek;
                ThreadSafeBindingList<CalendarWeek> lstCalendarWeeks = await CharacterObject.GetCalendarAsync(GenericToken).ConfigureAwait(false);
                CalendarWeek objLastWeek
                    = await lstCalendarWeeks.FirstOrDefaultAsync(GenericToken).ConfigureAwait(false);
                if (objLastWeek != null)
                {
                    objWeek = new CalendarWeek(await objLastWeek.GetYearAsync(GenericToken).ConfigureAwait(false), await objLastWeek.GetWeekAsync(GenericToken).ConfigureAwait(false) + 1);
                }
                else
                {
                    using (ThreadSafeForm<SelectCalendarStart> frmPickStart
                           = await ThreadSafeForm<SelectCalendarStart>.GetAsync(
                               () => new SelectCalendarStart(), GenericToken).ConfigureAwait(false))
                    {
                        if (await frmPickStart.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                        {
                            return;
                        }

                        objWeek = new CalendarWeek(frmPickStart.MyForm.SelectedYear, frmPickStart.MyForm.SelectedWeek);
                    }
                }
                try
                {
                    await lstCalendarWeeks.AddWithSortAsync(objWeek, (x, y) => y.CompareTo(x), token: GenericToken)
                                         .ConfigureAwait(false);
                }
                catch
                {
                    await objWeek.DisposeAsync().ConfigureAwait(false);
                    throw;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteWeek_Click(object sender, EventArgs e)
        {
            try
            {
                if (lstCalendar == null
                    || await lstCalendar.DoThreadSafeFuncAsync(x => x.SelectedItems.Count == 0, GenericToken)
                                        .ConfigureAwait(false))
                {
                    return;
                }

                string strWeekId
                    = await lstCalendar.DoThreadSafeFuncAsync(x => x.SelectedItems[0].SubItems[2].Text, GenericToken)
                                       .ConfigureAwait(false);

                ThreadSafeBindingList<CalendarWeek> lstCalendarWeeks = await CharacterObject.GetCalendarAsync(GenericToken).ConfigureAwait(false);
                CalendarWeek objCharacterWeek = lstCalendarWeeks.FirstOrDefault(x => x.InternalId == strWeekId);

                if (objCharacterWeek == null)
                    return;
                if (!await CommonFunctions
                           .ConfirmDeleteAsync(await LanguageManager.GetStringAsync("Message_DeleteCalendarWeek", token: GenericToken)
                                                                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false))
                    return;

                await lstCalendarWeeks.RemoveAsync(objCharacterWeek, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdEditWeek_Click(object sender, EventArgs e)
        {
            try
            {
                if (lstCalendar == null
                    || await lstCalendar.DoThreadSafeFuncAsync(x => x.SelectedItems.Count == 0, GenericToken)
                                        .ConfigureAwait(false))
                {
                    return;
                }

                string strWeekId
                    = await lstCalendar.DoThreadSafeFuncAsync(x => x.SelectedItems[0].SubItems[2].Text, GenericToken)
                                       .ConfigureAwait(false);

                CalendarWeek objWeek = await (await CharacterObject.GetCalendarAsync(GenericToken).ConfigureAwait(false)).FirstOrDefaultAsync(x => x.InternalId == strWeekId, GenericToken).ConfigureAwait(false);
                if (objWeek == null)
                    return;
                string strNotes = await objWeek.GetNotesAsync(GenericToken).ConfigureAwait(false);
                Color objColor = await objWeek.GetNotesColorAsync(GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<EditNotes> frmItemNotes
                       = await ThreadSafeForm<EditNotes>.GetAsync(
                                                            () => new EditNotes(strNotes, objColor,
                                                                GenericToken), GenericToken)
                                                        .ConfigureAwait(false))
                {
                    if (await frmItemNotes.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        != DialogResult.OK)
                        return;
                    await objWeek.SetNotesAsync(frmItemNotes.MyForm.Notes, GenericToken).ConfigureAwait(false);
                    await objWeek.SetNotesColorAsync(frmItemNotes.MyForm.NotesColor, GenericToken).ConfigureAwait(false);
                    await SetDirty(true).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdChangeStartWeek_Click(object sender, EventArgs e)
        {
            try
            {
                // Find the first date.
                ThreadSafeBindingList<CalendarWeek> lstCalendarWeeks = await CharacterObject.GetCalendarAsync(GenericToken).ConfigureAwait(false);
                CalendarWeek objStart = lstCalendarWeeks.LastOrDefault();
                if (objStart == null)
                {
                    return;
                }

                int intNewStartYear;
                int intNewStartWeek;
                using (ThreadSafeForm<SelectCalendarStart> frmPickStart
                       = await ThreadSafeForm<SelectCalendarStart>.GetAsync(
                           () => new SelectCalendarStart(objStart), GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickStart.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    intNewStartYear = frmPickStart.MyForm.SelectedYear;
                    intNewStartWeek = frmPickStart.MyForm.SelectedWeek;
                }

                // Determine the total number of weeks' difference between the old and new values
                int intTotalWeekDiff = intNewStartWeek - await objStart.GetWeekAsync(GenericToken).ConfigureAwait(false);
                int intOldStartYear = await objStart.GetYearAsync(GenericToken).ConfigureAwait(false);
                if (intNewStartYear != intOldStartYear)
                {
                    int intYearLoopDelta = intNewStartYear > intOldStartYear ? 1 : -1;
                    for (; intNewStartYear != intOldStartYear; intNewStartYear -= intYearLoopDelta)
                    {
                        intTotalWeekDiff += intNewStartYear.IsYearLongYear() ? 53 : 52;
                    }
                }

                // Update each of the CalendarWeek entries for the character.
                await lstCalendarWeeks.ForEachWithSideEffectsAsync(objWeek => objWeek.ModifyWeekAsync(intTotalWeekDiff, GenericToken), GenericToken).ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddImprovement_Click(object sender, EventArgs e)
        {
            try
            {
                await DoAddImprovement(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DoAddImprovement(CancellationToken token = default)
        {
            string location
                = await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                      string strSelectedId
                  && strSelectedId != "Node_SelectedImprovements"
                    ? strSelectedId
                    : string.Empty;
            using (ThreadSafeForm<CreateImprovement> frmPickImprovement = await ThreadSafeForm<CreateImprovement>
                       .GetAsync(() => new CreateImprovement(CharacterObject, location), token).ConfigureAwait(false))
            {
                if (await frmPickImprovement.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                    == DialogResult.Cancel)
                    return;
            }

            await RefreshCustomImprovements(treImprovements, lmtControl.LimitTreeView, cmsImprovementLocation,
                                            cmsImprovement, lmtControl.LimitContextMenuStrip, token: token)
                .ConfigureAwait(false);
        }

        private async void cmdCreateStackedFocus_Click(object sender, EventArgs e)
        {
            try
            {
                // Run through all the Foci the character has and count the un-Bonded ones.
                List<Gear> lstGear
                    = await CharacterObject.Gear.ToListAsync(x =>
                        (x.Category == "Foci" || x.Category == "Metamagic Foci") && !x.Bonded, GenericToken).ConfigureAwait(false);

                // If the character does not have at least 2 un-Bonded Foci, display an error and leave.
                if (lstGear.Count < 2)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CannotStackFoci", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                List<Gear> lstStack = new List<Gear>(lstGear.Count);
                string strDescription
                    = await LanguageManager.GetStringAsync("String_SelectItemFocus", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectItem> frmPickItem = await ThreadSafeForm<SelectItem>.GetAsync(
                           () => new SelectItem
                           {
                               AllowAutoSelect = false
                           }, GenericToken).ConfigureAwait(false))
                {
                    await frmPickItem.MyForm.DoThreadSafeAsync(x => x.Description = strDescription, GenericToken).ConfigureAwait(false);
                    // Let the character select the Foci they'd like to stack, stopping when they either click Cancel or there are no more items left in the list.
                    DialogResult eResult;
                    do
                    {
                        frmPickItem.MyForm.SetGearMode(lstGear);
                        eResult = await frmPickItem.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false);
                        if (eResult != DialogResult.OK)
                            continue;
                        string strSelected = await frmPickItem.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, GenericToken).ConfigureAwait(false);
                        // Move the item from the Gear list to the Stack list.
                        foreach (Gear objGear in lstGear)
                        {
                            if (objGear.InternalId != strSelected)
                                continue;
                            objGear.Bonded = true;
                            lstStack.Add(objGear);
                            lstGear.Remove(objGear);
                            break;
                        }
                    } while (lstGear.Count > 0 && eResult != DialogResult.Cancel);
                }

                // Make sure at least 2 Foci were selected.
                if (lstStack.Count < 2)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_StackedFocusMinimum", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Make sure the combined Force of the Foci do not exceed 6.
                if (!CharacterObjectSettings.AllowHigherStackedFoci)
                {
                    int intCombined = await lstStack.SumAsync(objGear => objGear.GetRatingAsync(GenericToken), GenericToken).ConfigureAwait(false);
                    if (intCombined > 6)
                    {
                        foreach (Gear objGear in lstStack)
                            objGear.Bonded = false;
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_StackedFocusForce", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci", token: GenericToken).ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                    }
                }

                // Create the Stacked Focus.
                StackedFocus objStack = new StackedFocus(CharacterObject);
                foreach (Gear objGear in lstStack)
                    await objStack.Gear.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                await CharacterObject.StackedFoci.AddAsync(objStack, GenericToken).ConfigureAwait(false);

                // Remove the Gear from the character and replace it with a Stacked Focus item.
                decimal decCost = 0.0m;
                foreach (Gear objGear in lstStack)
                {
                    decCost += await objGear.GetTotalCostAsync(GenericToken).ConfigureAwait(false);
                    await CharacterObject.Gear.RemoveAsync(objGear, GenericToken).ConfigureAwait(false);
                }

                Gear objStackItem = new Gear(CharacterObject)
                {
                    Category = "Stacked Focus",
                    Name = "Stacked Focus: "
                           + await objStack.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false),
                    Source = "SR5",
                    Page = "1",
                    Cost = decCost.ToString(GlobalSettings.CultureInfo),
                    Avail = "0"
                };

                await CharacterObject.Gear.AddAsync(objStackItem, GenericToken).ConfigureAwait(false);

                objStack.GearId = objStackItem.InternalId;
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdBurnStreetCred_Click(object sender, EventArgs e)
        {
            try
            {
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_BurnStreetCred", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_BurnStreetCred", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                    return;

                await CharacterObject.ModifyBurntStreetCredAsync(2, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdEditImprovement_Click(object sender, EventArgs e)
        {
            try
            {
                await DoEditImprovement(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DoEditImprovement(CancellationToken token = default)
        {
            // Edit the selected Improvement.
            if (!(await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                    Improvement objImprovement))
                return;
            Improvement objNewImprovement;
            using (ThreadSafeForm<CreateImprovement> frmPickImprovement = await ThreadSafeForm<CreateImprovement>
                       .GetAsync(
                           () => new CreateImprovement(CharacterObject, objImprovement.CustomGroup)
                           {
                               EditImprovementObject = objImprovement
                           }, token).ConfigureAwait(false))
            {
                if (await frmPickImprovement.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                    == DialogResult.Cancel)
                    return;
                objNewImprovement = frmPickImprovement.MyForm.NewImprovement;
            }

            TreeNode newNode = null;
            if (!string.IsNullOrEmpty(objNewImprovement?.InternalId))
                newNode = await treImprovements
                                .DoThreadSafeFuncAsync(x => x.FindNode(objNewImprovement.InternalId), token)
                                .ConfigureAwait(false);

            if (newNode != null)
            {
                Color objColor = await objNewImprovement.GetPreferredColorAsync(token).ConfigureAwait(false);
                string strNotes = await objNewImprovement.GetNotesAsync(token).ConfigureAwait(false);
                await treImprovements.DoThreadSafeAsync(() =>
                {
                    newNode.Text = objNewImprovement.CustomName;
                    newNode.ForeColor = objColor;
                    newNode.ToolTipText = strNotes;
                }, token).ConfigureAwait(false);
            }
            else
            {
                Utils.BreakIfDebug();
            }

            //TODO: This is currently necessary because the Custom Improvement refresh fires before the improvement is assigned a custom group.
            // Simplest way to fix this would be to make the customgroup a variable in the CreateImprovements method, but that's spooky.
            if (!string.IsNullOrWhiteSpace(objNewImprovement?.CustomGroup))
            {
                await RefreshCustomImprovements(treImprovements, lmtControl.LimitTreeView, cmsImprovementLocation,
                                                cmsImprovement, lmtControl.LimitContextMenuStrip, token: token)
                    .ConfigureAwait(false);
            }

            await MakeDirtyWithCharacterUpdate(token).ConfigureAwait(false);
        }

        private async void cmdDeleteImprovement_Click(object sender, EventArgs e)
        {
            try
            {
                await DoDeleteImprovement(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DoDeleteImprovement(CancellationToken token = default)
        {
            switch (await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false))
            {
                case Improvement objImprovement:
                    if (await CommonFunctions
                              .ConfirmDeleteAsync(
                                  await LanguageManager.GetStringAsync("Message_DeleteImprovement", token: token)
                                                       .ConfigureAwait(false), token).ConfigureAwait(false))
                        await ImprovementManager.RemoveImprovementsAsync(
                            CharacterObject, Improvement.ImprovementSource.Custom,
                            objImprovement.SourceName, token).ConfigureAwait(false);
                    break;

                case string strSelectedId:
                    if (strSelectedId == "Node_SelectedImprovements")
                        return;
                    if (!await CommonFunctions.ConfirmDeleteAsync(
                            await LanguageManager.GetStringAsync("Message_DeleteImprovementGroup", token: token)
                                                 .ConfigureAwait(false), token).ConfigureAwait(false))
                        return;
                    await (await CharacterObject.GetImprovementsAsync(token).ConfigureAwait(false)).ForEachWithSideEffectsAsync(objImprovement =>
                    {
                        if (objImprovement.CustomGroup == strSelectedId)
                            objImprovement.CustomGroup = string.Empty;
                    }, token: token).ConfigureAwait(false);

                    // Remove the Group from the character, then remove the selected node.
                    await (await CharacterObject.GetImprovementGroupsAsync(token).ConfigureAwait(false)).RemoveAsync(strSelectedId, token).ConfigureAwait(false);
                    break;
            }
        }

        private async void cmdAddArmorBundle_Click(object sender, EventArgs e)
        {
            try
            {
                string strDescription
                    = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                // Add a new location to the Armor Tree.
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel
                        || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                        return;

                    Location objLocation = new Location(CharacterObject, CharacterObject.ArmorLocations,
                                                        frmPickText.MyForm.SelectedValue);
                    await CharacterObject.ArmorLocations.AddAsync(objLocation, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdArmorEquipAll_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                                   .ConfigureAwait(false);
                if (objSelected is Location selectedLocation)
                {
                    // Equip all of the Armor in the Armor Bundle.
                    await selectedLocation.Children.ForEachWithSideEffectsAsync(async child =>
                    {
                        if (child is Armor objArmor && objArmor.Location == selectedLocation && !objArmor.Equipped)
                        {
                            await objArmor.SetEquippedAsync(true, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }
                else if (objSelected?.ToString() == "Node_SelectedArmor")
                {
                    await CharacterObject.Armor.ForEachWithSideEffectsAsync(async objArmor =>
                    {
                        if (!objArmor.Equipped && objArmor.Location == null)
                        {
                            await objArmor.SetEquippedAsync(true, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await CharacterObject.Armor.ForEachWithSideEffectsAsync(async objArmor =>
                    {
                        if (!objArmor.Equipped)
                        {
                            await objArmor.SetEquippedAsync(true, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdArmorUnEquipAll_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                                   .ConfigureAwait(false);
                if (objSelected is Location selectedLocation)
                {
                    // Equip all of the Armor in the Armor Bundle.
                    await selectedLocation.Children.ForEachWithSideEffectsAsync(async child =>
                    {
                        if (child is Armor objArmor && objArmor.Location == selectedLocation && objArmor.Equipped)
                        {
                            await objArmor.SetEquippedAsync(false, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }
                else if (objSelected?.ToString() == "Node_SelectedArmor")
                {
                    await CharacterObject.Armor.ForEachWithSideEffectsAsync(async objArmor =>
                    {
                        if (objArmor.Equipped && objArmor.Location == null)
                        {
                            await objArmor.SetEquippedAsync(false, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await CharacterObject.Armor.ForEachWithSideEffectsAsync(async objArmor =>
                    {
                        if (objArmor.Equipped)
                        {
                            await objArmor.SetEquippedAsync(false, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdImprovementsEnableAll_Click(object sender, EventArgs e)
        {
            try
            {
                // Enable all of the Improvements in the Improvement Group.
                if (!(await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                           .ConfigureAwait(false) is string
                        strSelectedId))
                    return;
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    List<Improvement> lstImprovementsEnabled;
                    if (strSelectedId == "Node_SelectedImprovements")
                    {
                        lstImprovementsEnabled
                            = await (await CharacterObject.GetImprovementsAsync(GenericToken).ConfigureAwait(false))
                                    .ToListAsync(objImprovement =>
                                                     objImprovement.Custom && !objImprovement.Enabled
                                                                           && string.IsNullOrEmpty(
                                                                               objImprovement.CustomGroup),
                                                 GenericToken).ConfigureAwait(false);
                    }
                    else
                    {
                        lstImprovementsEnabled
                            = await (await CharacterObject.GetImprovementsAsync(GenericToken).ConfigureAwait(false))
                                    .ToListAsync(objImprovement =>
                                                     objImprovement.Custom && !objImprovement.Enabled
                                                                           && objImprovement.CustomGroup == strSelectedId,
                                                 GenericToken).ConfigureAwait(false);
                    }

                    if (lstImprovementsEnabled.Count == 0)
                        return;
                    await ImprovementManager.EnableImprovementsAsync(CharacterObject, lstImprovementsEnabled, GenericToken)
                                            .ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
                await RefreshCustomImprovements(treImprovements, lmtControl.LimitTreeView,
                    cmsImprovementLocation,
                    cmsImprovement, lmtControl.LimitContextMenuStrip,
                    token: GenericToken).ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdImprovementsDisableAll_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                           .ConfigureAwait(false) is string
                        strSelectedId))
                    return;
                // Disable all of the Improvements in the Improvement Group.
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    List<Improvement> lstImprovementsDisabled;
                    if (strSelectedId == "Node_SelectedImprovements")
                    {
                        lstImprovementsDisabled
                            = await (await CharacterObject.GetImprovementsAsync(GenericToken).ConfigureAwait(false))
                                    .ToListAsync(objImprovement =>
                                                     objImprovement.Custom && objImprovement.Enabled
                                                                           && string.IsNullOrEmpty(
                                                                               objImprovement.CustomGroup),
                                                 GenericToken).ConfigureAwait(false);
                    }
                    else
                    {
                        lstImprovementsDisabled
                            = await (await CharacterObject.GetImprovementsAsync(GenericToken).ConfigureAwait(false))
                                    .ToListAsync(objImprovement =>
                                                     objImprovement.Custom && objImprovement.Enabled
                                                                           && objImprovement.CustomGroup == strSelectedId,
                                                 GenericToken).ConfigureAwait(false);
                    }

                    if (lstImprovementsDisabled.Count == 0)
                        return;
                    await ImprovementManager
                          .DisableImprovementsAsync(CharacterObject, lstImprovementsDisabled, GenericToken)
                          .ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
                await RefreshCustomImprovements(treImprovements, lmtControl.LimitTreeView,
                    cmsImprovementLocation,
                    cmsImprovement, lmtControl.LimitContextMenuStrip,
                    token: GenericToken).ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddVehicleLocation_Click(object sender, EventArgs e)
        {
            try
            {
                ThreadSafeObservableCollection<Location> destCollection;
                object objSelected = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                                      .ConfigureAwait(false);
                // Make sure a Vehicle is selected.
                if (objSelected is Vehicle objVehicle)
                {
                    destCollection = objVehicle.Locations;
                }
                else if (objSelected == null || objSelected.ToString() == "Node_SelectedVehicles")
                {
                    destCollection = CharacterObject.VehicleLocations;
                }
                else
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectVehicleLocation", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription
                    = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                // Add a new location to the Armor Tree.
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel
                        || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                        return;
                    Location objLocation
                        = new Location(CharacterObject, destCollection, frmPickText.MyForm.SelectedValue);
                    try
                    {
                        await destCollection.AddAsync(objLocation, GenericToken).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objLocation.DisposeAsync().ConfigureAwait(false);
                        throw;
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdQuickenSpell_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                          .ConfigureAwait(false);
                if (objSelectedNode == null || objSelectedNode.Level != 1)
                    return;

                string strSelectedSpell = await treSpells
                                                .DoThreadSafeFuncAsync(() => objSelectedNode.Text, GenericToken)
                                                .ConfigureAwait(false);
                int intKarmaCost;
                string strDescription = string.Format(GlobalSettings.CultureInfo,
                                                      await LanguageManager.GetStringAsync("String_QuickeningKarma", token: GenericToken)
                                                                           .ConfigureAwait(false),
                                                      strSelectedSpell);
                using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                           () => new SelectNumber(0)
                           {
                               Description = strDescription,
                               Minimum = 1
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickNumber.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    intKarmaCost = frmPickNumber.MyForm.SelectedValue.ToInt32();
                }

                // Make sure the character has enough Karma to improve the CharacterAttribute.
                if (intKarmaCost > await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(GlobalSettings.CultureInfo,
                                                                        await LanguageManager.GetStringAsync(
                                                                                "Message_ConfirmKarmaExpenseQuickeningMetamagic", token: GenericToken)
                                                                            .ConfigureAwait(false),
                                                                        intKarmaCost.ToString(
                                                                            GlobalSettings.CultureInfo),
                                                                        strSelectedSpell), token: GenericToken).ConfigureAwait(false))
                    return;

                // Create the Karma expense.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(intKarmaCost * -1,
                                  await LanguageManager
                                        .GetStringAsync("String_ExpenseQuickenMetamagic", token: GenericToken)
                                        .ConfigureAwait(false)
                                  + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                                         .ConfigureAwait(false) + strSelectedSpell,
                                  ExpenseType.Karma, DateTime.Now);
                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                     .ConfigureAwait(false);
                await CharacterObject.ModifyKarmaAsync(-intKarmaCost, GenericToken).ConfigureAwait(false);

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.QuickeningMetamagic, string.Empty);
                objExpense.Undo = objUndo;
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddSustainedSpell_Click(object sender, EventArgs e)
        {
            try
            {
                await AddSustainedSpell(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddSustainedForm_Click(object sender, EventArgs e)
        {
            try
            {
                await AddSustainedComplexForm(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddSustainedCritterPower_Click(object sender, EventArgs e)
        {
            try
            {
                await AddSustainedCritterPower(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Button Events

        #region ContextMenu Events

        private async void InitiationContextMenu_Opening(object sender, CancelEventArgs e)
        {
            try
            {
                // Enable and disable menu items
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is InitiationGrade objGrade))
                    return;
                int intGrade = objGrade.Grade;
                bool blnHasArt = await CharacterObject.Arts.AnyAsync(art => art.Grade == intGrade, GenericToken)
                    .ConfigureAwait(false);
                bool blnHasBonus = await CharacterObject.Metamagics
                                       .AnyAsync(bonus => bonus.Grade == intGrade, GenericToken)
                                       .ConfigureAwait(false)
                                   || await CharacterObject.Spells
                                       .AnyAsync(spell => spell.Grade == intGrade, GenericToken)
                                       .ConfigureAwait(false);
                await this.DoThreadSafeAsync(() =>
                {
                    tsMetamagicAddArt.Enabled = !blnHasArt;
                    tsMetamagicAddMetamagic.Enabled = !blnHasBonus;
                }, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Cyberware window.
                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is Cyberware
                        objCyberware && !string.IsNullOrWhiteSpace(objCyberware.AllowedSubsystems)))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickCyberware(objCyberware, objCyberware.SourceType, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleCyberwareAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Cyberware window.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Cyberware
                        objCyberware && !string.IsNullOrWhiteSpace(objCyberware.AllowedSubsystems)))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickCyberware(objCyberware, objCyberware.SourceType, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponAddAccessory_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent item is selected, then open the Select Accessory window.
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                             GenericToken).ConfigureAwait(false) is Weapon objWeapon))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectWeaponAccessory", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Accessories cannot be added to Cyberweapons.
                if (objWeapon.Cyberware)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_CyberweaponNoAccessory", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberweaponNoAccessory", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Weapons XML file and locate the selected Weapon.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("weapons.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);

                XmlNode objXmlWeapon = await objWeapon.GetNodeAsync(GenericToken).ConfigureAwait(false);
                if (objXmlWeapon == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CannotFindWeapon", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;

                do
                {
                    // Make sure the Weapon allows Accessories to be added to it.
                    if (!objWeapon.AllowAccessory)
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_CannotModifyWeapon", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon", token: GenericToken)
                                .ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        break;
                    }

                    using (ThreadSafeForm<SelectWeaponAccessory> frmPickWeaponAccessory
                           = await ThreadSafeForm<SelectWeaponAccessory>.GetAsync(
                               () => new SelectWeaponAccessory(CharacterObject), GenericToken).ConfigureAwait(false))
                    {
                        await frmPickWeaponAccessory.MyForm.SetWeapon(objWeapon, GenericToken).ConfigureAwait(false);
                        if (await frmPickWeaponAccessory.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickWeaponAccessory.MyForm.AddAgain;

                        // Locate the selected piece.
                        objXmlWeapon = objXmlDocument.TryGetNodeByNameOrId("/chummer/accessories/accessory", frmPickWeaponAccessory.MyForm.SelectedAccessory);

                        WeaponAccessory objAccessory = new WeaponAccessory(CharacterObject);
                        try
                        {
                            await objAccessory.CreateAsync(objXmlWeapon, frmPickWeaponAccessory.MyForm.SelectedMount,
                                frmPickWeaponAccessory.MyForm.SelectedRating, token: GenericToken).ConfigureAwait(false);
                            await objAccessory.SetParentAsync(objWeapon, GenericToken).ConfigureAwait(false);
                            objAccessory.DiscountCost = frmPickWeaponAccessory.MyForm.BlackMarketDiscount;

                            // Check the item's Cost and make sure the character can afford it.
                            decimal decOriginalCost = await objWeapon.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                            await objWeapon.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);

                            if (!frmPickWeaponAccessory.MyForm.FreeCost)
                            {
                                decimal decCost = await objWeapon.GetTotalCostAsync(GenericToken).ConfigureAwait(false) - decOriginalCost;
                                // Apply a markup if applicable.
                                if (frmPickWeaponAccessory.MyForm.Markup != 0)
                                {
                                    decCost *= 1 + frmPickWeaponAccessory.MyForm.Markup / 100.0m;
                                }

                                // Multiply the cost if applicable.
                                char chrAvail = (await objAccessory.TotalAvailTupleAsync(token: GenericToken).ConfigureAwait(false)).Suffix;
                                switch (chrAvail)
                                {
                                    case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                        decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                        break;

                                    case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                        decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                        break;
                                }

                                if (decCost > await CharacterObject.GetNuyenAsync(GenericToken).ConfigureAwait(false))
                                {
                                    await objWeapon.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: GenericToken)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen", token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                    continue;
                                }

                                // Create the Expense Log Entry.
                                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                objExpense.Create(decCost * -1,
                                                  await LanguageManager.GetStringAsync(
                                                      "String_ExpensePurchaseWeaponAccessory", token: GenericToken).ConfigureAwait(false)
                                                  + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                                                         .ConfigureAwait(false)
                                                  + await objAccessory.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                      .ConfigureAwait(false),
                                                  ExpenseType.Nuyen, DateTime.Now);
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken).ConfigureAwait(false);
                                await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken).ConfigureAwait(false);

                                ExpenseUndo objUndo = new ExpenseUndo();
                                objUndo.CreateNuyen(NuyenExpenseType.AddWeaponAccessory, objAccessory.InternalId);
                                objExpense.Undo = objUndo;
                            }
                        }
                        catch
                        {
                            await objAccessory.DeleteWeaponAccessoryAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task<bool> PickArmor(Location objLocation = null, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    using (ThreadSafeForm<SelectArmor> frmPickArmor = await ThreadSafeForm<SelectArmor>
                               .GetAsync(() => new SelectArmor(CharacterObject),
                                   token).ConfigureAwait(false))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickArmor.ShowDialogSafeAsync(this, token).ConfigureAwait(false) ==
                            DialogResult.Cancel)
                            return false;

                        // Open the Armor XML file and locate the selected piece.
                        XmlDocument objXmlDocument
                            = await CharacterObject.LoadDataAsync("armor.xml", token: token).ConfigureAwait(false);

                        XmlNode objXmlArmor
                            = objXmlDocument.TryGetNodeByNameOrId("/chummer/armors/armor",
                                frmPickArmor.MyForm.SelectedArmor);

                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        Armor objArmor = new Armor(CharacterObject);
                        try
                        {
                            await objArmor.CreateAsync(objXmlArmor, frmPickArmor.MyForm.Rating, lstWeapons, token: token)
                                .ConfigureAwait(false);
                            objArmor.DiscountCost = frmPickArmor.MyForm.BlackMarketDiscount;

                            if (objArmor.InternalId.IsEmptyGuid())
                            {
                                foreach (Weapon objWeapon in lstWeapons)
                                    await objWeapon.DeleteWeaponAsync(token: token).ConfigureAwait(false);
                                await objArmor.DeleteArmorAsync(token: token).ConfigureAwait(false);
                                return frmPickArmor.MyForm.AddAgain;
                            }

                            // Check the item's Cost and make sure the character can afford it.
                            if (!frmPickArmor.MyForm.FreeCost)
                            {
                                decimal decCost = await objArmor.GetTotalCostAsync(token).ConfigureAwait(false);
                                // Apply a markup if applicable.
                                if (frmPickArmor.MyForm.Markup != 0)
                                {
                                    decCost *= 1 + frmPickArmor.MyForm.Markup / 100.0m;
                                }

                                // Multiply the cost if applicable.
                                char chrAvail = (await objArmor.TotalAvailTupleAsync(token: token).ConfigureAwait(false))
                                    .Suffix;
                                switch (chrAvail)
                                {
                                    case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                        decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                        break;

                                    case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                        decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                        break;
                                }

                                if (decCost > await CharacterObject.GetNuyenAsync(token).ConfigureAwait(false))
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: token)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen", token: token)
                                            .ConfigureAwait(false), MessageBoxButtons.OK,
                                        MessageBoxIcon.Information, token: token).ConfigureAwait(false);
                                    // Remove the Improvements created by the Armor.
                                    await ImprovementManager
                                        .RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Armor,
                                            objArmor.InternalId, token).ConfigureAwait(false);

                                    return frmPickArmor.MyForm.AddAgain;
                                }

                                // Create the Expense Log Entry.
                                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                objExpense.Create(decCost * -1,
                                    await LanguageManager.GetStringAsync("String_ExpensePurchaseArmor", token: token)
                                        .ConfigureAwait(false)
                                    + await LanguageManager.GetStringAsync("String_Space", token: token)
                                        .ConfigureAwait(false)
                                    + await objArmor.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                    ExpenseType.Nuyen, DateTime.Now);
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: token)
                                    .ConfigureAwait(false);
                                await CharacterObject.ModifyNuyenAsync(-decCost, token).ConfigureAwait(false);

                                ExpenseUndo objUndo = new ExpenseUndo();
                                objUndo.CreateNuyen(NuyenExpenseType.AddArmor, objArmor.InternalId);
                                objExpense.Undo = objUndo;
                            }

                            // objArmor.Location = objLocation;
                            if (objLocation != null)
                                await objLocation.Children.AddAsync(objArmor, token).ConfigureAwait(false);
                            await CharacterObject.Armor.AddAsync(objArmor, token).ConfigureAwait(false);

                            foreach (Weapon objWeapon in lstWeapons)
                            {
                                await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                            }

                            return frmPickArmor.MyForm.AddAgain;
                        }
                        catch
                        {
                            foreach (Weapon objWeapon in lstWeapons)
                                await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                            await objArmor.DeleteArmorAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async void tsArmorLocationAddArmor_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is Location
                        objSelectedLocation))
                    return;
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickArmor(objSelectedLocation, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAddArmorMod_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent item is selected, then open the Select Accessory window.
                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is Armor objArmor))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Armor XML file and locate the selected Armor.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("armor.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);

                XmlNode objXmlArmor = await objArmor.GetNodeAsync(GenericToken).ConfigureAwait(false);

                string strAllowedCategories = objArmor.Category + "," + objArmor.Name;
                bool blnExcludeGeneralCategory = false;
                XmlElement xmlAddModCategory = objXmlArmor["forcemodcategory"];
                if (xmlAddModCategory != null)
                {
                    strAllowedCategories = xmlAddModCategory.InnerTextViaPool(GenericToken);
                    blnExcludeGeneralCategory = true;
                }
                else
                {
                    xmlAddModCategory = objXmlArmor["addmodcategory"];
                    if (xmlAddModCategory != null)
                    {
                        strAllowedCategories += "," + xmlAddModCategory.InnerTextViaPool(GenericToken);
                    }
                }

                bool blnAddAgain;
                do
                {
                    IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        using (ThreadSafeForm<SelectArmorMod> frmPickArmorMod
                               = await ThreadSafeForm<SelectArmorMod>.GetAsync(
                                   () => new SelectArmorMod(CharacterObject, objArmor)
                                   {
                                       AllowedCategories = strAllowedCategories,
                                       ExcludeGeneralCategory = blnExcludeGeneralCategory
                                   }, GenericToken).ConfigureAwait(false))
                        {
                            if (await frmPickArmorMod.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;
                            blnAddAgain = frmPickArmorMod.MyForm.AddAgain;

                            // Locate the selected piece.
                            objXmlArmor = objXmlDocument.TryGetNodeByNameOrId("/chummer/mods/mod",
                                frmPickArmorMod.MyForm.SelectedArmorMod);

                            if (objXmlArmor == null)
                                continue;

                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            int.TryParse(objXmlArmor["maxrating"]?.InnerTextViaPool(GenericToken), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intMaxRating);
                            int intRating = intMaxRating > 1
                                    ? frmPickArmorMod.MyForm.SelectedRating
                                    : 0;
                            ArmorMod objMod = new ArmorMod(CharacterObject, objArmor);
                            try
                            {
                                await objMod.CreateAsync(objXmlArmor, intRating, lstWeapons, token: GenericToken)
                                    .ConfigureAwait(false);
                                if (objMod.InternalId.IsEmptyGuid())
                                {
                                    foreach (Weapon objWeapon in lstWeapons)
                                        await objWeapon.DeleteWeaponAsync(token: GenericToken).ConfigureAwait(false);
                                    await objMod.DeleteArmorModAsync(token: GenericToken).ConfigureAwait(false);
                                    continue;
                                }

                                // Check the item's Cost and make sure the character can afford it.
                                decimal decOriginalCost =
                                    await objArmor.GetTotalCostAsync(GenericToken).ConfigureAwait(false);
                                await objArmor.ArmorMods.AddAsync(objMod, GenericToken).ConfigureAwait(false);

                                // Do not allow the user to add a new piece of Armor if its Capacity has been reached.
                                if (await CharacterObjectSettings.GetEnforceCapacityAsync(GenericToken)
                                        .ConfigureAwait(false) && await objArmor.GetCapacityRemainingAsync(GenericToken)
                                        .ConfigureAwait(false) < 0)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_CapacityReached", token: GenericToken)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_CapacityReached",
                                                token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                    await objArmor.ArmorMods.RemoveAsync(objMod, GenericToken).ConfigureAwait(false);
                                    continue;
                                }

                                if (!frmPickArmorMod.MyForm.FreeCost)
                                {
                                    decimal decCost = await objArmor.GetTotalCostAsync(GenericToken).ConfigureAwait(false) -
                                                      decOriginalCost;
                                    // Apply a markup if applicable.
                                    if (frmPickArmorMod.MyForm.Markup != 0)
                                    {
                                        decCost *= 1 + frmPickArmorMod.MyForm.Markup / 100.0m;
                                    }

                                    // Multiply the cost if applicable.
                                    char chrAvail =
                                        (await objMod.TotalAvailTupleAsync(token: GenericToken).ConfigureAwait(false))
                                        .Suffix;
                                    switch (chrAvail)
                                    {
                                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                            break;

                                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                            break;
                                    }

                                    if (decCost > await CharacterObject.GetNuyenAsync(GenericToken).ConfigureAwait(false))
                                    {
                                        await objArmor.ArmorMods.RemoveAsync(objMod, GenericToken).ConfigureAwait(false);
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager.GetStringAsync("Message_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        // Remove the Improvements created by the Armor Mod.
                                        await ImprovementManager.RemoveImprovementsAsync(
                                                CharacterObject, Improvement.ImprovementSource.ArmorMod,
                                                objMod.InternalId, GenericToken)
                                            .ConfigureAwait(false);
                                        continue;
                                    }

                                    // Create the Expense Log Entry.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(decCost * -1,
                                        await LanguageManager.GetStringAsync("String_ExpensePurchaseArmorMod",
                                                token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objMod.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Nuyen,
                                        DateTime.Now);
                                    await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                        .ConfigureAwait(false);
                                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken).ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateNuyen(NuyenExpenseType.AddArmorMod, objMod.InternalId);
                                    objExpense.Undo = objUndo;
                                }

                                // Add any Weapons created by the Mod.
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                                }
                            }
                            catch
                            {
                                foreach (Weapon objWeapon in lstWeapons)
                                    await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                await objMod.DeleteArmorModAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Gear window.
                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false)
                        is IHasChildren<Gear>
                        iParent))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickGear(iParent, token: GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleAddMod_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x =>
                {
                    TreeNode objReturn = x.SelectedNode;
                    while (objReturn?.Level > 1)
                        objReturn = objReturn.Parent;
                    return objReturn;
                }, GenericToken).ConfigureAwait(false);
                // Make sure a parent items is selected, then open the Select Vehicle Mod window.
                if (!(objSelectedNode?.Tag is Vehicle objVehicle))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectVehicle", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Vehicles XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("vehicles.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);

                bool blnAddAgain;

                do
                {
                    using (ThreadSafeForm<SelectVehicleMod> frmPickVehicleMod
                           = await ThreadSafeForm<SelectVehicleMod>.GetAsync(
                                                                       () => new SelectVehicleMod(CharacterObject,
                                                                           objVehicle), GenericToken)
                                                                   .ConfigureAwait(false))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickVehicleMod.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickVehicleMod.MyForm.AddAgain;

                        XmlNode objXmlMod = objXmlDocument.TryGetNodeByNameOrId("/chummer/mods/mod", frmPickVehicleMod.MyForm.SelectedMod);

                        VehicleMod objMod = new VehicleMod(CharacterObject);
                        try
                        {
                            objMod.DiscountCost = frmPickVehicleMod.MyForm.BlackMarketDiscount;
                            await objMod.CreateAsync(objXmlMod, frmPickVehicleMod.MyForm.SelectedRating, objVehicle, token: GenericToken).ConfigureAwait(false);

                            // Check the item's Cost and make sure the character can afford it.
                            decimal decOriginalCost = await objVehicle.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                            await objVehicle.Mods.AddAsync(objMod, GenericToken).ConfigureAwait(false);

                            // Do not allow the user to add a new Vehicle Mod if the Vehicle's Capacity has been reached.
                            if (await CharacterObjectSettings.GetEnforceCapacityAsync(GenericToken).ConfigureAwait(false))
                            {
                                bool blnOverCapacity;
                                if (await CharacterObjectSettings.BookEnabledAsync("R5", GenericToken)
                                                                 .ConfigureAwait(false))
                                {
                                    if (objVehicle.IsDrone && await CharacterObjectSettings.GetDroneModsAsync(GenericToken).ConfigureAwait(false))
                                        blnOverCapacity
                                            = await objVehicle.GetDroneModSlotsUsedAsync(GenericToken)
                                                               .ConfigureAwait(false) > await objVehicle
                                                .GetDroneModSlotsAsync(GenericToken).ConfigureAwait(false);
                                    else
                                        blnOverCapacity = await objVehicle.OverR5CapacityAsync(objMod.Category, GenericToken).ConfigureAwait(false);
                                }
                                else
                                    blnOverCapacity = await objVehicle.GetSlotsAsync(GenericToken).ConfigureAwait(false)
                                                      < await objVehicle.GetSlotsUsedAsync(GenericToken)
                                                                        .ConfigureAwait(false);

                                if (blnOverCapacity)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_CapacityReached", token: GenericToken)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_CapacityReached", token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                    await objVehicle.Mods.RemoveAsync(objMod, GenericToken).ConfigureAwait(false);
                                    continue;
                                }
                            }

                            if (!frmPickVehicleMod.MyForm.FreeCost)
                            {
                                decimal decCost = await objVehicle.GetTotalCostAsync(GenericToken).ConfigureAwait(false) - decOriginalCost;

                                // Apply a markup if applicable.
                                if (frmPickVehicleMod.MyForm.Markup != 0)
                                {
                                    decCost *= 1 + frmPickVehicleMod.MyForm.Markup / 100.0m;
                                }

                                // Multiply the cost if applicable.
                                char chrAvail = (await objMod.TotalAvailTupleAsync(token: GenericToken).ConfigureAwait(false)).Suffix;
                                switch (chrAvail)
                                {
                                    case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                        decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                        break;

                                    case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                        decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                        break;
                                }

                                if (decCost > await CharacterObject.GetNuyenAsync(GenericToken).ConfigureAwait(false))
                                {
                                    await objVehicle.Mods.RemoveAsync(objMod, GenericToken).ConfigureAwait(false);
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: GenericToken)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen", token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                    continue;
                                }

                                // Create the Expense Log Entry.
                                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                objExpense.Create(decCost * -1,
                                                  await LanguageManager.GetStringAsync("String_ExpensePurchaseVehicleMod", token: GenericToken)
                                                                       .ConfigureAwait(false)
                                                  + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                                                         .ConfigureAwait(false)
                                                  + await objMod.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                .ConfigureAwait(false), ExpenseType.Nuyen,
                                                  DateTime.Now);
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken).ConfigureAwait(false);
                                await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken).ConfigureAwait(false);

                                ExpenseUndo objUndo = new ExpenseUndo();
                                objUndo.CreateNuyen(NuyenExpenseType.AddVehicleMod, objMod.InternalId);
                                objExpense.Undo = objUndo;
                            }
                        }
                        catch
                        {
                            await objMod.DeleteVehicleModAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleAddWeaponWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is IHasInternalId
                        selectedObject))
                    return;
                string strSelectedId = selectedObject.InternalId;
                // Make sure that a Weapon Mount has been selected.
                // Attempt to locate the selected VehicleMod.
                VehicleMod objMod = null;
                WeaponMount objWeaponMount = null;
                if (!string.IsNullOrEmpty(strSelectedId))
                {
                    (objWeaponMount, _) = await CharacterObject.Vehicles.FindVehicleWeaponMountAsync(strSelectedId, GenericToken).ConfigureAwait(false);
                    if (objWeaponMount == null)
                    {
                        (objMod, _, objWeaponMount) = await CharacterObject.Vehicles.FindVehicleModAsync(x => x.InternalId == strSelectedId, GenericToken).ConfigureAwait(false);
                        if (objMod?.Name.StartsWith("Mechanical Arm", StringComparison.Ordinal) == false
                            && !objMod.Name.Contains("Drone Arm"))
                        {
                            objMod = null;
                        }
                    }
                }

                if (objWeaponMount == null && objMod == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CannotAddWeapon", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotAddWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                if (objWeaponMount?.IsWeaponsFull == true)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_WeaponMountFull", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotAddWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddWeaponToWeaponMount(objWeaponMount, objMod, GenericToken)
                        .ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task<bool> AddWeaponToWeaponMount(WeaponMount objWeaponMount, VehicleMod objMod, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(
                           () => new SelectWeapon(CharacterObject)
                           {
                               LimitToCategories = objMod == null
                                   ? objWeaponMount.AllowedWeaponCategories
                                   : objMod.WeaponMountCategories,
                               WeaponFilter = objMod == null
                                   ? objWeaponMount.WeaponFilter
                                   : string.Empty
                           }, token).ConfigureAwait(false))
                {
                    if (await frmPickWeapon.ShowDialogSafeAsync(this, token).ConfigureAwait(false) ==
                        DialogResult.Cancel)
                        return false;

                    // Open the Weapons XML file and locate the selected piece.
                    XmlDocument objXmlDocument
                        = await CharacterObject.LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false);

                    XmlNode objXmlWeapon = objXmlDocument.TryGetNodeByNameOrId("/chummer/weapons/weapon",
                        frmPickWeapon.MyForm.SelectedWeapon);

                    List<Weapon> lstWeapons = new List<Weapon>(1);
                    Weapon objWeapon = new Weapon(CharacterObject);
                    try
                    {
                        if (objMod != null)
                            await objWeapon.SetParentVehicleModAsync(objMod, GenericToken).ConfigureAwait(false);
                        else
                            await objWeapon.SetParentMountAsync(objWeaponMount, GenericToken).ConfigureAwait(false);
                        await objWeapon.CreateAsync(objXmlWeapon, lstWeapons, token: token).ConfigureAwait(false);

                        if (!frmPickWeapon.MyForm.FreeCost)
                        {
                            decimal decCost = await objWeapon.GetTotalCostAsync(token).ConfigureAwait(false);
                            // Apply a markup if applicable.
                            if (frmPickWeapon.MyForm.Markup != 0)
                            {
                                decCost *= 1 + frmPickWeapon.MyForm.Markup / 100.0m;
                            }

                            // Multiply the cost if applicable.
                            char chrAvail = (await objWeapon.TotalAvailTupleAsync(token: token).ConfigureAwait(false))
                                .Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            // Check the item's Cost and make sure the character can afford it.
                            if (decCost > await CharacterObject.GetNuyenAsync(token).ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: token)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen", token: token)
                                        .ConfigureAwait(false), MessageBoxButtons.OK,
                                    MessageBoxIcon.Information, token: token).ConfigureAwait(false);

                                return frmPickWeapon.MyForm.AddAgain;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                await LanguageManager
                                    .GetStringAsync("String_ExpensePurchaseVehicleWeapon", token: token)
                                    .ConfigureAwait(false)
                                + await LanguageManager.GetStringAsync("String_Space", token: token)
                                    .ConfigureAwait(false)
                                + await objWeapon.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                ExpenseType.Nuyen,
                                DateTime.Now);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: token)
                                .ConfigureAwait(false);
                            await CharacterObject.ModifyNuyenAsync(-decCost, token).ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddVehicleWeapon, objWeapon.InternalId);
                            objExpense.Undo = objUndo;
                        }

                        if (objMod != null)
                            await objMod.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                        else
                            await objWeaponMount.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);

                        foreach (Weapon objLoopWeapon in lstWeapons)
                        {
                            if (objMod != null)
                                await objMod.Weapons.AddAsync(objLoopWeapon, token).ConfigureAwait(false);
                            else
                                await objWeaponMount.Weapons.AddAsync(objLoopWeapon, token).ConfigureAwait(false);
                        }

                        return frmPickWeapon.MyForm.AddAgain && (objMod != null || !objWeaponMount.IsWeaponsFull);
                    }
                    catch
                    {
                        foreach (Weapon objLoopWeapon in lstWeapons)
                            await objLoopWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                        await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async void tsVehicleAddWeaponMount_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Vehicle
                        objVehicle))
                    return;
                WeaponMount objNewWeaponMount;
                decimal decMarkup;
                using (ThreadSafeForm<CreateWeaponMount> frmCreateWeaponMount
                       = await ThreadSafeForm<CreateWeaponMount>.GetAsync(
                           () => new CreateWeaponMount(objVehicle, CharacterObject), GenericToken).ConfigureAwait(false))
                {
                    if (await frmCreateWeaponMount.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    objNewWeaponMount = frmCreateWeaponMount.MyForm.WeaponMount;
                    decMarkup = frmCreateWeaponMount.MyForm.Markup;
                }

                if (objNewWeaponMount.FreeCost)
                    await objVehicle.WeaponMounts.AddAsync(objNewWeaponMount, GenericToken).ConfigureAwait(false);
                else
                {
                    // Calculate cost based on total vehicle cost change to make sure we capture everything
                    decimal decCost = -await objVehicle.GetTotalCostAsync(GenericToken).ConfigureAwait(false);
                    await objVehicle.WeaponMounts.AddAsync(objNewWeaponMount, GenericToken).ConfigureAwait(false);
                    decCost += await objVehicle.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                    // Apply a markup if applicable.
                    if (decMarkup != 0)
                    {
                        decCost *= 1 + decMarkup / 100.0m;
                    }

                    // Multiply the cost if applicable.
                    char chrAvail = (await objNewWeaponMount.TotalAvailTupleAsync(token: GenericToken).ConfigureAwait(false)).Suffix;
                    switch (chrAvail)
                    {
                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                            break;

                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                            break;
                    }

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(decCost * -1,
                                      await LanguageManager.GetStringAsync("String_ExpensePurchaseVehicleWeaponMount", token: GenericToken)
                                                           .ConfigureAwait(false)
                                      + await LanguageManager.GetStringAsync("String_Space", token: GenericToken).ConfigureAwait(false)
                                      + await objNewWeaponMount.GetCurrentDisplayNameShortAsync(GenericToken)
                                                               .ConfigureAwait(false), ExpenseType.Nuyen,
                                      DateTime.Now);
                    await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken).ConfigureAwait(false);
                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken).ConfigureAwait(false);

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateNuyen(NuyenExpenseType.AddVehicleWeaponMount, objNewWeaponMount.InternalId);
                    objExpense.Undo = objUndo;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsEditWeaponMount_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                            .ConfigureAwait(false) is WeaponMount
                        objWeaponMount))
                    return;

                Vehicle objVehicle = objWeaponMount.Parent;
                decimal decOldVehicleCost = await objVehicle.GetTotalCostAsync(GenericToken).ConfigureAwait(false);
                string strOldName = await objWeaponMount.GetCurrentDisplayNameShortAsync(GenericToken)
                    .ConfigureAwait(false);
                decimal decMarkup;
                using (ThreadSafeForm<CreateWeaponMount> frmCreateWeaponMount
                       = await ThreadSafeForm<CreateWeaponMount>.GetAsync(
                           () => new CreateWeaponMount(objVehicle, CharacterObject, objWeaponMount),
                           GenericToken).ConfigureAwait(false))
                {
                    if (await frmCreateWeaponMount.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;
                    decMarkup = frmCreateWeaponMount.MyForm.Markup;
                }

                decimal decCost = await objVehicle.GetTotalCostAsync(GenericToken).ConfigureAwait(false) - decOldVehicleCost;

                // Apply a markup if applicable.
                if (decMarkup != 0)
                {
                    decCost *= 1 + decMarkup / 100.0m;
                }

                // Multiply the cost if applicable.
                char chrAvail = (await objWeaponMount.TotalAvailTupleAsync(token: GenericToken).ConfigureAwait(false)).Suffix;
                switch (chrAvail)
                {
                    case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                        decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                        break;

                    case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                        decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                        break;
                }

                string strNewName = await objWeaponMount.GetCurrentDisplayNameShortAsync(GenericToken)
                    .ConfigureAwait(false);

                if (strNewName != strOldName)
                {
                    string strSpace = await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                        .ConfigureAwait(false);
                    strNewName = strOldName + strSpace + "->" + strSpace + strNewName;
                }

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(decCost * -1,
                    string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("String_ExpenseVehicleRetrofit", token: GenericToken)
                        .ConfigureAwait(false), strNewName), ExpenseType.Nuyen,
                    DateTime.Now);
                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken).ConfigureAwait(false);
                await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken).ConfigureAwait(false);

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateNuyen(NuyenExpenseType.ModifyVehicleWeaponMount, objWeaponMount.InternalId);
                objExpense.Undo = objUndo;
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleAddWeaponAccessory_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Weapon
                        objWeapon))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_VehicleWeaponAccessories", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_VehicleWeaponAccessories", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Weapons XML file and locate the selected Weapon.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("weapons.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                XmlNode objXmlWeapon = await objWeapon.GetNodeAsync(GenericToken).ConfigureAwait(false);
                if (objXmlWeapon == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CannotFindWeapon", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;

                do
                {
                    // Make sure the Weapon allows Accessories to be added to it.
                    if (!objWeapon.AllowAccessory)
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_CannotModifyWeapon", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon", token: GenericToken)
                                .ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                    }

                    using (ThreadSafeForm<SelectWeaponAccessory> frmPickWeaponAccessory
                           = await ThreadSafeForm<SelectWeaponAccessory>.GetAsync(
                               () => new SelectWeaponAccessory(CharacterObject), GenericToken).ConfigureAwait(false))
                    {
                        await frmPickWeaponAccessory.MyForm.SetWeapon(objWeapon, GenericToken).ConfigureAwait(false);
                        if (await frmPickWeaponAccessory.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickWeaponAccessory.MyForm.AddAgain;

                        // Locate the selected piece.
                        objXmlWeapon = objXmlDocument.TryGetNodeByNameOrId("/chummer/accessories/accessory", frmPickWeaponAccessory.MyForm.SelectedAccessory);

                        WeaponAccessory objAccessory = new WeaponAccessory(CharacterObject);
                        try
                        {
                            await objAccessory.CreateAsync(objXmlWeapon, frmPickWeaponAccessory.MyForm.SelectedMount,
                                frmPickWeaponAccessory.MyForm.SelectedRating, token: GenericToken).ConfigureAwait(false);
                            await objAccessory.SetParentAsync(objWeapon, GenericToken).ConfigureAwait(false);

                            // Check the item's Cost and make sure the character can afford it.
                            decimal intOriginalCost = await objWeapon.GetTotalCostAsync(GenericToken).ConfigureAwait(false);
                            await objWeapon.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);

                            if (!frmPickWeaponAccessory.MyForm.FreeCost)
                            {
                                decimal decCost = await objWeapon.GetTotalCostAsync(GenericToken).ConfigureAwait(false) - intOriginalCost;
                                // Apply a markup if applicable.
                                if (frmPickWeaponAccessory.MyForm.Markup != 0)
                                {
                                    decCost *= 1 + frmPickWeaponAccessory.MyForm.Markup / 100.0m;
                                }

                                // Multiply the cost if applicable.
                                char chrAvail = (await objAccessory.TotalAvailTupleAsync(token: GenericToken).ConfigureAwait(false)).Suffix;
                                switch (chrAvail)
                                {
                                    case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                        decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                        break;

                                    case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                        decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                        break;
                                }

                                if (decCost > await CharacterObject.GetNuyenAsync(GenericToken).ConfigureAwait(false))
                                {
                                    await objWeapon.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: GenericToken)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen", token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                    continue;
                                }

                                // Create the Expense Log Entry.
                                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                objExpense.Create(decCost * -1,
                                                  await LanguageManager.GetStringAsync(
                                                      "String_ExpensePurchaseVehicleWeaponAccessory", token: GenericToken).ConfigureAwait(false)
                                                  + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                                                         .ConfigureAwait(false)
                                                  + await objAccessory.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                      .ConfigureAwait(false),
                                                  ExpenseType.Nuyen, DateTime.Now);
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken).ConfigureAwait(false);
                                await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken).ConfigureAwait(false);

                                ExpenseUndo objUndo = new ExpenseUndo();
                                objUndo.CreateNuyen(NuyenExpenseType.AddVehicleWeaponAccessory, objAccessory.InternalId);
                                objExpense.Undo = objUndo;
                            }
                        }
                        catch
                        {
                            await objAccessory.DeleteWeaponAccessoryAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task<bool> AddUnderbarrelWeapon(Weapon objSelectedWeapon, string strExpenseString,
                                                           CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(
                           () => new SelectWeapon(CharacterObject)
                           {
                               LimitToCategories = "Underbarrel Weapons",
                               ParentWeapon = objSelectedWeapon
                           }, token).ConfigureAwait(false))
                {
                    frmPickWeapon.MyForm.Mounts.UnionWith(
                        await objSelectedWeapon.GetAccessoryMountsAsync(token: token));

                    // Make sure the dialogue window was not canceled.
                    if (await frmPickWeapon.ShowDialogSafeAsync(this, token).ConfigureAwait(false) ==
                        DialogResult.Cancel)
                        return false;

                    // Open the Weapons XML file and locate the selected piece.
                    XmlDocument objXmlDocument
                        = await CharacterObject.LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false);

                    XmlNode objXmlWeapon = objXmlDocument.TryGetNodeByNameOrId("/chummer/weapons/weapon",
                        frmPickWeapon.MyForm.SelectedWeapon);

                    List<Weapon> lstWeapons = new List<Weapon>(1);
                    Weapon objWeapon = new Weapon(CharacterObject);
                    try
                    {
                        await objWeapon.SetParentAsync(objSelectedWeapon, token).ConfigureAwait(false);
                        await objWeapon.CreateAsync(objXmlWeapon, lstWeapons, token: token).ConfigureAwait(false);
                        objWeapon.DiscountCost = frmPickWeapon.MyForm.BlackMarketDiscount;
                        if (!objSelectedWeapon.AllowAccessory)
                            objWeapon.AllowAccessory = false;

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickWeapon.MyForm.FreeCost)
                        {
                            decimal decCost = await objWeapon.GetTotalCostAsync(token).ConfigureAwait(false);
                            // Apply a markup if applicable.
                            if (frmPickWeapon.MyForm.Markup != 0)
                            {
                                decCost *= 1 + frmPickWeapon.MyForm.Markup / 100.0m;
                            }

                            // Multiply the cost if applicable.
                            char chrAvail = (await objWeapon.TotalAvailTupleAsync(token: token).ConfigureAwait(false))
                                .Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > await CharacterObject.GetNuyenAsync(token).ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: token)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen", token: token)
                                        .ConfigureAwait(false), MessageBoxButtons.OK,
                                    MessageBoxIcon.Information, token: token).ConfigureAwait(false);
                                return frmPickWeapon.MyForm.AddAgain;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                strExpenseString
                                + await LanguageManager.GetStringAsync("String_Space", token: token)
                                    .ConfigureAwait(false)
                                + await objWeapon.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                ExpenseType.Nuyen, DateTime.Now);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: token)
                                .ConfigureAwait(false);
                            await CharacterObject.ModifyNuyenAsync(-decCost, token).ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddVehicleWeapon, objWeapon.InternalId);
                            objExpense.Undo = objUndo;
                        }

                        await objSelectedWeapon.UnderbarrelWeapons.AddAsync(objWeapon, token).ConfigureAwait(false);

                        foreach (Weapon objLoopWeapon in lstWeapons)
                        {
                            if (!objSelectedWeapon.AllowAccessory)
                                objLoopWeapon.AllowAccessory = false;
                            await objSelectedWeapon.UnderbarrelWeapons.AddAsync(objLoopWeapon, token).ConfigureAwait(false);
                        }

                        return frmPickWeapon.MyForm.AddAgain;
                    }
                    catch
                    {
                        foreach (Weapon objLoopWeapon in lstWeapons)
                            await objLoopWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                        await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async void tsVehicleAddUnderbarrelWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                // Attempt to locate the selected VehicleWeapon.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Weapon
                        objWeapon))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_VehicleWeaponUnderbarrel", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_VehicleWeaponUnderbarrel", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddUnderbarrelWeapon(
                        objWeapon,
                        await LanguageManager.GetStringAsync("String_ExpensePurchaseVehicleWeapon", token: GenericToken)
                                             .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMartialArtsAddTechnique_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treMartialArts.DoThreadSafeFuncAsync(x =>
                {
                    TreeNode objReturn = x.SelectedNode;
                    while (objReturn?.Level > 1)
                        objReturn = objReturn.Parent;
                    return objReturn;
                }, GenericToken).ConfigureAwait(false);
                if (objSelectedNode != null)
                {
                    if (!(objSelectedNode.Tag is MartialArt objMartialArt))
                        return;

                    bool blnAddAgain = false;
                    do
                    {
                        using (ThreadSafeForm<SelectMartialArtTechnique> frmPickMartialArtTechnique
                               = await ThreadSafeForm<SelectMartialArtTechnique>.GetAsync(
                                       () => new SelectMartialArtTechnique(CharacterObject, objMartialArt),
                                       GenericToken)
                                   .ConfigureAwait(false))
                        {
                            if (await frmPickMartialArtTechnique.ShowDialogSafeAsync(this, GenericToken)
                                                                .ConfigureAwait(false)
                                == DialogResult.Cancel)
                                return;

                            // Open the Martial Arts XML file and locate the selected piece.
                            XmlNode xmlTechnique
                                = (await CharacterObject.LoadDataAsync("martialarts.xml", token: GenericToken)
                                                        .ConfigureAwait(false))
                                .TryGetNodeByNameOrId("/chummer/techniques/technique", frmPickMartialArtTechnique.MyForm.SelectedTechnique);

                            if (xmlTechnique == null)
                                continue;
                            // Create the Improvements for the Technique if there are any.
                            MartialArtTechnique objTechnique = new MartialArtTechnique(CharacterObject);
                            await objTechnique.CreateAsync(xmlTechnique, GenericToken).ConfigureAwait(false);
                            if (objTechnique.InternalId.IsEmptyGuid())
                                return;

                            blnAddAgain = frmPickMartialArtTechnique.MyForm.AddAgain;

                            int karmaCost = await objMartialArt.Techniques.GetCountAsync(GenericToken).ConfigureAwait(false) > 0
                                ? await CharacterObjectSettings.GetKarmaTechniqueAsync(GenericToken).ConfigureAwait(false)
                                : 0;
                            await objMartialArt.Techniques.AddAsync(objTechnique, GenericToken).ConfigureAwait(false);

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(karmaCost * -1,
                                              await LanguageManager
                                                    .GetStringAsync("String_ExpenseLearnTechnique", token: GenericToken)
                                                    .ConfigureAwait(false)
                                              + await LanguageManager
                                                      .GetStringAsync("String_Space", token: GenericToken)
                                                      .ConfigureAwait(false)
                                              + await objTechnique.GetCurrentDisplayNameAsync(GenericToken)
                                                                  .ConfigureAwait(false),
                                              ExpenseType.Karma, DateTime.Now);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                                 .ConfigureAwait(false);
                            await CharacterObject.ModifyKarmaAsync(-karmaCost, GenericToken).ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateKarma(KarmaExpenseType.AddMartialArtTechnique, objTechnique.InternalId);
                            objExpense.Undo = objUndo;
                        }
                    } while (blnAddAgain);
                }
                else
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectMartialArtTechnique", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectMartialArtTechnique", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                Vehicle objSelectedVehicle;
                Location objLocation = null;
                TreeNode objSelectedNode = await treVehicles
                                                 .DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                 .ConfigureAwait(false);
                switch (objSelectedNode?.Tag)
                {
                    case Vehicle vehicle:
                        objSelectedVehicle = vehicle;
                        break;

                    case Location location:
                        objLocation = location;
                        objSelectedVehicle = objSelectedNode.Parent.Tag as Vehicle;
                        break;

                    default:
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_SelectGearVehicle", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_SelectGearVehicle", token: GenericToken)
                                .ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                }

                await PurchaseVehicleGear(objSelectedVehicle, objLocation, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleSensorAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Gear window.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                              GenericToken).ConfigureAwait(false) is Gear objSensor))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strCategories = string.Empty;
                XPathNavigator objSensorNode = await objSensor.GetNodeXPathAsync(GenericToken).ConfigureAwait(false);
                XPathNodeIterator xmlAddonCategoryList = objSensorNode?.SelectAndCacheExpression("addoncategory", GenericToken);
                if (xmlAddonCategoryList?.Count > 0)
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                            sbdCategories.Append(objXmlCategory.Value, ',');
                        // Remove the trailing comma.
                        --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }
                }

                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                           () => new SelectGear(CharacterObject, objGearParent: objSensor, strAllowedCategories: strCategories), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                         && (!objSensor.Capacity.Contains('[')
                                                                             || objSensor.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                // Open the Gear XML file and locate the selected piece.
                                XmlNode objXmlGear = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                    frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    false, token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";

                                // Check the item's Cost and make sure the character can afford it.
                                if (!frmPickGear.MyForm.FreeCost)
                                {
                                    decimal decCost =
                                        await objGear.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                                    // Apply a markup if applicable.
                                    if (frmPickGear.MyForm.Markup != 0)
                                    {
                                        decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                                    }

                                    // Multiply the cost if applicable.
                                    char chrAvail = (await objGear.TotalAvailTupleAsync(token: GenericToken)
                                        .ConfigureAwait(false)).Suffix;
                                    switch (chrAvail)
                                    {
                                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                            break;

                                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                            break;
                                    }

                                    if (decCost > await CharacterObject.GetNuyenAsync(GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager.GetStringAsync("Message_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        continue;
                                    }

                                    // Create the Expense Log Entry.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(decCost * -1,
                                        await LanguageManager.GetStringAsync(
                                                "String_ExpensePurchaseVehicleGear", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Nuyen,
                                        DateTime.Now);
                                    await CharacterObject.ExpenseEntries
                                        .AddWithSortAsync(objExpense, token: GenericToken).ConfigureAwait(false);
                                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken)
                                        .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateNuyen(NuyenExpenseType.AddVehicleGear, objGear.InternalId,
                                        frmPickGear.MyForm.SelectedQty);
                                    objExpense.Undo = objUndo;
                                }

                                await objSensor.Children.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                                if (lstWeapons.Count > 0)
                                {
                                    Vehicle objVehicle =
                                        (await CharacterObject.Vehicles.FindVehicleGearAsync(objSensor.InternalId,
                                            GenericToken).ConfigureAwait(false)).Item2;
                                    foreach (Weapon objWeapon in lstWeapons)
                                    {
                                        await objVehicle.Weapons.AddAsync(objWeapon, GenericToken)
                                            .ConfigureAwait(false);
                                    }
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmsAmmoSingleShot_Click(object sender, EventArgs e)
        {
            try
            {
                await DoSingleShot(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DoSingleShot(CancellationToken token = default)
        {
            // Locate the selected Weapon.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                    Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining < objWeapon.SingleShot)
            {
                await Program.ShowScrollableMessageBoxAsync(
                    this, await LanguageManager.GetStringAsync("Message_OutOfAmmo", token: token).ConfigureAwait(false),
                    await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo", token: token).ConfigureAwait(false),
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false);
                return;
            }

            await objWeapon.SetAmmoRemaining(objWeapon.AmmoRemaining - objWeapon.SingleShot, token).ConfigureAwait(false);

            await lblWeaponAmmoRemaining
                  .DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo), token)
                  .ConfigureAwait(false);

            await SetDirty(true, token).ConfigureAwait(false);
        }

        private async void cmsAmmoShortBurst_Click(object sender, EventArgs e)
        {
            try
            {
                await DoShortBurst(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DoShortBurst(CancellationToken token = default)
        {
            // Locate the selected Weapon.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, CancellationToken.None)
                                  .ConfigureAwait(false) is Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                await Program.ShowScrollableMessageBoxAsync(
                    this, await LanguageManager.GetStringAsync("Message_OutOfAmmo", token: token).ConfigureAwait(false),
                    await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo", token: token).ConfigureAwait(false),
                    MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.ShortBurst)
            {
                await objWeapon.SetAmmoRemaining(objWeapon.AmmoRemaining - objWeapon.ShortBurst, token).ConfigureAwait(false);
            }
            else
            {
                if (objWeapon.AmmoRemaining == objWeapon.SingleShot)
                {
                    if (await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSingleShot", token: token)
                                .ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                                .ConfigureAwait(false), MessageBoxButtons.YesNo,
                            MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                        await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);
                }
                else
                {
                    if (await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurstShort", token: token)
                                .ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                                .ConfigureAwait(false), MessageBoxButtons.YesNo,
                            MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                        await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);
                }
            }

            await lblWeaponAmmoRemaining
                  .DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo), token)
                  .ConfigureAwait(false);

            await SetDirty(true, token).ConfigureAwait(false);
        }

        private async void cmsAmmoLongBurst_Click(object sender, EventArgs e)
        {
            try
            {
                await DoLongBurst(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DoLongBurst(CancellationToken token = default)
        {
            // Locate the selected Weapon.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                    Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                await Program.ShowScrollableMessageBoxAsync(
                    this, await LanguageManager.GetStringAsync("Message_OutOfAmmo", token: token).ConfigureAwait(false),
                    await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo", token: token).ConfigureAwait(false),
                    MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.LongBurst)
            {
                await objWeapon.SetAmmoRemaining(objWeapon.AmmoRemaining - objWeapon.LongBurst, token).ConfigureAwait(false);
            }
            else if (objWeapon.AmmoRemaining == objWeapon.SingleShot)
            {
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSingleShot", token: token)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                            .ConfigureAwait(false), MessageBoxButtons.YesNo,
                        MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                    await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);
            }
            else if (objWeapon.AmmoRemaining > objWeapon.ShortBurst)
            {
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_NotEnoughAmmoLongBurstShort", token: token)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                            .ConfigureAwait(false), MessageBoxButtons.YesNo,
                        MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                    await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);
            }
            else if (objWeapon.AmmoRemaining == objWeapon.ShortBurst)
            {
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurst", token: token)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                            .ConfigureAwait(false), MessageBoxButtons.YesNo,
                        MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                    await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);
            }
            else if (await Program.ShowScrollableMessageBoxAsync(
                         this,
                         await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurstShort", token: token)
                             .ConfigureAwait(false),
                         await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                             .ConfigureAwait(false), MessageBoxButtons.YesNo,
                         MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);

            await lblWeaponAmmoRemaining
                  .DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo), token)
                  .ConfigureAwait(false);

            await SetDirty(true, token).ConfigureAwait(false);
        }

        private async void cmsAmmoFullBurst_Click(object sender, EventArgs e)
        {
            try
            {
                // Locate the selected Weapon.
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                             GenericToken).ConfigureAwait(false) is Weapon objWeapon))
                    return;
                if (objWeapon.AmmoRemaining == 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_OutOfAmmo", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                if (objWeapon.AmmoRemaining >= objWeapon.FullBurst)
                {
                    await objWeapon.SetAmmoRemaining(objWeapon.AmmoRemaining - objWeapon.FullBurst, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_NotEnoughAmmoFullBurst", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false);
                }

                await lblWeaponAmmoRemaining.DoThreadSafeAsync(
                                                x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings
                                                    .CultureInfo), GenericToken)
                                            .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmsAmmoSuppressiveFire_Click(object sender, EventArgs e)
        {
            try
            {
                // Locate the selected Weapon.
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                             GenericToken).ConfigureAwait(false) is Weapon objWeapon))
                    return;
                if (objWeapon.AmmoRemaining == 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_OutOfAmmo", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                if (objWeapon.AmmoRemaining >= objWeapon.Suppressive)
                {
                    await objWeapon.SetAmmoRemaining(objWeapon.AmmoRemaining - objWeapon.Suppressive, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSuppressiveFire", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false);
                }

                await lblWeaponAmmoRemaining.DoThreadSafeAsync(
                                                x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings
                                                    .CultureInfo), GenericToken)
                                            .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmsVehicleAmmoSingleShot_Click(object sender, EventArgs e)
        {
            try
            {
                await DoVehicleAmmoSingleShot(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DoVehicleAmmoSingleShot(CancellationToken token = default)
        {
            // Locate the selected Vehicle Weapon.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                    Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining < objWeapon.SingleShot)
            {
                await Program.ShowScrollableMessageBoxAsync(
                    this, await LanguageManager.GetStringAsync("Message_OutOfAmmo", token: token).ConfigureAwait(false),
                    await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo", token: token).ConfigureAwait(false),
                    MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false);
                return;
            }

            await objWeapon.SetAmmoRemaining(objWeapon.AmmoRemaining - objWeapon.SingleShot, token).ConfigureAwait(false);

            await lblVehicleWeaponAmmoRemaining
                  .DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo), token)
                  .ConfigureAwait(false);

            await SetDirty(true, token).ConfigureAwait(false);
        }

        private async void cmsVehicleAmmoShortBurst_Click(object sender, EventArgs e)
        {
            try
            {
                await DoVehicleAmmoShortBurst(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DoVehicleAmmoShortBurst(CancellationToken token = default)
        {
            // Locate the selected Vehicle Weapon.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                    Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                await Program.ShowScrollableMessageBoxAsync(
                    this, await LanguageManager.GetStringAsync("Message_OutOfAmmo", token: token).ConfigureAwait(false),
                    await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo", token: token).ConfigureAwait(false),
                    MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.ShortBurst)
            {
                await objWeapon.SetAmmoRemaining(objWeapon.AmmoRemaining - objWeapon.ShortBurst, token).ConfigureAwait(false);
            }
            else if (objWeapon.AmmoRemaining == objWeapon.SingleShot)
            {
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSingleShot", token: token)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                            .ConfigureAwait(false), MessageBoxButtons.YesNo,
                        MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                    await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);
            }
            else if (await Program.ShowScrollableMessageBoxAsync(
                         this,
                         await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurstShort", token: token)
                             .ConfigureAwait(false),
                         await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                             .ConfigureAwait(false), MessageBoxButtons.YesNo,
                         MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);

            await lblVehicleWeaponAmmoRemaining
                  .DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo), token)
                  .ConfigureAwait(false);

            await SetDirty(true, token).ConfigureAwait(false);
        }

        private async void cmsVehicleAmmoLongBurst_Click(object sender, EventArgs e)
        {
            try
            {
                await DoVehicleAmmoLongBurst(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DoVehicleAmmoLongBurst(CancellationToken token = default)
        {
            // Locate the selected Vehicle Weapon.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                    Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                await Program.ShowScrollableMessageBoxAsync(
                    this, await LanguageManager.GetStringAsync("Message_OutOfAmmo", token: token).ConfigureAwait(false),
                    await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo", token: token).ConfigureAwait(false),
                    MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.LongBurst)
            {
                await objWeapon.SetAmmoRemaining(objWeapon.AmmoRemaining - objWeapon.LongBurst, token).ConfigureAwait(false);
            }
            else if (objWeapon.AmmoRemaining == objWeapon.SingleShot)
            {
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSingleShot", token: token)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                            .ConfigureAwait(false), MessageBoxButtons.YesNo,
                        MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                    await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);
            }
            else if (objWeapon.AmmoRemaining > objWeapon.ShortBurst)
            {
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_NotEnoughAmmoLongBurstShort", token: token)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                            .ConfigureAwait(false), MessageBoxButtons.YesNo,
                        MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                    await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);
            }
            else if (objWeapon.AmmoRemaining == objWeapon.ShortBurst)
            {
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurst", token: token)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                            .ConfigureAwait(false), MessageBoxButtons.YesNo,
                        MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                    await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);
            }
            else if (await Program.ShowScrollableMessageBoxAsync(
                         this,
                         await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurstShort", token: token)
                             .ConfigureAwait(false),
                         await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: token)
                             .ConfigureAwait(false), MessageBoxButtons.YesNo,
                         MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false) == DialogResult.Yes)
                await objWeapon.SetAmmoRemaining(0, token).ConfigureAwait(false);

            await lblVehicleWeaponAmmoRemaining
                  .DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo), token)
                  .ConfigureAwait(false);

            await SetDirty(true, token).ConfigureAwait(false);
        }

        private async void cmsVehicleAmmoFullBurst_Click(object sender, EventArgs e)
        {
            try
            {
                // Locate the selected Vehicle Weapon.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Weapon
                        objWeapon))
                    return;
                if (objWeapon.AmmoRemaining == 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_OutOfAmmo", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                if (objWeapon.AmmoRemaining >= objWeapon.FullBurst)
                {
                    await objWeapon.SetAmmoRemaining(objWeapon.AmmoRemaining - objWeapon.FullBurst, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_NotEnoughAmmoFullBurst", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false);
                }

                await lblVehicleWeaponAmmoRemaining.DoThreadSafeAsync(
                                                       x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings
                                                           .CultureInfo), GenericToken)
                                                   .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmsVehicleAmmoSuppressiveFire_Click(object sender, EventArgs e)
        {
            try
            {
                // Locate the selected Vehicle Weapon.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Weapon
                        objWeapon))
                    return;
                if (objWeapon.AmmoRemaining == 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_OutOfAmmo", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                if (objWeapon.AmmoRemaining >= objWeapon.Suppressive)
                {
                    await objWeapon.SetAmmoRemaining(objWeapon.AmmoRemaining - objWeapon.Suppressive, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSuppressiveFire", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false);
                }

                await lblVehicleWeaponAmmoRemaining.DoThreadSafeAsync(
                                                       x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings
                                                           .CultureInfo), GenericToken)
                                                   .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareSell_Click(object sender, EventArgs e)
        {
            try
            {
                switch (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                          .ConfigureAwait(false))
                {
                    case Cyberware objCyberware when objCyberware.Capacity == "[*]" && await objCyberware.GetParentAsync(GenericToken).ConfigureAwait(false) != null:
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_CannotRemoveCyberware", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_CannotRemoveCyberware", token: GenericToken)
                                .ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;

                    case ICanSell vendorTrash:
                    {
                        using (ThreadSafeForm<SellItem> frmSell
                               = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem(), GenericToken)
                                                               .ConfigureAwait(false))
                        {
                            if (await frmSell.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                return;
                            await vendorTrash.SellAsync(frmSell.MyForm.SellPercent, GlobalSettings.ConfirmDelete, GenericToken).ConfigureAwait(false);
                        }

                        break;
                    }
                    default:
                        Utils.BreakIfDebug();
                        break;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorSell_Click(object sender, EventArgs e)
        {
            try
            {
                if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                         GenericToken).ConfigureAwait(false) is ICanSell vendorTrash)
                {
                    using (ThreadSafeForm<SellItem> frmSell
                           = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem(), GenericToken)
                                                           .ConfigureAwait(false))
                    {
                        if (await frmSell.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;
                        await vendorTrash.SellAsync(frmSell.MyForm.SellPercent, GlobalSettings.ConfirmDelete, GenericToken).ConfigureAwait(false);
                    }
                }
                else
                {
                    Utils.BreakIfDebug();
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponSell_Click(object sender, EventArgs e)
        {
            try
            {
                // Delete the selected Weapon.
                if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is ICanSell
                    vendorTrash)
                {
                    using (ThreadSafeForm<SellItem> frmSell
                           = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem(), GenericToken)
                                                           .ConfigureAwait(false))
                    {
                        if (await frmSell.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;
                        await vendorTrash.SellAsync(frmSell.MyForm.SellPercent, GlobalSettings.ConfirmDelete, GenericToken).ConfigureAwait(false);
                    }
                }
                else
                {
                    Utils.BreakIfDebug();
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void sellItemToolStripMenuItem_Click(object sender, EventArgs e)
        {
            try
            {
                // Delete the selected Weapon.
                if (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    ICanSell vendorTrash)
                {
                    using (ThreadSafeForm<SellItem> frmSell
                           = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem(), GenericToken)
                                                           .ConfigureAwait(false))
                    {
                        if (await frmSell.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;
                        await vendorTrash.SellAsync(frmSell.MyForm.SellPercent, GlobalSettings.ConfirmDelete, GenericToken).ConfigureAwait(false);
                    }
                }
                else
                {
                    Utils.BreakIfDebug();
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleSell_Click(object sender, EventArgs e)
        {
            try
            {
                // Delete the selected Weapon.
                if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                     .ConfigureAwait(false) is ICanSell
                    vendorTrash)
                {
                    using (ThreadSafeForm<SellItem> frmSell
                           = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem(), GenericToken)
                                                           .ConfigureAwait(false))
                    {
                        if (await frmSell.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;
                        await vendorTrash.SellAsync(frmSell.MyForm.SellPercent, GlobalSettings.ConfirmDelete, GenericToken).ConfigureAwait(false);
                    }
                }
                else
                {
                    Utils.BreakIfDebug();
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAdvancedLifestyle_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        Lifestyle objLifestyle = new Lifestyle(CharacterObject);
                        try
                        {
                            await objLifestyle.SetStyleTypeAsync(LifestyleType.Advanced, GenericToken).ConfigureAwait(false);
                            using (ThreadSafeForm<SelectLifestyle> frmPickLifestyle
                                   = await ThreadSafeForm<SelectLifestyle>.GetAsync(
                                           () => new SelectLifestyle(
                                               CharacterObject, objLifestyle),
                                           GenericToken)
                                       .ConfigureAwait(false))
                            {
                                // Make sure the dialogue window was not canceled.
                                if (await frmPickLifestyle.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                {
                                    //And if it was, remove Improvements that was already added based on the lifestyle
                                    await objLifestyle.RemoveAsync(false, GenericToken).ConfigureAwait(false);
                                    return;
                                }

                                blnAddAgain = frmPickLifestyle.MyForm.AddAgain;

                                Lifestyle objNewLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;

                                await CharacterObject.Lifestyles.AddAsync(objNewLifestyle, GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }
                        catch
                        {
                            await objLifestyle.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponName_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent item is selected, then open the Select Accessory window.
                TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                           .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Weapon objWeapon))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectWeaponName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription = await LanguageManager.GetStringAsync("String_WeaponName", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objWeapon.CustomName,
                               AllowEmptyString = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objWeapon.CustomName = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objWeapon.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treWeapons.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearName_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Gear objGear))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectGearName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription = await LanguageManager.GetStringAsync("String_GearName", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objGear.GearName,
                               AllowEmptyString = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objGear.GearName = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                             .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponAddUnderbarrel_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent item is selected, then open the Select Accessory window.
                TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Weapon objSelectedWeapon))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectWeaponAccessory", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                if (objSelectedWeapon.Cyberware)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_CyberwareUnderbarrel", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_WeaponUnderbarrel", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddUnderbarrelWeapon(objSelectedWeapon,
                                                             await LanguageManager.GetStringAsync(
                                                                 "String_ExpensePurchaseWeapon", token: GenericToken).ConfigureAwait(false),
                                                             GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsUndoKarmaExpense_Click(object sender, EventArgs e)
        {
            try
            {
                ListViewItem objItem
                    = await lstKarma.DoThreadSafeFuncAsync(
                                        x => x.SelectedItems.Count > 0 ? lstKarma.SelectedItems[0] : null, GenericToken)
                                    .ConfigureAwait(false);

                if (objItem == null)
                {
                    return;
                }

                // Find the selected Karma Expense.
                ExpenseLogEntry objExpense
                    = (objItem.SubItems[3] as ListViewItemWithValue.ListViewSubItemWithValue)?.Value as ExpenseLogEntry;

                if (objExpense?.Undo == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_UndoNoHistory", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NoUndoHistory", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strUndoId = objExpense.Undo.ObjectId;

                if (objExpense.Undo.KarmaType == KarmaExpenseType.ImproveInitiateGrade)
                {
                    // Get the grade of the item we're undoing and make sure it's the highest grade
                    int intMaxGrade = 0;
                    await CharacterObject.InitiationGrades.ForEachAsync(x => intMaxGrade = Math.Max(intMaxGrade, x.Grade), GenericToken).ConfigureAwait(false);

                    InitiationGrade objGrade = await CharacterObject.InitiationGrades
                        .FirstOrDefaultAsync(x => x.InternalId == strUndoId, GenericToken).ConfigureAwait(false);
                    if (objGrade.Grade < intMaxGrade)
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_UndoNotHighestGrade", token: GenericToken)
                                .ConfigureAwait(false),
                            await LanguageManager
                                .GetStringAsync("MessageTitle_NotHighestGrade", token: GenericToken)
                                .ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                    }

                    if (await Program.ShowScrollableMessageBoxAsync(
                            this, await LanguageManager.GetStringAsync("Message_UndoExpense", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_UndoExpense", token: GenericToken).ConfigureAwait(false),
                            MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                        return;
                }
                else if (await Program.ShowScrollableMessageBoxAsync(
                             this, await LanguageManager.GetStringAsync("Message_UndoExpense", token: GenericToken).ConfigureAwait(false),
                             await LanguageManager.GetStringAsync("MessageTitle_UndoExpense", token: GenericToken).ConfigureAwait(false),
                             MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                    return;

                switch (objExpense.Undo.KarmaType)
                {
                    case KarmaExpenseType.ImproveAttribute:
                    {
                        await (await CharacterObject.GetAttributeAsync(strUndoId, token: GenericToken)
                                                    .ConfigureAwait(false)).Degrade(token: GenericToken)
                                                                           .ConfigureAwait(false);
                        break;
                    }
                    case KarmaExpenseType.AddPowerPoint:
                    {
                        await CharacterObject.ModifyMysticAdeptPowerPointsAsync(-1, GenericToken).ConfigureAwait(false);
                        break;
                    }
                    case KarmaExpenseType.AddQuality:
                    {
                        // Locate the Quality that was added.
                        for (int i = await CharacterObject.Qualities.GetCountAsync(GenericToken).ConfigureAwait(false)
                                     - 1;
                             i >= 0;
                             --i)
                        {
                            if (i >= await CharacterObject.Qualities.GetCountAsync(GenericToken).ConfigureAwait(false))
                                continue;
                            Quality objQuality = await CharacterObject.Qualities.GetValueAtAsync(i, GenericToken)
                                                                      .ConfigureAwait(false);
                            if (objQuality.InternalId == strUndoId)
                                await objQuality.DeleteQualityAsync(token: GenericToken).ConfigureAwait(false);
                        }
                    }
                        break;

                    case KarmaExpenseType.AddSpell:
                    {
                        // Locate the Spell that was added.
                        for (int i = await CharacterObject.Spells.GetCountAsync(GenericToken).ConfigureAwait(false) - 1;
                             i >= 0;
                             --i)
                        {
                            if (i >= await CharacterObject.Spells.GetCountAsync(GenericToken).ConfigureAwait(false))
                                continue;
                            Spell objSpell = await CharacterObject.Spells.GetValueAtAsync(i, GenericToken)
                                                                  .ConfigureAwait(false);
                            if (objSpell.InternalId == strUndoId)
                                await objSpell.RemoveAsync(false, GenericToken)
                                              .ConfigureAwait(false); // Remove the Spell from the character.
                        }

                        break;
                    }
                    case KarmaExpenseType.SkillSpec: // I am reasonably sure those 2 are the same. Was written looking at old AddSpecialization code
                    case KarmaExpenseType.AddSpecialization:
                    {
                        SkillSpecialization objSpec = CharacterObject.SkillsSection.KnowledgeSkills
                                                                     .SelectMany(x => x.Specializations)
                                                                     .FirstOrDefault(
                                                                         x => x.InternalId == strUndoId)
                                                      ?? CharacterObject.SkillsSection.Skills
                                                                        .SelectMany(x => x.Specializations)
                                                                        .FirstOrDefault(
                                                                            x => x.InternalId == strUndoId);
                        if (objSpec != null)
                            await objSpec.Parent.Specializations.RemoveAsync(objSpec, GenericToken)
                                         .ConfigureAwait(false);

                        break;
                    }
                    case KarmaExpenseType.ImproveSkillGroup:
                    {
                        // Locate the Skill Group that was affected. Old characters may have had the expense added as the Name instead of guid.
                        SkillGroup group
                            = await CharacterObject.SkillsSection.SkillGroups.FirstOrDefaultAsync(
                                                       g => g.InternalId == strUndoId || g.Name == strUndoId,
                                                       GenericToken)
                                                   .ConfigureAwait(false);

                        if (group != null)
                        {
                            if (await group.GetKarmaUnbrokenAsync(GenericToken).ConfigureAwait(false))
                                --group.Karma;
                            else
                            {
                                await Program.ShowScrollableMessageBoxAsync(this,
                                    await LanguageManager.GetStringAsync(
                                        "Message_UndoBrokenSkillGroup", token: GenericToken).ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync(
                                        "MessageTitle_UndoBrokenSkillGroup", token: GenericToken).ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Warning, token: GenericToken).ConfigureAwait(false);
                                return;
                            }
                        }

                        break;
                    }
                    case KarmaExpenseType.AddSkill:
                    {
                        // Locate the Skill that was affected.
                        Skill objSkill
                            = await CharacterObject.SkillsSection.Skills
                                                   .FirstOrDefaultAsync(s => s.InternalId == strUndoId, GenericToken)
                                                   .ConfigureAwait(false);
                        if (objSkill != null)
                        {
                            if (await objSkill.GetAllowDeleteAsync(GenericToken).ConfigureAwait(false))
                                await CharacterObject.SkillsSection.Skills.RemoveAsync(objSkill, GenericToken)
                                                     .ConfigureAwait(false);
                            else
                            {
                                await objSkill.SetBasePointsAsync(0, GenericToken).ConfigureAwait(false);
                                await objSkill.SetKarmaPointsAsync(0, GenericToken).ConfigureAwait(false);
                            }
                        }
                        else
                        {
                            KnowledgeSkill objKnowledgeSkill
                                = await CharacterObject.SkillsSection.KnowledgeSkills.FirstOrDefaultAsync(
                                    s => s.InternalId == strUndoId, GenericToken).ConfigureAwait(false);
                            if (objKnowledgeSkill != null)
                            {
                                if (await objKnowledgeSkill.GetAllowDeleteAsync(GenericToken).ConfigureAwait(false))
                                    await CharacterObject.SkillsSection.KnowledgeSkills
                                                         .RemoveAsync(objKnowledgeSkill, GenericToken)
                                                         .ConfigureAwait(false);
                                else
                                {
                                    await objKnowledgeSkill.SetBasePointsAsync(0, GenericToken).ConfigureAwait(false);
                                    await objKnowledgeSkill.SetKarmaPointsAsync(0, GenericToken).ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                // Old characters may have incorrectly had their ExpenseType set to AddSkill rather than ImproveSkillGroup.
                                // Since skill groups can never be deleted, we don't have/need an AddSkillGroup expense type.
                                // Locate the Skill Group that was affected.
                                SkillGroup group
                                    = await CharacterObject.SkillsSection.SkillGroups.FirstOrDefaultAsync(
                                        g => g.InternalId == strUndoId, GenericToken).ConfigureAwait(false);

                                if (group != null)
                                {
                                    if (await group.GetKarmaUnbrokenAsync(GenericToken).ConfigureAwait(false))
                                        --group.Karma;
                                    else
                                    {
                                        await Program.ShowScrollableMessageBoxAsync(this,
                                            await LanguageManager.GetStringAsync(
                                                    "Message_UndoBrokenSkillGroup", token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync(
                                                    "MessageTitle_UndoBrokenSkillGroup", token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Warning, token: GenericToken).ConfigureAwait(false);
                                        return;
                                    }
                                }
                            }
                        }

                        break;
                    }
                    case KarmaExpenseType.ImproveSkill:
                    {
                        // Locate the Skill that was affected.
                        Skill objSkill
                            = await CharacterObject.SkillsSection.Skills
                                                   .FirstOrDefaultAsync(s => s.InternalId == strUndoId, GenericToken)
                                                   .ConfigureAwait(false) ??
                              await CharacterObject.SkillsSection.KnowledgeSkills.FirstOrDefaultAsync(
                                  s => s.InternalId == strUndoId, GenericToken).ConfigureAwait(false);

                        if (objSkill != null)
                        {
                            IAsyncDisposable objLocker = await objSkill.LockObject.EnterWriteLockAsync(GenericToken)
                                                                       .ConfigureAwait(false);
                            try
                            {
                                GenericToken.ThrowIfCancellationRequested();
                                await objSkill
                                    .SetKarmaAsync(await objSkill.GetKarmaAsync(GenericToken).ConfigureAwait(false)
                                                   - 1, token: GenericToken).ConfigureAwait(false);
                            }
                            finally
                            {
                                await objLocker.DisposeAsync().ConfigureAwait(false);
                            }
                        }

                        break;
                    }
                    case KarmaExpenseType.AddMetamagic:
                    {
                        // Locate the Metamagic that was affected.
                        for (int i = await CharacterObject.Metamagics.GetCountAsync(GenericToken).ConfigureAwait(false)
                                     - 1;
                             i >= 0;
                             --i)
                        {
                            if (i >= await CharacterObject.Metamagics.GetCountAsync(GenericToken).ConfigureAwait(false))
                                continue;
                            Metamagic objMetamagic = await CharacterObject.Metamagics.GetValueAtAsync(i, GenericToken)
                                                                          .ConfigureAwait(false);
                            if (objMetamagic.InternalId == strUndoId)
                                await objMetamagic.RemoveAsync(false, GenericToken)
                                                  .ConfigureAwait(false); // Remove the Metamagic from the character.
                        }

                        break;
                    }
                    case KarmaExpenseType.ImproveInitiateGrade:
                    {
                        // Locate the Initiate Grade that was affected.
                        for (int i = await CharacterObject.InitiationGrades.GetCountAsync(GenericToken)
                                                          .ConfigureAwait(false) - 1;
                             i >= 0;
                             --i)
                        {
                            if (i >= await CharacterObject.InitiationGrades.GetCountAsync(GenericToken)
                                                          .ConfigureAwait(false))
                                continue;
                            InitiationGrade objGrade = await CharacterObject.InitiationGrades
                                                                            .GetValueAtAsync(i, GenericToken)
                                                                            .ConfigureAwait(false);
                            if (objGrade.InternalId == strUndoId)
                                await objGrade.RemoveAsync(false, GenericToken)
                                              .ConfigureAwait(false); // Remove the Grade from the character.
                        }

                        break;
                    }
                    case KarmaExpenseType.AddMartialArt:
                    {
                        // Locate the Martial Art that was affected.
                        for (int i = await CharacterObject.MartialArts.GetCountAsync(GenericToken).ConfigureAwait(false)
                                     - 1;
                             i >= 0;
                             --i)
                        {
                            if (i >= await CharacterObject.MartialArts.GetCountAsync(GenericToken)
                                                          .ConfigureAwait(false))
                                continue;
                            MartialArt objMartialArt = await CharacterObject.MartialArts
                                                                            .GetValueAtAsync(i, GenericToken)
                                                                            .ConfigureAwait(false);
                            if (objMartialArt.InternalId == strUndoId)
                                await objMartialArt.RemoveAsync(false, GenericToken)
                                                   .ConfigureAwait(false); // Remove the Martial Art from the character.
                        }

                        break;
                    }
                    case KarmaExpenseType.AddMartialArtTechnique:
                    {
                        // Locate the Martial Art Technique that was affected.
                        for (int i = await CharacterObject.MartialArts.GetCountAsync(GenericToken).ConfigureAwait(false)
                                     - 1;
                             i >= 0;
                             --i)
                        {
                            if (i >= await CharacterObject.MartialArts.GetCountAsync(GenericToken)
                                                          .ConfigureAwait(false))
                                continue;
                            MartialArt objMartialArt = await CharacterObject.MartialArts
                                                                            .GetValueAtAsync(i, GenericToken)
                                                                            .ConfigureAwait(false);
                            for (int j = await objMartialArt.Techniques.GetCountAsync(GenericToken)
                                                            .ConfigureAwait(false) - 1;
                                 j >= 0;
                                 --j)
                            {
                                if (j >= await objMartialArt.Techniques.GetCountAsync(GenericToken)
                                                            .ConfigureAwait(false))
                                    continue;
                                MartialArtTechnique objTechnique = await objMartialArt.Techniques
                                    .GetValueAtAsync(j, GenericToken).ConfigureAwait(false);
                                if (objTechnique.InternalId == strUndoId)
                                    await objTechnique.RemoveAsync(false, GenericToken)
                                                      .ConfigureAwait(
                                                          false); // Remove the Technique from the character.
                            }
                        }

                        break;
                    }

                    case KarmaExpenseType.AddComplexForm:
                    {
                        // Locate the Complex Form that was affected.
                        for (int i = await CharacterObject.ComplexForms.GetCountAsync(GenericToken)
                                                          .ConfigureAwait(false) - 1;
                             i >= 0;
                             --i)
                        {
                            if (i >= await CharacterObject.ComplexForms.GetCountAsync(GenericToken)
                                                          .ConfigureAwait(false))
                                continue;
                            ComplexForm objComplexForm = await CharacterObject.ComplexForms
                                                                              .GetValueAtAsync(i, GenericToken)
                                                                              .ConfigureAwait(false);
                            if (objComplexForm.InternalId == strUndoId)
                                await objComplexForm.RemoveAsync(false, GenericToken)
                                                    .ConfigureAwait(
                                                        false); // Remove the Complex Form from the character.
                        }

                        break;
                    }
                    case KarmaExpenseType.BindFocus:
                    {
                        // Locate the Focus that was bound.
                        bool blnFound = false;
                        for (int i = await CharacterObject.Foci.GetCountAsync(GenericToken).ConfigureAwait(false) - 1;
                             i >= 0;
                             --i)
                        {
                            if (i >= await CharacterObject.Foci.GetCountAsync(GenericToken).ConfigureAwait(false))
                                continue;
                            Focus objFocus = await CharacterObject.Foci.GetValueAtAsync(i, GenericToken)
                                                                  .ConfigureAwait(false);
                            if (objFocus == null || objFocus.InternalId != strUndoId)
                                continue;
                            blnFound = true;
                            await treFoci.DoThreadSafeAsync(x =>
                            {
                                TreeNode objNode = x.FindNode(objFocus.InternalId) ?? x.FindNode(objFocus.GearObject?.InternalId);
                                if (objNode != null)
                                {
                                    IsRefreshing = true;
                                    try
                                    {
                                        objNode.Checked = false;
                                    }
                                    finally
                                    {
                                        IsRefreshing = false;
                                    }
                                }
                            }, GenericToken).ConfigureAwait(false);
                        }

                        if (!blnFound)
                        {
                            // Locate the Stacked Focus that was bound.
                            for (int i = await CharacterObject.StackedFoci.GetCountAsync(GenericToken)
                                             .ConfigureAwait(false)
                                         - 1;
                                 i >= 0;
                                 --i)
                            {
                                if (i >= await CharacterObject.StackedFoci.GetCountAsync(GenericToken)
                                        .ConfigureAwait(false))
                                    continue;
                                StackedFocus objStack = await CharacterObject.StackedFoci
                                    .GetValueAtAsync(i, GenericToken)
                                    .ConfigureAwait(false);
                                if (objStack.InternalId != strUndoId)
                                    continue;
                                TreeNode objNode
                                    = await treFoci.DoThreadSafeFuncAsync(x => x.FindNode(objStack.InternalId),
                                        GenericToken).ConfigureAwait(false);
                                if (objNode == null)
                                    continue;

                                IsRefreshing = true;
                                try
                                {
                                    await treFoci.DoThreadSafeAsync(() =>
                                    {
                                        objNode.Checked = false;
                                        objStack.Bonded = false;
                                    }, GenericToken).ConfigureAwait(false);
                                }
                                finally
                                {
                                    IsRefreshing = false;
                                }
                            }
                        }

                        // Legacy fix for bad ID in undo entry (used the focus' gear object's ID instead of the focus')
                        if (!blnFound)
                        {
                            for (int i = await CharacterObject.Foci.GetCountAsync(GenericToken).ConfigureAwait(false) - 1;
                                 i >= 0;
                                 --i)
                            {
                                if (i >= await CharacterObject.Foci.GetCountAsync(GenericToken).ConfigureAwait(false))
                                    continue;
                                Focus objFocus = await CharacterObject.Foci.GetValueAtAsync(i, GenericToken)
                                    .ConfigureAwait(false);
                                string strLoopGearId = objFocus.GearObject?.InternalId;
                                if (strLoopGearId != strUndoId)
                                    continue;
                                await treFoci.DoThreadSafeAsync(x =>
                                {
                                    TreeNode objNode = x.FindNode(objFocus.InternalId) ?? x.FindNode(strLoopGearId);
                                    if (objNode != null)
                                    {
                                        IsRefreshing = true;
                                        try
                                        {
                                            objNode.Checked = false;
                                        }
                                        finally
                                        {
                                            IsRefreshing = false;
                                        }
                                    }
                                }, GenericToken).ConfigureAwait(false);
                            }
                        }

                        break;
                    }
                    case KarmaExpenseType.JoinGroup:
                    {
                        // Remove the character from their Group.
                        IsRefreshing = true;
                        try
                        {
                            CharacterObject.GroupMember = false;
                        }
                        finally
                        {
                            IsRefreshing = false;
                        }

                        break;
                    }
                    case KarmaExpenseType.LeaveGroup:
                    {
                        // Put the character back in their Group.
                        IsRefreshing = true;
                        try
                        {
                            CharacterObject.GroupMember = true;
                        }
                        finally
                        {
                            IsRefreshing = false;
                        }

                        break;
                    }
                    case KarmaExpenseType.RemoveQuality:
                    {
                        // Add the Quality back to the character.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Quality objAddQuality = new Quality(CharacterObject);
                        try
                        {
                            XmlDocument objXmlQualityDocument
                                = await CharacterObject.LoadDataAsync("qualities.xml", token: GenericToken)
                                                       .ConfigureAwait(false);
                            XmlNode objXmlQualityNode
                                = objXmlQualityDocument.TryGetNodeByNameOrId("/chummer/qualities/quality", strUndoId);
                            await objAddQuality.CreateAsync(objXmlQualityNode, QualitySource.Selected, lstWeapons,
                                objExpense.Undo.Extra, token: GenericToken).ConfigureAwait(false);
                            await CharacterObject.Qualities.AddAsync(objAddQuality, GenericToken).ConfigureAwait(false);
                            // Add any created Weapons to the character.
                            foreach (Weapon objWeapon in lstWeapons)
                            {
                                await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                            }
                        }
                        catch
                        {
                            await objAddQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                        break;
                    }
                    case KarmaExpenseType.ManualAdd:
                    case KarmaExpenseType.ManualSubtract:
                    case KarmaExpenseType.QuickeningMetamagic:
                        break;

                    case KarmaExpenseType.AddCritterPower:
                    {
                        // Locate the Critter Power that was affected.
                        for (int i = await CharacterObject.CritterPowers.GetCountAsync(GenericToken)
                                                          .ConfigureAwait(false) - 1;
                             i >= 0;
                             --i)
                        {
                            if (i >= await CharacterObject.CritterPowers.GetCountAsync(GenericToken)
                                                          .ConfigureAwait(false))
                                continue;
                            CritterPower objPower = await CharacterObject.CritterPowers.GetValueAtAsync(i, GenericToken)
                                                                         .ConfigureAwait(false);
                            if (objPower.InternalId == strUndoId)
                                await objPower.RemoveAsync(false, GenericToken).ConfigureAwait(false); // Remove the Critter Power from the character.
                        }
                    }
                        break;
                }

                // Refund the Karma amount and remove the Expense Entry.
                await CharacterObject.ModifyKarmaAsync(-objExpense.Amount.ToInt32(), GenericToken)
                                     .ConfigureAwait(false);
                await CharacterObject.ExpenseEntries.RemoveAsync(objExpense, GenericToken).ConfigureAwait(false);

                Tradition objTradition =
                    await CharacterObject.GetMagicTraditionAsync(GenericToken).ConfigureAwait(false);
                TraditionType eTraditionType = await objTradition.GetTypeAsync(GenericToken)
                    .ConfigureAwait(false);
                string strTraditionSourceIdString =
                    await objTradition.GetSourceIDStringAsync(GenericToken)
                        .ConfigureAwait(false);

                await cboTradition.DoThreadSafeAsync(x =>
                {
                    // Select the Magician's Tradition.
                    if (eTraditionType == TraditionType.MAG && !string.IsNullOrEmpty(strTraditionSourceIdString))
                        x.SelectedValue = strTraditionSourceIdString;
                    if (x.SelectedIndex == -1 && x.Items.Count > 0)
                        x.SelectedIndex = 0;
                }, GenericToken).ConfigureAwait(false);

                await cboStream.DoThreadSafeAsync(x =>
                {
                    // Select the Technomancer's Stream.
                    if (eTraditionType == TraditionType.RES && !string.IsNullOrEmpty(strTraditionSourceIdString))
                        x.SelectedValue = strTraditionSourceIdString;
                    if (x.SelectedIndex == -1 && x.Items.Count > 0)
                        x.SelectedIndex = 0;
                }, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsUndoNuyenExpense_Click(object sender, EventArgs e)
        {
            try
            {
                ListViewItem objItem
                    = await lstNuyen.DoThreadSafeFuncAsync(
                                        x => x.SelectedItems.Count > 0 ? lstNuyen.SelectedItems[0] : null, GenericToken)
                                    .ConfigureAwait(false);

                if (objItem == null)
                {
                    return;
                }

                // Find the selected Nuyen Expense.
                ExpenseLogEntry objExpense
                    = (objItem.SubItems[3] as ListViewItemWithValue.ListViewSubItemWithValue)?.Value as ExpenseLogEntry;

                if (objExpense?.Undo == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_UndoNoHistory", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NoUndoHistory", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strUndoId = objExpense.Undo.ObjectId;

                if (objExpense.Undo.KarmaType == KarmaExpenseType.ImproveInitiateGrade)
                {
                    // Get the grade of the item we're undoing and make sure it's the highest grade
                    int intMaxGrade = 0;
                    await CharacterObject.InitiationGrades.ForEachAsync(objGrade => intMaxGrade = Math.Max(intMaxGrade, objGrade.Grade), GenericToken).ConfigureAwait(false);

                    bool blnReturn = false;
                    await CharacterObject.InitiationGrades.ForEachWithBreakAsync(async objGrade =>
                    {
                        if (objGrade.InternalId != strUndoId)
                            return true;
                        if (objGrade.Grade < intMaxGrade)
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_UndoNotHighestGrade", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager
                                    .GetStringAsync("MessageTitle_NotHighestGrade", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            blnReturn = true;
                        }

                        return false;
                    }, GenericToken).ConfigureAwait(false);
                    if (blnReturn)
                        return;

                    if (await Program.ShowScrollableMessageBoxAsync(
                            this, await LanguageManager.GetStringAsync("Message_UndoExpense", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_UndoExpense", token: GenericToken).ConfigureAwait(false),
                            MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                        return;
                }
                else if (await Program.ShowScrollableMessageBoxAsync(
                             this, await LanguageManager.GetStringAsync("Message_UndoExpense", token: GenericToken).ConfigureAwait(false),
                             await LanguageManager.GetStringAsync("MessageTitle_UndoExpense", token: GenericToken).ConfigureAwait(false),
                             MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                    return;

                if (!string.IsNullOrEmpty(strUndoId))
                {
                    switch (objExpense.Undo.NuyenType)
                    {
                        case NuyenExpenseType.AddCyberware:
                        {
                            // Locate the Cyberware that was added.
                            Cyberware objCyberware = await CharacterObject.Cyberware.DeepFindByIdAsync(strUndoId, GenericToken).ConfigureAwait(false) ??
                                                     (await CharacterObject.Vehicles.FindVehicleCyberwareAsync(
                                                         x => x.InternalId == strUndoId, GenericToken).ConfigureAwait(false)).Item1;
                            if (objCyberware != null)
                                await objCyberware.DeleteCyberwareAsync(blnIncreaseEssenceHole: false, token: GenericToken)
                                                  .ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddGear:
                        {
                            // Locate the Gear that was added.
                            //If the gear was already deleted manually we will not be able to locate it here
                            Gear objGear = await CharacterObject.Gear.DeepFindByIdAsync(strUndoId, GenericToken).ConfigureAwait(false);
                            TreeNode objNode;
                            if (objGear != null)
                            {
                                objNode = await treGear.DoThreadSafeFuncAsync(
                                    x => x.FindNode(objGear.InternalId), GenericToken).ConfigureAwait(false);
                            }
                            else
                            {
                                objGear = (await CharacterObject.Vehicles.FindVehicleGearAsync(strUndoId, GenericToken).ConfigureAwait(false)).Item1;
                                if (objGear != null)
                                    objNode = await treVehicles.DoThreadSafeFuncAsync(
                                        x => x.FindNode(objGear.InternalId), GenericToken).ConfigureAwait(false);
                                else
                                    break;
                            }

                            await objGear.SetQuantityAsync(objGear.Quantity - objExpense.Undo.Qty, GenericToken).ConfigureAwait(false);

                            if (objGear.Quantity <= 0)
                            {
                                await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                            }
                            else if (objNode != null)
                            {
                                string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken)
                                                              .ConfigureAwait(false);
                                await objNode.TreeView.DoThreadSafeAsync(
                                    () => objNode.Text = strText, GenericToken).ConfigureAwait(false);
                            }
                        }
                            break;

                        case NuyenExpenseType.AddVehicle:
                        {
                            // Locate the Vehicle that was added.
                            Vehicle objVehicle = await CharacterObject.Vehicles.FindByIdAsync(strUndoId, GenericToken).ConfigureAwait(false);
                            if (objVehicle != null)
                                await objVehicle.DeleteVehicleAsync(token: GenericToken).ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddVehicleMod:
                        {
                            // Locate the Vehicle Mod that was added.
                            VehicleMod objVehicleMod
                                = (await CharacterObject.Vehicles.FindVehicleModAsync(x => x.InternalId == strUndoId, GenericToken).ConfigureAwait(false)).Item1;
                            if (objVehicleMod != null)
                                await objVehicleMod.DeleteVehicleModAsync(token: GenericToken).ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddVehicleGear:
                        {
                            // Locate the Gear that was added.
                            TreeNode objNode = null;
                            Gear objGear = (await CharacterObject.Vehicles.FindVehicleGearAsync(strUndoId, GenericToken).ConfigureAwait(false)).Item1;
                            if (objGear == null)
                            {
                                objGear = await CharacterObject.Gear.DeepFindByIdAsync(strUndoId, GenericToken).ConfigureAwait(false);
                                if (objGear == null)
                                {
                                    objGear = (await CharacterObject.Cyberware
                                        .FindCyberwareGearAsync(strUndoId, GenericToken).ConfigureAwait(false)).Item1;
                                    if (objGear == null)
                                    {
                                        objGear = (await CharacterObject.Weapons
                                            .FindWeaponGearAsync(strUndoId, GenericToken).ConfigureAwait(false)).Item1;
                                        if (objGear != null)
                                            objNode = await treWeapons.DoThreadSafeFuncAsync(
                                                x => x.FindNode(strUndoId), GenericToken).ConfigureAwait(false);
                                    }
                                    else
                                        objNode = await treCyberware.DoThreadSafeFuncAsync(
                                            x => x.FindNode(strUndoId), GenericToken).ConfigureAwait(false);
                                }
                                else
                                    objNode = await treGear.DoThreadSafeFuncAsync(
                                        x => x.FindNode(strUndoId), GenericToken).ConfigureAwait(false);
                            }
                            else
                                objNode = await treVehicles.DoThreadSafeFuncAsync(
                                    x => x.FindNode(strUndoId), GenericToken).ConfigureAwait(false);

                            if (objGear != null)
                            {
                                // Deduct the Qty from the Gear.
                                await objGear.SetQuantityAsync(objGear.Quantity - objExpense.Undo.Qty, GenericToken).ConfigureAwait(false);

                                // Remove the Gear if its Qty has been reduced to 0.
                                if (objGear.Quantity <= 0)
                                {
                                    await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                                }
                                else if (objNode != null)
                                {
                                    string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken)
                                                                  .ConfigureAwait(false);
                                    await objNode.TreeView.DoThreadSafeAsync(
                                        () => objNode.Text = strText, GenericToken).ConfigureAwait(false);
                                }
                            }
                        }
                            break;

                        case NuyenExpenseType.AddVehicleWeapon:
                        {
                            // Locate the Weapon that was added.
                            Weapon objWeapon = (await CharacterObject.Vehicles.FindVehicleWeaponAsync(strUndoId, GenericToken).ConfigureAwait(false)).Item1 ??
                                               await CharacterObject.Weapons.DeepFindByIdAsync(strUndoId, GenericToken).ConfigureAwait(false);
                            if (objWeapon != null)
                                await objWeapon.DeleteWeaponAsync(token: GenericToken).ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddVehicleWeaponAccessory:
                        {
                            // Locate the Weapon Accessory that was added.
                            WeaponAccessory objWeaponAccessory
                                = await CharacterObject.Vehicles.FindVehicleWeaponAccessoryAsync(strUndoId, GenericToken).ConfigureAwait(false) ??
                                  await CharacterObject.Weapons.FindWeaponAccessoryAsync(strUndoId, GenericToken).ConfigureAwait(false);
                            if (objWeaponAccessory != null)
                                await objWeaponAccessory.DeleteWeaponAccessoryAsync(token: GenericToken)
                                                        .ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddVehicleWeaponMount:
                        {
                            WeaponMount objWeaponMount = (await CharacterObject.Vehicles.FindVehicleWeaponMountAsync(strUndoId, GenericToken).ConfigureAwait(false)).Item1;
                            if (objWeaponMount != null)
                                await objWeaponMount.DeleteWeaponMountAsync(token: GenericToken).ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddVehicleWeaponMountMod:
                        {
                            VehicleMod objVehicleMod = (await CharacterObject.Vehicles.FindVehicleWeaponMountModAsync(strUndoId, GenericToken).ConfigureAwait(false)).Item1;
                            if (objVehicleMod != null)
                                await objVehicleMod.DeleteVehicleModAsync(token: GenericToken).ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.ModifyVehicleWeaponMount:
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this, await LanguageManager.GetStringAsync("Message_UndoExpenseNotSupported", token: GenericToken).ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("String_NotSupported", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Warning, token: GenericToken).ConfigureAwait(false);
                            return;
                        }

                        case NuyenExpenseType.AddArmor:
                        {
                            // Locate the Armor that was added.
                            Armor objArmor = await CharacterObject.Armor.FindByIdAsync(strUndoId, GenericToken).ConfigureAwait(false);
                            if (objArmor != null)
                                await objArmor.DeleteArmorAsync(token: GenericToken).ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddArmorMod:
                        {
                            // Locate the Armor Mod that was added.
                            ArmorMod objArmorMod = await CharacterObject.Armor.FindArmorModAsync(strUndoId, GenericToken).ConfigureAwait(false);
                            if (objArmorMod != null)
                                await objArmorMod.DeleteArmorModAsync(token: GenericToken).ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddWeapon:
                        {
                            // Locate the Weapon that was added.
                            Weapon objWeapon = await CharacterObject.Weapons.DeepFindByIdAsync(strUndoId, GenericToken).ConfigureAwait(false) ??
                                               (await CharacterObject.Vehicles
                                                   .FindVehicleWeaponAsync(strUndoId, GenericToken)
                                                   .ConfigureAwait(false)).Item1;
                            if (objWeapon != null)
                                await objWeapon.DeleteWeaponAsync(token: GenericToken).ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddWeaponAccessory:
                        {
                            // Locate the Weapon Accessory that was added.
                            WeaponAccessory objWeaponAccessory
                                = await CharacterObject.Weapons.FindWeaponAccessoryAsync(strUndoId, GenericToken).ConfigureAwait(false) ??
                                  await CharacterObject.Vehicles.FindVehicleWeaponAccessoryAsync(strUndoId, GenericToken).ConfigureAwait(false);
                            if (objWeaponAccessory != null)
                                await objWeaponAccessory.DeleteWeaponAccessoryAsync(token: GenericToken)
                                                        .ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.IncreaseLifestyle:
                        {
                            // Locate the Lifestyle that was increased.
                            Lifestyle objLifestyle
                                = await CharacterObject.Lifestyles.FirstOrDefaultAsync(x => x.InternalId == strUndoId, GenericToken)
                                                       .ConfigureAwait(false);
                            if (objLifestyle != null)
                                await objLifestyle.ModifyIncrementsAsync(-1, GenericToken).ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddArmorGear:
                        {
                            // Locate the Armor Gear that was added.
                            Gear objGear = (await CharacterObject.Armor.FindArmorGearAsync(strUndoId, GenericToken).ConfigureAwait(false)).Item1;
                            if (objGear != null)
                            {
                                // Deduct the Qty from the Gear.
                                await objGear.SetQuantityAsync(objGear.Quantity - objExpense.Undo.Qty, GenericToken).ConfigureAwait(false);

                                // Remove the Gear if its Qty has been reduced to 0.
                                if (objGear.Quantity <= 0)
                                {
                                    await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                                }
                                else
                                {
                                    string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken)
                                                                  .ConfigureAwait(false);
                                    await treArmor.DoThreadSafeAsync(x =>
                                    {
                                        TreeNode objNode = x.FindNode(strUndoId);
                                        if (objNode != null)
                                            objNode.Text = strText;
                                    }, GenericToken).ConfigureAwait(false);
                                }
                            }
                        }
                            break;

                        case NuyenExpenseType.AddVehicleModCyberware:
                        {
                            // Locate the Cyberware that was added.
                            Cyberware objCyberware
                                = (await CharacterObject.Vehicles.FindVehicleCyberwareAsync(x => x.InternalId == strUndoId, GenericToken).ConfigureAwait(false)).Item1
                                  ?? await CharacterObject.Cyberware.DeepFindByIdAsync(strUndoId, GenericToken).ConfigureAwait(false);
                            if (objCyberware != null)
                                await objCyberware
                                      .DeleteCyberwareAsync(blnIncreaseEssenceHole: false, token: GenericToken)
                                      .ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddCyberwareGear:
                        {
                            // Locate the Gear that was added.
                            Gear objGear = (await CharacterObject.Cyberware
                                               .FindCyberwareGearAsync(strUndoId, GenericToken).ConfigureAwait(false)).Item1 ??
                                           (await CharacterObject.Vehicles.FindVehicleGearAsync(strUndoId, GenericToken)
                                               .ConfigureAwait(false)).Item1 ??
                                           await CharacterObject.Gear.DeepFindByIdAsync(strUndoId, GenericToken).ConfigureAwait(false);
                            if (objGear != null)
                                await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.AddWeaponGear:
                        {
                            // Locate the Gear that was added.
                            Gear objGear = (await CharacterObject.Weapons.FindWeaponGearAsync(strUndoId, GenericToken)
                                               .ConfigureAwait(false)).Item1 ??
                                           (await CharacterObject.Vehicles.FindVehicleGearAsync(strUndoId, GenericToken)
                                               .ConfigureAwait(false)).Item1 ??
                                           await CharacterObject.Gear.DeepFindByIdAsync(strUndoId, GenericToken).ConfigureAwait(false);
                            if (objGear != null)
                                await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                        }
                            break;

                        case NuyenExpenseType.ManualAdd:
                        case NuyenExpenseType.ManualSubtract:
                            break;
                    }
                }

                // Refund the Nuyen amount and remove the Expense Entry.
                await CharacterObject.ModifyNuyenAsync(-objExpense.Amount, GenericToken).ConfigureAwait(false);
                await CharacterObject.ExpenseEntries.RemoveAsync(objExpense, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAddArmorGear_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Gear window.
                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is Armor objArmor))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Select the root Gear node then open the Select Gear window.
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickArmorGear(objArmor.InternalId, true, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorGearAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelectedNodeTag
                    = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false);
                // Make sure a parent items is selected, then open the Select Gear window.
                string strSelectedId;
                switch (objSelectedNodeTag)
                {
                    case Gear objGear:
                        strSelectedId = objGear.InternalId;
                        break;

                    case ArmorMod objMod:
                    {
                        strSelectedId = objMod.InternalId;
                        if (string.IsNullOrEmpty(objMod.GearCapacity))
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this, await LanguageManager.GetStringAsync("Message_SelectArmor", token: GenericToken).ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_SelectArmor", token: GenericToken).ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            return;
                        }

                        break;
                    }
                    default:
                        await Program.ShowScrollableMessageBoxAsync(
                            this, await LanguageManager.GetStringAsync("Message_SelectArmor", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_SelectArmor", token: GenericToken).ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                }

                if (string.IsNullOrEmpty(strSelectedId))
                    return;

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickArmorGear(strSelectedId, token: GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsQualityNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMartialArtsNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsSpellNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsComplexFormNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                         .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCritterPowersNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                          .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsLifestyleNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleName_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x =>
                {
                    TreeNode objReturn = x.SelectedNode;
                    while (objReturn?.Level > 1)
                        objReturn = objReturn.Parent;
                    return objReturn;
                }, GenericToken).ConfigureAwait(false);

                // Make sure a parent item is selected.
                if (objSelectedNode == null || objSelectedNode.Level <= 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectVehicleName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Get the information for the currently selected Vehicle.
                if (!(objSelectedNode.Tag is IHasCustomName objRename))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectVehicleName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription
                    = await LanguageManager.GetStringAsync("String_VehicleName", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objRename.CustomName,
                               AllowEmptyString = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    objRename.CustomName = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objRename.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treVehicles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                 .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleAddCyberware_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is IHasInternalId
                        strSelectedId))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_VehicleCyberwarePlugin", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NoCyberware", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                Cyberware objCyberwareParent = null;
                (VehicleMod objMod, Vehicle objVehicle, _)
                    = await CharacterObject.Vehicles.FindVehicleModAsync(x => x.InternalId == strSelectedId.InternalId, GenericToken).ConfigureAwait(false);
                if (objMod == null)
                    (objCyberwareParent, objMod)
                        = await CharacterObject.Vehicles.FindVehicleCyberwareAsync(x => x.InternalId == strSelectedId.InternalId, GenericToken).ConfigureAwait(false);

                if (objCyberwareParent == null && objMod?.AllowCyberware != true)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_VehicleCyberwarePlugin", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NoCyberware", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Cyberware XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("cyberware.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                bool blnAddAgain;

                do
                {
                    using (ThreadSafeForm<SelectCyberware> frmPickCyberware
                           = await ThreadSafeForm<SelectCyberware>.GetAsync(
                                                                      () => new SelectCyberware(
                                                                          CharacterObject,
                                                                          Improvement.ImprovementSource.Cyberware,
                                                                          objCyberwareParent ?? (object) objMod),
                                                                      GenericToken)
                                                                  .ConfigureAwait(false))
                    {
                        if (objCyberwareParent == null)
                        {
                            //frmPickCyberware.SetGrade = "Standard";
                            await frmPickCyberware.MyForm.SetMaximumCapacityAsync(await objMod.GetCapacityRemainingAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                            frmPickCyberware.MyForm.Subsystems = objMod.Subsystems;
                            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                            out HashSet<string> setDisallowedMounts))
                            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                            out HashSet<string> setHasMounts))
                            {
                                foreach (Cyberware objLoopCyberware in await objMod.Cyberware.DeepWhereAsync(
                                             x => x.GetChildrenAsync(GenericToken), async x => string.IsNullOrEmpty(await x.GetPlugsIntoModularMountAsync(GenericToken).ConfigureAwait(false)), GenericToken).ConfigureAwait(false))
                                {
                                    foreach (string strLoop in (await objLoopCyberware.GetBlocksMountsAsync(GenericToken).ConfigureAwait(false)).SplitNoAlloc(
                                                 ',', StringSplitOptions.RemoveEmptyEntries))
                                    {
                                        setDisallowedMounts.Add(strLoop + await objLoopCyberware.GetLocationAsync(GenericToken).ConfigureAwait(false));
                                    }

                                    string strLoopHasModularMount = await objLoopCyberware.GetHasModularMountAsync(GenericToken).ConfigureAwait(false);
                                    if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                        setHasMounts.Add(strLoopHasModularMount);
                                }

                                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdDisallowedMounts))
                                {
                                    foreach (string strLoop in setDisallowedMounts)
                                    {
                                        if (!strLoop.EndsWith("Right", StringComparison.Ordinal)
                                            && (!strLoop.EndsWith("Left", StringComparison.Ordinal)
                                                || setDisallowedMounts.Contains(
                                                    strLoop.Substring(0, strLoop.Length - 4) + "Right")))
                                            sbdDisallowedMounts.Append(strLoop.TrimEndOnce("Left"), ',');
                                    }

                                    // Remove trailing ","
                                    if (sbdDisallowedMounts.Length > 0)
                                        --sbdDisallowedMounts.Length;
                                    frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                                }

                                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdHasMounts))
                                {
                                    foreach (string strLoop in setHasMounts)
                                        sbdHasMounts.Append(strLoop, ',');
                                    // Remove trailing ","
                                    if (sbdHasMounts.Length > 0)
                                        --sbdHasMounts.Length;
                                    frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                                }
                            }
                        }
                        else
                        {
                            frmPickCyberware.MyForm.ForcedGrade = await objCyberwareParent.GetGradeAsync(GenericToken).ConfigureAwait(false);
                            // If the Cyberware has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that consume Capacity).
                            if (!objCyberwareParent.Capacity.Contains('[') || objCyberwareParent.Capacity.Contains("/["))
                            {
                                await frmPickCyberware.MyForm.SetMaximumCapacityAsync(await objCyberwareParent.GetCapacityRemainingAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                                // Do not allow the user to add a new piece of Cyberware if its Capacity has been reached.
                                if (await CharacterObjectSettings.GetEnforceCapacityAsync(GenericToken).ConfigureAwait(false) && frmPickCyberware.MyForm.MaximumCapacity < 0)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_CapacityReached", token: GenericToken)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_CapacityReached", token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                    break;
                                }
                            }

                            frmPickCyberware.MyForm.Subsystems = objCyberwareParent.AllowedSubsystems;

                            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                            out HashSet<string> setDisallowedMounts))
                            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                            out HashSet<string> setHasMounts))
                            {
                                string strLoopHasModularMount = await objCyberwareParent.GetHasModularMountAsync(GenericToken).ConfigureAwait(false);
                                if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                    setHasMounts.Add(strLoopHasModularMount);
                                foreach (Cyberware objLoopCyberware in await (await objCyberwareParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).DeepWhereAsync(
                                             x => x.GetChildrenAsync(GenericToken), async x => string.IsNullOrEmpty(await x.GetPlugsIntoModularMountAsync(GenericToken).ConfigureAwait(false)), GenericToken).ConfigureAwait(false))
                                {
                                    foreach (string strLoop in (await objLoopCyberware.GetBlocksMountsAsync(GenericToken).ConfigureAwait(false)).SplitNoAlloc(
                                                 ',', StringSplitOptions.RemoveEmptyEntries))
                                    {
                                        setDisallowedMounts.Add(strLoop + await objLoopCyberware.GetLocationAsync(GenericToken).ConfigureAwait(false));
                                    }

                                    strLoopHasModularMount = await objLoopCyberware.GetHasModularMountAsync(GenericToken).ConfigureAwait(false);
                                    if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                        setHasMounts.Add(strLoopHasModularMount);
                                }

                                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdDisallowedMounts))
                                {
                                    foreach (string strLoop in setDisallowedMounts)
                                    {
                                        if (!strLoop.EndsWith("Right", StringComparison.Ordinal)
                                            && (!strLoop.EndsWith("Left", StringComparison.Ordinal)
                                                || setDisallowedMounts.Contains(
                                                    strLoop.Substring(0, strLoop.Length - 4) + "Right")))
                                            sbdDisallowedMounts.Append(strLoop.TrimEndOnce("Left"), ',');
                                    }

                                    // Remove trailing ","
                                    if (sbdDisallowedMounts.Length > 0)
                                        --sbdDisallowedMounts.Length;
                                    frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                                }

                                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdHasMounts))
                                {
                                    foreach (string strLoop in setHasMounts)
                                        sbdHasMounts.Append(strLoop, ',');
                                    // Remove trailing ","
                                    if (sbdHasMounts.Length > 0)
                                        --sbdHasMounts.Length;
                                    frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                                }
                            }
                        }

                        frmPickCyberware.MyForm.LockGrade();
                        frmPickCyberware.MyForm.ParentVehicle = objVehicle ?? objMod.Parent;
                        frmPickCyberware.MyForm.ParentVehicleMod = objMod;

                        if (await frmPickCyberware.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickCyberware.MyForm.AddAgain;

                        XmlNode objXmlCyberware = objXmlDocument.TryGetNodeByNameOrId("/chummer/cyberwares/cyberware", frmPickCyberware.MyForm.SelectedCyberware);
                        Cyberware objCyberware = new Cyberware(CharacterObject);
                        try
                        {
                            if (!await objCyberware.Purchase(objXmlCyberware, Improvement.ImprovementSource.Cyberware,
                                    frmPickCyberware.MyForm.SelectedGrade,
                                    frmPickCyberware.MyForm.SelectedRating,
                                    objVehicle ?? objMod.Parent, objMod.Cyberware, await CharacterObject.GetVehiclesAsync(GenericToken).ConfigureAwait(false),
                                    (objVehicle ?? objMod.Parent).Weapons,
                                    frmPickCyberware.MyForm.Markup, frmPickCyberware.MyForm.FreeCost,
                                    frmPickCyberware.MyForm.BlackMarketDiscount, true,
                                    "String_ExpensePurchaseVehicleCyberware", objCyberwareParent, GenericToken).ConfigureAwait(false))
                                await objCyberware.DeleteCyberwareAsync(token: GenericToken).ConfigureAwait(false);
                        }
                        catch
                        {
                            await objCyberware.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorName_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treArmor.DoThreadSafeFuncAsync(x =>
                {
                    TreeNode objReturn = x.SelectedNode;
                    while (objReturn?.Level > 1)
                        objReturn = objReturn.Parent;
                    return objReturn;
                }, GenericToken).ConfigureAwait(false);

                // Make sure a parent item is selected.
                if (objSelectedNode == null || objSelectedNode.Level == 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectArmorName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                if (!(objSelectedNode.Tag is IHasCustomName objRename))
                    return;

                string strDescription = await LanguageManager.GetStringAsync("String_ArmorName", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objRename.CustomName,
                               AllowEmptyString = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objRename.CustomName = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objRename.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treArmor.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                              .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsLifestyleName_Click(object sender, EventArgs e)
        {
            try
            {
                // Get the information for the currently selected Lifestyle.
                TreeNode objSelectedNode = await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                              .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is IHasCustomName objCustomName))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectLifestyleName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectLifestyle", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription
                    = await LanguageManager.GetStringAsync("String_LifestyleName", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objCustomName.CustomName,
                               AllowEmptyString = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    if (objCustomName.CustomName == frmPickText.MyForm.SelectedValue)
                        return;
                    objCustomName.CustomName = frmPickText.MyForm.SelectedValue;

                    string strText = await objCustomName.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                    await treLifestyles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                       .ConfigureAwait(false);

                    await SetDirty(true).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearRenameLocation_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Location objLocation))
                    return;
                string strDescription
                    = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objLocation.Name
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objLocation.Name = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objLocation.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                             .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponRenameLocation_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                           .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Location objLocation))
                    return;
                string strDescription
                    = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objLocation.Name
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objLocation.Name = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objLocation.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treWeapons.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken).ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCreateSpell_Click(object sender, EventArgs e)
        {
            try
            {
                int intSpellKarmaCost
                    = await CharacterObject.SpellKarmaCostAsync("Spells", GenericToken).ConfigureAwait(false);
                // Make sure the character has enough Karma before letting them select a Spell.
                if (await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false) < intSpellKarmaCost)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // The character is still allowed to add Spells, so show the Create Spell window.
                using (ThreadSafeForm<CreateSpell> frmSpell
                       = await ThreadSafeForm<CreateSpell>.GetAsync(() => new CreateSpell(CharacterObject),
                                                                    GenericToken).ConfigureAwait(false))
                {
                    if (await frmSpell.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                    {
                        await frmSpell.MyForm.SelectedSpell.DisposeAsync().ConfigureAwait(false);
                        return;
                    }

                    Spell objSpell = frmSpell.MyForm.SelectedSpell;
                    try
                    {
                        if (objSpell.Alchemical)
                        {
                            intSpellKarmaCost = await CharacterObject.SpellKarmaCostAsync("Preparations", GenericToken)
                                                                     .ConfigureAwait(false);
                        }
                        else if (objSpell.Category == "Rituals")
                        {
                            intSpellKarmaCost = await CharacterObject.SpellKarmaCostAsync("Rituals", GenericToken)
                                                                     .ConfigureAwait(false);
                        }

                        if (await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false) < intSpellKarmaCost)
                        {
                            await objSpell.DisposeAsync().ConfigureAwait(false);
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            return;
                        }

                        if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(GlobalSettings.CultureInfo,
                                                                                await LanguageManager.GetStringAsync(
                                                                                        "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                                                                    .ConfigureAwait(false),
                                                                                await objSpell
                                                                                    .GetCurrentDisplayNameAsync(
                                                                                        GenericToken)
                                                                                    .ConfigureAwait(false),
                                                                                intSpellKarmaCost.ToString(GlobalSettings.CultureInfo)), GenericToken)
                                                  .ConfigureAwait(false))
                        {
                            await objSpell.DisposeAsync().ConfigureAwait(false);
                            return;
                        }

                        await CharacterObject.Spells.AddAsync(objSpell, GenericToken).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objSpell.DisposeAsync().ConfigureAwait(false);
                        throw;
                    }

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(intSpellKarmaCost * -1,
                                      await LanguageManager.GetStringAsync("String_ExpenseLearnSpell", token: GenericToken)
                                                           .ConfigureAwait(false)
                                      + await LanguageManager.GetStringAsync("String_Space", token: GenericToken).ConfigureAwait(false)
                                      + await objSpell.GetCurrentDisplayNameShortAsync(GenericToken)
                                                      .ConfigureAwait(false),
                                      ExpenseType.Karma, DateTime.Now);
                    await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                         .ConfigureAwait(false);
                    await CharacterObject.ModifyKarmaAsync(-intSpellKarmaCost, GenericToken).ConfigureAwait(false);

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.AddSpell, objSpell.InternalId);
                    objExpense.Undo = objUndo;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsImprovementNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                         .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorRenameLocation_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                         .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Location objLocation))
                    return;
                string strDescription
                    = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objLocation.Name
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    objLocation.Name = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objLocation.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treArmor.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                              .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsImprovementRenameLocation_Click(object sender, EventArgs e)
        {
            try
            {
                string strDescription
                    = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    string strOldLocation = await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Text, GenericToken).ConfigureAwait(false);
                    string strNewLocation = frmPickText.MyForm.SelectedValue;
                    await CharacterObject.Improvements.ForEachWithSideEffectsAsync(objImprovement =>
                    {
                        if (objImprovement.CustomGroup == strOldLocation)
                            objImprovement.CustomGroup = strNewLocation;
                    }, GenericToken).ConfigureAwait(false);
                    ThreadSafeObservableCollection<string> lstImprovementGroups = await CharacterObject.GetImprovementGroupsAsync(GenericToken).ConfigureAwait(false);
                    for (int i = await lstImprovementGroups.GetCountAsync(GenericToken).ConfigureAwait(false) - 1; i >= 0; --i)
                    {
                        if (await lstImprovementGroups.GetValueAtAsync(i, GenericToken).ConfigureAwait(false) != strOldLocation)
                            continue;
                        await lstImprovementGroups.SetValueAtAsync(i, strNewLocation, GenericToken).ConfigureAwait(false);
                        break;
                    }
                }

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Gear window.
                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is Cyberware
                        objCyberware))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Make sure the Cyberware is allowed to accept Gear.
                if (objCyberware.AllowGear == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    string strCategories = string.Empty;
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                               out StringBuilder sbdCategories))
                    {
                        foreach (XmlNode objXmlCategory in objCyberware.AllowGear)
                            sbdCategories.Append(objXmlCategory.InnerTextViaPool(GenericToken), ',');
                        if (sbdCategories.Length > 0)
                        {
                            --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                       () => new SelectGear(CharacterObject, objGearParent: objCyberware, strAllowedCategories: strCategories),
                                       GenericToken).ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) &&
                                    !string.IsNullOrEmpty(objCyberware.Capacity) &&
                                    objCyberware.Capacity != "0" && (!objCyberware.Capacity.Contains('[') ||
                                                                     objCyberware.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                // Open the Gear XML file and locate the selected piece.
                                XmlDocument objXmlDocument
                                    = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                        .ConfigureAwait(false);
                                XmlNode objXmlGear = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                    frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    await objCyberware.GetIsModularCurrentlyEquippedAsync(GenericToken)
                                        .ConfigureAwait(false), token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";

                                // Check the item's Cost and make sure the character can afford it.
                                if (!frmPickGear.MyForm.FreeCost)
                                {
                                    decimal decCost =
                                        await objGear.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                                    // Apply a markup if applicable.
                                    if (frmPickGear.MyForm.Markup != 0)
                                    {
                                        decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                                    }

                                    // Multiply the cost if applicable.
                                    char chrAvail = (await objGear.TotalAvailTupleAsync(token: GenericToken)
                                        .ConfigureAwait(false)).Suffix;
                                    switch (chrAvail)
                                    {
                                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                            break;

                                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                            break;
                                    }

                                    if (decCost > await CharacterObject.GetNuyenAsync(GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager.GetStringAsync("Message_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        continue;
                                    }

                                    // Create the Expense Log Entry.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(decCost * -1,
                                        await LanguageManager.GetStringAsync(
                                                "String_ExpensePurchaseCyberwareGear", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Nuyen,
                                        DateTime.Now);
                                    await CharacterObject.ExpenseEntries
                                        .AddWithSortAsync(objExpense, token: GenericToken).ConfigureAwait(false);
                                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken)
                                        .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateNuyen(NuyenExpenseType.AddCyberwareGear, objGear.InternalId, 1);
                                    objExpense.Undo = objUndo;
                                }

                                // Create any Weapons that came with this Gear.
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }

                                await objCyberware.GearChildren.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleCyberwareAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Gear window.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Cyberware
                        objCyberware))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Make sure the Cyberware is allowed to accept Gear.
                if (objCyberware.AllowGear == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    string strCategories = string.Empty;
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                               out StringBuilder sbdCategories))
                    {
                        foreach (XmlNode objXmlCategory in objCyberware.AllowGear)
                            sbdCategories.Append(objXmlCategory.InnerTextViaPool(GenericToken), ',');
                        if (sbdCategories.Length > 0)
                        {
                            --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                       () => new SelectGear(CharacterObject, objGearParent: objCyberware, strAllowedCategories: strCategories),
                                       GenericToken).ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) &&
                                    !string.IsNullOrEmpty(objCyberware.Capacity) &&
                                    objCyberware.Capacity != "0" && (!objCyberware.Capacity.Contains('[') ||
                                                                     objCyberware.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                // Open the Gear XML file and locate the selected piece.
                                XmlDocument objXmlDocument
                                    = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                        .ConfigureAwait(false);
                                XmlNode objXmlGear = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                    frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    false, token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";

                                // Check the item's Cost and make sure the character can afford it.
                                if (!frmPickGear.MyForm.FreeCost)
                                {
                                    decimal decCost =
                                        await objGear.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                                    // Apply a markup if applicable.
                                    if (frmPickGear.MyForm.Markup != 0)
                                    {
                                        decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                                    }

                                    // Multiply the cost if applicable.
                                    char chrAvail = (await objGear.TotalAvailTupleAsync(token: GenericToken)
                                        .ConfigureAwait(false)).Suffix;
                                    switch (chrAvail)
                                    {
                                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                            break;

                                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                            break;
                                    }

                                    if (decCost > await CharacterObject.GetNuyenAsync(GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager.GetStringAsync("Message_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        continue;
                                    }

                                    // Create the Expense Log Entry.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(decCost * -1,
                                        await LanguageManager.GetStringAsync(
                                                "String_ExpensePurchaseCyberwareGear", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Nuyen,
                                        DateTime.Now);
                                    await CharacterObject.ExpenseEntries
                                        .AddWithSortAsync(objExpense, token: GenericToken).ConfigureAwait(false);
                                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken)
                                        .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateNuyen(NuyenExpenseType.AddCyberwareGear, objGear.InternalId, 1);
                                    objExpense.Undo = objUndo;
                                }

                                // Create any Weapons that came with this Gear.
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }

                                await objCyberware.GearChildren.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                             .ConfigureAwait(false);
                // Make sure a parent items is selected, then open the Select Gear window.
                if (objSelectedNode == null || objSelectedNode.Level < 2)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Locate the Vehicle Sensor Gear.
                if (!(objSelectedNode.Tag is Gear objSensor))
                    // Make sure the Gear was found.
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                Cyberware objCyberware =
                    (await CharacterObject.Cyberware.FindCyberwareGearAsync(objSensor.InternalId, GenericToken).ConfigureAwait(false)).Item2;

                string strCategories = string.Empty;
                XPathNavigator objSensorNode = await objSensor.GetNodeXPathAsync(GenericToken).ConfigureAwait(false);
                XPathNodeIterator xmlAddonCategoryList = objSensorNode?.SelectAndCacheExpression("addoncategory", GenericToken);
                if (xmlAddonCategoryList?.Count > 0)
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                            sbdCategories.Append(objXmlCategory.Value, ',');
                        // Remove the trailing comma.
                        --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }
                }

                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                           () => new SelectGear(CharacterObject, objGearParent: objSensor, strAllowedCategories: strCategories), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                         && (!objSensor.Capacity.Contains('[')
                                                                             || objSensor.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                // Open the Gear XML file and locate the selected piece.
                                XmlNode objXmlGear = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                    frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    (objSensor.Parent as Gear)?.Equipped
                                    ?? objCyberware != null && await objCyberware
                                        .GetIsModularCurrentlyEquippedAsync(GenericToken).ConfigureAwait(false),
                                    token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";

                                // Check the item's Cost and make sure the character can afford it.
                                if (!frmPickGear.MyForm.FreeCost)
                                {
                                    decimal decCost =
                                        await objGear.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                                    // Apply a markup if applicable.
                                    if (frmPickGear.MyForm.Markup != 0)
                                    {
                                        decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                                    }

                                    // Multiply the cost if applicable.
                                    char chrAvail = (await objGear.TotalAvailTupleAsync(token: GenericToken)
                                        .ConfigureAwait(false)).Suffix;
                                    switch (chrAvail)
                                    {
                                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                            break;

                                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                            break;
                                    }

                                    if (decCost > await CharacterObject.GetNuyenAsync(GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager.GetStringAsync("Message_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        continue;
                                    }

                                    // Create the Expense Log Entry.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(decCost * -1,
                                        await LanguageManager.GetStringAsync(
                                                "String_ExpensePurchaseCyberwareGear", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Nuyen,
                                        DateTime.Now);
                                    await CharacterObject.ExpenseEntries
                                        .AddWithSortAsync(objExpense, token: GenericToken)
                                        .ConfigureAwait(false);
                                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken)
                                        .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateNuyen(NuyenExpenseType.AddCyberwareGear, objGear.InternalId,
                                        frmPickGear.MyForm.SelectedQty);
                                    objExpense.Undo = objUndo;
                                }

                                await objSensor.Children.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleCyberwareGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Gear window.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                              GenericToken).ConfigureAwait(false) is Gear objSensor))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strCategories = string.Empty;
                XPathNavigator objSensorNode = await objSensor.GetNodeXPathAsync(GenericToken).ConfigureAwait(false);
                XPathNodeIterator xmlAddonCategoryList = objSensorNode?.SelectAndCacheExpression("addoncategory", GenericToken);
                if (xmlAddonCategoryList?.Count > 0)
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                            sbdCategories.Append(objXmlCategory.Value, ',');
                        // Remove the trailing comma.
                        --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }
                }

                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                           () => new SelectGear(CharacterObject, objGearParent: objSensor, strAllowedCategories: strCategories), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                         && (!objSensor.Capacity.Contains('[')
                                                                             || objSensor.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                // Open the Gear XML file and locate the selected piece.
                                XmlNode objXmlGear = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                    frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    false, token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";

                                // Check the item's Cost and make sure the character can afford it.
                                if (!frmPickGear.MyForm.FreeCost)
                                {
                                    decimal decCost =
                                        await objGear.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                                    // Apply a markup if applicable.
                                    if (frmPickGear.MyForm.Markup != 0)
                                    {
                                        decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                                    }

                                    // Multiply the cost if applicable.
                                    char chrAvail = (await objGear.TotalAvailTupleAsync(token: GenericToken)
                                        .ConfigureAwait(false)).Suffix;
                                    switch (chrAvail)
                                    {
                                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                            break;

                                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                            break;
                                    }

                                    if (decCost > await CharacterObject.GetNuyenAsync(GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager.GetStringAsync("Message_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        continue;
                                    }

                                    // Create the Expense Log Entry.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(decCost * -1,
                                        await LanguageManager.GetStringAsync(
                                                "String_ExpensePurchaseCyberwareGear", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Nuyen,
                                        DateTime.Now);
                                    await CharacterObject.ExpenseEntries
                                        .AddWithSortAsync(objExpense, token: GenericToken)
                                        .ConfigureAwait(false);
                                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken)
                                        .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateNuyen(NuyenExpenseType.AddCyberwareGear, objGear.InternalId,
                                        frmPickGear.MyForm.SelectedQty);
                                    objExpense.Undo = objUndo;
                                }

                                await objSensor.Children.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponAccessoryAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is WeaponAccessory
                        objAccessory))
                    return;
                // Make sure the Weapon Accessory is allowed to accept Gear.
                if (objAccessory.AllowGear == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_WeaponGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    string strCategories = string.Empty;
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                               out StringBuilder sbdCategories))
                    {
                        foreach (XmlNode objXmlCategory in objAccessory.AllowGear)
                            sbdCategories.Append(objXmlCategory.InnerTextViaPool(GenericToken), ',');
                        if (sbdCategories.Length > 0)
                        {
                            --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                       () => new SelectGear(CharacterObject, objGearParent: objAccessory, strAllowedCategories: strCategories),
                                       GenericToken).ConfigureAwait(false))
                            {
                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                // Open the Gear XML file and locate the selected piece.
                                XmlDocument objXmlDocument
                                    = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                        .ConfigureAwait(false);
                                XmlNode objXmlGear = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                    frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    objAccessory.Equipped, token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";

                                // Check the item's Cost and make sure the character can afford it.
                                if (!frmPickGear.MyForm.FreeCost)
                                {
                                    decimal decCost =
                                        await objGear.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                                    // Apply a markup if applicable.
                                    if (frmPickGear.MyForm.Markup != 0)
                                    {
                                        decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                                    }

                                    // Multiply the cost if applicable.
                                    char chrAvail = (await objGear.TotalAvailTupleAsync(token: GenericToken)
                                        .ConfigureAwait(false)).Suffix;
                                    switch (chrAvail)
                                    {
                                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                            break;

                                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                            break;
                                    }

                                    if (decCost > await CharacterObject.GetNuyenAsync(GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager.GetStringAsync("Message_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        continue;
                                    }

                                    // Create the Expense Log Entry.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(decCost * -1,
                                        await LanguageManager.GetStringAsync(
                                                "String_ExpensePurchaseWeaponGear", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Nuyen,
                                        DateTime.Now);
                                    await CharacterObject.ExpenseEntries
                                        .AddWithSortAsync(objExpense, token: GenericToken)
                                        .ConfigureAwait(false);
                                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken)
                                        .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateNuyen(NuyenExpenseType.AddWeaponGear, objGear.InternalId, 1);
                                    objExpense.Undo = objUndo;
                                }

                                // Create any Weapons that came with this Gear.
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }

                                await objAccessory.GearChildren.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponAccessoryDetach_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is WeaponAccessory objAccessory))
                    return;

                // Check if this accessory is part of the base weapon
                if (objAccessory.IncludedInWeapon)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_AccessoryCannotBeDetached", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_DetachAccessory", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Confirm detachment
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_ConfirmDetachAccessory", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_DetachAccessory", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) != DialogResult.Yes)
                    return;

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();

                        // Remove from parent weapon
                        Weapon objParentWeapon = objAccessory.Parent;
                        if (objParentWeapon != null)
                        {
                            // Store the parent weapon reference before removal
                            string strParentWeaponId = objParentWeapon.InternalId;
                            
                            // Try multiple removal methods to ensure it's removed
                            bool blnRemoved = false;
                            
                            // Method 1: Async removal
                            if (objParentWeapon.WeaponAccessories.Contains(objAccessory))
                            {
                                await objParentWeapon.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                blnRemoved = !objParentWeapon.WeaponAccessories.Contains(objAccessory);
                            }
                            
                            // Method 2: Synchronous removal if async failed
                            if (!blnRemoved && objParentWeapon.WeaponAccessories.Contains(objAccessory))
                            {
                                objParentWeapon.WeaponAccessories.Remove(objAccessory);
                                blnRemoved = !objParentWeapon.WeaponAccessories.Contains(objAccessory);
                            }
                            
                            // Method 3: Force removal by index if still present
                            if (!blnRemoved)
                            {
                                int intIndex = objParentWeapon.WeaponAccessories.IndexOf(objAccessory);
                                if (intIndex >= 0)
                                {
                                    objParentWeapon.WeaponAccessories.RemoveAt(intIndex);
                                }
                            }
                            
                        // Clear the accessory's parent reference and mounting relationship
                        objAccessory.Parent = null;
                        objAccessory.MountedOnAccessoryID = string.Empty;
                        }

                        // Check if this accessory has other accessories mounted on it (cascading detach)
                        if (!string.IsNullOrEmpty(objAccessory.AddMount) && objAccessory.AddMount.Equals("Passthrough", StringComparison.OrdinalIgnoreCase))
                        {
                            // Find any accessories that are mounted on this accessory
                            List<WeaponAccessory> lstMountedAccessories = new List<WeaponAccessory>();
                            foreach (WeaponAccessory objMountedAccessory in objParentWeapon.WeaponAccessories)
                            {
                                if (objMountedAccessory.MountedOnAccessoryID == objAccessory.InternalId)
                                {
                                    lstMountedAccessories.Add(objMountedAccessory);
                                }
                            }
                            
                            // Detach all accessories that are mounted on this accessory
                            foreach (WeaponAccessory objMountedAccessory in lstMountedAccessories)
                            {
                                // Remove from parent weapon
                                if (objParentWeapon.WeaponAccessories.Contains(objMountedAccessory))
                                {
                                    await objParentWeapon.WeaponAccessories.RemoveAsync(objMountedAccessory, GenericToken).ConfigureAwait(false);
                                }
                                
                                // Clear the mounted accessory's parent reference and mounting relationship
                                objMountedAccessory.Parent = null;
                                objMountedAccessory.MountedOnAccessoryID = string.Empty;
                                
                                // Add to detached accessories collection
                                if (!CharacterObject.DetachedWeaponAccessories.Contains(objMountedAccessory))
                                {
                                    await CharacterObject.DetachedWeaponAccessories.AddAsync(objMountedAccessory, GenericToken).ConfigureAwait(false);
                                }
                            }
                        }

                        // Ensure accessory is not already in detached collection
                        if (!CharacterObject.DetachedWeaponAccessories.Contains(objAccessory))
                        {
                            // Add to character's detached accessories collection
                            await CharacterObject.DetachedWeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                        }
                        
                        // Accessory is now detached (no need to change equip status)

                        // Refresh only the detached accessories node to avoid debug errors
                        await RefreshDetachedAccessoriesNode(treWeapons, cmsWeaponAccessory, cmsWeaponAccessoryGear, GenericToken).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponAccessoryAttach_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is WeaponAccessory objAccessory))
                    return;

                // All accessories can be attached to other weapons/accessories

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    // Show a dialog to select which weapon/accessory to attach to
                    using (ThreadSafeForm<SelectWeaponAccessoryTarget> frmSelectTarget
                           = await ThreadSafeForm<SelectWeaponAccessoryTarget>.GetAsync(
                               () => new SelectWeaponAccessoryTarget(CharacterObject, objAccessory), GenericToken).ConfigureAwait(false))
                    {
                        if (await frmSelectTarget.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.OK)
                        {
                            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken).ConfigureAwait(false);
                            try
                            {
                                GenericToken.ThrowIfCancellationRequested();

                                // Get the target weapon/accessory
                                Weapon objTargetWeapon = frmSelectTarget.MyForm.SelectedWeapon;
                                WeaponAccessory objTargetAccessory = frmSelectTarget.MyForm.SelectedAccessory;

                                // Remove from detached accessories collection if it's there
                                if (CharacterObject.DetachedWeaponAccessories.Contains(objAccessory))
                                {
                                    await CharacterObject.DetachedWeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                }

                                if (objTargetWeapon != null)
                                {
                                    // Check if the accessory is already on this weapon to prevent conflicts
                                    if (objAccessory.Parent != objTargetWeapon)
                                    {
                                        // Remove from current parent if it has one
                                        if (objAccessory.Parent != null)
                                        {
                                            await objAccessory.Parent.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                        
                                        // Ensure accessory is not already in target weapon's accessories
                                        if (!objTargetWeapon.WeaponAccessories.Contains(objAccessory))
                                        {
                                            // Set the parent weapon reference
                                            objAccessory.Parent = objTargetWeapon;
                                            
                                            // Add to target weapon
                                            await objTargetWeapon.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else if (objTargetAccessory != null)
                                {
                                    // Attach to another accessory - set the mounting relationship
                                    if (objAccessory.Parent != objTargetAccessory.Parent)
                                    {
                                        // Remove from current parent if it has one
                                        if (objAccessory.Parent != null)
                                        {
                                            await objAccessory.Parent.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                        
                                        // Set the mounting relationship
                                        objAccessory.MountedOnAccessoryID = objTargetAccessory.InternalId;
                                        
                                        // Add to the target accessory's parent weapon
                                        await objTargetAccessory.Parent.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                    }
                                }

                                // Accessory is now attached (no need to change equip status)

                                // Show appropriate message based on target location
                                bool blnTargetIsVehicle = objTargetWeapon?.Parent?.Parent is Vehicle || objTargetAccessory?.Parent?.Parent?.Parent is Vehicle;
                                bool blnSourceIsVehicle = objAccessory.Parent?.Parent is Vehicle;
                                
                                if (blnTargetIsVehicle && !blnSourceIsVehicle)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_AccessoryMovedToVehicle", token: GenericToken).ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_AttachAccessory", token: GenericToken).ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                }
                                else if (!blnTargetIsVehicle && blnSourceIsVehicle)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_AccessoryMovedToCharacter", token: GenericToken).ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_AttachAccessory", token: GenericToken).ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                }

                                // Refresh only the detached accessories node to avoid debug errors
                                await RefreshDetachedAccessoriesNode(treWeapons, cmsWeaponAccessory, cmsWeaponAccessoryGear, GenericToken).ConfigureAwait(false);
                            }
                            finally
                            {
                                await objLocker.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleWeaponAccessoryDetach_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is WeaponAccessory objAccessory))
                    return;

                // Check if accessory is part of base weapon
                if (objAccessory.IncludedInWeapon)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_AccessoryCannotBeDetached", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_DetachAccessory", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Confirm detach
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_ConfirmDetachAccessory", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_DetachAccessory", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) != DialogResult.Yes)
                    return;

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();

                        // Get the parent weapon
                        Weapon objParentWeapon = objAccessory.Parent;
                        if (objParentWeapon != null)
                        {
                            // Try multiple removal methods to ensure it's removed
                            bool blnRemoved = false;
                            // Method 1: Async removal
                            if (objParentWeapon.WeaponAccessories.Contains(objAccessory))
                            {
                                await objParentWeapon.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                blnRemoved = !objParentWeapon.WeaponAccessories.Contains(objAccessory);
                            }
                            // Method 2: Synchronous removal if async failed
                            if (!blnRemoved && objParentWeapon.WeaponAccessories.Contains(objAccessory))
                            {
                                objParentWeapon.WeaponAccessories.Remove(objAccessory);
                                blnRemoved = !objParentWeapon.WeaponAccessories.Contains(objAccessory);
                            }
                            // Method 3: Force removal by index if still present
                            if (!blnRemoved)
                            {
                                int intIndex = objParentWeapon.WeaponAccessories.IndexOf(objAccessory);
                                if (intIndex >= 0)
                                {
                                    objParentWeapon.WeaponAccessories.RemoveAt(intIndex);
                                }
                            }
                        }

                        // Clear the accessory's parent reference and mounting relationship
                        objAccessory.Parent = null;
                        objAccessory.MountedOnAccessoryID = string.Empty;

                        // Check if this accessory has other accessories mounted on it (cascading detach)
                        if (!string.IsNullOrEmpty(objAccessory.AddMount) && objAccessory.AddMount.Equals("Passthrough", StringComparison.OrdinalIgnoreCase))
                        {
                            // Find any accessories that are mounted on this accessory
                            List<WeaponAccessory> lstMountedAccessories = new List<WeaponAccessory>();
                            foreach (WeaponAccessory objMountedAccessory in objParentWeapon.WeaponAccessories)
                            {
                                if (objMountedAccessory.MountedOnAccessoryID == objAccessory.InternalId)
                                {
                                    lstMountedAccessories.Add(objMountedAccessory);
                                }
                            }
                            
                            // Detach all accessories that are mounted on this accessory
                            foreach (WeaponAccessory objMountedAccessory in lstMountedAccessories)
                            {
                                // Remove from parent weapon
                                if (objParentWeapon.WeaponAccessories.Contains(objMountedAccessory))
                                {
                                    await objParentWeapon.WeaponAccessories.RemoveAsync(objMountedAccessory, GenericToken).ConfigureAwait(false);
                                }
                                
                                // Clear the mounted accessory's parent reference and mounting relationship
                                objMountedAccessory.Parent = null;
                                objMountedAccessory.MountedOnAccessoryID = string.Empty;
                                
                                // Add to detached accessories collection
                                if (!CharacterObject.DetachedWeaponAccessories.Contains(objMountedAccessory))
                                {
                                    await CharacterObject.DetachedWeaponAccessories.AddAsync(objMountedAccessory, GenericToken).ConfigureAwait(false);
                                }
                            }
                        }

                        // Add to detached accessories collection
                        await CharacterObject.DetachedWeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);

                        // Refresh only the detached accessories node to avoid debug errors
                        await RefreshDetachedAccessoriesNode(treWeapons, cmsWeaponAccessory, cmsWeaponAccessoryGear, GenericToken).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleWeaponAccessoryAttach_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is WeaponAccessory objAccessory))
                    return;

                // All accessories can be attached to other weapons/accessories

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    // Show a dialog to select which weapon/accessory to attach to
                    using (ThreadSafeForm<SelectWeaponAccessoryTarget> frmSelectTarget
                           = await ThreadSafeForm<SelectWeaponAccessoryTarget>.GetAsync(
                               () => new SelectWeaponAccessoryTarget(CharacterObject, objAccessory), GenericToken).ConfigureAwait(false))
                    {
                        if (await frmSelectTarget.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.OK)
                        {
                            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken).ConfigureAwait(false);
                            try
                            {
                                GenericToken.ThrowIfCancellationRequested();

                                // Get the target weapon/accessory
                                Weapon objTargetWeapon = frmSelectTarget.MyForm.SelectedWeapon;
                                WeaponAccessory objTargetAccessory = frmSelectTarget.MyForm.SelectedAccessory;

                                // Remove from detached accessories collection if it's there
                                if (CharacterObject.DetachedWeaponAccessories.Contains(objAccessory))
                                {
                                    await CharacterObject.DetachedWeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                }

                                if (objTargetWeapon != null)
                                {
                                    // Check if the accessory is already on this weapon to prevent conflicts
                                    if (objAccessory.Parent != objTargetWeapon)
                                    {
                                        // Remove from current parent if it has one
                                        if (objAccessory.Parent != null)
                                        {
                                            await objAccessory.Parent.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                        
                                        // Ensure accessory is not already in target weapon's accessories
                                        if (!objTargetWeapon.WeaponAccessories.Contains(objAccessory))
                                        {
                                            // Set the parent weapon reference
                                            objAccessory.Parent = objTargetWeapon;
                                            
                                            // Add to target weapon
                                            await objTargetWeapon.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else if (objTargetAccessory != null)
                                {
                                    // Attach to another accessory - set the mounting relationship
                                    if (objAccessory.Parent != objTargetAccessory.Parent)
                                    {
                                        // Remove from current parent if it has one
                                        if (objAccessory.Parent != null)
                                        {
                                            await objAccessory.Parent.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                        
                                        // Set the mounting relationship
                                        objAccessory.MountedOnAccessoryID = objTargetAccessory.InternalId;
                                        
                                        // Add to the target accessory's parent weapon
                                        await objTargetAccessory.Parent.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                    }
                                }

                                // Show appropriate message for cross-platform movement
                                bool blnSourceIsVehicle = objAccessory.Parent?.Parent?.Parent is Vehicle;
                                bool blnTargetIsVehicle = objTargetWeapon?.Parent?.Parent is Vehicle || objTargetAccessory?.Parent?.Parent?.Parent is Vehicle;

                                if (blnSourceIsVehicle && !blnTargetIsVehicle)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_AccessoryMovedToCharacter", token: GenericToken).ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_AttachAccessory", token: GenericToken).ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                }
                                else if (!blnSourceIsVehicle && blnTargetIsVehicle)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_AccessoryMovedToVehicle", token: GenericToken).ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_AttachAccessory", token: GenericToken).ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                }

                                // Refresh only the detached accessories node to avoid debug errors
                                await RefreshDetachedAccessoriesNode(treWeapons, cmsWeaponAccessory, cmsWeaponAccessoryGear, GenericToken).ConfigureAwait(false);
                            }
                            finally
                            {
                                await objLocker.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponAccessoryGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                              GenericToken).ConfigureAwait(false) is Gear objSensor))
                    // Make sure the Gear was found.
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                WeaponAccessory objAccessory =
                    (await CharacterObject.Weapons.FindWeaponGearAsync(objSensor.InternalId, GenericToken).ConfigureAwait(false)).Item2;

                // Open the Gear XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                string strCategories = string.Empty;
                XPathNavigator objSensorNode = await objSensor.GetNodeXPathAsync(GenericToken).ConfigureAwait(false);
                XPathNodeIterator xmlAddonCategoryList = objSensorNode?.SelectAndCacheExpression("addoncategory", GenericToken);
                if (xmlAddonCategoryList?.Count > 0)
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                            sbdCategories.Append(objXmlCategory.Value, ',');
                        // Remove the trailing comma.
                        --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                           () => new SelectGear(CharacterObject, objGearParent: objSensor, strAllowedCategories: strCategories), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                         && (!objSensor.Capacity.Contains('[')
                                                                             || objSensor.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                XmlNode objXmlGear = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                    frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    (objSensor.Parent as Gear)?.Equipped ?? objAccessory?.Equipped == true,
                                    token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";

                                // Check the item's Cost and make sure the character can afford it.
                                if (!frmPickGear.MyForm.FreeCost)
                                {
                                    decimal decCost =
                                        await objGear.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                                    // Apply a markup if applicable.
                                    if (frmPickGear.MyForm.Markup != 0)
                                    {
                                        decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                                    }

                                    // Multiply the cost if applicable.
                                    char chrAvail = (await objGear.TotalAvailTupleAsync(token: GenericToken)
                                        .ConfigureAwait(false)).Suffix;
                                    switch (chrAvail)
                                    {
                                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                            break;

                                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                            break;
                                    }

                                    if (decCost > await CharacterObject.GetNuyenAsync(GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager.GetStringAsync("Message_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        continue;
                                    }

                                    // Create the Expense Log Entry.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(decCost * -1,
                                        await LanguageManager.GetStringAsync(
                                                "String_ExpensePurchaseWeaponGear", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Nuyen,
                                        DateTime.Now);
                                    await CharacterObject.ExpenseEntries
                                        .AddWithSortAsync(objExpense, token: GenericToken)
                                        .ConfigureAwait(false);
                                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken)
                                        .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateNuyen(NuyenExpenseType.AddWeaponGear, objGear.InternalId,
                                        frmPickGear.MyForm.SelectedQty);
                                    objExpense.Undo = objUndo;
                                }

                                await objSensor.Children.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleRenameLocation_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Location objLocation))
                    return;

                string strDescription
                    = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objLocation.Name
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objLocation.Name = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objLocation.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treVehicles
                      .DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                      .ConfigureAwait(false);
                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void tsCreateNaturalWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                IAsyncDisposable objLocker =
                    await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    using (ThreadSafeForm<CreateNaturalWeapon> frmCreateNaturalWeapon
                           = await ThreadSafeForm<CreateNaturalWeapon>.GetAsync(
                               () => new CreateNaturalWeapon(CharacterObject), GenericToken).ConfigureAwait(false))
                    {
                        if (await frmCreateNaturalWeapon.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        Weapon objWeapon = frmCreateNaturalWeapon.MyForm.SelectedWeapon;
                        await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleWeaponAccessoryGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                // Locate the Vehicle Sensor Gear.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                              GenericToken).ConfigureAwait(false) is Gear objSensor))
                    // Make sure the Gear was found.
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Gear XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                string strCategories = string.Empty;
                XPathNavigator objSensorNode = await objSensor.GetNodeXPathAsync(GenericToken).ConfigureAwait(false);
                XPathNodeIterator xmlAddonCategoryList = objSensorNode?.SelectAndCacheExpression("addoncategory", GenericToken);
                if (xmlAddonCategoryList?.Count > 0)
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                            sbdCategories.Append(objXmlCategory.Value, ',');
                        // Remove the trailing comma.
                        --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                           () => new SelectGear(CharacterObject, objGearParent: objSensor, strAllowedCategories: strCategories), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                         && (!objSensor.Capacity.Contains('[')
                                                                             || objSensor.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                XmlNode objXmlGear = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                    frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    false, token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";

                                // Check the item's Cost and make sure the character can afford it.
                                if (!frmPickGear.MyForm.FreeCost)
                                {
                                    decimal decCost =
                                        await objGear.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                                    // Apply a markup if applicable.
                                    if (frmPickGear.MyForm.Markup != 0)
                                    {
                                        decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                                    }

                                    // Multiply the cost if applicable.
                                    char chrAvail = (await objGear.TotalAvailTupleAsync(token: GenericToken)
                                        .ConfigureAwait(false)).Suffix;
                                    switch (chrAvail)
                                    {
                                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                            break;

                                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                            break;
                                    }

                                    if (decCost > await CharacterObject.GetNuyenAsync(GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager.GetStringAsync("Message_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        continue;
                                    }

                                    // Create the Expense Log Entry.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(decCost * -1,
                                        await LanguageManager.GetStringAsync(
                                                "String_ExpensePurchaseWeaponGear", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Nuyen,
                                        DateTime.Now);
                                    await CharacterObject.ExpenseEntries
                                        .AddWithSortAsync(objExpense, token: GenericToken)
                                        .ConfigureAwait(false);
                                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken)
                                        .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateNuyen(NuyenExpenseType.AddWeaponGear, objGear.InternalId,
                                        frmPickGear.MyForm.SelectedQty);
                                    objExpense.Undo = objUndo;
                                }

                                await objSensor.Children.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                                Vehicle objVehicle =
                                    (await CharacterObject.Vehicles.FindVehicleGearAsync(objGear.InternalId,
                                        GenericToken).ConfigureAwait(false)).Item2;
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await objWeapon.SetParentVehicleAsync(objVehicle, GenericToken)
                                        .ConfigureAwait(false);
                                    await objVehicle.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleWeaponAccessoryAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is WeaponAccessory
                        objAccessory))
                    return;
                // Make sure the Weapon Accessory is allowed to accept Gear.
                if (objAccessory.AllowGear == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_WeaponGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Gear XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    string strCategories = string.Empty;
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                               out StringBuilder sbdCategories))
                    {
                        foreach (XmlNode objXmlCategory in objAccessory.AllowGear)
                            sbdCategories.Append(objXmlCategory.InnerTextViaPool(GenericToken), ',');
                        if (sbdCategories.Length > 0)
                        {
                            --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                       () => new SelectGear(CharacterObject, objGearParent: objAccessory, strAllowedCategories: strCategories),
                                       token: GenericToken).ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                XmlNode objXmlGear = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                    frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    false, token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";

                                // Check the item's Cost and make sure the character can afford it.
                                if (!frmPickGear.MyForm.FreeCost)
                                {
                                    decimal decCost =
                                        await objGear.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                                    // Apply a markup if applicable.
                                    if (frmPickGear.MyForm.Markup != 0)
                                    {
                                        decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                                    }

                                    // Multiply the cost if applicable.
                                    char chrAvail = (await objGear.TotalAvailTupleAsync(token: GenericToken)
                                        .ConfigureAwait(false)).Suffix;
                                    switch (chrAvail)
                                    {
                                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                            break;

                                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                            break;
                                    }

                                    if (decCost > await CharacterObject.GetNuyenAsync(GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await objGear.DeleteGearAsync(token: GenericToken).ConfigureAwait(false);
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager.GetStringAsync("Message_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        continue;
                                    }

                                    // Create the Expense Log Entry.
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    objExpense.Create(decCost * -1,
                                        await LanguageManager.GetStringAsync(
                                                "String_ExpensePurchaseWeaponGear", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Nuyen,
                                        DateTime.Now);
                                    await CharacterObject.ExpenseEntries
                                        .AddWithSortAsync(objExpense, token: GenericToken)
                                        .ConfigureAwait(false);
                                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken)
                                        .ConfigureAwait(false);

                                    ExpenseUndo objUndo = new ExpenseUndo();
                                    objUndo.CreateNuyen(NuyenExpenseType.AddWeaponGear, objGear.InternalId, 1);
                                    objExpense.Undo = objUndo;
                                }

                                await objAccessory.GearChildren.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await objWeapon.SetParentAsync(objAccessory.Parent, GenericToken)
                                        .ConfigureAwait(false);
                                    await objAccessory.Parent.Children.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion ContextMenu Events

        #region Additional Common Tab Control Events

        private async void treQualities_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedQuality(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedQuality(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            await tlpCommonLeftSide.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
            try
            {
                // Locate the selected Quality.
                Quality objQuality = await treQualities
                                           .DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag as Quality, token)
                                           .ConfigureAwait(false);
                if (objQuality == null)
                {
                    await lblQualitySourceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                               .ConfigureAwait(false);
                    await lblQualityBPLabel.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    await lblQualitySource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    await lblQualityBP.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    await UpdateQualityLevelValue(null, token).ConfigureAwait(false);
                }
                else
                {
                    await lblQualitySourceLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                        .ConfigureAwait(false);
                    await lblQualityBPLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    await lblQualitySource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    await lblQualityBP.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    IAsyncDisposable objLocker = await objQuality.LockObject.EnterReadLockAsync(token)
                        .ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await UpdateQualityLevelValue(objQuality, token).ConfigureAwait(false);
                        await objQuality.SetSourceDetailAsync(lblQualitySource, token).ConfigureAwait(false);
                        string strText
                            = (await objQuality.GetBPAsync(token).ConfigureAwait(false) * await objQuality.GetLevelsAsync(token).ConfigureAwait(false) * await CharacterObjectSettings.GetKarmaQualityAsync(token).ConfigureAwait(false)).ToString(
                                  GlobalSettings.CultureInfo) +
                              await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false)
                              + await LanguageManager.GetStringAsync("String_Karma", token: token)
                                                     .ConfigureAwait(false);
                        await lblQualityBP.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                await tlpCommonLeftSide.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
            }
        }

        #endregion Additional Common Tab Control Events

        #region Additional Cyberware Tab Control Events

        private async void treCyberware_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedCyberware(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Cyberware Tab Control Events

        #region Additional Street Gear Tab Control Events

        private async void treWeapons_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedWeapon(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treArmor_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedArmor(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treLifestyles_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedLifestyle(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treLifestyles_DoubleClick(object sender, EventArgs e)
        {
            try
            {
                if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                         .ConfigureAwait(false) is Lifestyle
                        objLifestyle))
                    return;

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker =
                        await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken)
                            .ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        string strGuid = objLifestyle.InternalId;
                        int intMonths = await objLifestyle.GetIncrementsAsync(GenericToken).ConfigureAwait(false);
                        int intPosition = await CharacterObject.Lifestyles.IndexOfAsync(
                                await CharacterObject.Lifestyles.FirstOrDefaultAsync(p =>
                                    p.InternalId == strGuid, GenericToken).ConfigureAwait(false), GenericToken)
                            .ConfigureAwait(false);
                        string strOldLifestyleName
                            = await objLifestyle.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                        decimal decOldLifestyleTotalCost
                            = await objLifestyle.GetTotalCostAsync(GenericToken).ConfigureAwait(false);

                        Lifestyle objLifestyleLocal = objLifestyle;
                        using (ThreadSafeForm<SelectLifestyle> frmPickLifestyle
                               = await ThreadSafeForm<SelectLifestyle>.GetAsync(
                                       () => new SelectLifestyle(
                                           CharacterObject, objLifestyleLocal),
                                       GenericToken)
                                   .ConfigureAwait(false))
                        {
                            DialogResult eResult = await frmPickLifestyle.ShowDialogSafeAsync(this, GenericToken)
                                .ConfigureAwait(false);
                            Lifestyle objSelected = frmPickLifestyle.MyForm.SelectedLifestyle;
                            if (eResult == DialogResult.Cancel)
                            {
                                if (objSelected != null && !ReferenceEquals(objLifestyle, objSelected))
                                    await objSelected.DisposeAsync().ConfigureAwait(false);
                                return;
                            }

                            // Update the selected Lifestyle and refresh the list.
                            objLifestyle = objSelected;
                        }

                        await objLifestyle.SetIncrementsAsync(intMonths, GenericToken).ConfigureAwait(false);

                        decimal decAmount
                            = Math.Max(
                                await objLifestyle.GetTotalCostAsync(GenericToken).ConfigureAwait(false) -
                                decOldLifestyleTotalCost,
                                0);
                        if (decAmount > await CharacterObject.GetNuyenAsync(GenericToken).ConfigureAwait(false))
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            return;
                        }

                        objLifestyle.SetInternalId(strGuid);
                        await CharacterObject.Lifestyles.SetValueAtAsync(intPosition, objLifestyle, GenericToken)
                            .ConfigureAwait(false);

                        string strSpace = await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                            .ConfigureAwait(false);

                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(
                            -decAmount,
                            await LanguageManager.GetStringAsync("String_ExpenseModifiedLifestyle", token: GenericToken)
                                .ConfigureAwait(false)
                            + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                .ConfigureAwait(false) + strOldLifestyleName
                            + strSpace + "->"
                            + strSpace + await objLifestyle.GetCurrentDisplayNameAsync(GenericToken)
                                .ConfigureAwait(false),
                            ExpenseType.Nuyen, DateTime.Now);
                        await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                            .ConfigureAwait(false);
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treGear_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedGear(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkArmorEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                                       .ConfigureAwait(false);
                    if (objSelected == null)
                        return;

                    bool blnChecked = await chkArmorEquipped.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                            .ConfigureAwait(false);

                    // Locate the selected Armor or Armor Mod.
                    switch (objSelected)
                    {
                        case Armor objArmor:
                            await objArmor.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                            break;

                        case ArmorMod objMod:
                            await objMod.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                            break;

                        case Gear objGear:
                            await objGear.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                            if (blnChecked)
                            {
                                (_, Armor objParentArmor, ArmorMod objParentMod) = await CharacterObject.Armor.FindArmorGearAsync(objGear.InternalId, GenericToken).ConfigureAwait(false);
                                // Add the Gear's Improvements to the character.
                                if (objParentArmor.Equipped && objParentMod?.Equipped != false)
                                {
                                    await objGear.ChangeEquippedStatusAsync(true, token: GenericToken)
                                                 .ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                await objGear.ChangeEquippedStatusAsync(false, token: GenericToken)
                                             .ConfigureAwait(false);
                            }

                            break;

                        default:
                            return;
                    }

                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdFireWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    // "Click" the first menu item available.
                    if (await cmsAmmoExpense.DoThreadSafeFuncAsync(() => cmsAmmoSingleShot.Enabled, GenericToken)
                                            .ConfigureAwait(false))
                        await DoSingleShot(GenericToken).ConfigureAwait(false);
                    else if (await cmsAmmoExpense.DoThreadSafeFuncAsync(() => cmsAmmoShortBurst.Enabled, GenericToken)
                                                 .ConfigureAwait(false))
                        await DoShortBurst(GenericToken).ConfigureAwait(false);
                    else
                        await DoLongBurst(GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdReloadWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                                 GenericToken)
                                          .ConfigureAwait(false) is Weapon objWeapon))
                        return;
                    await objWeapon.Reload(await CharacterObject.GetGearAsync(GenericToken).ConfigureAwait(false), treGear, GenericToken).ConfigureAwait(false);
                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdUnloadWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                                 GenericToken)
                                          .ConfigureAwait(false) is Weapon objWeapon))
                        return;
                    await objWeapon.Unload(await CharacterObject.GetGearAsync(GenericToken).ConfigureAwait(false), treGear, GenericToken).ConfigureAwait(false);
                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkWeaponEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    object objSelected = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                                         .ConfigureAwait(false);
                    if (objSelected == null)
                        return;

                    bool blnChecked = await chkWeaponEquipped.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                             .ConfigureAwait(false);
                    // Determine if this is a Weapon.
                    switch (objSelected)
                    {
                        case Weapon objWeapon:
                            await objWeapon.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                            break;

                        case Gear objGear:
                            // Find the selected Gear.
                            await objGear.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                            await objGear.ChangeEquippedStatusAsync(blnChecked, token: GenericToken)
                                         .ConfigureAwait(false);
                            break;

                        case WeaponAccessory objAccessory:
                            await objAccessory.SetEquippedAsync(blnChecked, token: GenericToken)
                                .ConfigureAwait(false);
                            break;

                        default:
                            return;
                    }

                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkIncludedInWeapon_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    // Locate the selected Weapon Accessory or Modification.
                    if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                          .ConfigureAwait(false) is WeaponAccessory
                            objAccessory))
                        return;
                    objAccessory.IncludedInWeapon
                        = await chkIncludedInWeapon.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                   .ConfigureAwait(false);

                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkGearEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is Gear
                        objSelectedGear))
                    return;
                bool blnChecked = await chkGearEquipped.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                       .ConfigureAwait(false);
                await objSelectedGear.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                await objSelectedGear.ChangeEquippedStatusAsync(blnChecked, token: GenericToken).ConfigureAwait(false);

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboWeaponAmmo_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                             GenericToken).ConfigureAwait(false) is Weapon objWeapon))
                    return;

                objWeapon.ActiveAmmoSlot
                    = Convert.ToInt32(
                        await cboWeaponAmmo.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString(), GenericToken)
                                           .ConfigureAwait(false),
                        GlobalSettings.InvariantCultureInfo);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkGearHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    IHasMatrixAttributes objCommlink)
                {
                    await objCommlink.SetHomeNodeAsync(CharacterObject,
                            await chkGearHomeNode.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                .ConfigureAwait(false), GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkArmorHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    IHasMatrixAttributes objCommlink)
                {
                    await objCommlink.SetHomeNodeAsync(CharacterObject,
                            await chkArmorHomeNode.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                .ConfigureAwait(false), GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkWeaponHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    IHasMatrixAttributes objCommlink)
                {
                    await objCommlink.SetHomeNodeAsync(CharacterObject,
                            await chkWeaponHomeNode.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                .ConfigureAwait(false), GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkCyberwareHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    IHasMatrixAttributes objCommlink)
                {
                    await objCommlink.SetHomeNodeAsync(CharacterObject,
                            await chkCyberwareHomeNode.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                .ConfigureAwait(false), GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkVehicleHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    IHasMatrixAttributes objCommlink)
                {
                    await objCommlink.SetHomeNodeAsync(CharacterObject,
                            await chkVehicleHomeNode.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                .ConfigureAwait(false), GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cmdWeaponBuyAmmo_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                             GenericToken).ConfigureAwait(false) is Weapon objWeapon))
                    return;
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickGear(null, objAmmoForWeapon: objWeapon, token: GenericToken)
                        .ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdWeaponMoveToVehicle_Click(object sender, EventArgs e)
        {
            try
            {
                // Locate the selected Weapon.
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                             GenericToken).ConfigureAwait(false) is Weapon objWeapon))
                    return;

                List<Vehicle> lstVehicles = await CharacterObject.Vehicles.ToListAsync(
                    async x => await x.WeaponMounts.GetCountAsync(GenericToken).ConfigureAwait(false) > 0 || await x
                        .Mods.AnyAsync(
                            y => y.Name.Contains("Drone Arm") ||
                                 y.Name.StartsWith("Mechanical Arm", StringComparison.Ordinal), GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                // Cannot continue if there are no Vehicles with a Weapon Mount or Mechanical Arm.
                if (lstVehicles.Count == 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CannotMoveWeapons", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotMoveWeapons", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                WeaponMount objWeaponMount;
                VehicleMod objMod = null;

                using (ThreadSafeForm<SelectItem> frmPickItem
                       = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem(), GenericToken)
                                                         .ConfigureAwait(false))
                {
                    frmPickItem.MyForm.SetVehiclesMode(lstVehicles);

                    if (await frmPickItem.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    // Locate the selected Vehicle.
                    string strSelectedItem = await frmPickItem.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, GenericToken).ConfigureAwait(false);
                    Vehicle objVehicle
                        = await CharacterObject.Vehicles.FirstOrDefaultAsync(
                            x => x.InternalId == strSelectedItem, GenericToken).ConfigureAwait(false);
                    if (objVehicle == null)
                        return;

                    // Now display a list of the acceptable mounting points for the Weapon.
                    using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(Utils.ListItemListPool, out List<ListItem> lstItems))
                    {
                        foreach (WeaponMount objVehicleWeaponMount in objVehicle.WeaponMounts)
                        {
                            //TODO: RAW, some mounts can have multiple weapons attached. Needs support in the Weapon Mount class itself, ideally a 'CanMountThisWeapon' bool or something.
                            if ((objVehicleWeaponMount.AllowedWeaponCategories.Contains(objWeapon.SizeCategory) ||
                                 objVehicleWeaponMount.AllowedWeapons.Contains(objWeapon.Name)) &&
                                !objVehicleWeaponMount.IsWeaponsFull)
                                lstItems.Add(new ListItem(objVehicleWeaponMount.InternalId,
                                                          await objVehicleWeaponMount
                                                                .GetCurrentDisplayNameAsync(GenericToken)
                                                                .ConfigureAwait(false)));
                            else
                                foreach (VehicleMod objVehicleMod in objVehicleWeaponMount.Mods)
                                {
                                    if ((objVehicleMod.Name.Contains("Drone Arm") ||
                                         objVehicleMod.Name.StartsWith("Mechanical Arm", StringComparison.Ordinal)) &&
                                        await objVehicleMod.Weapons.GetCountAsync(GenericToken).ConfigureAwait(false) == 0)
                                        lstItems.Add(new ListItem(objVehicleMod.InternalId,
                                                                  await objVehicleMod
                                                                        .GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)));
                                }
                        }

                        foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                        {
                            if ((objVehicleMod.Name.Contains("Drone Arm") ||
                                 objVehicleMod.Name.StartsWith("Mechanical Arm", StringComparison.Ordinal))
                                && await objVehicleMod.Weapons.GetCountAsync(GenericToken).ConfigureAwait(false) == 0)
                                lstItems.Add(new ListItem(objVehicleMod.InternalId,
                                                          await objVehicleMod.GetCurrentDisplayNameAsync(GenericToken)
                                                                             .ConfigureAwait(false)));
                        }

                        if (lstItems.Count == 0)
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NoValidWeaponMount", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NoValidWeaponMount", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Error, token: GenericToken).ConfigureAwait(false);
                            return;
                        }

                        frmPickItem.MyForm.SetGeneralItemsMode(lstItems);

                        if (await frmPickItem.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        string strId = await frmPickItem.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, GenericToken).ConfigureAwait(false);
                        // Locate the selected Vehicle Mod.
                        objWeaponMount
                            = await objVehicle.WeaponMounts.FirstOrDefaultAsync(
                                x => x.InternalId == strId, GenericToken).ConfigureAwait(false);
                        // Locate the selected Vehicle Mod.
                        if (objWeaponMount == null)
                        {
                            (objMod, objWeaponMount) = await objVehicle.FindVehicleModAsync(x => x.InternalId == strId, GenericToken).ConfigureAwait(false);
                            if (objMod == null)
                                return;
                        }
                    }
                }

                objWeapon.Location = null;
                // Remove the Weapon from the character and add it to the Vehicle Mod.
                await CharacterObject.Weapons.RemoveAsync(objWeapon, GenericToken).ConfigureAwait(false);

                // Remove any Improvements from the Character.
                await objWeapon.WeaponAccessories.ForEachWithSideEffectsAsync(objAccessory =>
                        objAccessory.GearChildren.ForEachWithSideEffectsAsync(objGear =>
                            objGear.ChangeEquippedStatusAsync(false, token: GenericToken), GenericToken), GenericToken)
                    .ConfigureAwait(false);

                if (await objWeapon.UnderbarrelWeapons.GetCountAsync(GenericToken).ConfigureAwait(false) > 0)
                {
                    foreach (Weapon objUnderbarrelWeapon in await objWeapon.UnderbarrelWeapons
                                 .GetAllDescendantsAsync(objUnderbarrelWeapon => objUnderbarrelWeapon.Children, GenericToken)
                                 .ConfigureAwait(false))
                    {
                        await objUnderbarrelWeapon.WeaponAccessories.ForEachWithSideEffectsAsync(objAccessory =>
                                    objAccessory.GearChildren.ForEachWithSideEffectsAsync(objGear =>
                                        objGear.ChangeEquippedStatusAsync(false, token: GenericToken), GenericToken),
                                GenericToken)
                            .ConfigureAwait(false);
                    }
                }

                if (objWeaponMount != null)
                {
                    await objWeapon.SetParentMountAsync(objWeaponMount, GenericToken).ConfigureAwait(false);
                    await objWeaponMount.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await objWeapon.SetParentVehicleModAsync(objMod, GenericToken).ConfigureAwait(false);
                    await objMod.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                }

                List<Gear> lstGearToMove = new List<Gear>(objWeapon.Clips.Count);
                foreach (Clip objClip in objWeapon.Clips)
                {
                    if (objClip.AmmoGear != null)
                    {
                        lstGearToMove.Add(objClip.AmmoGear);
                    }
                }

                foreach (Clip objClip in (await objWeapon.Children.GetAllDescendantsAsync(x => x.Children, GenericToken).ConfigureAwait(false)).SelectMany(x => x.Clips))
                {
                    if (objClip.AmmoGear != null)
                    {
                        lstGearToMove.Add(objClip.AmmoGear);
                    }
                }

                foreach (Gear objGear in lstGearToMove)
                {
                    switch (objGear.Parent)
                    {
                        case IHasGear objHasChildren:
                            await objHasChildren.GearChildren.RemoveAsync(objGear, GenericToken).ConfigureAwait(false);
                            break;

                        case IHasChildren<Gear> objHasChildren:
                            await objHasChildren.Children.RemoveAsync(objGear, GenericToken).ConfigureAwait(false);
                            break;

                        default:
                            await CharacterObject.Gear.RemoveAsync(objGear, GenericToken).ConfigureAwait(false);
                            break;
                    }

                    if (objWeaponMount != null)
                    {
                        await objWeaponMount.Parent.GearChildren.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                    }
                    else
                    {
                        await objMod.Parent.GearChildren.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdArmorIncrease_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is Armor objArmor))
                    return;

                --objArmor.ArmorDamage;

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdArmorDecrease_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is Armor objArmor))
                    return;

                ++objArmor.ArmorDamage;

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkCommlinks_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                await FilterCheckboxChanged(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkHideLoadedAmmo_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                await FilterCheckboxChanged(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task FilterCheckboxChanged(CancellationToken token = default)
        {
            bool commlinksOnly = await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false);
            bool hideLoadedAmmo
                = await chkHideLoadedAmmo.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false);
            await RefreshGears(treGear, cmsGearLocation, cmsGear, null, commlinksOnly, hideLoadedAmmo, token: token)
                .ConfigureAwait(false);
        }

        private async void chkGearActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is
                    IHasMatrixAttributes objSelectedCommlink)
                {
                    await objSelectedCommlink.SetActiveCommlinkAsync(CharacterObject,
                        await chkGearActiveCommlink.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkArmorActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is
                    IHasMatrixAttributes objSelectedCommlink)
                {
                    await objSelectedCommlink.SetActiveCommlinkAsync(CharacterObject,
                        await chkArmorActiveCommlink.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkWeaponActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is
                    IHasMatrixAttributes objSelectedCommlink)
                {
                    await objSelectedCommlink.SetActiveCommlinkAsync(CharacterObject,
                        await chkWeaponActiveCommlink.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkCyberwareActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is
                    IHasMatrixAttributes objSelectedCommlink)
                {
                    await objSelectedCommlink.SetActiveCommlinkAsync(CharacterObject,
                        await chkCyberwareActiveCommlink.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkVehicleActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is
                    IHasMatrixAttributes objSelectedCommlink)
                {
                    await objSelectedCommlink.SetActiveCommlinkAsync(CharacterObject,
                        await chkVehicleActiveCommlink.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cboGearAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboGearAttack.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                        .ConfigureAwait(false))
                    return;

                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboGearAttack, cboGearAttack,
                            cboGearSleaze, cboGearDataProcessing, cboGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboGearSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboGearSleaze.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                        .ConfigureAwait(false))
                    return;

                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboGearSleaze, cboGearAttack,
                            cboGearSleaze, cboGearDataProcessing, cboGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboGearDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboGearDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                                .ConfigureAwait(false))
                    return;

                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboGearDataProcessing, cboGearAttack,
                            cboGearSleaze, cboGearDataProcessing, cboGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboGearFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboGearFirewall.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                          .ConfigureAwait(false))
                    return;

                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboGearFirewall, cboGearAttack,
                            cboGearSleaze, cboGearDataProcessing, cboGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboVehicleAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboVehicleAttack.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                           .ConfigureAwait(false))
                    return;

                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboVehicleAttack, cboVehicleAttack,
                            cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboVehicleSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboVehicleSleaze.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                           .ConfigureAwait(false))
                    return;

                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboVehicleSleaze, cboVehicleAttack,
                            cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboVehicleFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboVehicleFirewall.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                             .ConfigureAwait(false))
                    return;

                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboVehicleFirewall, cboVehicleAttack,
                            cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboVehicleDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboVehicleDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                                   .ConfigureAwait(false))
                    return;

                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboVehicleDataProcessing, cboVehicleAttack,
                            cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboCyberwareAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboCyberwareAttack.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                             .ConfigureAwait(false))
                    return;

                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboCyberwareAttack, cboCyberwareAttack,
                            cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboCyberwareSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboCyberwareSleaze.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                             .ConfigureAwait(false))
                    return;

                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboCyberwareSleaze, cboCyberwareAttack,
                            cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboCyberwareDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing
                    || !await cboCyberwareDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                        .ConfigureAwait(false))
                    return;

                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboCyberwareDataProcessing, cboCyberwareAttack,
                            cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboCyberwareFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboCyberwareFirewall.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                               .ConfigureAwait(false))
                    return;

                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboCyberwareFirewall, cboCyberwareAttack,
                            cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboArmorAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboArmorAttack.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                         .ConfigureAwait(false))
                    return;

                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboArmorAttack, cboArmorAttack, cboArmorSleaze, cboArmorDataProcessing,
                            cboArmorFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboArmorSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboArmorSleaze.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                         .ConfigureAwait(false))
                    return;

                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboArmorSleaze, cboArmorAttack, cboArmorSleaze, cboArmorDataProcessing,
                            cboArmorFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboArmorDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboArmorDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                                 .ConfigureAwait(false))
                    return;

                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboArmorDataProcessing, cboArmorAttack, cboArmorSleaze,
                            cboArmorDataProcessing,
                            cboArmorFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboArmorFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboArmorFirewall.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                           .ConfigureAwait(false))
                    return;

                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboArmorFirewall, cboArmorAttack, cboArmorSleaze, cboArmorDataProcessing,
                            cboArmorFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboWeaponGearAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboWeaponGearAttack.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                              .ConfigureAwait(false))
                    return;

                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboWeaponGearAttack, cboWeaponGearAttack, cboWeaponGearSleaze,
                            cboWeaponGearDataProcessing, cboWeaponGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboWeaponGearSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboWeaponGearSleaze.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                              .ConfigureAwait(false))
                    return;

                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboWeaponGearSleaze, cboWeaponGearAttack, cboWeaponGearSleaze,
                            cboWeaponGearDataProcessing, cboWeaponGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboWeaponGearDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing
                    || !await cboWeaponGearDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                         .ConfigureAwait(false))
                    return;

                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboWeaponGearDataProcessing, cboWeaponGearAttack, cboWeaponGearSleaze,
                            cboWeaponGearDataProcessing, cboWeaponGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboWeaponGearFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboWeaponGearFirewall.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                                .ConfigureAwait(false))
                    return;

                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboWeaponGearFirewall, cboWeaponGearAttack, cboWeaponGearSleaze,
                            cboWeaponGearDataProcessing, cboWeaponGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Street Gear Tab Control Events

        #region Additional Vehicle Tab Control Events

        private async void treVehicles_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedVehicle(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdFireVehicleWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                // "Click" the first menu item available.
                if (await cmdVehicleAmmoExpense.DoThreadSafeFuncAsync(() => cmsVehicleAmmoSingleShot.Enabled,
                                                                      GenericToken).ConfigureAwait(false))
                    await DoVehicleAmmoSingleShot(GenericToken).ConfigureAwait(false);
                else if (await cmdVehicleAmmoExpense.DoThreadSafeFuncAsync(
                             () => cmsVehicleAmmoShortBurst.Enabled, GenericToken).ConfigureAwait(false))
                    await DoVehicleAmmoShortBurst(GenericToken).ConfigureAwait(false);
                else
                    await DoVehicleAmmoLongBurst(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdReloadVehicleWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                           .ConfigureAwait(false) is Weapon
                            objWeapon))
                        return;
                    await objWeapon.Reload(objWeapon.ParentVehicle.GearChildren, treVehicles, GenericToken)
                                   .ConfigureAwait(false);

                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdUnloadVehicleWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                           .ConfigureAwait(false) is Weapon
                            objWeapon))
                        return;
                    await objWeapon.Unload(objWeapon.ParentVehicle.GearChildren, treVehicles, GenericToken)
                                   .ConfigureAwait(false);

                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkVehicleWeaponAccessoryInstalled_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                           .ConfigureAwait(false) is ICanEquip
                            objEquippable))
                        return;
                    await objEquippable.SetEquippedAsync(await chkVehicleWeaponAccessoryInstalled
                        .DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                    await SetDirty(true).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboVehicleWeaponAmmo_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing
                    || !(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                          .ConfigureAwait(false) is Weapon
                        objWeapon))
                    return;
                objWeapon.ActiveAmmoSlot
                    = Convert.ToInt32(
                        await cboVehicleWeaponAmmo.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString(), GenericToken)
                                                  .ConfigureAwait(false),
                        GlobalSettings.InvariantCultureInfo);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Vehicle Tab Control Events

        #region Additional Spells and Spirits Tab Control Events

        private async void treSpells_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedSpell(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treFoci_AfterCheck(object sender, TreeViewEventArgs e)
        {
            if (e.Node.Checked)
                return;
            if (!(e.Node.Tag is IHasInternalId objId))
                return;
            try
            {
                string strFindId = objId.InternalId;
                Focus objFocus
                    = await CharacterObject.Foci.FindAsync(x => x.GearObject?.InternalId == strFindId,
                          GenericToken).ConfigureAwait(false)
                      ?? await CharacterObject.Foci.FindAsync(x => x.InternalId == strFindId,
                          GenericToken).ConfigureAwait(false);

                // Mark the Gear as not Bonded and remove any Improvements.
                Gear objGear = objFocus?.GearObject;

                if (objGear != null)
                {
                    objGear.Bonded = false;
                    await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear,
                                                                     objGear.InternalId, GenericToken).ConfigureAwait(false);
                    await CharacterObject.Foci.RemoveAsync(objFocus, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    // This is a Stacked Focus.
                    StackedFocus objStack = await CharacterObject.StackedFoci.FindAsync(x => x.InternalId == objId.InternalId, GenericToken).ConfigureAwait(false);

                    if (objStack != null)
                    {
                        objStack.Bonded = false;
                        await ImprovementManager.RemoveImprovementsAsync(CharacterObject,
                                                                         Improvement.ImprovementSource.StackedFocus,
                                                                         objStack.InternalId, GenericToken).ConfigureAwait(false);
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treFoci_BeforeCheck(object sender, TreeViewCancelEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            TreeView treViewToUse = e.Node.TreeView;
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    CursorWait objCursorWait =
                        await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                    try
                    {
                        // If the item is being unchecked, confirm that the user wants to un-bind the Focus.
                        if (await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Checked, GenericToken)
                                .ConfigureAwait(false))
                        {
                            if (await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager.GetStringAsync("Message_UnbindFocus", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager
                                        .GetStringAsync("MessageTitle_UnbindFocus", token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                                e.Cancel = true;
                            return;
                        }

                        // Set the Focus count to 1 and get its current Rating (Force). This number isn't used in the following loops because it isn't yet checked or unchecked.
                        int intFociCount = 1;
                        int intFociTotal = 0;

                        Gear objSelectedFocus = null;

                        switch (await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Tag, GenericToken)
                                    .ConfigureAwait(false))
                        {
                            case Gear objGear:
                            {
                                objSelectedFocus = objGear;
                                intFociTotal = await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false);
                                break;
                            }
                            case StackedFocus objStackedFocus:
                            {
                                intFociTotal = await objStackedFocus.GetTotalForceAsync(GenericToken).ConfigureAwait(false);
                                break;
                            }
                        }

                        List<string> lstActiveIds = await treViewToUse.DoThreadSafeFuncAsync(y =>
                        {
                            List<string> lstInnerReturn = new List<string>(y.Nodes.Count);
                            // Run through the list of items. Count the number of Foci the character would have bonded including this one, plus the total Force of all checked Foci.
                            foreach (TreeNode objNode in y.Nodes)
                            {
                                if (objNode.Checked)
                                {
                                    lstInnerReturn.Add(objNode.Tag.ToString());
                                }
                            }
                            return lstInnerReturn;
                        }, GenericToken).ConfigureAwait(false);
                        intFociCount += lstActiveIds.Count;

                        foreach (string strNodeId in lstActiveIds)
                        {
                            Gear objGear = await CharacterObject.Gear.FindByIdAsync(strNodeId, GenericToken).ConfigureAwait(false);
                            if (objGear?.Bonded == true)
                                intFociTotal += await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false);
                            StackedFocus objFocus = await CharacterObject.StackedFoci.FindAsync(x => x.InternalId == strNodeId && x.Bonded, GenericToken).ConfigureAwait(false);
                            if (objFocus != null)
                                intFociTotal += await objFocus.GetTotalForceAsync(GenericToken).ConfigureAwait(false);
                        }

                        if (!await CharacterObject.GetIgnoreRulesAsync(GenericToken).ConfigureAwait(false))
                        {
                            if (intFociTotal > await (await CharacterObject
                                        .GetAttributeAsync("MAG", token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken).ConfigureAwait(false) * 5 ||
                                await CharacterObjectSettings.GetMysAdeptSecondMAGAttributeAsync(GenericToken)
                                    .ConfigureAwait(false)
                                && await CharacterObject.GetIsMysticAdeptAsync(GenericToken).ConfigureAwait(false)
                                && intFociTotal
                                > await (await CharacterObject.GetAttributeAsync("MAGAdept", token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken).ConfigureAwait(false) * 5)
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager
                                        .GetStringAsync("Message_FocusMaximumForce", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager
                                        .GetStringAsync("MessageTitle_FocusMaximum", token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                e.Cancel = true;
                                return;
                            }

                            if (intFociCount > await (await CharacterObject
                                        .GetAttributeAsync("MAG", token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken).ConfigureAwait(false) ||
                                await CharacterObjectSettings.GetMysAdeptSecondMAGAttributeAsync(GenericToken)
                                    .ConfigureAwait(false)
                                && await CharacterObject.GetIsMysticAdeptAsync(GenericToken).ConfigureAwait(false)
                                && intFociCount
                                > await (await CharacterObject.GetAttributeAsync("MAGAdept", token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken).ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager
                                        .GetStringAsync("Message_FocusMaximumNumber", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager
                                        .GetStringAsync("MessageTitle_FocusMaximum", token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                e.Cancel = true;
                                return;
                            }
                        }

                        // If we've made it this far, everything is okay, so create a Karma Expense for the newly-bound Focus.
                        IAsyncDisposable objLocker2 = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken)
                            .ConfigureAwait(false);
                        try
                        {
                            if (objSelectedFocus != null)
                            {
                                bool blnOldEquipped = objSelectedFocus.Equipped;
                                Focus objFocus = new Focus(CharacterObject)
                                {
                                    GearObject = objSelectedFocus
                                };
                                if (objSelectedFocus.Bonus != null
                                    || objSelectedFocus.WirelessOn && objSelectedFocus.WirelessBonus != null)
                                {
                                    if (!string.IsNullOrEmpty(objSelectedFocus.Extra))
                                        ImprovementManager.SetForcedValue(objSelectedFocus.Extra, CharacterObject);
                                    if (objSelectedFocus.Bonus != null)
                                    {
                                        if (!await ImprovementManager.CreateImprovementsAsync(
                                                CharacterObject, Improvement.ImprovementSource.Gear,
                                                objSelectedFocus.InternalId,
                                                objSelectedFocus.Bonus, await objSelectedFocus.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                await objSelectedFocus.GetCurrentDisplayNameShortAsync(GenericToken)
                                                    .ConfigureAwait(false), token: GenericToken).ConfigureAwait(false))
                                        {
                                            // Clear created improvements
                                            await objSelectedFocus.ChangeEquippedStatusAsync(false, token: GenericToken)
                                                .ConfigureAwait(false);
                                            if (blnOldEquipped)
                                                await objSelectedFocus
                                                    .ChangeEquippedStatusAsync(true, token: GenericToken)
                                                    .ConfigureAwait(false);
                                            e.Cancel = true;
                                            return;
                                        }

                                        objSelectedFocus.Extra = ImprovementManager.GetSelectedValue(CharacterObject);
                                    }

                                    if (objSelectedFocus.WirelessOn && objSelectedFocus.WirelessBonus != null
                                                                    && !await ImprovementManager
                                                                        .CreateImprovementsAsync(
                                                                            CharacterObject,
                                                                            Improvement.ImprovementSource.Gear,
                                                                            objSelectedFocus.InternalId,
                                                                            objSelectedFocus.WirelessBonus,
                                                                            await objSelectedFocus.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                                            await objSelectedFocus
                                                                                .GetCurrentDisplayNameShortAsync(
                                                                                    GenericToken)
                                                                                .ConfigureAwait(false),
                                                                            token: GenericToken)
                                                                        .ConfigureAwait(false))
                                    {
                                        // Clear created improvements
                                        await objSelectedFocus.ChangeEquippedStatusAsync(false, token: GenericToken)
                                            .ConfigureAwait(false);
                                        if (blnOldEquipped)
                                            await objSelectedFocus.ChangeEquippedStatusAsync(true, token: GenericToken)
                                                .ConfigureAwait(false);
                                        e.Cancel = true;
                                        return;
                                    }
                                }

                                int intKarmaExpense =
                                    await objFocus.BindingKarmaCostAsync(GenericToken).ConfigureAwait(false);
                                if (intKarmaExpense >
                                    await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false))
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_NotEnoughKarma",
                                                token: GenericToken)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma",
                                                token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                    // Clear created improvements
                                    await objSelectedFocus.ChangeEquippedStatusAsync(false, token: GenericToken)
                                        .ConfigureAwait(false);
                                    if (blnOldEquipped)
                                        await objSelectedFocus.ChangeEquippedStatusAsync(true, token: GenericToken)
                                            .ConfigureAwait(false);
                                    e.Cancel = true;
                                    return;
                                }

                                if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(
                                            GlobalSettings.CultureInfo,
                                            await LanguageManager.GetStringAsync(
                                                    "Message_ConfirmKarmaExpenseFocus", token: GenericToken)
                                                .ConfigureAwait(false),
                                            intKarmaExpense.ToString(
                                                GlobalSettings.CultureInfo),
                                            await objSelectedFocus.GetCurrentDisplayNameAsync(GenericToken)
                                                .ConfigureAwait(false)), token: GenericToken)
                                        .ConfigureAwait(false))
                                {
                                    // Clear created improvements
                                    await objSelectedFocus.ChangeEquippedStatusAsync(false, token: GenericToken)
                                        .ConfigureAwait(false);
                                    if (blnOldEquipped)
                                        await objSelectedFocus.ChangeEquippedStatusAsync(true, token: GenericToken)
                                            .ConfigureAwait(false);
                                    e.Cancel = true;
                                    return;
                                }

                                // Create the Expense Log Entry.
                                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                objExpense.Create(intKarmaExpense * -1,
                                    await LanguageManager.GetStringAsync("String_ExpenseBound", token: GenericToken)
                                        .ConfigureAwait(false)
                                    + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                        .ConfigureAwait(false)
                                    + await objSelectedFocus.GetCurrentDisplayNameAsync(GenericToken)
                                        .ConfigureAwait(false), ExpenseType.Karma, DateTime.Now);
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                    .ConfigureAwait(false);
                                await CharacterObject.ModifyKarmaAsync(-intKarmaExpense, GenericToken)
                                    .ConfigureAwait(false);

                                ExpenseUndo objUndo = new ExpenseUndo();
                                objUndo.CreateKarma(KarmaExpenseType.BindFocus, objFocus.InternalId);
                                objExpense.Undo = objUndo;

                                await CharacterObject.Foci.AddAsync(objFocus, GenericToken).ConfigureAwait(false);
                                objSelectedFocus.Bonded = true;
                                if (!blnOldEquipped)
                                {
                                    await objSelectedFocus.ChangeEquippedStatusAsync(false, token: GenericToken)
                                        .ConfigureAwait(false);
                                }

                                string strName = await objSelectedFocus.GetCurrentDisplayNameAsync(GenericToken)
                                    .ConfigureAwait(false);
                                await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Text = strName, GenericToken)
                                    .ConfigureAwait(false);
                            }
                            else
                            {
                                // The Focus was not found in Gear, so this is a Stacked Focus.
                                if (!(await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Tag, GenericToken)
                                            .ConfigureAwait(false) is StackedFocus
                                        objStackedFocus))
                                {
                                    e.Cancel = true;
                                    return;
                                }

                                Gear objStackGear = await CharacterObject.Gear.DeepFindByIdAsync(objStackedFocus.GearId, GenericToken).ConfigureAwait(false);
                                if (objStackGear == null)
                                {
                                    e.Cancel = true;
                                    return;
                                }

                                bool blnOldEquipped = objStackGear.Equipped;

                                await objStackedFocus.Gear.ForEachWithSideEffectsWithBreakAsync(async objGear =>
                                {
                                    if (objGear.Bonus == null && (!objGear.WirelessOn || objGear.WirelessBonus == null))
                                        return true;
                                    if (!string.IsNullOrEmpty(objGear.Extra))
                                        ImprovementManager.SetForcedValue(objGear.Extra, CharacterObject);
                                    if (objGear.Bonus != null)
                                    {
                                        if (!await ImprovementManager.CreateImprovementsAsync(
                                                    CharacterObject, Improvement.ImprovementSource.StackedFocus,
                                                    objStackedFocus.InternalId, objGear.Bonus,
                                                    await objGear.GetRatingAsync(GenericToken)
                                                        .ConfigureAwait(false),
                                                    await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                                        .ConfigureAwait(false), token: GenericToken)
                                                .ConfigureAwait(false))
                                        {
                                            e.Cancel = true;
                                            return false;
                                        }

                                        objGear.Extra = ImprovementManager.GetSelectedValue(CharacterObject);
                                    }

                                    if (objGear.WirelessOn && objGear.WirelessBonus != null
                                                           && !await ImprovementManager.CreateImprovementsAsync(
                                                                   CharacterObject,
                                                                   Improvement.ImprovementSource
                                                                       .StackedFocus,
                                                                   objStackedFocus.InternalId,
                                                                   objGear.WirelessBonus,
                                                                   await objGear.GetRatingAsync(GenericToken)
                                                                       .ConfigureAwait(false),
                                                                   await objGear
                                                                       .GetCurrentDisplayNameShortAsync(
                                                                           GenericToken)
                                                                       .ConfigureAwait(false), token: GenericToken)
                                                               .ConfigureAwait(false))
                                    {
                                        e.Cancel = true;
                                        return false;
                                    }

                                    return true;
                                }, GenericToken).ConfigureAwait(false);

                                if (e.Cancel)
                                {
                                    // Clear created improvements
                                    await objStackedFocus.Gear.ForEachWithSideEffectsAsync(objGear =>
                                            objGear.ChangeEquippedStatusAsync(false, token: GenericToken), GenericToken)
                                        .ConfigureAwait(false);
                                    if (blnOldEquipped)
                                        await objStackedFocus.Gear.ForEachWithSideEffectsAsync(objGear =>
                                                objGear.ChangeEquippedStatusAsync(true, token: GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                    return;
                                }

                                int intKarmaExpense = objStackedFocus.BindingCost;
                                if (intKarmaExpense >
                                    await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false))
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_NotEnoughKarma",
                                                token: GenericToken)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma",
                                                token: GenericToken)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                    // Clear created improvements
                                    await objStackGear.ChangeEquippedStatusAsync(false, token: GenericToken)
                                        .ConfigureAwait(false);
                                    if (blnOldEquipped)
                                        await objStackGear.ChangeEquippedStatusAsync(true, token: GenericToken)
                                            .ConfigureAwait(false);
                                    e.Cancel = true;
                                    return;
                                }

                                if (!await CommonFunctions.ConfirmKarmaExpenseAsync(
                                        string.Format(GlobalSettings.CultureInfo,
                                            await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseFocus",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            intKarmaExpense.ToString(GlobalSettings.CultureInfo),
                                            await LanguageManager.GetStringAsync("String_StackedFocus",
                                                    token: GenericToken)
                                                .ConfigureAwait(false)
                                            + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                                .ConfigureAwait(false)
                                            + await objStackedFocus.GetCurrentDisplayNameAsync(GenericToken)
                                                .ConfigureAwait(false)), token: GenericToken).ConfigureAwait(false))
                                {
                                    // Clear created improvements
                                    await objStackGear.ChangeEquippedStatusAsync(false, token: GenericToken)
                                        .ConfigureAwait(false);
                                    if (blnOldEquipped)
                                        await objStackGear.ChangeEquippedStatusAsync(true, token: GenericToken)
                                            .ConfigureAwait(false);
                                    e.Cancel = true;
                                    return;
                                }

                                // Create the Expense Log Entry.
                                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                objExpense.Create(intKarmaExpense * -1,
                                    await LanguageManager.GetStringAsync("String_ExpenseBound", token: GenericToken)
                                        .ConfigureAwait(false)
                                    + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                        .ConfigureAwait(false)
                                    + await LanguageManager.GetStringAsync("String_StackedFocus", token: GenericToken)
                                        .ConfigureAwait(false)
                                    + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                        .ConfigureAwait(false)
                                    + await objStackedFocus.GetCurrentDisplayNameAsync(GenericToken)
                                        .ConfigureAwait(false), ExpenseType.Karma, DateTime.Now);
                                await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                    .ConfigureAwait(false);
                                await CharacterObject.ModifyKarmaAsync(-intKarmaExpense, GenericToken)
                                    .ConfigureAwait(false);

                                ExpenseUndo objUndo = new ExpenseUndo();
                                objUndo.CreateKarma(KarmaExpenseType.BindFocus, objStackedFocus.InternalId);
                                objExpense.Undo = objUndo;

                                objStackedFocus.Bonded = true;
                                string strText = await objStackGear.GetCurrentDisplayNameAsync(GenericToken)
                                    .ConfigureAwait(false);
                                await treViewToUse.DoThreadSafeAsync(() => e.Node.Text = strText, GenericToken)
                                    .ConfigureAwait(false);
                            }

                            await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objCursorWait.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboTradition_SelectedIndexChanged(object sender, EventArgs e)
        {
            //TODO: Why can't IsInitialized be used here? Throws an error when trying to use chummer.helpers.
            if (IsLoading || IsRefreshing || IsDisposed)
                return;

            SkipUpdate = true;
            try
            {
                string strSelectedId
                    = await cboTradition.DoThreadSafeFuncAsync(x => x.SelectedValue?.ToString(), GenericToken)
                                        .ConfigureAwait(false);
                if (string.IsNullOrEmpty(strSelectedId))
                    return;

                XmlNode xmlTradition = (await CharacterObject.LoadDataAsync("traditions.xml", token: GenericToken)
                                                             .ConfigureAwait(false))
                    .TryGetNodeByNameOrId("/chummer/traditions/tradition", strSelectedId);

                Tradition objTradition =
                    await CharacterObject.GetMagicTraditionAsync(GenericToken).ConfigureAwait(false);
                if (xmlTradition == null)
                {
                    await lblTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                          .ConfigureAwait(false);
                    await txtTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                          .ConfigureAwait(false);
                    await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = false, GenericToken).ConfigureAwait(false);
                    await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                            .ConfigureAwait(false);
                    await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = false, GenericToken).ConfigureAwait(false);
                    await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                           .ConfigureAwait(false);
                    await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                               .ConfigureAwait(false);
                    await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                            .ConfigureAwait(false);
                    await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                                 .ConfigureAwait(false);
                    await cboSpiritCombat.DoThreadSafeAsync(x => x.Visible = false, GenericToken).ConfigureAwait(false);
                    await cboSpiritDetection.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                            .ConfigureAwait(false);
                    await cboSpiritHealth.DoThreadSafeAsync(x => x.Visible = false, GenericToken).ConfigureAwait(false);
                    await cboSpiritIllusion.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                           .ConfigureAwait(false);
                    await cboSpiritManipulation.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                               .ConfigureAwait(false);

                    if (await objTradition.GetTypeAsync(GenericToken).ConfigureAwait(false) == TraditionType.MAG)
                    {
                        await objTradition.ResetTraditionAsync(GenericToken).ConfigureAwait(false);
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }

                    string strSourceIDString = await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strSourceIDString))
                        await cboTradition.DoThreadSafeAsync(x => x.SelectedValue = strSourceIDString, GenericToken)
                            .ConfigureAwait(false);
                }
                else if (strSelectedId == Tradition.CustomMagicalTraditionGuidString)
                {
                    if (await objTradition.CreateAsync(xmlTradition, token: GenericToken).ConfigureAwait(false))
                    {
                        await lblTraditionName.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                              .ConfigureAwait(false);
                        await txtTraditionName.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                              .ConfigureAwait(false);
                        await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                             .ConfigureAwait(false);
                        await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                                .ConfigureAwait(false);
                        await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                             .ConfigureAwait(false);
                        await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                               .ConfigureAwait(false);
                        await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                                   .ConfigureAwait(false);
                        await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                                .ConfigureAwait(false);
                        await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                                     .ConfigureAwait(false);
                        await cboSpiritCombat.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken).ConfigureAwait(false);
                        await cboSpiritDetection.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken).ConfigureAwait(false);
                        await cboSpiritHealth.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken).ConfigureAwait(false);
                        await cboSpiritIllusion.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken).ConfigureAwait(false);
                        await cboSpiritManipulation.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken).ConfigureAwait(false);

                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                    else
                    {
                        await objTradition.ResetTraditionAsync(GenericToken).ConfigureAwait(false);
                        string strSourceIDString = await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false);
                        if (!string.IsNullOrEmpty(strSourceIDString))
                            await cboTradition.DoThreadSafeAsync(x => x.SelectedValue = strSourceIDString, GenericToken)
                                .ConfigureAwait(false);
                    }
                }
                else if (await objTradition.CreateAsync(xmlTradition, token: GenericToken).ConfigureAwait(false))
                {
                    await lblTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                          .ConfigureAwait(false);
                    await txtTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                          .ConfigureAwait(false);
                    await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                    await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                            .ConfigureAwait(false);
                    await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                    await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                           .ConfigureAwait(false);
                    await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                               .ConfigureAwait(false);
                    await cboSpiritCombat.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken).ConfigureAwait(false);
                    await cboSpiritDetection.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken).ConfigureAwait(false);
                    await cboSpiritHealth.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken).ConfigureAwait(false);
                    await cboSpiritIllusion.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken).ConfigureAwait(false);
                    await cboSpiritManipulation.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken).ConfigureAwait(false);

                    await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                            .ConfigureAwait(false);
                    await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                                 .ConfigureAwait(false);
                    await objTradition.SetSourceDetailAsync(lblTraditionSource, GenericToken)
                                         .ConfigureAwait(false);

                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await objTradition.ResetTraditionAsync(GenericToken).ConfigureAwait(false);
                    string strSourceIDString = await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strSourceIDString))
                        await cboTradition.DoThreadSafeAsync(x => x.SelectedValue = strSourceIDString, GenericToken)
                            .ConfigureAwait(false);
                }

                bool blnDrainVisible = (!await CharacterObject.GetAdeptEnabledAsync(GenericToken).ConfigureAwait(false)
                                        || await CharacterObject.GetMagicianEnabledAsync(GenericToken).ConfigureAwait(false)) &&
                                       await objTradition.GetCanChooseDrainAttributeAsync(GenericToken).ConfigureAwait(false);
                await cboDrain.DoThreadSafeAsync(x => x.Visible = blnDrainVisible, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
            finally
            {
                SkipUpdate = false;
            }
        }

        #endregion Additional Spells and Spirits Tab Control Events

        #region Additional Sprites and Complex Forms Tab Control Events

        private async void treComplexForms_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedComplexForm(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboStream_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing)
                return;
            try
            {
                string strSelectedId = await cboStream
                    .DoThreadSafeFuncAsync(x => x.SelectedValue?.ToString(), GenericToken)
                    .ConfigureAwait(false);
                if (string.IsNullOrEmpty(strSelectedId))
                    return;

                XmlNode xmlNewStreamNode = (await CharacterObject.LoadDataAsync("streams.xml", token: GenericToken)
                        .ConfigureAwait(false))
                    .TryGetNodeByNameOrId("/chummer/traditions/tradition", strSelectedId);

                Tradition objTradition =
                    await CharacterObject.GetMagicTraditionAsync(GenericToken).ConfigureAwait(false);
                if (strSelectedId == await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false))
                    return;
                if (xmlNewStreamNode == null)
                {
                    if (await objTradition.GetTypeAsync(GenericToken).ConfigureAwait(false) == TraditionType.RES)
                    {
                        await objTradition.ResetTraditionAsync(GenericToken).ConfigureAwait(false);
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }

                    string strSourceIDString =
                        await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strSourceIDString))
                        await cboStream
                            .DoThreadSafeAsync(x => x.SelectedValue = strSourceIDString,
                                GenericToken).ConfigureAwait(false);
                }
                else if (await objTradition.CreateAsync(xmlNewStreamNode, true, token: GenericToken)
                             .ConfigureAwait(false))
                {
                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await objTradition.ResetTraditionAsync(GenericToken).ConfigureAwait(false);
                    string strSourceIDString =
                        await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strSourceIDString))
                        await cboStream
                            .DoThreadSafeAsync(x => x.SelectedValue = strSourceIDString,
                                GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Sprites and Complex Forms Tab Control Events

        #region Additional Initiation Tab Control Events

        private void chkInitiationGroup_EnabledChanged(object sender, EventArgs e)
        {
            if (!chkInitiationGroup.Enabled)
            {
                chkInitiationGroup.Checked = false;
            }
        }

        private void chkInitiationSchooling_EnabledChanged(object sender, EventArgs e)
        {
            if (!chkInitiationSchooling.Enabled)
            {
                chkInitiationSchooling.Checked = false;
            }
        }

        private async void treMetamagic_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedMetamagic(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedMetamagic(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!await CharacterObject.GetInitiationEnabledAsync(token).ConfigureAwait(false))
            {
                await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = false, token).ConfigureAwait(false);
                await cmdDeleteMetamagic.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                return;
            }

            IsRefreshing = true;
            try
            {
                string strText;
                switch (await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false))
                {
                    case Metamagic objMetamagic:
                    {
                        strText = await LanguageManager.GetStringAsync(
                            objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic
                                ? "Button_RemoveMetamagic"
                                : "Button_RemoveEcho", token: token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objMetamagic.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await objMetamagic.SetSourceDetailAsync(lblMetamagicSource, token).ConfigureAwait(false);
                        break;
                    }
                    case Art objArt:
                    {
                        strText = await LanguageManager.GetStringAsync("Button_RemoveMetamagic", token: token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objArt.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await objArt.SetSourceDetailAsync(lblMetamagicSource, token).ConfigureAwait(false);
                        break;
                    }
                    case Spell objSpell:
                    {
                        strText = await LanguageManager.GetStringAsync("Button_RemoveMetamagic", token: token)
                                                       .ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objSpell.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await objSpell.SetSourceDetailAsync(lblMetamagicSource, token).ConfigureAwait(false);
                        break;
                    }
                    case ComplexForm objComplexForm:
                    {
                        strText = await LanguageManager.GetStringAsync("Button_RemoveEcho", token: token)
                                                       .ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objComplexForm.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await objComplexForm.SetSourceDetailAsync(lblMetamagicSource, token).ConfigureAwait(false);
                        break;
                    }
                    case Enhancement objEnhancement:
                    {
                        strText = await LanguageManager.GetStringAsync("Button_RemoveMetamagic", token: token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objEnhancement.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await objEnhancement.SetSourceDetailAsync(lblMetamagicSource, token).ConfigureAwait(false);
                        break;
                    }
                    case InitiationGrade objGrade:
                    {
                        strText = await LanguageManager.GetStringAsync(
                            objGrade.Technomancer
                                ? "Button_RemoveSubmersionGrade"
                                : "Button_RemoveInitiateGrade", token: token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objGrade.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await SourceString.Blank.SetControlAsync(lblMetamagicSource, this, token).ConfigureAwait(false);
                        break;
                    }
                    default:
                    {
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = false, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        break;
                    }
                }

                bool blnVisible = await lblMetamagicSource
                                        .DoThreadSafeFuncAsync(x => x.Visible = !string.IsNullOrEmpty(x.Text),
                                                               token: token).ConfigureAwait(false);
                await lblMetamagicSourceLabel.DoThreadSafeAsync(x => x.Visible = blnVisible, token: token)
                                             .ConfigureAwait(false);
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void chkJoinGroup_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || IsLoading
                                 || await chkJoinGroup.DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false)
                                 == await CharacterObject.GetGroupMemberAsync(GenericToken).ConfigureAwait(false))
                    return;

                // Joining a Network does not cost Karma for Technomancers, so this only applies to Magicians/Adepts.
                if (await CharacterObject.GetMAGEnabledAsync(GenericToken).ConfigureAwait(false))
                {
                    if (await chkJoinGroup.DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false))
                    {
                        int intKarmaExpense = await CharacterObjectSettings.GetKarmaJoinGroupAsync(GenericToken).ConfigureAwait(false);

                        if (intKarmaExpense > await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false))
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            IsRefreshing = true;
                            try
                            {
                                await chkJoinGroup.DoThreadSafeAsync(x => x.Checked = false, GenericToken).ConfigureAwait(false);
                            }
                            finally
                            {
                                IsRefreshing = false;
                            }

                            return;
                        }

                        string strMessage = await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseJoinGroup", token: GenericToken)
                            .ConfigureAwait(false);
                        string strExpense = await LanguageManager.GetStringAsync("String_ExpenseJoinGroup", token: GenericToken)
                            .ConfigureAwait(false);

                        if (!await CommonFunctions.ConfirmKarmaExpenseAsync(
                                                      string.Format(GlobalSettings.CultureInfo, strMessage,
                                                                    intKarmaExpense.ToString(GlobalSettings
                                                                        .CultureInfo)), GenericToken)
                                                  .ConfigureAwait(false))
                        {
                            IsRefreshing = true;
                            try
                            {
                                await chkJoinGroup.DoThreadSafeAsync(x => x.Checked = false, GenericToken).ConfigureAwait(false);
                            }
                            finally
                            {
                                IsRefreshing = false;
                            }

                            return;
                        }

                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(intKarmaExpense * -1, strExpense, ExpenseType.Karma, DateTime.Now);
                        await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                             .ConfigureAwait(false);
                        await CharacterObject.ModifyKarmaAsync(-intKarmaExpense, GenericToken).ConfigureAwait(false);

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateKarma(KarmaExpenseType.JoinGroup, string.Empty);
                        objExpense.Undo = objUndo;
                    }
                    else
                    {
                        int intKarmaExpense = await CharacterObjectSettings.GetKarmaLeaveGroupAsync(GenericToken).ConfigureAwait(false);

                        if (intKarmaExpense > await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false))
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken).ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            IsRefreshing = true;
                            try
                            {
                                await chkJoinGroup.DoThreadSafeAsync(x => x.Checked = true, GenericToken).ConfigureAwait(false);
                            }
                            finally
                            {
                                IsRefreshing = false;
                            }

                            return;
                        }

                        string strMessage = await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseLeaveGroup", token: GenericToken)
                            .ConfigureAwait(false);
                        string strExpense = await LanguageManager.GetStringAsync("String_ExpenseLeaveGroup", token: GenericToken)
                            .ConfigureAwait(false);

                        if (!await CommonFunctions.ConfirmKarmaExpenseAsync(
                                                      string.Format(GlobalSettings.CultureInfo, strMessage,
                                                                    intKarmaExpense.ToString(GlobalSettings
                                                                        .CultureInfo)), token: GenericToken)
                                                  .ConfigureAwait(false))
                        {
                            IsRefreshing = true;
                            try
                            {
                                await chkJoinGroup.DoThreadSafeAsync(x => x.Checked = true, GenericToken).ConfigureAwait(false);
                            }
                            finally
                            {
                                IsRefreshing = false;
                            }

                            return;
                        }

                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(intKarmaExpense * -1, strExpense, ExpenseType.Karma, DateTime.Now);
                        await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                             .ConfigureAwait(false);
                        await CharacterObject.ModifyKarmaAsync(-intKarmaExpense, GenericToken).ConfigureAwait(false);

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateKarma(KarmaExpenseType.LeaveGroup, string.Empty);
                        objExpense.Undo = objUndo;
                    }
                }

                //TODO: If using a databinding for GroupMember, changing Karma here causes chkJoinGroup to revert to false. Unclear why, lazy fix to resolve it for now.
                CharacterObject.GroupMember
                    = await chkJoinGroup.DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false);

                if (!await chkJoinGroup.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken).ConfigureAwait(false))
                {
                    await chkInitiationGroup.DoThreadSafeAsync(x => x.Checked = false, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void txtNotes_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Control && e.KeyCode == Keys.A)
            {
                e.SuppressKeyPress = true;
                ((TextBox) sender)?.SelectAll();
            }
        }

        #endregion Additional Initiation Tab Control Events

        #region Additional Critter Powers Tab Control Events

        private async void treCritterPowers_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedCritterPower(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedCritterPower(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                // Look for the selected Critter Power.
                if (await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false)
                    is CritterPower objPower)
                {
                    await cmdDeleteCritterPower.DoThreadSafeAsync(x => x.Enabled = objPower.Grade == 0, token)
                                               .ConfigureAwait(false);
                    string strName = await objPower.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false);
                    await lblCritterPowerName.DoThreadSafeAsync(x => x.Text = strName, token).ConfigureAwait(false);
                    string strText = await objPower.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                   .ConfigureAwait(false);
                    await lblCritterPowerCategory.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                    string strText2 = await objPower.DisplayTypeAsync(GlobalSettings.Language, token)
                                                    .ConfigureAwait(false);
                    await lblCritterPowerType.DoThreadSafeAsync(x => x.Text = strText2, token).ConfigureAwait(false);
                    string strText3 = await objPower.DisplayActionAsync(GlobalSettings.Language, token)
                                                    .ConfigureAwait(false);
                    await lblCritterPowerAction.DoThreadSafeAsync(x => x.Text = strText3, token).ConfigureAwait(false);
                    string strText4 = await objPower.DisplayRangeAsync(GlobalSettings.Language, token)
                                                    .ConfigureAwait(false);
                    await lblCritterPowerRange.DoThreadSafeAsync(x => x.Text = strText4, token).ConfigureAwait(false);
                    string strText5 = await objPower.DisplayDurationAsync(GlobalSettings.Language, token)
                                                    .ConfigureAwait(false);
                    await lblCritterPowerDuration.DoThreadSafeAsync(x => x.Text = strText5, token)
                                                 .ConfigureAwait(false);
                    await chkCritterPowerCount.DoThreadSafeAsync(x => x.Checked = objPower.CountTowardsLimit, token)
                                              .ConfigureAwait(false);
                    await objPower.SetSourceDetailAsync(lblCritterPowerSource, token).ConfigureAwait(false);
                    if (objPower.PowerPoints > 0)
                    {
                        await lblCritterPowerPointCost.DoThreadSafeAsync(x =>
                        {
                            x.Text = objPower.PowerPoints.ToString(GlobalSettings
                                                                       .CultureInfo);
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                           .ConfigureAwait(false);
                    }
                    else
                    {
                        await lblCritterPowerPointCost.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                        await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                    }
                }
                else
                {
                    await cmdDeleteCritterPower.DoThreadSafeAsync(x => x.Enabled = false, token).ConfigureAwait(false);
                    await lblCritterPowerName.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                             .ConfigureAwait(false);
                    await lblCritterPowerCategory.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                                 .ConfigureAwait(false);
                    await lblCritterPowerType.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                             .ConfigureAwait(false);
                    await lblCritterPowerAction.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                               .ConfigureAwait(false);
                    await lblCritterPowerRange.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                              .ConfigureAwait(false);
                    await lblCritterPowerDuration.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                                 .ConfigureAwait(false);
                    await chkCritterPowerCount.DoThreadSafeAsync(x => x.Checked = false, token).ConfigureAwait(false);
                    await SourceString.Blank.SetControlAsync(lblCritterPowerSource, this, token).ConfigureAwait(false);
                    await lblCritterPowerPointCost.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                    await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void chkCritterPowerCount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                // Locate the selected Critter Power.
                if (!(await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                        CritterPower objPower))
                    return;
                objPower.CountTowardsLimit
                    = await chkCritterPowerCount.DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false);

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Critter Powers Tab Control Events

        #region Additional Karma and Nuyen Tab Control Events

        private async void lstKarma_DoubleClick(object sender, EventArgs e)
        {
            try
            {
                ListViewItem objItem
                    = await lstKarma.DoThreadSafeFuncAsync(
                                        x => x.SelectedItems.Count > 0 ? lstKarma.SelectedItems[0] : null, GenericToken)
                                    .ConfigureAwait(false);
                if (objItem == null)
                {
                    return;
                }

                // Find the selected Karma Expense.
                ExpenseLogEntry objExpense
                    = (objItem.SubItems[3] as ListViewItemWithValue.ListViewSubItemWithValue)?.Value as ExpenseLogEntry
                      ?? new ExpenseLogEntry(CharacterObject);

                // If this is a manual entry, let the player modify the amount.
                int intOldAmount = objExpense.Amount.ToInt32();
                bool blnAllowEdit = objExpense.Undo != null
                                    && (objExpense.Undo.KarmaType == KarmaExpenseType.ManualAdd ||
                                        objExpense.Undo.KarmaType ==
                                        KarmaExpenseType.ManualSubtract);

                bool blnDoRepopulateList;
                using (ThreadSafeForm<CreateExpense> frmEditExpense = await ThreadSafeForm<CreateExpense>.GetAsync(
                           () => new CreateExpense(CharacterObjectSettings)
                           {
                               Reason = objExpense.Reason,
                               Amount = objExpense.Amount,
                               Refund = objExpense.Refund,
                               SelectedDate = objExpense.Date,
                               ForceCareerVisible = objExpense.ForceCareerVisible,
                               IsInEditMode = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    frmEditExpense.MyForm.LockFields(blnAllowEdit);

                    if (await frmEditExpense.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    // If this is a manual entry, update the character's Karma total.
                    int intNewAmount = frmEditExpense.MyForm.Amount.ToInt32();
                    if (blnAllowEdit && intOldAmount != intNewAmount)
                    {
                        await objExpense.SetAmountAsync(intNewAmount, GenericToken).ConfigureAwait(false);
                        await CharacterObject.ModifyKarmaAsync(intNewAmount - intOldAmount, GenericToken)
                                             .ConfigureAwait(false);
                        blnDoRepopulateList = true;
                    }
                    else
                        blnDoRepopulateList = intNewAmount != 0
                                              || await chkShowFreeKarma
                                                       .DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                       .ConfigureAwait(false);

                    // Rename the Expense.
                    objExpense.Reason = frmEditExpense.MyForm.Reason;
                    objExpense.Date = frmEditExpense.MyForm.SelectedDate;
                }

                if (blnDoRepopulateList)
                    await RepopulateKarmaExpenseList(GenericToken).ConfigureAwait(false);

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void lstNuyen_DoubleClick(object sender, EventArgs e)
        {
            try
            {
                ListViewItem objItem
                    = await lstNuyen.DoThreadSafeFuncAsync(
                                        x => x.SelectedItems.Count > 0 ? lstNuyen.SelectedItems[0] : null, GenericToken)
                                    .ConfigureAwait(false);
                if (objItem == null)
                {
                    return;
                }

                // Find the selected Nuyen Expense.
                ExpenseLogEntry objExpense
                    = (objItem.SubItems[3] as ListViewItemWithValue.ListViewSubItemWithValue)?.Value as ExpenseLogEntry
                      ?? new ExpenseLogEntry(CharacterObject);

                // If this is a manual entry, let the player modify the amount.
                decimal decOldAmount = objExpense.Amount;
                bool blnAllowEdit = objExpense.Undo != null
                                    && (objExpense.Undo.NuyenType == NuyenExpenseType.ManualAdd ||
                                        objExpense.Undo.NuyenType ==
                                        NuyenExpenseType.ManualSubtract);

                bool blnDoRepopulateList;
                using (ThreadSafeForm<CreateExpense> frmEditExpense = await ThreadSafeForm<CreateExpense>.GetAsync(
                           () => new CreateExpense(CharacterObjectSettings)
                           {
                               Reason = objExpense.Reason,
                               Amount = objExpense.Amount,
                               Refund = objExpense.Refund,
                               SelectedDate = objExpense.Date,
                               ForceCareerVisible = objExpense.ForceCareerVisible,
                               IsInEditMode = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    await frmEditExpense.MyForm.SetModeAsync(ExpenseType.Nuyen, GenericToken).ConfigureAwait(false);
                    frmEditExpense.MyForm.LockFields(blnAllowEdit);

                    if (await frmEditExpense.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    // If this is a manual entry, update the character's Karma total.
                    decimal decNewAmount = frmEditExpense.MyForm.Amount;
                    if (blnAllowEdit && decOldAmount != decNewAmount)
                    {
                        await objExpense.SetAmountAsync(decNewAmount, GenericToken).ConfigureAwait(false);
                        await CharacterObject.ModifyNuyenAsync(decNewAmount - decOldAmount, GenericToken).ConfigureAwait(false);
                        blnDoRepopulateList = true;
                    }
                    else
                        blnDoRepopulateList = decNewAmount != 0
                                              || await chkShowFreeNuyen
                                                       .DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                       .ConfigureAwait(false);

                    // Rename the Expense.
                    objExpense.Reason = frmEditExpense.MyForm.Reason;
                    objExpense.Date = frmEditExpense.MyForm.SelectedDate;
                }

                if (blnDoRepopulateList)
                    await RepopulateNuyenExpenseList(GenericToken).ConfigureAwait(false);

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void lstKarma_ColumnClick(object sender, ColumnClickEventArgs e)
        {
            if (e.Column == _lvwKarmaColumnSorter.SortColumn)
            {
                _lvwKarmaColumnSorter.Order = _lvwKarmaColumnSorter.Order == SortOrder.Ascending
                    ? SortOrder.Descending
                    : SortOrder.Ascending;
            }
            else
            {
                _lvwKarmaColumnSorter.SortColumn = e.Column;
                _lvwKarmaColumnSorter.Order = SortOrder.Ascending;
            }

            lstKarma.Sort();
        }

        private void lstNuyen_ColumnClick(object sender, ColumnClickEventArgs e)
        {
            if (e.Column == _lvwNuyenColumnSorter.SortColumn)
            {
                _lvwNuyenColumnSorter.Order = _lvwNuyenColumnSorter.Order == SortOrder.Ascending
                    ? SortOrder.Descending
                    : SortOrder.Ascending;
            }
            else
            {
                _lvwNuyenColumnSorter.SortColumn = e.Column;
                _lvwNuyenColumnSorter.Order = SortOrder.Ascending;
            }

            lstNuyen.Sort();
        }

        #endregion Additional Karma and Nuyen Tab Control Events

        #region Additional Improvements Tab Control Events

        private async void treImprovements_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedImprovement(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedImprovement(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                if (await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false)
                    is Improvement objImprovement)
                {
                    // Get the human-readable name of the Improvement from the Improvements file.
                    XmlNode objNode = (await CharacterObject.LoadDataAsync("improvements.xml", token: token)
                                                            .ConfigureAwait(false))
                        .TryGetNodeByNameOrId("/chummer/improvements/improvement", objImprovement.CustomId);
                    if (objNode != null)
                    {
                        string strText = objNode["translate"]?.InnerTextViaPool(token) ?? objNode["name"]?.InnerTextViaPool(token) ?? objImprovement.CustomId;
                        await lblImprovementType.DoThreadSafeAsync(x => x.Text = strText, token)
                              .ConfigureAwait(false);
                    }
                    else
                        await lblImprovementType.DoThreadSafeAsync(x => x.Text = objImprovement.CustomId, token)
                              .ConfigureAwait(false);

                    token.ThrowIfCancellationRequested();
                    string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token)
                                                           .ConfigureAwait(false);
                    // Build a string that contains the value(s) of the Improvement.
                    string strValue;
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdValue))
                    {
                        token.ThrowIfCancellationRequested();
                        if (!string.IsNullOrEmpty(objImprovement.ImprovedName))
                            sbdValue.AppendLine(await LanguageManager
                                              .GetStringAsync("Label_CreateImprovementSelectedValue", token: token)
                                              .ConfigureAwait(false)).Append(strSpace
                                                                     ).Append(objImprovement.ImprovedName);
                        if (objImprovement.Rating != 0)
                            sbdValue.AppendLine(await LanguageManager.GetStringAsync("Label_Rating", token: token)
                                                             .ConfigureAwait(false)).Append(strSpace
                                ).Append(objImprovement.Rating.ToString(GlobalSettings.CultureInfo));
                        if (objImprovement.Value != 0)
                            sbdValue.AppendLine(await LanguageManager.GetStringAsync("Label_CreateImprovementValue", token: token)
                                                             .ConfigureAwait(false)).Append(strSpace
                                ).Append(objImprovement.Value.ToString(GlobalSettings.CultureInfo));
                        if (objImprovement.Minimum != 0)
                            sbdValue.AppendLine(await LanguageManager.GetStringAsync("Label_CreateImprovementMinimum", token: token)
                                                             .ConfigureAwait(false)).Append(strSpace
                                ).Append(objImprovement.Minimum.ToString(GlobalSettings.CultureInfo));
                        if (objImprovement.Maximum != 0)
                            sbdValue.AppendLine(await LanguageManager.GetStringAsync("Label_CreateImprovementMaximum", token: token)
                                                             .ConfigureAwait(false)).Append(strSpace
                                ).Append(objImprovement.Maximum.ToString(GlobalSettings.CultureInfo));
                        if (objImprovement.Augmented != 0)
                            sbdValue.AppendLine(await LanguageManager
                                              .GetStringAsync("Label_CreateImprovementAugmented", token: token)
                                              .ConfigureAwait(false)).Append(strSpace
                                                                     ).Append(objImprovement.Augmented.ToString(
                                                                         GlobalSettings.CultureInfo));
                        strValue = sbdValue.ToString();
                    }
                    await cmdImprovementsEnableAll.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                    await cmdImprovementsDisableAll.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                    await lblImprovementValue.DoThreadSafeAsync(x => x.Text = strValue, token).ConfigureAwait(false);
                    await chkImprovementActive.DoThreadSafeAsync(x =>
                    {
                        x.Checked = objImprovement.Enabled;
                        x.Visible = true;
                    }, token).ConfigureAwait(false);
                }
                else if (await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Level, token)
                                              .ConfigureAwait(false) == 0)
                {
                    await cmdImprovementsEnableAll.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                    await cmdImprovementsDisableAll.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                    await lblImprovementType.DoThreadSafeAsync(x => x.Text = string.Empty, token).ConfigureAwait(false);
                    await lblImprovementValue.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                             .ConfigureAwait(false);
                    await chkImprovementActive.DoThreadSafeAsync(x =>
                    {
                        x.Checked = false;
                        x.Visible = false;
                    }, token).ConfigureAwait(false);
                }
                else
                {
                    await cmdImprovementsEnableAll.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                    await cmdImprovementsDisableAll.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                    await lblImprovementType.DoThreadSafeAsync(x => x.Text = string.Empty, token).ConfigureAwait(false);
                    await lblImprovementValue.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                             .ConfigureAwait(false);
                    await chkImprovementActive.DoThreadSafeAsync(x =>
                    {
                        x.Checked = false;
                        x.Visible = false;
                    }, token).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void treImprovements_DoubleClick(object sender, EventArgs e)
        {
            try
            {
                if (await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                         .ConfigureAwait(false) is Improvement)
                {
                    await DoEditImprovement(GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await DoAddImprovement(GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkImprovementActive_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                TreeNode nodSelected = await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false);
                if (nodSelected == null || !(nodSelected.Tag is Improvement objImprovement))
                    return;
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    if (await chkImprovementActive.DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false))
                        await ImprovementManager.EnableImprovementsAsync(CharacterObject, objImprovement, GenericToken)
                                                .ConfigureAwait(false);
                    else
                        await ImprovementManager.DisableImprovementsAsync(CharacterObject, objImprovement, GenericToken)
                                                .ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
                Color objColor = await objImprovement.GetPreferredColorAsync(GenericToken).ConfigureAwait(false);
                await treImprovements.DoThreadSafeAsync(() => nodSelected.ForeColor = objColor, GenericToken).ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddImprovementGroup_Click(object sender, EventArgs e)
        {
            try
            {
                string strDescription = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                // Add a new location to the Improvements Tree.
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    string strLocation = frmPickText.MyForm.SelectedValue;

                    if (string.IsNullOrEmpty(strLocation))
                        return;

                    await (await CharacterObject.GetImprovementGroupsAsync(GenericToken).ConfigureAwait(false)).AddAsync(strLocation, GenericToken).ConfigureAwait(false);
                }

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Improvements Tab Control Events

        #region Tree KeyDown Events

        private async void treQualities_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                try
                {
                    await DoDeleteQuality(GenericToken).ConfigureAwait(false);
                }
                catch (OperationCanceledException)
                {
                    //swallow this
                }
            }
        }

        private async void treImprovements_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                try
                {
                    await DoDeleteImprovement(GenericToken).ConfigureAwait(false);
                }
                catch (OperationCanceledException)
                {
                    //swallow this
                }
            }
        }

        #endregion Tree KeyDown Events

        #region Additional Drug Tab Control Events

        private async void treCustomDrugs_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedDrug(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Drug Tab Control Events

        #region Splitter Resize Events

        private void splitKarmaNuyen_Panel1_Resize(object sender, EventArgs e)
        {
            if (lstKarma.Columns.Count >= 2 && lstKarma.Width > 409)
            {
                lstKarma.Columns[2].Width = lstKarma.Width - 195;
            }
        }

        private void splitKarmaNuyen_Panel2_Resize(object sender, EventArgs e)
        {
            if (lstNuyen.Columns.Count >= 2 && lstNuyen.Width > 409)
            {
                lstNuyen.Columns[2].Width = lstNuyen.Width - 195;
            }
        }

        #endregion Splitter Resize Events

        #region Other Control Events

        private async void cmdEdgeSpent_Click(object sender, EventArgs e)
        {
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    if (await CharacterObject.GetEdgeUsedAsync(GenericToken).ConfigureAwait(false)
                        >= await (await CharacterObject.GetAttributeAsync("EDG", token: GenericToken)
                            .ConfigureAwait(false)).GetTotalValueAsync(
                            GenericToken).ConfigureAwait(false))
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_CannotSpendEdge", token: GenericToken)
                                .ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_CannotSpendEdge", token: GenericToken)
                                .ConfigureAwait(false),
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                    }

                    await CharacterObject.ModifyEdgeUsedAsync(1, GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdEdgeGained_Click(object sender, EventArgs e)
        {
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    if (await CharacterObject.GetEdgeUsedAsync(GenericToken).ConfigureAwait(false) <= 0)
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                            this, await LanguageManager.GetStringAsync("Message_CannotRegainEdge", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_CannotRegainEdge", token: GenericToken).ConfigureAwait(false),
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                    }

                    await CharacterObject.ModifyEdgeUsedAsync(-1, GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ProcessSelectedTabChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private enum CmdOperation
        {
            None,
            Up,
            Down
        }

        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            CmdOperation op = CmdOperation.None;

            // Determine which custom operation we're attempting, if any
            switch (keyData)
            {
                case Keys.Up | Keys.Alt:
                    op = CmdOperation.Up;
                    break;

                case Keys.Down | Keys.Alt:
                    op = CmdOperation.Down;
                    break;
            }

            bool up = op == CmdOperation.Up;
            if (up || op == CmdOperation.Down)
            {
                bool requireParentSortable = false;
                TreeView treActiveView = null;

                if (tabCharacterTabs.SelectedTab == tabStreetGear)
                {
                    // Lifestyle Tab.
                    if (tabStreetGearTabs.SelectedTab == tabLifestyle)
                    {
                        treActiveView = treLifestyles;
                    }
                    // Armor Tab.
                    else if (tabStreetGearTabs.SelectedTab == tabArmor)
                    {
                        treActiveView = treArmor;
                    }
                    // Weapons Tab.
                    else if (tabStreetGearTabs.SelectedTab == tabWeapons)
                    {
                        treActiveView = treWeapons;
                    }
                    // Gear Tab.
                    else if (tabStreetGearTabs.SelectedTab == tabGear)
                    {
                        treActiveView = treGear;
                    }
                    // Drugs Tab.
                    else if (tabStreetGearTabs.SelectedTab == tabDrugs)
                    {
                        treActiveView = treCustomDrugs;
                    }
                }
                // Cyberware Tab.
                else if (tabCharacterTabs.SelectedTab == tabCyberware)
                {
                    // Top-level cyberware is sorted alphabetically, but we can re-arrange any plugins/gear inside them
                    requireParentSortable = true;
                    treActiveView = treCyberware;
                }
                // Vehicles Tab.
                else if (tabCharacterTabs.SelectedTab == tabVehicles)
                {
                    treActiveView = treVehicles;
                }
                // Critter Powers Tab.
                else if (tabCharacterTabs.SelectedTab == tabCritter)
                {
                    treActiveView = treCritterPowers;
                }
                // Improvements Tab.
                else if (tabCharacterTabs.SelectedTab == tabImprovements)
                {
                    treActiveView = treImprovements;
                }

                if (treActiveView != null)
                {
                    TreeNode objSelectedNode = treActiveView.SelectedNode;
                    TreeNode objParentNode = objSelectedNode?.Parent;

                    if (!requireParentSortable || objParentNode?.Tag is ICanSort)
                    {
                        TreeNodeCollection lstNodes = objParentNode?.Nodes ?? treActiveView.Nodes;
                        int intNewIndex = lstNodes.IndexOf(objSelectedNode);
                        intNewIndex = up ? Math.Max(0, intNewIndex - 1) : Math.Min(lstNodes.Count - 1, intNewIndex + 1);

                        try
                        {
                            Utils.SafelyRunSynchronously(
                                () => MoveTreeNode(objSelectedNode, intNewIndex, requireParentSortable, GenericToken), GenericToken);
                        }
                        catch (OperationCanceledException)
                        {
                            //swallow this
                        }
                    }
                }

                // Returning true tells the program to consume the input
                return true;
            }

            // If none of our key combinations are used then use the default logic
            return base.ProcessCmdKey(ref msg, keyData);
        }

        #endregion Other Control Events

        #region Condition Monitors

        private async void chkPhysicalCM_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                if (sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                    await ProcessConditionMonitorCheckedChanged(objBox, i => CharacterObject.SetPhysicalCMFilledAsync(i, GenericToken), token: GenericToken)
                        .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkStunCM_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                if (sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                    await ProcessConditionMonitorCheckedChanged(objBox, i => CharacterObject.SetStunCMFilledAsync(i, GenericToken), token: GenericToken)
                        .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        /// <summary>
        /// Manages the rendering of condition monitor checkboxes for characters that can have modifiers like overflow and threshold offsets.
        /// </summary>
        /// <param name="pnlConditionMonitorPanel">Container panel for the condition monitor checkboxes.</param>
        /// <param name="intConditionMax">Highest value of the condition monitor type.</param>
        /// <param name="intThreshold">Show an increase in modifiers every <paramref name="intThreshold"/> boxes.</param>
        /// <param name="intThresholdOffset">Initial threshold for penalties from <paramref name="intThreshold"/> should be offset by this much.</param>
        /// <param name="intOverflow">Number of overflow boxes to show (set to 0 if none, like for the stun condition monitor).</param>
        /// <param name="evtButtonClickEvent">Event handler for when a CM box is clicked</param>
        /// <param name="check">Whether to check the checkbox when finished processing. Expected to only be called on load.</param>
        /// <param name="value">Tag value of the checkbox to enable when using the check parameter. Expected to be the StunCMFilled or PhysicalCMFilled properties.</param>
        /// <param name="token">Cancellation token to use.</param>
        private async Task ProcessCharacterConditionMonitorBoxDisplays(
            Control pnlConditionMonitorPanel, int intConditionMax, int intThreshold, int intThresholdOffset,
            int intOverflow, EventHandler evtButtonClickEvent, bool check = false, int value = 0,
            CancellationToken token = default)
        {
            await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
            try
            {
                if (intConditionMax > 0)
                {
                    await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                    List<DpiFriendlyCheckBoxDisguisedAsButton> lstCheckBoxes = await pnlConditionMonitorPanel
                        .DoThreadSafeFuncAsync(x => x.Controls
                                                     .OfType<DpiFriendlyCheckBoxDisguisedAsButton>().ToList(), token)
                        .ConfigureAwait(false);
                    if (lstCheckBoxes.Count < intConditionMax + intOverflow)
                    {
                        int intMax = 0;
                        DpiFriendlyCheckBoxDisguisedAsButton objMaxCheckBox = null;
                        foreach (DpiFriendlyCheckBoxDisguisedAsButton objLoopCheckBox in lstCheckBoxes)
                        {
                            int intLoop = Convert.ToInt32(
                                await objLoopCheckBox.DoThreadSafeFuncAsync(x => x.Tag, token).ConfigureAwait(false),
                                GlobalSettings.InvariantCultureInfo);
                            if (objMaxCheckBox == null || intMax < intLoop)
                            {
                                intMax = intLoop;
                                objMaxCheckBox = objLoopCheckBox;
                            }
                        }

                        if (objMaxCheckBox != null)
                        {
                            await pnlConditionMonitorPanel.DoThreadSafeAsync(x =>
                            {
                                for (int i = intMax + 1; i <= intConditionMax + intOverflow; i++)
                                {
                                    DpiFriendlyCheckBoxDisguisedAsButton cb
                                        = new DpiFriendlyCheckBoxDisguisedAsButton
                                        {
                                            Tag = i,
                                            Appearance = objMaxCheckBox.Appearance,
                                            AutoSize = objMaxCheckBox.AutoSize,
                                            MinimumSize = objMaxCheckBox.MinimumSize,
                                            Size = objMaxCheckBox.Size,
                                            Padding = objMaxCheckBox.Padding,
                                            Margin = objMaxCheckBox.Margin,
                                            TextAlign = objMaxCheckBox.TextAlign,
                                            Font = objMaxCheckBox.Font,
                                            FlatStyle = objMaxCheckBox.FlatStyle,
                                            UseVisualStyleBackColor = objMaxCheckBox.UseVisualStyleBackColor
                                        };
                                    if (evtButtonClickEvent != null)
                                        cb.Click += evtButtonClickEvent;
                                    x.Controls.Add(cb);
                                    lstCheckBoxes.Add(cb);
                                }
                            }, token).ConfigureAwait(false);
                        }
                    }

                    int intMaxDimension = 0;
                    int intMaxMargin = 0;
                    foreach (DpiFriendlyCheckBoxDisguisedAsButton chkCmBox in lstCheckBoxes)
                    {
                        int intCurrentBoxTag
                            = Convert.ToInt32(
                                await chkCmBox.DoThreadSafeFuncAsync(x => x.Tag, token).ConfigureAwait(false),
                                GlobalSettings.InvariantCultureInfo);
                        await chkCmBox.DoThreadSafeAsync(x =>
                        {
                            x.BackColor = ColorManager
                                .ControlLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                            if (x.Focused)
                                x.Parent.Focus();
                        }, token).ConfigureAwait(false);
                        if (check && intCurrentBoxTag <= value)
                        {
                            await chkCmBox.DoThreadSafeAsync(x =>
                            {
                                x.Checked = true;
                                x.BackColor = ColorManager
                                    .ControlDarkestLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                            }, token).ConfigureAwait(false);
                        }

                        if (intCurrentBoxTag <= intConditionMax)
                        {
                            string strText = " "; // Non-breaking space to help with DPI stuff
                            if (intCurrentBoxTag > intThresholdOffset)
                            {
                                int intModifiers = (intThresholdOffset - intCurrentBoxTag).DivRem(intThreshold, out int intModulo);
                                if (intModulo == 0)
                                    strText = intModifiers.ToString(GlobalSettings.CultureInfo);
                            }
                            await chkCmBox.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.BatchSetImages(null, null, null, null, null, null);
                                x.Text = strText;
                            }, token).ConfigureAwait(false);
                        }
                        else if (intOverflow != 0 && intCurrentBoxTag <= intConditionMax + intOverflow)
                        {
                            await chkCmBox.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.BackColor = x.Checked
                                    ? ColorManager.ControlTextLight
                                    : ColorManager
                                        .ControlDarkerLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                if (intCurrentBoxTag == intConditionMax + intOverflow)
                                {
                                    x.BatchSetImages(Properties.Resources.rip_16, Properties.Resources.rip_20,
                                        Properties.Resources.rip_24, Properties.Resources.rip_32,
                                        Properties.Resources.rip_48, Properties.Resources.rip_64);
                                }
                                else
                                {
                                    x.BatchSetImages(null, null, null, null, null, null);
                                }
                            }, token).ConfigureAwait(false);
                        }
                        else
                        {
                            await chkCmBox.DoThreadSafeAsync(x =>
                            {
                                x.Visible = false;
                                x.BatchSetImages(null, null, null, null, null, null);
                                x.Text = " "; // Non-breaking space to help with DPI stuff
                            }, token).ConfigureAwait(false);
                        }

                        intMaxDimension = Math.Max(intMaxDimension,
                                                   Math.Max(
                                                       await chkCmBox.DoThreadSafeFuncAsync(x => x.Width, token)
                                                                     .ConfigureAwait(false),
                                                       await chkCmBox.DoThreadSafeFuncAsync(x => x.Height, token)
                                                                     .ConfigureAwait(false)));
                        Padding objMargin = await chkCmBox.DoThreadSafeFuncAsync(x => x.Margin, token)
                                                          .ConfigureAwait(false);
                        intMaxMargin = Math.Max(intMaxMargin,
                                                Math.Max(Math.Max(objMargin.Left, objMargin.Right),
                                                         Math.Max(objMargin.Top, objMargin.Bottom)));
                    }

                    Size objSquareSize = new Size(intMaxDimension, intMaxDimension);
                    Padding objSquarePadding = new Padding(intMaxMargin);
                    foreach (DpiFriendlyCheckBoxDisguisedAsButton chkCmBox in lstCheckBoxes)
                    {
                        await chkCmBox.DoThreadSafeAsync(x =>
                        {
                            x.MinimumSize = objSquareSize;
                            x.Margin = objSquarePadding;
                        }, token).ConfigureAwait(false);
                    }

                    await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.MaximumSize = new Size(
                                                                         (2 * intThreshold + 1)
                                                                         * (intMaxDimension + intMaxMargin) / 2,
                                                                         x.MaximumSize
                                                                          .Height), token)
                                                  .ConfigureAwait(
                                                      false); // Width slightly longer to give enough wiggle room to take care of any funny business
                }
                else
                {
                    await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                }
            }
            finally
            {
                await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Manages the rendering of condition monitor checkboxes for characters that can have modifiers like overflow and threshold offsets.
        /// </summary>
        /// <param name="pnlConditionMonitorPanel">Container panel for the condition monitor checkboxes.</param>
        /// <param name="intConditionMax">Highest value of the condition monitor type.</param>
        /// <param name="intCurrentConditionFilled">Current amount of boxes that should be filled in the condition monitor.</param>
        /// <param name="token">Cancellation token to use.</param>
        private async Task ProcessEquipmentConditionMonitorBoxDisplays(
            Control pnlConditionMonitorPanel, int intConditionMax, int intCurrentConditionFilled,
            CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    if (intConditionMax > 0)
                    {
                        await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                        foreach (DpiFriendlyCheckBoxDisguisedAsButton chkCmBox in await pnlConditionMonitorPanel
                                     .DoThreadSafeFuncAsync(x => x.Controls
                                                                  .OfType<DpiFriendlyCheckBoxDisguisedAsButton>(),
                                                            token).ConfigureAwait(false))
                        {
                            int intCurrentBoxTag
                                = Convert.ToInt32(
                                    await chkCmBox.DoThreadSafeFuncAsync(x => x.Tag, token).ConfigureAwait(false),
                                    GlobalSettings.InvariantCultureInfo);

                            await chkCmBox.DoThreadSafeAsync(x => x.Text = string.Empty, token).ConfigureAwait(false);
                            if (intCurrentBoxTag <= intConditionMax)
                            {
                                await chkCmBox.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    if (intCurrentBoxTag <= intCurrentConditionFilled)
                                    {
                                        x.Checked = true;
                                        if (x.BackColor == ColorManager.ControlLight
                                            || x.BackColor == ColorManager.ControlDarkestLight)
                                            x.BackColor = ColorManager
                                                .ControlDarkestLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                        else
                                            x.BackColor = ColorManager
                                                .ControlTextLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                    }
                                    else
                                    {
                                        x.Checked = false;
                                        if (x.BackColor == ColorManager.ControlLight
                                            || x.BackColor == ColorManager.ControlDarkestLight)
                                            x.BackColor = ColorManager
                                                .ControlLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                        else
                                            x.BackColor = ColorManager
                                                .ControlDarkerLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                    }

                                    if (x.Focused)
                                        x.Parent.Focus();
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkCmBox.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = false;
                                    x.Checked = false;
                                    if (x.BackColor == ColorManager.ControlLight
                                        || x.BackColor == ColorManager.ControlDarkestLight)
                                        x.BackColor = ColorManager
                                            .ControlLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                    else
                                        x.BackColor = ColorManager
                                            .ControlDarkerLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                    if (x.Focused)
                                        x.Parent.Focus();
                                }, token).ConfigureAwait(false);
                            }
                        }
                    }
                    else
                    {
                        await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken)
                                                  .ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Changes which boxes are filled and unfilled in a condition monitor when a box in that condition monitor is clicked.
        /// </summary>
        /// <param name="chkSender">Checkbox we're currently changing.</param>
        /// <param name="funcPropertyToUpdate">Function to run once the condition monitor has been processed, probably a property setter. Uses the amount of filled boxes as its argument.</param>
        /// <param name="blnDoUIUpdate">Whether to update all the other boxes in the UI or not. If something like ProcessEquipmentConditionMonitorBoxDisplays would be called later, this can be false.</param>
        /// <param name="token">Cancellation token to use.</param>
        private async Task ProcessConditionMonitorCheckedChanged(DpiFriendlyCheckBoxDisguisedAsButton chkSender,
                                                                      Func<int, Task> funcPropertyToUpdate = null,
                                                                      bool blnDoUIUpdate = true,
                                                                      CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (IsRefreshing || SkipUpdate)
                return;

            if (blnDoUIUpdate)
            {
                Control pnlConditionMonitorPanel
                    = await chkSender.DoThreadSafeFuncAsync(x => x.Parent, token).ConfigureAwait(false);

                if (pnlConditionMonitorPanel == null)
                    return;

                int intBoxTag
                    = Convert.ToInt32(await chkSender.DoThreadSafeFuncAsync(x => x.Tag, token).ConfigureAwait(false),
                                      GlobalSettings.InvariantCultureInfo);

                int intFillCount = (await chkSender.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                    .ToInt32();

                // If this is being checked, make sure everything before it is checked off.
                IsRefreshing = true;
                try
                {
                    await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.SuspendLayout(), token)
                                                  .ConfigureAwait(false);
                    try
                    {
                        foreach (DpiFriendlyCheckBoxDisguisedAsButton chkCmBox in await pnlConditionMonitorPanel
                                     .DoThreadSafeFuncAsync(x => x.Controls
                                                                  .OfType<DpiFriendlyCheckBoxDisguisedAsButton>(),
                                                            token).ConfigureAwait(false))
                        {
                            if (chkCmBox != chkSender)
                            {
                                int intCurrentBoxTag = Convert.ToInt32(
                                    await chkCmBox.DoThreadSafeFuncAsync(x => x.Tag, token).ConfigureAwait(false),
                                    GlobalSettings.InvariantCultureInfo);
                                if (intCurrentBoxTag < intBoxTag)
                                {
                                    await chkCmBox.DoThreadSafeAsync(x =>
                                    {
                                        x.Checked = true;
                                        if (x.BackColor == ColorManager.ControlLight
                                            || x.BackColor == ColorManager.ControlDarkestLight)
                                            x.BackColor = ColorManager
                                                .ControlDarkestLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                        else
                                            x.BackColor = ColorManager
                                                .ControlTextLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                        if (x.Focused)
                                            x.Parent.Focus();
                                    }, token).ConfigureAwait(false);
                                    ++intFillCount;
                                }
                                else if (intCurrentBoxTag > intBoxTag)
                                {
                                    await chkCmBox.DoThreadSafeAsync(x =>
                                    {
                                        x.Checked = false;
                                        if (x.BackColor == ColorManager.ControlLight
                                            || x.BackColor == ColorManager.ControlDarkestLight)
                                            x.BackColor = ColorManager
                                                .ControlLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                        else
                                            x.BackColor = ColorManager
                                                .ControlDarkerLight; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                        if (x.Focused)
                                            x.Parent.Focus();
                                    }, token).ConfigureAwait(false);
                                }
                            }
                        }
                    }
                    finally
                    {
                        await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken)
                                                      .ConfigureAwait(false);
                    }

                    if (funcPropertyToUpdate != null)
                        await funcPropertyToUpdate.Invoke(intFillCount).ConfigureAwait(false);
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            else if (funcPropertyToUpdate != null)
            {
                int intFillCount
                    = Convert.ToInt32(await chkSender.DoThreadSafeFuncAsync(x => x.Tag, token).ConfigureAwait(false),
                                      GlobalSettings.InvariantCultureInfo);
                if (!await chkSender.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                    --intFillCount;
                await funcPropertyToUpdate.Invoke(intFillCount).ConfigureAwait(false);
            }

            await SetDirty(true, token).ConfigureAwait(false);
        }

        private async void chkCyberwareCM_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                if (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                        IHasMatrixAttributes objItem && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                    await ProcessConditionMonitorCheckedChanged(objBox, i => {
                            objItem.MatrixCMFilled = i;
                            return Task.CompletedTask;
                        }, false, token: GenericToken)
                        .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkGearCM_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Locate the selected Gear.
                TreeNode objGearNode = null;
                await treGear.DoThreadSafeAsync(x =>
                {
                    objGearNode = x.SelectedNode;
                    while (objGearNode?.Level > 1)
                        objGearNode = objGearNode.Parent;
                }, GenericToken).ConfigureAwait(false);

                if (objGearNode?.Tag is Gear objGear && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                    await ProcessConditionMonitorCheckedChanged(objBox, i => {
                            objGear.MatrixCMFilled = i;
                            return Task.CompletedTask;
                        }, false, token: GenericToken)
                        .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkArmorMatrixCM_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                        IHasMatrixAttributes objItem && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                    await ProcessConditionMonitorCheckedChanged(objBox, i => {
                            objItem.MatrixCMFilled = i;
                            return Task.CompletedTask;
                        }, false, token: GenericToken)
                        .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkWeaponCM_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                        IHasMatrixAttributes objItem && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                    await ProcessConditionMonitorCheckedChanged(objBox, i => {
                            objItem.MatrixCMFilled = i;
                            return Task.CompletedTask;
                        }, false, token: GenericToken)
                        .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkVehicleCM_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                if (await panVehicleCM.DoThreadSafeFuncAsync(x => x.SelectedIndex, GenericToken).ConfigureAwait(false) == 0)
                {
                    // Locate the selected Vehicle.
                    TreeNode objVehicleNode = null;
                    await treVehicles.DoThreadSafeAsync(x =>
                    {
                        objVehicleNode = x.SelectedNode;
                        while (objVehicleNode?.Level > 1)
                            objVehicleNode = objVehicleNode.Parent;
                    }, GenericToken).ConfigureAwait(false);

                    if (objVehicleNode?.Tag is Vehicle objVehicle && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                        await ProcessConditionMonitorCheckedChanged(objBox, i => {
                                objVehicle.PhysicalCMFilled = i;
                                return Task.CompletedTask;
                            }, token: GenericToken)
                            .ConfigureAwait(false);
                }
                else if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                             IHasMatrixAttributes objItem && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                    await ProcessConditionMonitorCheckedChanged(objBox, i =>
                        {
                            objItem.MatrixCMFilled = i;
                            return Task.CompletedTask;
                        }, false, token: GenericToken)
                        .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Condition Monitors

        #region Custom Methods

        /// <summary>
        /// Refresh the currently-selected Drug.
        /// </summary>
        private async Task RefreshSelectedDrug(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpDrugs.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    object objSelectedNodeTag = await treCustomDrugs
                                                      .DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token)
                                                      .ConfigureAwait(false);
                    if (objSelectedNodeTag is Drug objDrug && await treCustomDrugs
                                                                    .DoThreadSafeFuncAsync(
                                                                        x => x.SelectedNode?.Level != 0, token)
                                                                    .ConfigureAwait(false))
                    {
                        await flpDrugs.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await btnDeleteCustomDrug.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await lblDrugName.DoThreadSafeAsync(x => x.Text = objDrug.Name, token).ConfigureAwait(false);
                        string strAvail = await objDrug.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                        await lblDrugAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                          .ConfigureAwait(false);
                        string strGradeName
                            = await objDrug.Grade.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                        await lblDrugGrade.DoThreadSafeAsync(x => x.Text = strGradeName, token)
                                          .ConfigureAwait(false);
                        string strCost = (await objDrug.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                             await CharacterObjectSettings.GetNuyenFormatAsync(token)
                                                 .ConfigureAwait(false),
                                             GlobalSettings.CultureInfo)
                                         + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                        await lblDrugCost.DoThreadSafeAsync(x => x.Text = strCost, token).ConfigureAwait(false);
                        await lblDrugQty
                              .DoThreadSafeAsync(x => x.Text = objDrug.Quantity.ToString(GlobalSettings.CultureInfo),
                                                 token).ConfigureAwait(false);
                        bool blnEnabled = await objDrug.GetTotalCostAsync(token).ConfigureAwait(false) <= await CharacterObject.GetNuyenAsync(token).ConfigureAwait(false);
                        await btnIncreaseDrugQty
                              .DoThreadSafeAsync(x => x.Enabled = blnEnabled, token)
                              .ConfigureAwait(false);
                        await btnDecreaseDrugQty.DoThreadSafeAsync(x => x.Enabled = objDrug.Quantity != 0, token)
                                                .ConfigureAwait(false);
                        string strCategory = await objDrug.DisplayCategoryAsync(GlobalSettings.Language, token).ConfigureAwait(false);
                        await lblDrugCategory.DoThreadSafeAsync(x => x.Text = strCategory, token)
                                             .ConfigureAwait(false);
                        string strAddictionRating = (await objDrug.GetAddictionRatingAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                        await lblDrugAddictionRating
                              .DoThreadSafeAsync(
                                  x => x.Text = strAddictionRating, token)
                              .ConfigureAwait(false);
                        string strAddictionThreshold = (await objDrug.GetAddictionThresholdAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                        await lblDrugAddictionThreshold
                              .DoThreadSafeAsync(
                                  x => x.Text = strAddictionThreshold, token)
                              .ConfigureAwait(false);
                        string strText = await objDrug.GetEffectDescriptionAsync(token: token).ConfigureAwait(false);
                        await lblDrugEffect.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                        using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdComponents))
                        {
                            await objDrug.Components.ForEachAsync(async objComponent =>
                            {
                                sbdComponents.AppendLine(
                                    await objComponent.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                            }, token).ConfigureAwait(false);
                            string strComponents = sbdComponents.ToString();
                            await lblDrugComponents.DoThreadSafeAsync(x => x.Text = strComponents, token)
                                                   .ConfigureAwait(false);
                        }
                    }
                    else
                    {
                        await flpDrugs.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await btnDeleteCustomDrug
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await flpDrugs.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private int _intFileUpdateQueued;

        protected override async void LiveUpdateFromCharacterFile(object sender, FileSystemEventArgs e)
        {
            if (Interlocked.Increment(ref _intFileUpdateQueued) > 1)
            {
                Interlocked.Decrement(ref _intFileUpdateQueued);
                return;
            }

            try
            {
                while (IsDirty || IsLoading || SkipUpdate || IsCharacterUpdateRequested)
                    await Utils.SafeSleepAsync(GenericToken).ConfigureAwait(false);

                string strCharacterFile = await CharacterObject.GetFileNameAsync(GenericToken).ConfigureAwait(false);
                if (string.IsNullOrEmpty(strCharacterFile) || !File.Exists(strCharacterFile))
                    return;

                // Character is not dirty and their save file was updated outside of Chummer5 while it is open, so reload them
                CursorWait objCursorWaitOuter
                    = await CursorWait.NewAsync(this, true, GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker =
                        await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        CursorWait objCursorWait
                            = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                        try
                        {
                            using (ThreadSafeForm<LoadingBar> frmLoadingBar
                                   = await Program.CreateAndShowProgressBarAsync(Path.GetFileName(strCharacterFile),
                                       Character.NumLoadingSections + 1,
                                       GenericToken).ConfigureAwait(false))
                            {
                                SkipUpdate = true;
                                try
                                {
                                    await CharacterObject
                                        .LoadAsync(frmLoadingForm: frmLoadingBar.MyForm, token: GenericToken)
                                        .ConfigureAwait(false);
                                    await frmLoadingBar.MyForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_UI", token: GenericToken)
                                            .ConfigureAwait(false),
                                        token: GenericToken).ConfigureAwait(false);

                                    Tradition objTradition = await CharacterObject.GetMagicTraditionAsync(GenericToken)
                                        .ConfigureAwait(false);
                                    TraditionType eTraditionType = await objTradition.GetTypeAsync(GenericToken)
                                        .ConfigureAwait(false);
                                    string strTraditionSourceIdString =
                                        await objTradition.GetSourceIDStringAsync(GenericToken)
                                            .ConfigureAwait(false);
                                    await cboTradition.DoThreadSafeAsync(x =>
                                    {
                                        if (eTraditionType == TraditionType.MAG &&
                                            !string.IsNullOrEmpty(strTraditionSourceIdString))
                                            x.SelectedValue = strTraditionSourceIdString;
                                        if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                            x.SelectedIndex = 0;
                                    }, GenericToken).ConfigureAwait(false);
                                    await cboStream.DoThreadSafeAsync(x =>
                                    {
                                        if (eTraditionType == TraditionType.RES &&
                                            !string.IsNullOrEmpty(strTraditionSourceIdString))
                                            x.SelectedValue = strTraditionSourceIdString;
                                        if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                            x.SelectedIndex = 0;
                                    }, GenericToken).ConfigureAwait(false);
                                }
                                finally
                                {
                                    SkipUpdate = false;
                                }
                            }
                        }
                        finally
                        {
                            await objCursorWait.DisposeAsync().ConfigureAwait(false);
                        }

                        // Immediately await character update because we know it's necessary
                        try
                        {
                            await RequestAndProcessCharacterUpdate(GenericToken).ConfigureAwait(false);
                        }
                        catch (OperationCanceledException)
                        {
                            return;
                        }

                        IsDirty = false;

                        ConcurrentBag<string> lstInternalIdsNeedingReapplyImprovements
                            = await CharacterObject.TakeInternalIdsNeedingReapplyImprovementsAsync(GenericToken)
                                .ConfigureAwait(false);
                        if (lstInternalIdsNeedingReapplyImprovements?.Count > 0 && !Utils.IsUnitTest)
                        {
                            string strListFriendlyNames;
                            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdListFriendlyNames))
                            {
                                foreach (IHasInternalId objSource in await CharacterObject.GetItemsByInternalIdsAsync(lstInternalIdsNeedingReapplyImprovements, true, GenericToken).ConfigureAwait(false))
                                {
                                    string strToAdd;
                                    if (objSource is IHasCustomName objCustomNameItem)
                                        strToAdd = objCustomNameItem.CustomName;
                                    else if (objSource is Improvement objImprovement)
                                        strToAdd = await CharacterObject.GetObjectNameAsync(objImprovement, token: GenericToken).ConfigureAwait(false);
                                    else if (objSource is IHasName objNamedItem)
                                        strToAdd = await objNamedItem.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                                    else
                                        strToAdd = objSource.InternalId;
                                    sbdListFriendlyNames.AppendLine(strToAdd);
                                }
                                strListFriendlyNames = sbdListFriendlyNames.ToString();
                            }
                            string strDescription = await LanguageManager.GetStringAsync("Message_ImprovementLoadError", token: GenericToken).ConfigureAwait(false);
                            if (!string.IsNullOrEmpty(strListFriendlyNames))
                            {
                                strDescription += await LanguageManager.GetStringAsync("Message_ImprovementLoadErrorPart2", token: GenericToken).ConfigureAwait(false) + strListFriendlyNames;
                            }
                            if (await Program.ShowScrollableMessageBoxAsync(
                                this, strDescription,
                                await LanguageManager.GetStringAsync("MessageTitle_ImprovementLoadError", token: GenericToken).ConfigureAwait(false),
                                MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false) == DialogResult.Yes)
                            {
                                await DoReapplyImprovements(lstInternalIdsNeedingReapplyImprovements,
                                    GenericToken).ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWaitOuter.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
            finally
            {
                Interlocked.Decrement(ref _intFileUpdateQueued);
            }
        }

        /// <summary>
        /// Update the Character information.
        /// </summary>
        protected override async Task DoUpdateCharacterInfo(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            await base.DoUpdateCharacterInfo(token).ConfigureAwait(false);
            while (SkipUpdate)
                await Utils.SafeSleepAsync(token).ConfigureAwait(false);
            SkipUpdate = true;
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, true, token).ConfigureAwait(false);
                try
                {
                    // Upgradeable read lock so that we make sure all potential write locks are finished before executing
                    IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                        .ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        // Read lock to make sure we are not writing anything despite being in an upgradeable read lock
                        IAsyncDisposable objLocker2 = await CharacterObject.LockObject.EnterReadLockAsync(token)
                            .ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            ProcessCharacterUpdateHasStarted();

                            Task tskAutosave = Task.CompletedTask;
                            if (AutosaveStopwatch?.Elapsed.Minutes >= 5 && IsDirty)
                            {
                                tskAutosave = AutoSaveCharacter(token);
                            }

                            // TODO: DataBind these wherever possible
                            if (await CharacterObject.GetMetatypeAsync(token).ConfigureAwait(false) == "Free Spirit"
                                && !await CharacterObject.GetIsCritterAsync(token).ConfigureAwait(false)
                                || (await CharacterObject.GetMetatypeCategoryAsync(token).ConfigureAwait(false))
                                .EndsWith(
                                    "Spirits", StringComparison.Ordinal))
                            {
                                await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                    .ConfigureAwait(false);
                                string strFreeSpiritPowerPoints = await CharacterObject
                                    .CalculateFreeSpiritPowerPointsAsync(token)
                                    .ConfigureAwait(false);
                                await lblCritterPowerPoints.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strFreeSpiritPowerPoints;
                                }, token).ConfigureAwait(false);
                            }
                            else if (await CharacterObject.GetIsFreeSpriteAsync(token).ConfigureAwait(false))
                            {
                                await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                    .ConfigureAwait(false);
                                string strFreeSpritePowerPoints = await CharacterObject
                                    .CalculateFreeSpritePowerPointsAsync(token)
                                    .ConfigureAwait(false);
                                await lblCritterPowerPoints.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strFreeSpritePowerPoints;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                                await lblCritterPowerPoints.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                            }

                            await Task.WhenAll(RefreshSelectedQuality(token), RefreshSelectedCyberware(token),
                                RefreshSelectedArmor(token),
                                RefreshSelectedGear(token), RefreshSelectedDrug(token),
                                RefreshSelectedLifestyle(token),
                                RefreshSelectedVehicle(token), RefreshSelectedWeapon(token),
                                RefreshSelectedSpell(token),
                                RefreshSelectedComplexForm(token), RefreshSelectedCritterPower(token),
                                RefreshSelectedAIProgram(token), RefreshSelectedMetamagic(token),
                                RefreshSelectedMartialArt(token), UpdateInitiationCost(token),
                                RefreshSelectedImprovement(token), RefreshPasteStatus(token)).ConfigureAwait(false);
                            await tskAutosave.ConfigureAwait(false);
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                SkipUpdate = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed piece of Cyberware.
        /// </summary>
        private async Task RefreshSelectedCyberware(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpCyberware.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    TreeNode objSelectedNode = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                                 .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag == null || objSelectedNode.Level == 0)
                    {
                        await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbCyberwareMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await tabCyberwareCM.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        // Buttons
                        await cmdDeleteCyberware
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                        return;
                    }

                    if (objSelectedNodeTag is IHasWirelessBonus objHasWirelessBonus)
                    {
                        await chkCyberwareWireless.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objHasWirelessBonus.WirelessOn;
                        }, token).ConfigureAwait(false);
                    }
                    else
                        await chkCyberwareWireless.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);

                    if (objSelectedNodeTag is IHasSource objSelected)
                    {
                        await lblCyberwareSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                     .ConfigureAwait(false);
                        await lblCyberwareSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await objSelected.SetSourceDetailAsync(lblCyberwareSource, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await lblCyberwareSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                        await lblCyberwareSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    if (objSelectedNodeTag is IHasRating objHasRating)
                    {
                        string strText = string.Format(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Label_RatingFormat", token: token).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync(
                                objHasRating.RatingLabel, token: token).ConfigureAwait(false));
                        await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token)
                                                     .ConfigureAwait(false);
                    }

                    string strESSFormat = await CharacterObjectSettings.GetEssenceFormatAsync(token).ConfigureAwait(false);
                    switch (objSelectedNodeTag)
                    {
                        case Cyberware objCyberware:
                        {
                            await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            bool blnIsCyberware = (await objCyberware.GetSourceTypeAsync(token).ConfigureAwait(false)) == Improvement.ImprovementSource.Cyberware;
                            await gpbCyberwareMatrix.DoThreadSafeAsync(
                                x => x.Visible = blnIsCyberware,
                                token).ConfigureAwait(false);
                            await tabCyberwareCM.DoThreadSafeAsync(
                                x => x.Visible = blnIsCyberware,
                                token).ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteCyberware.DoThreadSafeAsync(
                                                        x => x.Enabled = string.IsNullOrEmpty(objCyberware.ParentID),
                                                        token)
                                                    .ConfigureAwait(false);
                            // gpbCyberwareCommon
                            string strName = await objCyberware.GetCurrentDisplayNameShortAsync(token)
                                                               .ConfigureAwait(false);
                            await lblCyberwareName
                                  .DoThreadSafeAsync(x => x.Text = strName, token)
                                  .ConfigureAwait(false);
                            string strText = await objCyberware.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                               .ConfigureAwait(false);
                            await lblCyberwareCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                      .ConfigureAwait(false);
                            await lblCyberwareGradeLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                            await lblCyberwareGrade.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            string strGradeName = await (await objCyberware.GetGradeAsync(token).ConfigureAwait(false)).GetCurrentDisplayNameAsync(token)
                                                                    .ConfigureAwait(false);
                            await lblCyberwareGrade
                                  .DoThreadSafeAsync(x => x.Text = strGradeName, token)
                                  .ConfigureAwait(false);
                            await lblCyberwareEssenceLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                            await lblCyberwareEssence.DoThreadSafeAsync(x => x.Visible = true, token)
                                                     .ConfigureAwait(false);
                            bool blnNoParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false) == null;
                            if (blnNoParent || await objCyberware.GetAddToParentESSAsync(token).ConfigureAwait(false))
                            {
                                decimal decCalculatedEss
                                    = await objCyberware.GetCalculatedESSAsync(token).ConfigureAwait(false);
                                await lblCyberwareEssence.DoThreadSafeAsync(x => x.Text = blnNoParent
                                                                                ? decCalculatedEss.ToString(
                                                                                    strESSFormat,
                                                                                    GlobalSettings.CultureInfo)
                                                                                : "+" + decCalculatedEss.ToString(
                                                                                    strESSFormat,
                                                                                    GlobalSettings.CultureInfo), token)
                                                         .ConfigureAwait(false);
                            }
                            else
                                await lblCyberwareEssence.DoThreadSafeAsync(
                                                             x => x.Text = 0.0m.ToString(strESSFormat,
                                                                 GlobalSettings.CultureInfo), token)
                                                         .ConfigureAwait(false);

                            string strAvail = await objCyberware.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblCyberwareAvail
                                  .DoThreadSafeAsync(x => x.Text = strAvail, token)
                                  .ConfigureAwait(false);
                            bool blnVisible = !string.IsNullOrEmpty(await objCyberware.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false));
                            await cmdCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = blnVisible, token).ConfigureAwait(false);
                            int intRating = await objCyberware.GetRatingAsync(token).ConfigureAwait(false);
                            await lblCyberwareRating.DoThreadSafeAsync(
                                                        x => x.Text = intRating.ToString(GlobalSettings
                                                            .CultureInfo), token)
                                                    .ConfigureAwait(false);
                            string strCapacity = await objCyberware.GetDisplayCapacityAsync(token).ConfigureAwait(false);
                            await lblCyberwareCapacity
                                  .DoThreadSafeAsync(x => x.Text = strCapacity, token)
                                  .ConfigureAwait(false);
                            string strCost = (await objCyberware.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                                    await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                                    GlobalSettings.CultureInfo)
                                                                + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblCyberwareCost.DoThreadSafeAsync(
                                                      x => x.Text = strCost,
                                                      token)
                                                  .ConfigureAwait(false);
                            if (await objCyberware.GetIsLimbAsync(token).ConfigureAwait(false))
                            {
                                await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                await lblCyberlimbAGI.DoThreadSafeAsync(x => x.Visible = true, token)
                                                     .ConfigureAwait(false);
                                string strAgi = (await objCyberware.GetAttributeTotalValueAsync("AGI", token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                                await lblCyberlimbAGI.DoThreadSafeAsync(x => x.Text = strAgi, token)
                                                     .ConfigureAwait(false);
                                await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                await lblCyberlimbSTR.DoThreadSafeAsync(x => x.Visible = true, token)
                                                     .ConfigureAwait(false);
                                string strStr = (await objCyberware.GetAttributeTotalValueAsync("STR", token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                                await lblCyberlimbSTR.DoThreadSafeAsync(x => x.Text = strStr, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblCyberlimbAGI.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                                await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblCyberlimbSTR.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            }

                            // gpbCyberwareMatrix
                            if (await gpbCyberwareMatrix.DoThreadSafeFuncAsync(x => x.Visible, token)
                                                        .ConfigureAwait(false))
                            {
                                int intDeviceRating = await objCyberware.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                                await lblCyberDeviceRating.DoThreadSafeAsync(
                                                              x => x.Text = intDeviceRating.ToString(GlobalSettings
                                                                  .CultureInfo), token)
                                                          .ConfigureAwait(false);
                                await objCyberware.RefreshMatrixAttributeComboBoxesAsync(
                                    cboCyberwareAttack, cboCyberwareSleaze, cboCyberwareDataProcessing,
                                    cboCyberwareFirewall, token).ConfigureAwait(false);
                                bool blnIsActiveCommlink = await objCyberware.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnIsCommlink = await objCyberware.GetIsCommlinkAsync(token).ConfigureAwait(false);
                                if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                                {
                                    bool blnIsHomeNode = await objCyberware.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                    bool blnCanBeHomeNode = blnIsCommlink &&
                                                            await objCyberware.GetTotalMatrixAttributeAsync(
                                                                "Program Limit", token).ConfigureAwait(false) >=
                                                            (await (await CharacterObject.GetAttributeAsync("DEP",
                                                                token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                                ? 2
                                                                : 1);
                                    await chkCyberwareHomeNode.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Checked = blnIsHomeNode;
                                        x.Enabled = blnCanBeHomeNode;
                                    }, token).ConfigureAwait(false);
                                }
                                else
                                    await chkCyberwareHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                        .ConfigureAwait(false);

                                await chkCyberwareActiveCommlink.DoThreadSafeAsync(x =>
                                {
                                    x.Checked = blnIsActiveCommlink;
                                    x.Visible = blnIsCommlink;
                                }, token).ConfigureAwait(false);

                                token.ThrowIfCancellationRequested();
                                await lblCyberwareOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                  .ConfigureAwait(false);
                                await cboCyberwareOverclocker.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                            }

                            break;
                        }
                        case Gear objGear:
                        {
                            await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            await gpbCyberwareMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            await tabCyberwareCM.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteCyberware
                                  .DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token)
                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbCyberwareCommon
                            string strName = await objGear.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false);
                            await lblCyberwareName
                                  .DoThreadSafeAsync(x => x.Text = strName, token)
                                  .ConfigureAwait(false);
                            string strCategory = await objGear.GetCurrentDisplayCategoryAsync(token).ConfigureAwait(false);
                            await lblCyberwareCategory.DoThreadSafeAsync(x => x.Text = strCategory, token)
                                                      .ConfigureAwait(false);
                            await lblCyberwareGradeLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await lblCyberwareGrade.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await lblCyberwareEssenceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                            await lblCyberwareEssence.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            string strAvail = await objGear.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblCyberwareAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                   .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            int intRating = await objGear.GetRatingAsync(token).ConfigureAwait(false);
                            await lblCyberwareRating.DoThreadSafeAsync(
                                                        x => x.Text = intRating.ToString(
                                                            GlobalSettings.CultureInfo), token)
                                                    .ConfigureAwait(false);
                            string strCapacity = await objGear.GetDisplayCapacityAsync(token).ConfigureAwait(false);
                            await lblCyberwareCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token)
                                .ConfigureAwait(false);
                            string strCost = (await objGear.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                                    .ConfigureAwait(false);
                            await lblCyberwareCost.DoThreadSafeAsync(x => x.Text = strCost, token).ConfigureAwait(false);
                            await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            await lblCyberlimbAGI.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                            await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            await lblCyberlimbSTR.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbCyberwareMatrix
                            int intDeviceRating = await objGear.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblCyberDeviceRating.DoThreadSafeAsync(
                                                          x => x.Text = intDeviceRating.ToString(GlobalSettings
                                                              .CultureInfo), token)
                                                      .ConfigureAwait(false);
                            await objGear.RefreshMatrixAttributeComboBoxesAsync(
                                cboCyberwareAttack, cboCyberwareSleaze, cboCyberwareDataProcessing,
                                cboCyberwareFirewall, token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            bool blnIsActiveCommlink = await objGear.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objGear.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objGear.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objGear.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkCyberwareHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkCyberwareHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkCyberwareActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                                token.ThrowIfCancellationRequested();
                            if (await CharacterObject.GetOverclockerAsync(token).ConfigureAwait(false) && objGear.Category == "Cyberdecks")
                            {
                                using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstOverclocker))
                                {
                                    lstOverclocker.Add(
                                        new ListItem(
                                            "None",
                                            await LanguageManager.GetStringAsync("String_None", token: token)
                                                                 .ConfigureAwait(false)));
                                    lstOverclocker.Add(
                                        new ListItem(
                                            "Attack",
                                            await LanguageManager.GetStringAsync("String_Attack", token: token)
                                                                 .ConfigureAwait(false)));
                                    lstOverclocker.Add(
                                        new ListItem(
                                            "Sleaze",
                                            await LanguageManager.GetStringAsync("String_Sleaze", token: token)
                                                                 .ConfigureAwait(false)));
                                    lstOverclocker.Add(new ListItem("Data Processing",
                                                                    await LanguageManager.GetStringAsync(
                                                                            "String_DataProcessing", token: token)
                                                                        .ConfigureAwait(false)));
                                    lstOverclocker.Add(
                                        new ListItem(
                                            "Firewall",
                                            await LanguageManager.GetStringAsync("String_Firewall", token: token)
                                                                 .ConfigureAwait(false)));

                                    await cboCyberwareOverclocker.PopulateWithListItemsAsync(lstOverclocker, token)
                                                                 .ConfigureAwait(false);
                                    string strOverclocked = await objGear.GetOverclockedAsync(token).ConfigureAwait(false);
                                    await cboCyberwareOverclocker.DoThreadSafeAsync(x =>
                                    {
                                        if (!string.IsNullOrEmpty(strOverclocked))
                                            x.SelectedValue = strOverclocked;
                                        if (x.SelectedIndex == -1)
                                            x.SelectedIndex = 0;
                                    }, token).ConfigureAwait(false);
                                }

                                token.ThrowIfCancellationRequested();
                                await cboCyberwareOverclocker.DoThreadSafeAsync(x => x.Visible = true, token)
                                                             .ConfigureAwait(false);
                                await lblCyberwareOverclockerLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                  .ConfigureAwait(false);
                            }
                            else
                            {
                                await cboCyberwareOverclocker.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                                await lblCyberwareOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                  .ConfigureAwait(false);
                            }

                            break;
                        }
                    }

                    token.ThrowIfCancellationRequested();
                    if (await tabCyberwareCM.DoThreadSafeFuncAsync(x => x.Visible, token).ConfigureAwait(false))
                    {
                        token.ThrowIfCancellationRequested();
                        if (objSelectedNodeTag is IHasMatrixAttributes objMatrixCM)
                        {
                            await ProcessEquipmentConditionMonitorBoxDisplays(
                                panCyberwareMatrixCM, objMatrixCM.MatrixCM,
                                objMatrixCM.MatrixCMFilled, token).ConfigureAwait(false);
                        }
                        else
                        {
                            await tabCyberwareCM.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        }

                        token.ThrowIfCancellationRequested();
                    }

                    token.ThrowIfCancellationRequested();
                }
                finally
                {
                    await flpCyberware.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Weapon.
        /// </summary>
        private async Task RefreshSelectedWeapon(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpWeapons.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                               .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag == null || objSelectedNode.Level <= 0)
                    {
                        await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteWeapon
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                        return;
                    }

                    token.ThrowIfCancellationRequested();
                    string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token)
                                                           .ConfigureAwait(false);
                    if (objSelectedNodeTag is IHasWirelessBonus objHasWirelessBonus)
                    {
                        await chkWeaponWireless.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objHasWirelessBonus.WirelessOn;
                        }, token).ConfigureAwait(false);
                    }
                    else
                        await chkWeaponWireless.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasSource objSelected)
                    {
                        await lblWeaponSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                        await lblWeaponSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await objSelected.SetSourceDetailAsync(lblWeaponSource, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await lblWeaponSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                        await lblWeaponSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasRating objHasRating)
                    {
                        string strText = string.Format(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Label_RatingFormat", token: token).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync(
                                objHasRating.RatingLabel, token: token).ConfigureAwait(false));
                        await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token)
                                                  .ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    switch (objSelectedNodeTag)
                    {
                        case Weapon objWeapon:
                        {
                            await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            bool blnDeleteWeaponEnabled = !objWeapon.IncludedInWeapon &&
                                                          !objWeapon.Cyberware &&
                                                          objWeapon.Category != "Gear" &&
                                                          !objWeapon.Category.StartsWith(
                                                              "Quality", StringComparison.Ordinal) &&
                                                          string.IsNullOrEmpty(objWeapon.ParentID);
                            await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = blnDeleteWeaponEnabled, token)
                                                 .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbWeaponsCommon
                            string strName = await objWeapon.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                            await lblWeaponName.DoThreadSafeAsync(x => x.Text = strName, token)
                                               .ConfigureAwait(false);
                            string strText = await objWeapon.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                            .ConfigureAwait(false);
                            await lblWeaponCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                   .ConfigureAwait(false);
                            await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            await lblWeaponRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                            await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await lblWeaponCapacity.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            string strAvail = await objWeapon.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblWeaponAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                            .ConfigureAwait(false);
                            string strCost = (await objWeapon.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblWeaponCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                               .ConfigureAwait(false);
                            await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                     .ConfigureAwait(false);
                            string strMounts = await objWeapon.GetCurrentDisplayAccessoryMounts(token).ConfigureAwait(false);
                            await lblWeaponSlots.DoThreadSafeAsync(x =>
                            {
                                x.Text = strMounts;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            string strConcealText = await objWeapon.GetDisplayConcealabilityAsync(token).ConfigureAwait(false);
                            await lblWeaponConcealLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            await lblWeaponConceal.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strConcealText;
                            }, token).ConfigureAwait(false);
                            bool blnVisible = blnDeleteWeaponEnabled && await CharacterObject.Vehicles.GetCountAsync(token).ConfigureAwait(false) > 0;
                            await cmdWeaponMoveToVehicle
                                  .DoThreadSafeAsync(
                                      x => x.Visible = blnVisible,
                                      token).ConfigureAwait(false);
                            string strText2 = await LanguageManager.GetStringAsync(
                                                                       objWeapon.Parent == null
                                                                           ? "Checkbox_Equipped"
                                                                           : "Checkbox_Installed", token: token)
                                                                   .ConfigureAwait(false);
                            await chkWeaponEquipped.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText2;
                                x.Enabled = !objWeapon.IncludedInWeapon;
                                x.Checked = objWeapon.Equipped;
                            }, token).ConfigureAwait(false);
                            await chkIncludedInWeapon.DoThreadSafeAsync(x =>
                            {
                                x.Visible = objWeapon.Parent != null;
                                x.Enabled = false;
                                x.Checked = objWeapon.IncludedInWeapon;
                            }, token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbWeaponsWeapon
                            string strText3 = await LanguageManager.GetStringAsync("String_Weapon", token: token)
                                                                   .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Text = strText3, token)
                                                  .ConfigureAwait(false);
                            await lblWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                            string strDamage = await objWeapon.GetDisplayDamageAsync(token).ConfigureAwait(false);
                            await lblWeaponDamage.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                            await lblWeaponDamage.DoThreadSafeAsync(x => x.Text = strDamage, token)
                                                 .ConfigureAwait(false);
                            string strAP = await objWeapon.GetDisplayTotalAPAsync(token).ConfigureAwait(false);
                            await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                .ConfigureAwait(false);
                            await lblWeaponAP.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strAP;
                            }, token).ConfigureAwait(false);
                            string strAccuracy = await objWeapon.GetDisplayAccuracyAsync(token).ConfigureAwait(false);
                            await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            await lblWeaponAccuracy.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strAccuracy;
                            }, token).ConfigureAwait(false);
                            await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                            int intPool
                                = await objWeapon.GetDicePoolAsync(token: token).ConfigureAwait(false);
                            await dpcWeaponDicePool.SetDicePoolAsync(intPool, token).ConfigureAwait(false);
                            await dpcWeaponDicePool.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.CanBeRolled = true;
                            }, token).ConfigureAwait(false);
                            await dpcWeaponDicePool.SetLabelToolTipAsync(await objWeapon.GetDicePoolTooltipAsync(token).ConfigureAwait(false), token)
                                                   .ConfigureAwait(false);
                            if (objWeapon.RangeType == "Ranged")
                            {
                                await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                                await lblWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                                (string strRC, string strRCTooltip) = await objWeapon.GetDisplayTotalRCAsync(token).ConfigureAwait(false);
                                await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                                await lblWeaponRC.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strRC;
                                }, token).ConfigureAwait(false);
                                await lblWeaponRC.SetToolTipTextAsync(strRCTooltip, token).ConfigureAwait(false);
                                string strAmmo = await objWeapon.GetDisplayAmmoAsync(token).ConfigureAwait(false);
                                await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                                await lblWeaponAmmo.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strAmmo;
                                }, token).ConfigureAwait(false);
                                string strMode = await objWeapon.GetDisplayModeAsync(token).ConfigureAwait(false);
                                await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                                await lblWeaponMode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strMode;
                                }, token).ConfigureAwait(false);
                                await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                                string strRange = await objWeapon.GetCurrentDisplayRangeAsync(token)
                                                                 .ConfigureAwait(false);
                                await lblWeaponRangeMain
                                      .DoThreadSafeAsync(x => x.Text = strRange, token)
                                      .ConfigureAwait(false);
                                string strAlternateRange = await objWeapon.GetCurrentDisplayAlternateRangeAsync(token)
                                                                          .ConfigureAwait(false);
                                await lblWeaponRangeAlternate
                                      .DoThreadSafeAsync(x => x.Text = strAlternateRange, token)
                                      .ConfigureAwait(false);
                                Dictionary<string, string> dicRanges
                                    = await objWeapon.GetRangeStringsAsync(GlobalSettings.CultureInfo, token: token)
                                                     .ConfigureAwait(false);
                                string strModifierShort = await objWeapon.RangeModifierAsync("Short", token).ConfigureAwait(false);
                                string strModifierMedium = await objWeapon.RangeModifierAsync("Medium", token).ConfigureAwait(false);
                                string strModifierLong = await objWeapon.RangeModifierAsync("Long", token).ConfigureAwait(false);
                                string strModifierExtreme = await objWeapon.RangeModifierAsync("Extreme", token).ConfigureAwait(false);
                                await lblWeaponRangeShortLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierShort, token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeMediumLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierMedium, token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeLongLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierLong, token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeExtremeLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierExtreme, token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeShort
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["short"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeMedium
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["medium"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeLong
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["long"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeExtreme
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["extreme"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponAlternateRangeShort
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternateshort"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponAlternateRangeMedium
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternatemedium"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponAlternateRangeLong
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternatelong"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponAlternateRangeExtreme
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternateextreme"], token)
                                      .ConfigureAwait(false);
                            }
                            else
                            {
                                await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                         .ConfigureAwait(false);
                                string strReach
                                    = (await objWeapon.GetTotalReachAsync(token).ConfigureAwait(false)).ToString(
                                        GlobalSettings.CultureInfo);
                                await lblWeaponReach.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strReach;
                                }, token).ConfigureAwait(false);
                                await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                                await lblWeaponRC.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                                if (objWeapon.Ammo != "0")
                                {
                                    string strAmmo = await objWeapon.GetDisplayAmmoAsync(token).ConfigureAwait(false);
                                    await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                    await lblWeaponAmmo.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strAmmo;
                                    }, token).ConfigureAwait(false);
                                }
                                else
                                {
                                    await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                    await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                                }

                                token.ThrowIfCancellationRequested();
                                await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                                await lblWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                                await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            // Enable the fire button if the Weapon is Ranged.
                            if (objWeapon.RangeType == "Ranged"
                                || objWeapon.RangeType == "Melee" && objWeapon.Ammo != "0")
                            {
                                await tlpWeaponsCareer.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                                await lblWeaponAmmoRemaining
                                      .DoThreadSafeAsync(
                                          x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo),
                                          token).ConfigureAwait(false);
                                await cmdFireWeapon
                                      .DoThreadSafeAsync(x => x.Enabled = objWeapon.AmmoRemaining != 0, token)
                                      .ConfigureAwait(false);
                                await cmdUnloadWeapon
                                      .DoThreadSafeAsync(
                                          x => x.Enabled = objWeapon.RequireAmmo && objWeapon.AmmoLoaded != null
                                              && objWeapon.AmmoRemaining != 0, token).ConfigureAwait(false);
                                token.ThrowIfCancellationRequested();
                                bool blnAllowSingleShot = await objWeapon.GetAllowSingleShotAsync(token).ConfigureAwait(false);
                                bool blnAllowShortBurst = await objWeapon.GetAllowShortBurstAsync(token).ConfigureAwait(false);
                                bool blnAllowLongBurst = await objWeapon.GetAllowLongBurstAsync(token).ConfigureAwait(false);
                                bool blnAllowFullBurst = await objWeapon.GetAllowFullBurstAsync(token).ConfigureAwait(false);
                                bool blnAllowSuppressive = await objWeapon.GetAllowSuppressiveAsync(token).ConfigureAwait(false);
                                string strSingleShotText
                                    = blnAllowSingleShot
                                        ? string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager.GetStringAsync(
                                                            "String_SingleShot", token: token).ConfigureAwait(false),
                                                        objWeapon.SingleShot.ToString(GlobalSettings.CultureInfo),
                                                        objWeapon.SingleShot == 1
                                                            ? await LanguageManager.GetStringAsync(
                                                                "String_Bullet", token: token).ConfigureAwait(false)
                                                            : await LanguageManager.GetStringAsync(
                                                                "String_Bullets", token: token).ConfigureAwait(false))
                                        : await
                                            LanguageManager.GetStringAsync("String_SingleShotNA", token: token)
                                                            .ConfigureAwait(false);
                                string strShortBurstText
                                    = blnAllowShortBurst
                                        ? string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager.GetStringAsync(
                                                            "String_ShortBurst", token: token).ConfigureAwait(false),
                                                        objWeapon.ShortBurst.ToString(GlobalSettings.CultureInfo),
                                                        objWeapon.ShortBurst == 1
                                                            ? await LanguageManager.GetStringAsync(
                                                                "String_Bullet", token: token).ConfigureAwait(false)
                                                            : await LanguageManager.GetStringAsync(
                                                                "String_Bullets", token: token).ConfigureAwait(false))
                                        : await
                                            LanguageManager.GetStringAsync("String_ShortBurstNA", token: token)
                                                           .ConfigureAwait(false);
                                string strLongBurstText
                                    = blnAllowLongBurst
                                        ? string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager.GetStringAsync(
                                                            "String_LongBurst", token: token).ConfigureAwait(false),
                                                        objWeapon.LongBurst.ToString(GlobalSettings.CultureInfo),
                                                        objWeapon.LongBurst == 1
                                                            ? await LanguageManager.GetStringAsync(
                                                                "String_Bullet", token: token).ConfigureAwait(false)
                                                            : await LanguageManager.GetStringAsync(
                                                                "String_Bullets", token: token).ConfigureAwait(false))
                                        : await
                                            LanguageManager.GetStringAsync("String_LongBurstNA", token: token)
                                                           .ConfigureAwait(false);
                                string strFullBurstText
                                    = blnAllowFullBurst
                                        ? string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager.GetStringAsync(
                                                            "String_FullBurst", token: token).ConfigureAwait(false),
                                                        objWeapon.FullBurst.ToString(GlobalSettings.CultureInfo),
                                                        objWeapon.FullBurst == 1
                                                            ? await LanguageManager.GetStringAsync(
                                                                "String_Bullet", token: token).ConfigureAwait(false)
                                                            : await LanguageManager.GetStringAsync(
                                                                "String_Bullets", token: token).ConfigureAwait(false))
                                        : await
                                            LanguageManager.GetStringAsync("String_FullBurstNA", token: token)
                                                           .ConfigureAwait(false);
                                string strSuppressiveFireText
                                    = blnAllowSuppressive
                                        ? string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager.GetStringAsync(
                                                                                 "String_SuppressiveFire", token: token)
                                                                             .ConfigureAwait(false),
                                                        objWeapon.Suppressive.ToString(GlobalSettings.CultureInfo),
                                                        objWeapon.Suppressive == 1
                                                            ? await LanguageManager.GetStringAsync(
                                                                "String_Bullet", token: token).ConfigureAwait(false)
                                                            : await LanguageManager.GetStringAsync(
                                                                "String_Bullets", token: token).ConfigureAwait(false))
                                        : await
                                            LanguageManager.GetStringAsync("String_SuppressiveFireNA", token: token)
                                                           .ConfigureAwait(false);
                                await cmsAmmoExpense.DoThreadSafeAsync(() =>
                                {
                                    cmsAmmoSingleShot.Enabled = blnAllowSingleShot;
                                    cmsAmmoShortBurst.Enabled = blnAllowShortBurst;
                                    cmsAmmoLongBurst.Enabled = blnAllowLongBurst;
                                    cmsAmmoFullBurst.Enabled = blnAllowFullBurst;
                                    cmsAmmoSuppressiveFire.Enabled = blnAllowSuppressive;
                                    cmsAmmoSingleShot.Text = strSingleShotText;
                                    cmsAmmoShortBurst.Text = strShortBurstText;
                                    cmsAmmoLongBurst.Text = strLongBurstText;
                                    cmsAmmoFullBurst.Text = strFullBurstText;
                                    cmsAmmoSuppressiveFire.Text = strSuppressiveFireText;
                                }, token).ConfigureAwait(false);
                                token.ThrowIfCancellationRequested();
                                using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstAmmo))
                                {
                                    int intSlot = 0;
                                    foreach (Clip objClip in objWeapon.Clips)
                                    {
                                        ++intSlot;
                                        token.ThrowIfCancellationRequested();
                                        string strAmmoName;
                                        if (objWeapon.RequireAmmo)
                                        {
                                            Gear objGear = objClip.AmmoGear;
                                            strAmmoName = objGear != null
                                                ? await objGear.GetCurrentDisplayNameShortAsync(token)
                                                               .ConfigureAwait(false)
                                                : await LanguageManager.GetStringAsync(objClip.Ammo > 0
                                                    ? "String_ExternalSource"
                                                    : "String_Empty", token: token).ConfigureAwait(false);
                                            if (objWeapon.Clips.Count > 1)
                                                strAmmoName += strSpace + "(" + string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager
                                                            .GetStringAsync("String_SlotNumber", token: token)
                                                            .ConfigureAwait(false),
                                                    intSlot.ToString(GlobalSettings.CultureInfo)) + ")";

                                            string strPlugins = string.Empty;
                                            if (objGear?.Children.Count > 0)
                                            {
                                                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                           out StringBuilder sbdPlugins))
                                                {
                                                    foreach (Gear objChild in objGear.Children)
                                                    {
                                                        sbdPlugins.Append(await objChild
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), ',', strSpace);
                                                    }

                                                    strPlugins = sbdPlugins.ToString();
                                                }
                                            }

                                            // Remove the trailing comma.
                                            if (!string.IsNullOrEmpty(strPlugins))
                                                strPlugins = strPlugins.Substring(
                                                    0, strPlugins.Length - 1 - strSpace.Length);

                                            if (!string.IsNullOrEmpty(strPlugins))
                                                strAmmoName += strSpace + "[" + strPlugins + "]";
                                        }
                                        else
                                            strAmmoName = await LanguageManager.GetStringAsync(objClip.Ammo > 0
                                                ? "String_MountInternal"
                                                : "String_Empty", token: token).ConfigureAwait(false);

                                        token.ThrowIfCancellationRequested();
                                        lstAmmo.Add(new ListItem(intSlot.ToString(GlobalSettings.InvariantCultureInfo),
                                                                 strAmmoName));
                                    }

                                    token.ThrowIfCancellationRequested();
                                    await cboWeaponAmmo.PopulateWithListItemsAsync(lstAmmo, token)
                                                       .ConfigureAwait(false);
                                    await cboWeaponAmmo.DoThreadSafeAsync(x =>
                                    {
                                        x.SelectedValue
                                            = objWeapon.ActiveAmmoSlot.ToString(GlobalSettings.InvariantCultureInfo);
                                        if (x.SelectedIndex == -1)
                                            x.SelectedIndex = 0;
                                        x.Enabled = lstAmmo.Count > 1;
                                    }, token).ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                await tlpWeaponsCareer.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            }

                            // gpbWeaponsMatrix
                            int intDeviceRating = await objWeapon.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblWeaponDeviceRating
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await objWeapon.RefreshMatrixAttributeComboBoxesAsync(
                                cboWeaponGearAttack, cboWeaponGearSleaze, cboWeaponGearDataProcessing,
                                cboWeaponGearFirewall, token).ConfigureAwait(false);
                            bool blnIsActiveCommlink = await objWeapon.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objWeapon.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objWeapon.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objWeapon.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkWeaponHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkWeaponHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkWeaponActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                                token.ThrowIfCancellationRequested();
                            await cboWeaponOverclocker.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            await lblWeaponOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            break;
                        }
                        case WeaponAccessory objSelectedAccessory:
                        {
                            await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled
                                                                        = !objSelectedAccessory.IncludedInWeapon
                                                                          && string.IsNullOrEmpty(
                                                                              objSelectedAccessory.ParentID), token)
                                                 .ConfigureAwait(false);
                            // gpbWeaponsCommon
                            string strName = await objSelectedAccessory.GetCurrentDisplayNameShortAsync(token)
                                                                       .ConfigureAwait(false);
                            await lblWeaponName
                                  .DoThreadSafeAsync(x => x.Text = strName, token)
                                  .ConfigureAwait(false);
                            string strText = await LanguageManager
                                                   .GetStringAsync("String_WeaponAccessory", token: token)
                                                   .ConfigureAwait(false);
                            await lblWeaponCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                   .ConfigureAwait(false);
                            int intRating = await objSelectedAccessory.GetRatingAsync(GenericToken).ConfigureAwait(false);
                            if (intRating > 0)
                            {
                                await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                await lblWeaponRating.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = intRating.ToString(GlobalSettings.CultureInfo);
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblWeaponRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await lblWeaponCapacity.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            string strAvail = await objSelectedAccessory.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblWeaponAvail
                              .DoThreadSafeAsync(x => x.Text = strAvail, token)
                              .ConfigureAwait(false);
                            string strCost = (await objSelectedAccessory.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblWeaponCost.DoThreadSafeAsync(x => x.Text = strCost, token: token)
                                               .ConfigureAwait(false);
                            await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                     .ConfigureAwait(false);
                            string strSlotsText;
                            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                        out StringBuilder sbdSlotsText))
                            {
                                sbdSlotsText.Append(await objSelectedAccessory.DisplayMountAsync(GlobalSettings.Language, token).ConfigureAwait(false));

                                if (!string.IsNullOrEmpty(objSelectedAccessory.ExtraMount)
                                    && objSelectedAccessory.ExtraMount != "None")
                                {
                                    bool boolHaveAddedItem = false;
                                    foreach (string strCurrentExtraMount in
                                             objSelectedAccessory.ExtraMount.SplitNoAlloc(
                                                 '/', StringSplitOptions.RemoveEmptyEntries))
                                    {
                                        if (!boolHaveAddedItem)
                                        {
                                            sbdSlotsText.Append(strSpace, '+', strSpace);
                                            boolHaveAddedItem = true;
                                        }

                                        sbdSlotsText
                                            .Append(await LanguageManager.GetStringAsync(
                                                                             "String_Mount" + strCurrentExtraMount,
                                                                             token: token)
                                                                         .ConfigureAwait(false), '/');
                                    }

                                    // Remove the trailing /
                                    if (boolHaveAddedItem)
                                        --sbdSlotsText.Length;
                                }

                                if (!string.IsNullOrEmpty(objSelectedAccessory.AddMount))
                                {
                                    sbdSlotsText.Append(strSpace, "(++", strSpace)
                                            .Append(await LanguageManager.GetStringAsync(
                                                                                "String_Mount" + objSelectedAccessory.AddMount,
                                                                                token: token)
                                                                            .ConfigureAwait(false), ')');
                                }
    
                                token.ThrowIfCancellationRequested();
                                strSlotsText = sbdSlotsText.ToString();
                            }
                            await lblWeaponSlots.DoThreadSafeAsync(x =>
                            {
                                x.Text = strSlotsText;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);

                            token.ThrowIfCancellationRequested();
                            decimal decConceal = await objSelectedAccessory.GetTotalConcealabilityAsync(token).ConfigureAwait(false);
                            await lblWeaponConcealLabel
                                  .DoThreadSafeAsync(x => x.Visible = decConceal != 0,
                                                     token).ConfigureAwait(false);
                            await lblWeaponConceal.DoThreadSafeAsync(x =>
                            {
                                x.Visible = decConceal != 0;
                                x.Text
                                    = decConceal.ToString(
                                        "+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                            }, token).ConfigureAwait(false);
                            string strText2 = await LanguageManager.GetStringAsync(objSelectedAccessory.Parent == null
                                ? "Checkbox_Equipped"
                                : "Checkbox_Installed", token: token).ConfigureAwait(false);
                            await chkWeaponEquipped.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText2;
                                x.Enabled = !objSelectedAccessory.IncludedInWeapon;
                                x.Checked = objSelectedAccessory.Equipped;
                            }, token).ConfigureAwait(false);
                            await chkIncludedInWeapon.DoThreadSafeAsync(x =>
                            {
                                x.Visible = objSelectedAccessory.Parent != null;
                                x.Enabled = CharacterObjectSettings.AllowEditPartOfBaseWeapon;
                                x.Checked = objSelectedAccessory.IncludedInWeapon;
                            }, token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbWeaponsWeapon
                            string strText3 = await LanguageManager
                                                    .GetStringAsync("String_WeaponAccessory", token: token)
                                                    .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Text = strText3, token)
                                                  .ConfigureAwait(false);
                            if (string.IsNullOrEmpty(objSelectedAccessory.Damage))
                            {
                                await lblWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblWeaponDamage.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            }
                            else
                            {
                                string strDamageText = (await objSelectedAccessory.GetTotalDamageAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblWeaponDamageLabel
                                      .DoThreadSafeAsync(
                                          x => x.Visible = true, token)
                                      .ConfigureAwait(false);
                                await lblWeaponDamage.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strDamageText;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            if (string.IsNullOrEmpty(objSelectedAccessory.AP))
                            {
                                await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                                await lblWeaponAP.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                            }
                            else
                            {
                                string strAPText = (await objSelectedAccessory.GetTotalAPAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                                await lblWeaponAP.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strAPText;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            if (string.IsNullOrEmpty(objSelectedAccessory.Accuracy))
                            {
                                await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                await lblWeaponAccuracy.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            }
                            else
                            {
                                string strAccuracyText = (await objSelectedAccessory.GetTotalAccuracyAsync(token).ConfigureAwait(false))
                                        .ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                await lblWeaponAccuracy.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strAccuracyText;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            decimal decDicePool = await objSelectedAccessory.GetDicePoolAsync(token).ConfigureAwait(false);
                            if (decDicePool == 0)
                            {
                                await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                await dpcWeaponDicePool.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            }
                            else
                            {
                                await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                                await dpcWeaponDicePool.SetDicePoolAsync(decDicePool, token).ConfigureAwait(false);
                                await dpcWeaponDicePool.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.CanBeRolled = false;
                                }, token).ConfigureAwait(false);
                                await dpcWeaponDicePool.SetLabelToolTipAsync(string.Empty, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            await lblWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                            if (string.IsNullOrEmpty(objSelectedAccessory.RC))
                            {
                                await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                                await lblWeaponRC.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                            }
                            else
                            {
                                string strRCText = (await objSelectedAccessory.GetTotalRCAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                                await lblWeaponRC.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strRCText;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            decimal decAmmoBonus = await objSelectedAccessory.GetTotalAmmoBonusAsync(token).ConfigureAwait(false);
                            if (decAmmoBonus != 0
                                || (!string.IsNullOrEmpty(objSelectedAccessory.ModifyAmmoCapacity)
                                    && objSelectedAccessory.ModifyAmmoCapacity != "0"))
                            {
                                await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdAmmoBonus))
                                {
                                    if (decAmmoBonus != 0)
                                        sbdAmmoBonus.Append(
                                            (decAmmoBonus / 100.0m).ToString(
                                                "+#,0.##%;-#,0.##%;0.##%", GlobalSettings.CultureInfo));
                                    if (!string.IsNullOrEmpty(objSelectedAccessory.ModifyAmmoCapacity)
                                        && objSelectedAccessory.ModifyAmmoCapacity != "0")
                                        sbdAmmoBonus.Append(objSelectedAccessory.ModifyAmmoCapacity);
                                    await lblWeaponAmmo.DoThreadSafeAsync(x => x.Text = sbdAmmoBonus.ToString(), token)
                                                       .ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                                await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await lblWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await tlpWeaponsCareer.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            break;
                        }
                        case Gear objGear:
                        {
                            await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token)
                                                 .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbWeaponsCommon
                            string strName = await objGear.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false);
                            await lblWeaponName.DoThreadSafeAsync(x => x.Text = strName, token)
                                               .ConfigureAwait(false);
                            string strCategory = await objGear.GetCurrentDisplayCategoryAsync(token).ConfigureAwait(false);
                            await lblWeaponCategory.DoThreadSafeAsync(x => x.Text = strCategory, token).ConfigureAwait(false);
                            int intGearMaxRatingValue = await objGear.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                            if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                            {
                                await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                int intRating = await objGear.GetRatingAsync(token).ConfigureAwait(false);
                                await lblWeaponRating.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = intRating.ToString(GlobalSettings.CultureInfo);
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblWeaponRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                            string strCapacity = await objGear.GetDisplayCapacityAsync(token).ConfigureAwait(false);
                            await lblWeaponCapacity.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strCapacity;
                            }, token).ConfigureAwait(false);
                            string strAvail = await objGear.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblWeaponAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                .ConfigureAwait(false);
                            string strCost = (await objGear.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                                    .ConfigureAwait(false);
                            await lblWeaponCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                               .ConfigureAwait(false);
                            await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            await lblWeaponSlots.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                            await lblWeaponConcealLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            await lblWeaponConceal.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            string strText = await LanguageManager.GetStringAsync("Checkbox_Equipped", token: token)
                                                                  .ConfigureAwait(false);
                            await chkWeaponEquipped.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Checked = objGear.Equipped;
                                x.Enabled = objGear.CanChangeEquip;
                            }, token).ConfigureAwait(false);
                            await chkIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbWeaponsMatrix
                            int intDeviceRating = await objGear.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblWeaponDeviceRating
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await objGear.RefreshMatrixAttributeComboBoxesAsync(
                                cboWeaponGearAttack, cboWeaponGearSleaze, cboWeaponGearDataProcessing,
                                cboWeaponGearFirewall, token).ConfigureAwait(false);
                            bool blnIsActiveCommlink = await objGear.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objGear.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objGear.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objGear.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkWeaponHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkWeaponHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkWeaponActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                                token.ThrowIfCancellationRequested();
                            if (await CharacterObject.GetOverclockerAsync(token).ConfigureAwait(false) && objGear.Category == "Cyberdecks")
                            {
                                using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstOverclocker))
                                {
                                    lstOverclocker.Add(
                                        new ListItem(
                                            "None",
                                            await LanguageManager.GetStringAsync("String_None", token: token)
                                                                 .ConfigureAwait(false)));
                                    lstOverclocker.Add(
                                        new ListItem(
                                            "Attack",
                                            await LanguageManager.GetStringAsync("String_Attack", token: token)
                                                                 .ConfigureAwait(false)));
                                    lstOverclocker.Add(
                                        new ListItem(
                                            "Sleaze",
                                            await LanguageManager.GetStringAsync("String_Sleaze", token: token)
                                                                 .ConfigureAwait(false)));
                                    lstOverclocker.Add(new ListItem("Data Processing",
                                                                    await LanguageManager.GetStringAsync(
                                                                            "String_DataProcessing", token: token)
                                                                        .ConfigureAwait(false)));
                                    lstOverclocker.Add(
                                        new ListItem(
                                            "Firewall",
                                            await LanguageManager.GetStringAsync("String_Firewall", token: token)
                                                                 .ConfigureAwait(false)));
                                    token.ThrowIfCancellationRequested();
                                    await cboWeaponOverclocker.PopulateWithListItemsAsync(lstOverclocker, token)
                                                              .ConfigureAwait(false);
                                    string strOverclocked = await objGear.GetOverclockedAsync(token).ConfigureAwait(false);
                                    await cboWeaponOverclocker.DoThreadSafeAsync(x =>
                                    {
                                        if (!string.IsNullOrEmpty(strOverclocked))
                                            x.SelectedValue = strOverclocked;
                                        if (x.SelectedIndex == -1)
                                            x.SelectedIndex = 0;
                                    }, token).ConfigureAwait(false);
                                }

                                token.ThrowIfCancellationRequested();
                                await cboWeaponOverclocker.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                await lblWeaponOverclockerLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                               .ConfigureAwait(false);
                            }
                            else
                            {
                                await cboWeaponOverclocker.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblWeaponOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                            }

                            break;
                        }
                        default:
                            await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                 .ConfigureAwait(false);
                            break;
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasMatrixAttributes objMatrixCM)
                    {
                        await tabWeaponCM.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await ProcessEquipmentConditionMonitorBoxDisplays(panWeaponMatrixCM, objMatrixCM.MatrixCM,
                                                                          objMatrixCM.MatrixCMFilled, token)
                            .ConfigureAwait(false);
                    }
                    else
                        await tabWeaponCM.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);

                    token.ThrowIfCancellationRequested();
                    await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible
                                                                 = objSelectedNodeTag is IHasMatrixAttributes ||
                                                                   objSelectedNodeTag is IHasWirelessBonus, token)
                                          .ConfigureAwait(false);
                    token.ThrowIfCancellationRequested();
                }
                finally
                {
                    await flpWeapons.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Armor.
        /// </summary>
        private async Task RefreshSelectedArmor(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpArmor.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    object objSelectedNodeTag = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token)
                                                              .ConfigureAwait(false);
                    if (objSelectedNodeTag == null)
                    {
                        await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token).ConfigureAwait(false);
                        return;
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasWirelessBonus objHasWirelessBonus)
                    {
                        await chkArmorWireless.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objHasWirelessBonus.WirelessOn;
                        }, token).ConfigureAwait(false);
                    }
                    else
                        await chkArmorWireless.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasSource objSelected)
                    {
                        await lblArmorSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await lblArmorSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await objSelected.SetSourceDetailAsync(lblArmorSource, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await lblArmorSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                        await lblArmorSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasRating objHasRating)
                    {
                        string strText = string.Format(GlobalSettings.CultureInfo,
                                                       await LanguageManager
                                                             .GetStringAsync("Label_RatingFormat", token: token)
                                                             .ConfigureAwait(false),
                                                       await LanguageManager.GetStringAsync(
                                                                                objHasRating.RatingLabel, token: token)
                                                                            .ConfigureAwait(false));
                        await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is Armor objArmor)
                    {
                        await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        // gpbArmorCommon
                        await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await flpArmorValue.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        string strArmorValue = await objArmor.GetDisplayArmorValueAsync(token).ConfigureAwait(false);
                        await lblArmorValue.DoThreadSafeAsync(x => x.Text = strArmorValue, token)
                                           .ConfigureAwait(false);
                        if (await CharacterObjectSettings.GetArmorDegradationAsync(token).ConfigureAwait(false))
                        {
                            bool blnArmorIncreaseEnabled = objArmor.ArmorDamage > 0;
                            bool blnArmorDecreaseEnabled =
                                objArmor.ArmorDamage < await objArmor.GetTotalArmorAsync(token: token).ConfigureAwait(false) &&
                                objArmor.ArmorDamage
                                < (string.IsNullOrEmpty(objArmor.ArmorOverrideValue)
                                    ? int.MaxValue
                                    : await objArmor.GetTotalOverrideArmorAsync(token: token).ConfigureAwait(false));
                            await cmdArmorIncrease.DoThreadSafeAsync(x =>
                                                  {
                                                      x.Visible = true;
                                                      x.Enabled = blnArmorIncreaseEnabled;
                                                  }, token)
                                                  .ConfigureAwait(false);
                            await cmdArmorDecrease.DoThreadSafeAsync(x =>
                                                  {
                                                      x.Visible = true;
                                                      x.Enabled = blnArmorDecreaseEnabled;
                                                  }, token)
                                                  .ConfigureAwait(false);
                        }

                        string strAvail = await objArmor.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                        await lblArmorAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                           .ConfigureAwait(false);
                        string strCapacity = await objArmor.GetDisplayCapacityAsync(token).ConfigureAwait(false);
                        await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token)
                                              .ConfigureAwait(false);
                        await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                        await lblArmorRating.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        string strCost = (await objArmor.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                             await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                             GlobalSettings.CultureInfo)
                                         + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                        await lblArmorCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                          .ConfigureAwait(false);
                        await chkArmorEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objArmor.Equipped;
                            x.Enabled = true;
                        }, token).ConfigureAwait(false);
                        await chkIncludedInArmor.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }
                    else
                    {
                        token.ThrowIfCancellationRequested();
                        string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token)
                                                               .ConfigureAwait(false);
                        if (objSelectedNodeTag is ArmorMod objArmorMod)
                        {
                            await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                            await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = !objArmorMod.IncludedInArmor, token)
                                                .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbArmorCommon
                            if (objArmorMod.Armor != 0)
                            {
                                await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                await flpArmorValue.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                                await lblArmorValue
                                      .DoThreadSafeAsync(
                                          x => x.Text = objArmorMod.Armor.ToString(
                                              "+0;-0;0", GlobalSettings.CultureInfo), token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                                await flpArmorValue.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await cmdArmorIncrease.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await cmdArmorDecrease.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            string strAvail = await objArmorMod.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblArmorAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                               .ConfigureAwait(false);
                            string strCapacity = objArmorMod.Parent.CapacityDisplayStyle == CapacityStyle.Zero
                                ? "[0]"
                                : await objArmorMod.GetCalculatedCapacityAsync(token).ConfigureAwait(false);
                            if (!string.IsNullOrEmpty(objArmorMod.GearCapacity))
                            {
                                strCapacity = objArmorMod.GearCapacity + "/" + strCapacity + strSpace + "("
                                              + (await objArmorMod.GetGearCapacityRemainingAsync(token).ConfigureAwait(false)).ToString(
                                                  "#,0.##", GlobalSettings.CultureInfo) + strSpace
                                              + await LanguageManager.GetStringAsync("String_Remaining", token: token)
                                                  .ConfigureAwait(false) + ")";
                            }

                            await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token)
                                                  .ConfigureAwait(false);
                            int intRating = await objArmorMod.GetRatingAsync(token).ConfigureAwait(false);
                            if (intRating > 0)
                            {
                                await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                         .ConfigureAwait(false);
                                await lblArmorRating.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = intRating.ToString(GlobalSettings.CultureInfo);
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                                await lblArmorRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            string strCost = (await objArmorMod.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblArmorCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                              .ConfigureAwait(false);
                            await chkArmorEquipped.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objArmorMod.Equipped;
                                x.Enabled = !objArmorMod.IncludedInArmor;
                            }, token).ConfigureAwait(false);
                            await chkIncludedInArmor.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objArmorMod.IncludedInArmor;
                            }, token).ConfigureAwait(false);
                        }
                        else
                        {
                            switch (objSelectedNodeTag)
                            {
                                case Gear objSelectedGear:
                                {
                                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                    token.ThrowIfCancellationRequested();
                                    // Buttons
                                    await cmdDeleteArmor
                                          .DoThreadSafeAsync(x => x.Enabled = !objSelectedGear.IncludedInParent, token)
                                          .ConfigureAwait(false);
                                    token.ThrowIfCancellationRequested();
                                    // gpbArmorCommon
                                    await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                    await flpArmorValue.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                                    string strAvail = await objSelectedGear.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                                    await lblArmorAvail
                                          .DoThreadSafeAsync(x => x.Text = strAvail, token)
                                          .ConfigureAwait(false);
                                    (_, objArmor, objArmorMod) = await CharacterObject.Armor.FindArmorGearAsync(objSelectedGear.InternalId, token).ConfigureAwait(false);
                                    if (objArmorMod != null)
                                    {
                                        string strCapacity = await objSelectedGear.GetCalculatedCapacityAsync(token).ConfigureAwait(false);
                                        await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token).ConfigureAwait(false);
                                    }
                                    else if (objArmor.CapacityDisplayStyle == CapacityStyle.Zero)
                                    {
                                        await lblArmorCapacity
                                            .DoThreadSafeAsync(
                                                x => x.Text = "[" + 0.ToString(GlobalSettings.CultureInfo) + "]",
                                                token).ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        string strCapacity = await objSelectedGear.GetCalculatedArmorCapacityAsync(token).ConfigureAwait(false);
                                        await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token).ConfigureAwait(false);
                                    }
                                    int intMaxRatingValue = await objSelectedGear.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                                    if (intMaxRatingValue > 1 && intMaxRatingValue != int.MaxValue)
                                    {
                                        await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                 .ConfigureAwait(false);
                                        int intRating = await objSelectedGear.GetRatingAsync(token).ConfigureAwait(false);
                                        await lblArmorRating.DoThreadSafeAsync(x =>
                                        {
                                            x.Visible = true;
                                            x.Text = intRating.ToString(GlobalSettings.CultureInfo);
                                        }, token).ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                 .ConfigureAwait(false);
                                        await lblArmorRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                    }

                                    token.ThrowIfCancellationRequested();
                                    string strCost = objSelectedGear.TotalCost.ToString(
                                                                await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                                GlobalSettings.CultureInfo)
                                                            + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                                    await lblArmorCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                    .ConfigureAwait(false);
                                    await chkArmorEquipped.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Checked = objSelectedGear.Equipped;
                                        x.Enabled = objSelectedGear.CanChangeEquip;
                                    }, token).ConfigureAwait(false);
                                    await chkIncludedInArmor.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Checked = objSelectedGear.IncludedInParent;
                                    }, token).ConfigureAwait(false);
                                    break;
                                }
                                case Location objLocation:
                                {
                                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                    token.ThrowIfCancellationRequested();
                                    // Buttons
                                    await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = true, token)
                                                        .ConfigureAwait(false);
                                    token.ThrowIfCancellationRequested();
                                    // gpbArmorLocation
                                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                               out StringBuilder sbdArmorEquipped))
                                    {
                                        await CharacterObject.Armor.ForEachAsync(async objLoopArmor =>
                                        {
                                            if (!objLoopArmor.Equipped || objLoopArmor.Location != objLocation)
                                                return;
                                            sbdArmorEquipped.Append(await objLoopArmor.GetCurrentDisplayNameAsync(token)
                                                                        .ConfigureAwait(false), strSpace)
                                                            .Append('(', await objLoopArmor.GetDisplayArmorValueAsync(token).ConfigureAwait(false))
                                                            .AppendLine(')');
                                        }, token).ConfigureAwait(false);

                                        token.ThrowIfCancellationRequested();
                                        if (sbdArmorEquipped.Length > 0)
                                        {
                                            --sbdArmorEquipped.Length;
                                            await lblArmorEquipped
                                                  .DoThreadSafeAsync(x => x.Text = sbdArmorEquipped.ToString(), token)
                                                  .ConfigureAwait(false);
                                        }
                                        else
                                        {
                                            string strNone = await LanguageManager
                                                                   .GetStringAsync("String_None", token: token)
                                                                   .ConfigureAwait(false);
                                            await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = strNone, token)
                                                                  .ConfigureAwait(false);
                                        }
                                    }

                                    break;
                                }
                                default:
                                {
                                    if (objSelectedNodeTag.ToString() == "Node_SelectedArmor")
                                    {
                                        await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                        await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                        await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = true, token)
                                                              .ConfigureAwait(false);
                                        token.ThrowIfCancellationRequested();
                                        // Buttons
                                        await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                            .ConfigureAwait(false);
                                        token.ThrowIfCancellationRequested();
                                        using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                   out StringBuilder sbdArmorEquipped))
                                        {
                                            await CharacterObject.Armor.ForEachAsync(async objLoopArmor =>
                                            {
                                                if (!objLoopArmor.Equipped || objLoopArmor.Location != null)
                                                    return;
                                                sbdArmorEquipped.Append(await objLoopArmor
                                                                              .GetCurrentDisplayNameAsync(token)
                                                                              .ConfigureAwait(false), strSpace)
                                                                .Append('(', await objLoopArmor.GetDisplayArmorValueAsync(token).ConfigureAwait(false)).AppendLine(')');
                                            }, token).ConfigureAwait(false);

                                            token.ThrowIfCancellationRequested();
                                            if (sbdArmorEquipped.Length > 0)
                                            {
                                                --sbdArmorEquipped.Length;
                                                await lblArmorEquipped
                                                      .DoThreadSafeAsync(
                                                          x => x.Text = sbdArmorEquipped.ToString(), token)
                                                      .ConfigureAwait(false);
                                            }
                                            else
                                            {
                                                string strNone = await LanguageManager
                                                                       .GetStringAsync("String_None", token: token)
                                                                       .ConfigureAwait(false);
                                                await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = strNone, token)
                                                                      .ConfigureAwait(false);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                        await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                        await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                                        token.ThrowIfCancellationRequested();
                                        // Buttons
                                        await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                            .ConfigureAwait(false);
                                    }

                                    break;
                                }
                            }
                        }
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasMatrixAttributes objHasMatrixAttributes)
                    {
                        int intDeviceRating = await objHasMatrixAttributes.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                        await lblArmorDeviceRating
                              .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                 token).ConfigureAwait(false);
                        await objHasMatrixAttributes.RefreshMatrixAttributeComboBoxesAsync(
                                                        cboArmorAttack, cboArmorSleaze, cboArmorDataProcessing,
                                                        cboArmorFirewall, token)
                                                    .ConfigureAwait(false);
                        bool blnIsActiveCommlink = await objHasMatrixAttributes.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                        bool blnIsCommlink = await objHasMatrixAttributes.GetIsCommlinkAsync(token).ConfigureAwait(false);
                        if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                        {
                            bool blnIsHomeNode = await objHasMatrixAttributes.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnCanBeHomeNode = blnIsCommlink &&
                                                    await objHasMatrixAttributes.GetTotalMatrixAttributeAsync(
                                                        "Program Limit", token).ConfigureAwait(false) >=
                                                    (await (await CharacterObject.GetAttributeAsync("DEP",
                                                        token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                        ? 2
                                                        : 1);
                            await chkArmorHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = blnIsHomeNode;
                                x.Enabled = blnCanBeHomeNode;
                            }, token).ConfigureAwait(false);
                        }
                        else
                            await chkArmorHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);

                        token.ThrowIfCancellationRequested();
                        await chkArmorActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Checked = blnIsActiveCommlink;
                            x.Visible = blnIsCommlink;
                        }, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        if (await CharacterObject.GetOverclockerAsync(token).ConfigureAwait(false) && objHasMatrixAttributes is Gear objGear
                                                        && objGear.Category == "Cyberdecks")
                        {
                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstOverclocker))
                            {
                                lstOverclocker.Add(
                                    new ListItem(
                                        "None",
                                        await LanguageManager.GetStringAsync("String_None", token: token)
                                                             .ConfigureAwait(false)));
                                lstOverclocker.Add(
                                    new ListItem(
                                        "Attack",
                                        await LanguageManager.GetStringAsync("String_Attack", token: token)
                                                             .ConfigureAwait(false)));
                                lstOverclocker.Add(
                                    new ListItem(
                                        "Sleaze",
                                        await LanguageManager.GetStringAsync("String_Sleaze", token: token)
                                                             .ConfigureAwait(false)));
                                lstOverclocker.Add(new ListItem("Data Processing",
                                                                await LanguageManager.GetStringAsync(
                                                                        "String_DataProcessing", token: token)
                                                                    .ConfigureAwait(false)));
                                lstOverclocker.Add(
                                    new ListItem(
                                        "Firewall",
                                        await LanguageManager.GetStringAsync("String_Firewall", token: token)
                                                             .ConfigureAwait(false)));
                                token.ThrowIfCancellationRequested();
                                await cboArmorOverclocker.PopulateWithListItemsAsync(lstOverclocker, token)
                                                         .ConfigureAwait(false);
                                string strOverclocked = await objHasMatrixAttributes.GetOverclockedAsync(token).ConfigureAwait(false);
                                await cboArmorOverclocker.DoThreadSafeAsync(x =>
                                {
                                    if (!string.IsNullOrEmpty(strOverclocked))
                                        x.SelectedValue = strOverclocked;
                                    if (x.SelectedIndex == -1)
                                        x.SelectedIndex = 0;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await cboArmorOverclocker.DoThreadSafeAsync(x => x.Visible = true, token)
                                                     .ConfigureAwait(false);
                            await lblArmorOverclockerLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                        }
                        else
                        {
                            await cboArmorOverclocker.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            await lblArmorOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                        }

                        token.ThrowIfCancellationRequested();
                        await tabArmorCM.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await ProcessEquipmentConditionMonitorBoxDisplays(
                            panArmorMatrixCM, objHasMatrixAttributes.MatrixCM,
                            objHasMatrixAttributes.MatrixCMFilled, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        await lblArmorDeviceRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                       .ConfigureAwait(false);
                        await lblArmorDeviceRating.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                        await lblArmorAttackLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await lblArmorSleazeLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await lblArmorDataProcessingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                         .ConfigureAwait(false);
                        await lblArmorFirewallLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                        await cboArmorAttack.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await cboArmorSleaze.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await cboArmorDataProcessing.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                        await cboArmorFirewall.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await chkArmorWireless
                              .DoThreadSafeAsync(x => x.Visible = objSelectedNodeTag is IHasWirelessBonus, token)
                              .ConfigureAwait(false);
                        await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    }
                    else
                    {
                        token.ThrowIfCancellationRequested();
                        await tabArmorCM.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        if (objSelectedNodeTag is IHasWirelessBonus)
                        {
                            await cboArmorOverclocker.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            await lblArmorOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                            await chkArmorHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await lblArmorDeviceRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            await lblArmorDeviceRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            await lblArmorAttackLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            await lblArmorSleazeLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            await lblArmorDataProcessingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                            await lblArmorFirewallLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            await cboArmorAttack.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                            await cboArmorSleaze.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                            await cboArmorDataProcessing.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await cboArmorFirewall.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await chkArmorWireless.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        }
                        else
                            await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                }
                finally
                {
                    await flpArmor.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Gear.
        /// </summary>
        private async Task RefreshSelectedGear(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpGear.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    TreeNode objSelectedNode
                        = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, token).ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag == null || objSelectedNode.Level == 0)
                    {
                        await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await tabGearCM.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                                           .ConfigureAwait(false);
                        return;
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasWirelessBonus objHasWirelessBonus)
                    {
                        await chkGearWireless.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objHasWirelessBonus.WirelessOn;
                        }, token).ConfigureAwait(false);
                    }
                    else
                        await chkGearWireless.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasSource objSelected)
                    {
                        await lblGearSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await lblGearSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await objSelected.SetSourceDetailAsync(lblGearSource, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await lblGearSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await lblGearSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasRating objHasRating)
                    {
                        string strText = string.Format(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Label_RatingFormat", token: token).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync(
                                objHasRating.RatingLabel, token: token).ConfigureAwait(false));
                        await lblGearRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is Gear objGear)
                    {
                        await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await tabGearCM.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token)
                                           .ConfigureAwait(false);
                        // gpbGearCommon
                        string strName = await objGear.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false);
                        await lblGearName.DoThreadSafeAsync(x => x.Text = strName, token)
                                         .ConfigureAwait(false);
                        string strCategory = await objGear.GetCurrentDisplayCategoryAsync(token).ConfigureAwait(false);
                        await lblGearCategory
                              .DoThreadSafeAsync(x => x.Text = strCategory, token)
                              .ConfigureAwait(false);
                        int intGearMaxRatingValue = await objGear.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                        if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                        {
                            await lblGearRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            int intRating = await objGear.GetRatingAsync(token).ConfigureAwait(false);
                            await lblGearRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = intRating.ToString(GlobalSettings.CultureInfo);
                            }, token).ConfigureAwait(false);
                        }
                        else
                        {
                            await lblGearRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await lblGearRating.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        }

                        await lblGearQty
                              .DoThreadSafeAsync(x => x.Text = objGear.Quantity.ToString(GlobalSettings.CultureInfo),
                                                 token).ConfigureAwait(false);
                        bool blnEnabled = !objGear.IncludedInParent;
                        await cmdGearIncreaseQty.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Enabled = blnEnabled;
                        }, token).ConfigureAwait(false);
                        await cmdGearReduceQty.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Enabled = blnEnabled;
                        }, token).ConfigureAwait(false);
                        await cmdGearSplitQty.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Enabled = blnEnabled;
                        }, token).ConfigureAwait(false);
                        await cmdGearMergeQty.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Enabled = blnEnabled;
                        }, token).ConfigureAwait(false);
                        bool blnEnabled2 = blnEnabled && objGear.LoadedIntoClip == null
                                                && await CharacterObject.Vehicles.GetCountAsync(token).ConfigureAwait(false) > 0;
                        await cmdGearMoveToVehicle.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Enabled = blnEnabled2;
                        }, token).ConfigureAwait(false);
                        string strAvail = await objGear.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                        await lblGearAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                          .ConfigureAwait(false);
                        string strCost;
                        try
                        {
                            strCost = (await objGear.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                                    .ConfigureAwait(false);
                        }
                        catch (FormatException)
                        {
                            strCost = objGear.Cost + await LanguageManager
                                                           .GetStringAsync("String_NuyenSymbol", token: token)
                                                           .ConfigureAwait(false);
                        }
                        await lblGearCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                         .ConfigureAwait(false);
                        string strCapacity = await objGear.GetDisplayCapacityAsync(token).ConfigureAwait(false);
                        await lblGearCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token)
                                             .ConfigureAwait(false);
                        await chkGearEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objGear.Equipped;
                            x.Enabled = objGear.CanChangeEquip;
                        }, token).ConfigureAwait(false);
                        // If this is a Program, determine if its parent Gear (if any) is a Commlink. If so, show the Equipped checkbox.
                        if (objGear.IsProgram && objGear.Parent is IHasMatrixAttributes objCommlink
                                              && await objCommlink.GetIsCommlinkAsync(token).ConfigureAwait(false))
                        {
                            string strText = await LanguageManager
                                                   .GetStringAsync("Checkbox_SoftwareRunning", token: token)
                                                   .ConfigureAwait(false);
                            await chkGearEquipped.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                        }
                        else
                        {
                            string strText = await LanguageManager.GetStringAsync("Checkbox_Equipped", token: token)
                                                                  .ConfigureAwait(false);
                            await chkGearEquipped.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                        }

                        // gpbGearMatrix
                        int intDeviceRating = await objGear.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                        await lblGearDeviceRating
                              .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                 token).ConfigureAwait(false);
                        await objGear.RefreshMatrixAttributeComboBoxesAsync(cboGearAttack, cboGearSleaze,
                                                                            cboGearDataProcessing, cboGearFirewall,
                                                                            token).ConfigureAwait(false);
                        bool blnIsActiveCommlink = await objGear.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                        bool blnIsCommlink = await objGear.GetIsCommlinkAsync(token).ConfigureAwait(false);
                        if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                        {
                            bool blnIsHomeNode = await objGear.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnCanBeHomeNode = blnIsCommlink &&
                                                    await objGear.GetTotalMatrixAttributeAsync(
                                                        "Program Limit", token).ConfigureAwait(false) >=
                                                    (await (await CharacterObject.GetAttributeAsync("DEP",
                                                        token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                        ? 2
                                                        : 1);
                            await chkGearHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = blnIsHomeNode;
                                x.Enabled = blnCanBeHomeNode;
                            }, token).ConfigureAwait(false);
                        }
                        else
                            await chkGearHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);

                        await chkGearActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Checked = blnIsActiveCommlink;
                            x.Visible = blnIsCommlink;
                        }, token).ConfigureAwait(false);
                        if (await CharacterObject.GetOverclockerAsync(token).ConfigureAwait(false) && objGear.Category == "Cyberdecks")
                        {
                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstOverclocker))
                            {
                                lstOverclocker.Add(
                                    new ListItem(
                                        "None",
                                        await LanguageManager.GetStringAsync("String_None", token: token)
                                                             .ConfigureAwait(false)));
                                lstOverclocker.Add(
                                    new ListItem(
                                        "Attack",
                                        await LanguageManager.GetStringAsync("String_Attack", token: token)
                                                             .ConfigureAwait(false)));
                                lstOverclocker.Add(
                                    new ListItem(
                                        "Sleaze",
                                        await LanguageManager.GetStringAsync("String_Sleaze", token: token)
                                                             .ConfigureAwait(false)));
                                lstOverclocker.Add(new ListItem("Data Processing",
                                                                await LanguageManager.GetStringAsync(
                                                                        "String_DataProcessing", token: token)
                                                                    .ConfigureAwait(false)));
                                lstOverclocker.Add(
                                    new ListItem(
                                        "Firewall",
                                        await LanguageManager.GetStringAsync("String_Firewall", token: token)
                                                             .ConfigureAwait(false)));

                                await cboGearOverclocker.PopulateWithListItemsAsync(lstOverclocker, token)
                                                        .ConfigureAwait(false);
                                string strOverclocked = await objGear.GetOverclockedAsync(token).ConfigureAwait(false);
                                await cboGearOverclocker.DoThreadSafeAsync(x =>
                                {
                                    if (!string.IsNullOrEmpty(strOverclocked))
                                        x.SelectedValue = strOverclocked;
                                    if (x.SelectedIndex == -1)
                                        x.SelectedIndex = 0;
                                }, token).ConfigureAwait(false);
                            }

                            await cboGearOverclocker.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            await lblGearOverclockerLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                         .ConfigureAwait(false);
                        }
                        else
                        {
                            await cboGearOverclocker.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await lblGearOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                        }

                        string strNodeText = await objGear.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                        await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = strNodeText, token)
                                     .ConfigureAwait(false);
                        await ProcessEquipmentConditionMonitorBoxDisplays(panGearMatrixCM, objGear.MatrixCM,
                                                                          objGear.MatrixCMFilled, token)
                            .ConfigureAwait(false);
                        if (objGear.LoadedIntoClip != null)
                        {
                            await cmdGearIncreaseQty.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                    .ConfigureAwait(false);
                            await cmdGearReduceQty.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                  .ConfigureAwait(false);
                            await cmdGearMergeQty.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                 .ConfigureAwait(false);
                            await cmdGearSplitQty.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                 .ConfigureAwait(false);
                            await cmdGearMoveToVehicle.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                      .ConfigureAwait(false);
                        }
                    }
                    else
                    {
                        await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await tabGearCM.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        // Buttons
                        await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                                           .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await flpGear.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        protected override string FormMode
        {
            get
            {
                try
                {
                    return LanguageManager.GetString("Title_CareerMode", token: GenericToken);
                }
                catch (OperationCanceledException)
                {
                    //swallow this
                    return string.Empty;
                }
            }
        }

        protected override Task<string> GetFormModeAsync(CancellationToken token = default)
        {
            return LanguageManager.GetStringAsync("Title_CareerMode", token: token);
        }

        /// <summary>
        /// Open the Select Cyberware window and handle adding to the Tree and Character.
        /// </summary>
        private async Task<bool> PickCyberware(Cyberware objSelectedCyberware,
                                                    Improvement.ImprovementSource objSource,
                                                    CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    using (ThreadSafeForm<SelectCyberware> frmPickCyberware
                           = await ThreadSafeForm<SelectCyberware>.GetAsync(
                                   () => new SelectCyberware(CharacterObject, objSource,
                                       objSelectedCyberware), token)
                               .ConfigureAwait(false))
                    {
                        List<Improvement> lstUsedImprovements;
                        decimal decMultiplier = 1.0m;
                        switch (objSource)
                        {
                            // Apply the character's Cyberware Essence cost multiplier if applicable.
                            case Improvement.ImprovementSource.Cyberware:
                            {
                                lstUsedImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject, Improvement.ImprovementType.CyberwareEssCost,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstUsedImprovements.Count != 0)
                                {
                                    foreach (Improvement objImprovement in lstUsedImprovements)
                                    {
                                        decMultiplier -= 1 - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterESSMultiplier *= decMultiplier;
                                }

                                lstUsedImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.CyberwareTotalEssMultiplier,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstUsedImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstUsedImprovements)
                                    {
                                        decMultiplier *= objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                                }

                                lstUsedImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                        CharacterObject, Improvement.ImprovementType.CyberwareEssCostNonRetroactive,
                                        token: token).ConfigureAwait(false);
                                if (lstUsedImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstUsedImprovements)
                                    {
                                        decMultiplier -= 1 - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterESSMultiplier *= decMultiplier;
                                }

                                lstUsedImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                        CharacterObject,
                                        Improvement.ImprovementType.CyberwareTotalEssMultiplierNonRetroactive,
                                        token: token).ConfigureAwait(false);
                                if (lstUsedImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstUsedImprovements)
                                    {
                                        decMultiplier *= objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                                }

                                break;
                            }
                            // Apply the character's Bioware Essence cost multiplier if applicable.
                            case Improvement.ImprovementSource.Bioware:
                            {
                                lstUsedImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject, Improvement.ImprovementType.BiowareEssCost,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstUsedImprovements.Count != 0)
                                {
                                    foreach (Improvement objImprovement in lstUsedImprovements)
                                    {
                                        decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterESSMultiplier = decMultiplier;
                                }

                                lstUsedImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.BiowareTotalEssMultiplier,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstUsedImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstUsedImprovements)
                                    {
                                        decMultiplier *= objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                                }

                                lstUsedImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.BiowareEssCostNonRetroactive,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstUsedImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstUsedImprovements)
                                    {
                                        decMultiplier -= 1 - objImprovement.Value / 100;
                                    }

                                    frmPickCyberware.MyForm.CharacterESSMultiplier = decMultiplier;
                                }

                                lstUsedImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                        CharacterObject,
                                        Improvement.ImprovementType.BiowareTotalEssMultiplierNonRetroactive,
                                        token: token).ConfigureAwait(false);
                                if (lstUsedImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstUsedImprovements)
                                    {
                                        decMultiplier *= objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                                }

                                // Apply the character's Basic Bioware Essence cost multiplier if applicable.
                                lstUsedImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.BasicBiowareEssCost, token: token)
                                        .ConfigureAwait(false);
                                if (lstUsedImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstUsedImprovements)
                                    {
                                        decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.BasicBiowareESSMultiplier = decMultiplier;
                                }

                                // Genetech Cost multiplier.
                                lstUsedImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.GenetechCostMultiplier,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstUsedImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstUsedImprovements)
                                    {
                                        decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.GenetechCostMultiplier = decMultiplier;
                                }

                                // Apply the character's Genetech Essence cost multiplier if applicable.
                                lstUsedImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.GenetechEssMultiplier,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstUsedImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstUsedImprovements)
                                    {
                                        decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.GenetechEssMultiplier = decMultiplier;
                                }

                                break;
                            }
                        }

                        Dictionary<string, int> dicDisallowedMounts = new Dictionary<string, int>(6);
                        Dictionary<string, int> dicHasMounts = new Dictionary<string, int>(6);
                        if (objSelectedCyberware != null)
                        {
                            frmPickCyberware.MyForm.ForcedGrade =
                                await objSelectedCyberware.GetGradeAsync(token).ConfigureAwait(false);
                            frmPickCyberware.MyForm.LockGrade();
                            frmPickCyberware.MyForm.Subsystems = objSelectedCyberware.AllowedSubsystems;
                            // If the Cyberware has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that consume Capacity).
                            if (!objSelectedCyberware.Capacity.Contains('[') ||
                                objSelectedCyberware.Capacity.Contains("/["))
                            {
                                await frmPickCyberware.MyForm.SetMaximumCapacityAsync(await objSelectedCyberware
                                    .GetCapacityRemainingAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);

                                // Do not allow the user to add a new piece of Cyberware if its Capacity has been reached.
                                if (await CharacterObjectSettings.GetEnforceCapacityAsync(token)
                                        .ConfigureAwait(false) &&
                                    frmPickCyberware.MyForm.MaximumCapacity < 0)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        await LanguageManager
                                            .GetStringAsync("MessageTitle_CapacityReached", token: token)
                                            .ConfigureAwait(false), MessageBoxButtons.OK,
                                        MessageBoxIcon.Information, token: token).ConfigureAwait(false);
                                    return false;
                                }
                            }

                            string strLoopHasModularMount = await objSelectedCyberware.GetHasModularMountAsync(token)
                                .ConfigureAwait(false);
                            if (!string.IsNullOrEmpty(strLoopHasModularMount)
                                && !dicHasMounts.ContainsKey(strLoopHasModularMount))
                                dicHasMounts.Add(strLoopHasModularMount, int.MaxValue);
                            string strSelectedLocation =
                                await objSelectedCyberware.GetLocationAsync(token).ConfigureAwait(false);
                            foreach (Cyberware objLoopCyberware in await (await objSelectedCyberware.GetChildrenAsync(token).ConfigureAwait(false)).DeepWhereAsync(
                                             x => x.GetChildrenAsync(token),
                                             async x => string.IsNullOrEmpty(await x
                                                 .GetPlugsIntoModularMountAsync(token).ConfigureAwait(false)), token)
                                         .ConfigureAwait(false))
                            {
                                string strLoopLocation =
                                    await objLoopCyberware.GetLocationAsync(token).ConfigureAwait(false);
                                foreach (string strLoop in objLoopCyberware.BlocksMounts.SplitNoAlloc(
                                             ',', StringSplitOptions.RemoveEmptyEntries))
                                {
                                    string strKey = strLoop;
                                    if (strSelectedLocation != strLoopLocation)
                                        strKey += strLoopLocation;
                                    if (!dicDisallowedMounts.ContainsKey(strKey))
                                        dicDisallowedMounts.Add(strKey, int.MaxValue);
                                }

                                strLoopHasModularMount = strSelectedLocation != strLoopLocation
                                    ? await objLoopCyberware.GetHasModularMountAsync(token).ConfigureAwait(false) +
                                      strLoopLocation
                                    : await objLoopCyberware.GetHasModularMountAsync(token).ConfigureAwait(false);
                                if (!string.IsNullOrEmpty(strLoopHasModularMount)
                                    && !dicHasMounts.ContainsKey(strLoopHasModularMount))
                                    dicHasMounts.Add(strLoopHasModularMount, int.MaxValue);
                            }
                        }
                        else
                        {
                            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                       out HashSet<string> setLoopDisallowedMounts))
                            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                       out HashSet<string> setLoopHasModularMount))
                            {
                                await CharacterObject.Cyberware.ForEachAsync(async objLoopCyberware =>
                                {
                                    setLoopDisallowedMounts.Clear();
                                    setLoopDisallowedMounts.AddRange(
                                        (await objLoopCyberware.GetBlocksMountsAsync(token).ConfigureAwait(false)).SplitNoAlloc(',',
                                            StringSplitOptions.RemoveEmptyEntries));
                                    setLoopHasModularMount.Clear();
                                    string strLoopHasModularMount = await objLoopCyberware
                                        .GetHasModularMountAsync(token).ConfigureAwait(false);
                                    if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                        setLoopHasModularMount.Add(strLoopHasModularMount);
                                    foreach (Cyberware objInnerLoopCyberware in await (await objLoopCyberware.GetChildrenAsync(token).ConfigureAwait(false))
                                                 .DeepWhereAsync(
                                                     x => x.GetChildrenAsync(token),
                                                     async x => string.IsNullOrEmpty(
                                                         await x.GetPlugsIntoModularMountAsync(token)
                                                             .ConfigureAwait(false)),
                                                     token).ConfigureAwait(false))
                                    {
                                        foreach (string strLoop in (await objInnerLoopCyberware
                                                     .GetBlocksMountsAsync(token).ConfigureAwait(false)).SplitNoAlloc(
                                                     ',', StringSplitOptions.RemoveEmptyEntries))
                                            setLoopDisallowedMounts.Add(strLoop);
                                        strLoopHasModularMount = await objInnerLoopCyberware
                                            .GetHasModularMountAsync(token).ConfigureAwait(false);
                                        if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                            setLoopHasModularMount.Add(strLoopHasModularMount);
                                    }

                                    foreach (string strLoop in setLoopDisallowedMounts)
                                    {
                                        string strKey = strLoop + objLoopCyberware.Location;
                                        if (!dicDisallowedMounts.ContainsKey(strKey))
                                            dicDisallowedMounts.Add(strKey,
                                                await objLoopCyberware.GetLimbSlotCountAsync(token)
                                                    .ConfigureAwait(false));
                                        else
                                            dicDisallowedMounts[strKey] += await objLoopCyberware
                                                .GetLimbSlotCountAsync(token).ConfigureAwait(false);
                                    }

                                    foreach (string strLoop in setLoopHasModularMount)
                                    {
                                        string strKey = strLoop + objLoopCyberware.Location;
                                        if (!dicHasMounts.ContainsKey(strKey))
                                            dicHasMounts.Add(strKey,
                                                await objLoopCyberware.GetLimbSlotCountAsync(token)
                                                    .ConfigureAwait(false));
                                        else
                                            dicHasMounts[strKey] += await objLoopCyberware.GetLimbSlotCountAsync(token)
                                                .ConfigureAwait(false);
                                    }
                                }, token).ConfigureAwait(false);
                            }
                        }

                        using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                   out StringBuilder sbdDisallowedMounts))
                        {
                            foreach (KeyValuePair<string, int> kvpLoop in dicDisallowedMounts)
                            {
                                string strKey = kvpLoop.Key;
                                if (strKey.EndsWith("Right", StringComparison.Ordinal))
                                    continue;
                                int intValue = kvpLoop.Value;
                                if (strKey.EndsWith("Left", StringComparison.Ordinal))
                                {
                                    strKey = strKey.TrimEndOnce("Left", true);
                                    intValue = dicDisallowedMounts.TryGetValue(strKey + "Right",
                                        out int intExistingValue)
                                        ? 2 * Math.Min(intValue, intExistingValue)
                                        : 0;
                                    if (dicDisallowedMounts.TryGetValue(strKey, out intExistingValue))
                                        intValue += intExistingValue;
                                }

                                if (intValue >= await CharacterObject
                                        .LimbCountAsync(Cyberware.MountToLimbType(strKey), token: token)
                                        .ConfigureAwait(false))
                                    sbdDisallowedMounts.Append(strKey, ',');
                            }

                            // Remove trailing ","
                            if (sbdDisallowedMounts.Length > 0)
                                --sbdDisallowedMounts.Length;
                            frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                        }

                        using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                   out StringBuilder sbdHasMounts))
                        {
                            foreach (KeyValuePair<string, int> kvpLoop in dicHasMounts)
                            {
                                string strKey = kvpLoop.Key;
                                if (strKey.EndsWith("Right", StringComparison.Ordinal))
                                    continue;
                                int intValue = kvpLoop.Value;
                                if (strKey.EndsWith("Left", StringComparison.Ordinal))
                                {
                                    strKey = strKey.TrimEndOnce("Left", true);
                                    intValue = dicHasMounts.TryGetValue(strKey + "Right", out int intExistingValue)
                                        ? 2 * Math.Min(intValue, intExistingValue)
                                        : 0;
                                    if (dicHasMounts.TryGetValue(strKey, out intExistingValue))
                                        intValue += intExistingValue;
                                }

                                if (intValue >= await CharacterObject
                                        .LimbCountAsync(Cyberware.MountToLimbType(strKey), token: token)
                                        .ConfigureAwait(false))
                                    sbdHasMounts.Append(strKey, ',');
                            }

                            // Remove trailing ","
                            if (sbdHasMounts.Length > 0)
                                --sbdHasMounts.Length;
                            frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                        }

                        // Make sure the dialogue window was not canceled.
                        if (await frmPickCyberware.ShowDialogSafeAsync(this, token: token).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return false;

                        // Open the Cyberware XML file and locate the selected piece.
                        XmlNode objXmlCyberware = objSource == Improvement.ImprovementSource.Bioware
                            ? (await CharacterObject.LoadDataAsync("bioware.xml", token: token).ConfigureAwait(false))
                            .TryGetNodeByNameOrId("/chummer/biowares/bioware",
                                frmPickCyberware.MyForm.SelectedCyberware)
                            : (await CharacterObject.LoadDataAsync("cyberware.xml", token: token).ConfigureAwait(false))
                            .TryGetNodeByNameOrId("/chummer/cyberwares/cyberware",
                                frmPickCyberware.MyForm.SelectedCyberware);

                        Cyberware objCyberware = new Cyberware(CharacterObject);
                        try
                        {
                            if (await CharacterObjectSettings.GetAllowCyberwareESSDiscountsAsync(token).ConfigureAwait(false))
                                await objCyberware.SetESSDiscountAsync(frmPickCyberware.MyForm.SelectedESSDiscount, token).ConfigureAwait(false);
                            await objCyberware.SetParentAsync(objSelectedCyberware, token).ConfigureAwait(false);
                            if (!await objCyberware.Purchase(objXmlCyberware, objSource,
                                    frmPickCyberware.MyForm.SelectedGrade,
                                    frmPickCyberware.MyForm.SelectedRating, null,
                                    objSelectedCyberware != null
                                        ? await objSelectedCyberware.GetChildrenAsync(token).ConfigureAwait(false)
                                        : await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false),
                                    await CharacterObject.GetVehiclesAsync(token).ConfigureAwait(false),
                                    await CharacterObject.GetWeaponsAsync(token).ConfigureAwait(false),
                                    frmPickCyberware.MyForm.Markup,
                                    frmPickCyberware.MyForm.FreeCost,
                                    frmPickCyberware.MyForm.BlackMarketDiscount,
                                    objParent: objSelectedCyberware, token: token).ConfigureAwait(false))
                                await objCyberware.DeleteCyberwareAsync(token: token).ConfigureAwait(false);

                            return frmPickCyberware.MyForm.AddAgain;
                        }
                        catch
                        {
                            await objCyberware.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Select a piece of Gear to be added to the character.
        /// </summary>
        /// <param name="iParent">Parent to which the gear should be added.</param>
        /// <param name="objLocation">Location to which the gear should be added.</param>
        /// <param name="objStackGear">Whether the selected item should stack with a matching item on the character.</param>
        /// <param name="strForceItemValue">Force the user to select an item with the passed name.</param>
        /// <param name="objAmmoForWeapon">Gear is being bought as ammo for this weapon.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        private async Task<bool> PickGear(IHasChildren<Gear> iParent, Location objLocation = null,
                                               Gear objStackGear = null, string strForceItemValue = "",
                                               Weapon objAmmoForWeapon = null, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    bool blnNullParent = false;
                    Gear objSelectedGear = null;
                    if (iParent is Gear gear)
                    {
                        objSelectedGear = gear;
                    }
                    else
                    {
                        blnNullParent = true;
                    }

                    // Open the Gear XML file and locate the selected Gear.
                    XPathNavigator xmlParent
                        = blnNullParent ? null : await objSelectedGear.GetNodeXPathAsync(token).ConfigureAwait(false);

                    string strCategories = string.Empty;

                    if (xmlParent != null)
                    {
                        XPathNodeIterator xmlAddonCategoryList = xmlParent
                            .SelectAndCacheExpression(
                                "addoncategory", token);
                        if (xmlAddonCategoryList.Count > 0)
                        {
                            using (new FetchSafelyFromObjectPool<StringBuilder>(
                                       Utils.StringBuilderPool, out StringBuilder sbdCategories))
                            {
                                foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                                    sbdCategories.Append(objXmlCategory.Value, ',');
                                // Remove the trailing comma.
                                --sbdCategories.Length;
                                strCategories = sbdCategories.ToString();
                            }
                        }
                    }

                    using (ThreadSafeForm<SelectGear> frmPickGear
                           = await ThreadSafeForm<SelectGear>.GetAsync(() => new SelectGear(CharacterObject,
                               objSelectedGear?.ChildAvailModifier ?? 0,
                               objSelectedGear?.ChildCostMultiplier ?? 1,
                               objSelectedGear, strCategories)
                           {
                               ShowFlechetteAmmoOnly
                                   = objAmmoForWeapon?.Damage.EndsWith(
                                         "(f)", StringComparison.Ordinal)
                                     == true
                           }, token).ConfigureAwait(false))
                    {
                        if (!blnNullParent)
                        {
                            // If the Gear has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that consume Capacity).
                            if (!string.IsNullOrEmpty(objSelectedGear.Capacity) &&
                                !objSelectedGear.Capacity.Contains('[')
                                || objSelectedGear.Capacity.Contains("/["))
                            {
                                await frmPickGear.MyForm.SetMaximumCapacityAsync(await objSelectedGear.GetCapacityRemainingAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);

                                // Do not allow the user to add a new piece of Gear if its Capacity has been reached.
                                if (await CharacterObjectSettings.GetEnforceCapacityAsync(token).ConfigureAwait(false) && frmPickGear.MyForm.MaximumCapacity < 0)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager
                                                .GetStringAsync("Message_CapacityReached", token: token)
                                                .ConfigureAwait(false),
                                            await LanguageManager
                                                .GetStringAsync("MessageTitle_CapacityReached", token: token)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: token)
                                        .ConfigureAwait(false);
                                    return false;
                                }

                                if (!string.IsNullOrEmpty(strCategories))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;
                            }

                            // If a Commlink has just been added, see if the character already has one. If not, make it the active Commlink.
                            if (await CharacterObject.GetActiveCommlinkAsync(token).ConfigureAwait(false) == null &&
                                await objSelectedGear.GetIsCommlinkAsync(token).ConfigureAwait(false))
                            {
                                await objSelectedGear.SetActiveCommlinkAsync(CharacterObject, true, token)
                                    .ConfigureAwait(false);
                            }
                        }

                        frmPickGear.MyForm.DefaultSearchText = strForceItemValue;
                        frmPickGear.MyForm.ForceItemAmmoForWeaponType = objAmmoForWeapon?.WeaponType ?? string.Empty;

                        // Make sure the dialogue window was not canceled.
                        if (await frmPickGear.ShowDialogSafeAsync(this, token).ConfigureAwait(false) ==
                            DialogResult.Cancel)
                            return false;

                        // Open the Cyberware XML file and locate the selected piece.
                        XmlDocument objXmlDocument
                            = await CharacterObject.LoadDataAsync("gear.xml", token: token).ConfigureAwait(false);
                        XmlNode objXmlGear
                            = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                frmPickGear.MyForm.SelectedGear);

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        string strForceValue = objStackGear?.Extra ?? strForceItemValue;
                        if (string.IsNullOrEmpty(strForceValue) && objAmmoForWeapon != null)
                        {
                            //If the amount of an ammunition was increased, force the correct weapon category.
                            strForceValue = objAmmoForWeapon.AmmoCategory;
                        }

                        Gear objGear = new Gear(CharacterObject);
                        await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                            strForceValue,
                            objSelectedGear?.Equipped != false, token: token).ConfigureAwait(false);

                        if (objGear.InternalId.IsEmptyGuid())
                        {
                            await objGear.DeleteGearAsync(token: token).ConfigureAwait(false);
                            foreach (Weapon objWeapon in lstWeapons)
                                await objWeapon.DeleteWeaponAsync(token: token).ConfigureAwait(false);
                            return frmPickGear.MyForm.AddAgain;
                        }

                        await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, token).ConfigureAwait(false);

                        await objGear.SetParentAsync(blnNullParent ? null : objSelectedGear, token)
                            .ConfigureAwait(false);
                        //Reduce the Cost for Black Market Pipeline
                        objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = "(" + objGear.Cost + ") * 0.5";

                        Gear objStackWith = null;
                        // See if the character already has the item on them if they chose to stack.
                        if (frmPickGear.MyForm.Stack)
                        {
                            objStackWith = objStackGear
                                           ?? CharacterObject.Gear.FirstOrDefault(x => x.Location == objLocation
                                               && objGear.IsIdenticalToOtherGear(x));
                            if (objStackWith != null && objStackWith.InternalId.IsEmptyGuid())
                            {
                                await objGear.DeleteGearAsync(token: token).ConfigureAwait(false);
                                foreach (Weapon objWeapon in lstWeapons)
                                    await objWeapon.DeleteWeaponAsync(token: token).ConfigureAwait(false);
                                return frmPickGear.MyForm.AddAgain;
                            }
                        }

                        // Do not allow the user to add a new piece of Cyberware if its Capacity has been reached.
                        if (!blnNullParent && objStackWith == null &&
                            await CharacterObjectSettings.GetEnforceCapacityAsync(token).ConfigureAwait(false) &&
                            await objSelectedGear.GetCapacityRemainingAsync(token).ConfigureAwait(false) <
                            await objGear.GetPluginCapacityAsync(token).ConfigureAwait(false))
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_CapacityReached", token: token)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_CapacityReached", token: token)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Information, token: token).ConfigureAwait(false);
                            await objGear.DeleteGearAsync(token: token).ConfigureAwait(false);
                            foreach (Weapon objWeapon in lstWeapons)
                                await objWeapon.DeleteWeaponAsync(token: token).ConfigureAwait(false);
                            return frmPickGear.MyForm.AddAgain;
                        }

                        // Add the gear now to help with cost calculations
                        decimal decOldCost = 0;
                        if (objStackWith != null)
                        {
                            if (!frmPickGear.MyForm.FreeCost)
                                decOldCost = await objStackWith.GetTotalCostAsync(token).ConfigureAwait(false);
                            // A match was found, so increase the quantity instead.
                            await objStackWith.SetQuantityAsync(objStackWith.Quantity + objGear.Quantity, token).ConfigureAwait(false);
                        }
                        else if (!blnNullParent)
                        {
                            if (!frmPickGear.MyForm.FreeCost)
                                decOldCost = await objSelectedGear.GetTotalCostAsync(token).ConfigureAwait(false);
                            await objSelectedGear.Children.AddAsync(objGear, token).ConfigureAwait(false);
                        }
                        else
                        {
                            await CharacterObject.Gear.AddAsync(objGear, token).ConfigureAwait(false);
                        }

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickGear.MyForm.FreeCost)
                        {
                            decimal decCost = objStackWith != null
                                ? await objStackWith.GetTotalCostAsync(token).ConfigureAwait(false) - decOldCost
                                : blnNullParent
                                    ? await objGear.GetTotalCostAsync(token).ConfigureAwait(false)
                                    : await objSelectedGear.GetTotalCostAsync(token).ConfigureAwait(false) - decOldCost;

                            // Apply a markup if applicable.
                            if (frmPickGear.MyForm.Markup != 0)
                            {
                                decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                            }

                            // Multiply the cost if applicable.
                            switch ((await objGear.TotalAvailTupleAsync(token: token).ConfigureAwait(false)).Suffix)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > await CharacterObject.GetNuyenAsync(token).ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: token)
                                            .ConfigureAwait(false),
                                        await LanguageManager
                                            .GetStringAsync("MessageTitle_NotEnoughNuyen", token: token)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: token)
                                    .ConfigureAwait(false);
                                if (objStackWith != null)
                                {
                                    await objStackWith.SetQuantityAsync(objStackWith.Quantity - objGear.Quantity, token).ConfigureAwait(false);
                                    foreach (Weapon objWeapon in lstWeapons)
                                        await objWeapon.DeleteWeaponAsync(token: token).ConfigureAwait(false);
                                }
                                // Remove any Improvements created by the Gear.
                                await objGear.DeleteGearAsync(token: token).ConfigureAwait(false);
                                return frmPickGear.MyForm.AddAgain;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                await LanguageManager
                                    .GetStringAsync("String_ExpensePurchaseGear", token: token)
                                    .ConfigureAwait(false)
                                + await LanguageManager.GetStringAsync("String_Space", token: token)
                                    .ConfigureAwait(false)
                                + await objGear.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                ExpenseType.Nuyen,
                                DateTime.Now);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: token)
                                .ConfigureAwait(false);
                            await CharacterObject.ModifyNuyenAsync(-decCost, token).ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddGear, objStackWith != null ? objStackWith.InternalId : objGear.InternalId, objGear.Quantity);
                            objExpense.Undo = objUndo;
                        }

                        if (objStackWith != null)
                        {
                            await objGear.DeleteGearAsync(token: token).ConfigureAwait(false);
                            foreach (Weapon objWeapon in lstWeapons)
                                await objWeapon.DeleteWeaponAsync(token: token).ConfigureAwait(false);
                        }
                        // Add the rest of the Gear.
                        else
                        {
                            // Create any Weapons that came with this Gear.
                            foreach (Weapon objWeapon in lstWeapons)
                                await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);

                            if (objLocation != null)
                                await objLocation.Children.AddAsync(objGear, token).ConfigureAwait(false);
                        }

                        return frmPickGear.MyForm.AddAgain;
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Select a piece of Gear and add it to a piece of Armor.
        /// </summary>
        /// <param name="strSelectedId">Id attached to the object to which the gear should be added.</param>
        /// <param name="blnShowArmorCapacityOnly">Whether only items that consume capacity should be shown.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        private async Task<bool> PickArmorGear(string strSelectedId, bool blnShowArmorCapacityOnly = false,
                                                    CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    (Gear objSelectedGear, Armor objSelectedArmor, ArmorMod objSelectedMod)
                        = await CharacterObject.Armor.FindArmorGearAsync(strSelectedId, token)
                            .ConfigureAwait(false);
                    if (objSelectedGear == null)
                    {
                        objSelectedMod = await CharacterObject.Armor.FindArmorModAsync(strSelectedId, token)
                            .ConfigureAwait(false);
                        if (objSelectedMod == null)
                            objSelectedArmor = await CharacterObject.Armor.FindByIdAsync(strSelectedId, token).ConfigureAwait(false);
                        else
                            objSelectedArmor = objSelectedMod.Parent;
                    }

                    // Open the Gear XML file and locate the selected Gear.
                    object objParent = objSelectedGear ?? objSelectedMod ?? (object)objSelectedArmor;
                    string strCategories = string.Empty;

                    if (!string.IsNullOrEmpty(strSelectedId) && objParent is IHasXmlDataNode objParentWithDataNode)
                    {
                        XPathNavigator objParentDataNode
                            = await objParentWithDataNode.GetNodeXPathAsync(token).ConfigureAwait(false);
                        XPathNodeIterator xmlAddonCategoryList =
                            objParentDataNode?.SelectAndCacheExpression("addoncategory", token);
                        if (xmlAddonCategoryList?.Count > 0)
                        {
                            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                       out StringBuilder sbdCategories))
                            {
                                foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                                    sbdCategories.Append(objXmlCategory.Value, ',');
                                // Remove the trailing comma.
                                if (sbdCategories.Length > 0)
                                    --sbdCategories.Length;
                                strCategories = sbdCategories.ToString();
                            }
                        }
                    }

                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject, objGearParent: objParent, strAllowedCategories: strCategories)
                               {
                                   EnableStack = false,
                                   ShowArmorCapacityOnly = blnShowArmorCapacityOnly,
                                   CapacityDisplayStyle = objSelectedMod != null
                                       ? CapacityStyle.Standard
                                       : objSelectedArmor.CapacityDisplayStyle
                               }, token).ConfigureAwait(false))
                    {
                        // If the Gear has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that consume Capacity).
                        if (!string.IsNullOrEmpty(strSelectedId))
                        {
                            if (objSelectedGear != null && (!objSelectedGear.Capacity.Contains('[')
                                                            || objSelectedGear.Capacity.Contains("/[")))
                            {
                                await frmPickGear.MyForm.SetMaximumCapacityAsync(await objSelectedGear.GetCapacityRemainingAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);

                                // Do not allow the user to add a new piece of Gear if its Capacity has been reached.
                                if (await CharacterObjectSettings.GetEnforceCapacityAsync(token).ConfigureAwait(false) && frmPickGear.MyForm.MaximumCapacity < 0)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        await LanguageManager
                                            .GetStringAsync("MessageTitle_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK,
                                        MessageBoxIcon.Information, token: token).ConfigureAwait(false);
                                    return false;
                                }
                            }
                            else if (objSelectedMod != null)
                            {
                                await frmPickGear.MyForm.SetMaximumCapacityAsync(await objSelectedMod
                                    .GetGearCapacityRemainingAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);

                                // Do not allow the user to add a new piece of Gear if its Capacity has been reached.
                                if (await CharacterObjectSettings.GetEnforceCapacityAsync(token)
                                        .ConfigureAwait(false) && await objSelectedMod
                                        .GetGearCapacityRemainingAsync(token).ConfigureAwait(false) < 0)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        await LanguageManager
                                            .GetStringAsync("MessageTitle_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK,
                                        MessageBoxIcon.Information, token: token).ConfigureAwait(false);
                                    return false;
                                }
                            }
                        }

                        // Make sure the dialogue window was not canceled.
                        if (await frmPickGear.ShowDialogSafeAsync(this, token).ConfigureAwait(false) ==
                            DialogResult.Cancel)
                            return false;

                        // Open the Cyberware XML file and locate the selected piece.
                        XmlDocument objXmlDocument
                            = await CharacterObject.LoadDataAsync("gear.xml", token: token).ConfigureAwait(false);
                        XmlNode objXmlGear
                            = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                frmPickGear.MyForm.SelectedGear);

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                            string.Empty,
                            objSelectedGear?.Equipped ?? objSelectedMod?.Equipped ?? objSelectedArmor.Equipped,
                            token: token).ConfigureAwait(false);

                        if (objGear.InternalId.IsEmptyGuid())
                            return frmPickGear.MyForm.AddAgain;

                        await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, token).ConfigureAwait(false);

                        if (objSelectedGear != null)
                        {
                            await objGear.SetParentAsync(objSelectedGear, token).ConfigureAwait(false);
                        }

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = "(" + objGear.Cost + ") * 0.5";

                        Gear objMatchingGear = null;
                        // If this is Ammunition, see if the character already has it on them.
                        if (objGear.Category == "Ammunition" || !string.IsNullOrEmpty(objGear.AmmoForWeaponType))
                        {
                            TaggedObservableCollection<Gear> lstToSearch = !string.IsNullOrEmpty(objSelectedGear?.Name)
                                ? objSelectedGear.Children
                                : !string.IsNullOrEmpty(objSelectedMod?.Name)
                                    ? objSelectedMod.GearChildren
                                    : objSelectedArmor.GearChildren;
                            objMatchingGear = lstToSearch.FirstOrDefault(x => objGear.IsIdenticalToOtherGear(x));
                        }

                        decimal decGearQuantity = 0;
                        if (objMatchingGear != null)
                        {
                            decGearQuantity = objGear.Quantity;
                            // A match was found, so increase the quantity instead.
                            await objMatchingGear.SetQuantityAsync(objMatchingGear.Quantity + decGearQuantity, token).ConfigureAwait(false);

                            await objGear.DeleteGearAsync(token: token).ConfigureAwait(false);
                            if (await CharacterObjectSettings.GetEnforceCapacityAsync(token).ConfigureAwait(false) &&
                                await objMatchingGear.GetCapacityRemainingAsync(token).ConfigureAwait(false) < 0)
                            {
                                await objMatchingGear.SetQuantityAsync(objMatchingGear.Quantity - decGearQuantity, token).ConfigureAwait(false);
                                await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        await LanguageManager
                                            .GetStringAsync("MessageTitle_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: token)
                                    .ConfigureAwait(false);
                                return frmPickGear.MyForm.AddAgain;
                            }
                        }
                        // Add the Gear.
                        else if (!string.IsNullOrEmpty(objSelectedGear?.Name))
                        {
                            await objSelectedGear.Children.AddAsync(objGear, token).ConfigureAwait(false);
                            if (await CharacterObjectSettings.GetEnforceCapacityAsync(token).ConfigureAwait(false) &&
                                await objSelectedGear.GetCapacityRemainingAsync(token).ConfigureAwait(false) < 0)
                            {
                                await objGear.DeleteGearAsync(token: token).ConfigureAwait(false);
                                await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        await LanguageManager
                                            .GetStringAsync("MessageTitle_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: token)
                                    .ConfigureAwait(false);
                                return frmPickGear.MyForm.AddAgain;
                            }
                        }
                        else if (!string.IsNullOrEmpty(objSelectedMod?.Name))
                        {
                            await objSelectedMod.GearChildren.AddAsync(objGear, token).ConfigureAwait(false);
                            if (await CharacterObjectSettings.GetEnforceCapacityAsync(token).ConfigureAwait(false) &&
                                await objSelectedMod.GetGearCapacityRemainingAsync(token).ConfigureAwait(false) < 0)
                            {
                                await objGear.DeleteGearAsync(token: token).ConfigureAwait(false);
                                await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        await LanguageManager
                                            .GetStringAsync("MessageTitle_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: token)
                                    .ConfigureAwait(false);
                                return frmPickGear.MyForm.AddAgain;
                            }
                        }
                        else
                        {
                            await objSelectedArmor.GearChildren.AddAsync(objGear, token).ConfigureAwait(false);
                            if (await CharacterObjectSettings.GetEnforceCapacityAsync(token).ConfigureAwait(false) &&
                                await objSelectedArmor.GetCapacityRemainingAsync(token).ConfigureAwait(false) < 0)
                            {
                                await objGear.DeleteGearAsync(token: token).ConfigureAwait(false);
                                await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        await LanguageManager
                                            .GetStringAsync("MessageTitle_CapacityReached", token: token)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: token)
                                    .ConfigureAwait(false);
                                return frmPickGear.MyForm.AddAgain;
                            }
                        }

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickGear.MyForm.FreeCost)
                        {
                            // Apply a markup if applicable.
                            decimal decCost = await objGear.GetTotalCostAsync(token).ConfigureAwait(false);
                            if (frmPickGear.MyForm.Markup != 0)
                            {
                                decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                            }

                            // Multiply the cost if applicable.
                            char chrAvail = (await objGear.TotalAvailTupleAsync(token: token).ConfigureAwait(false)).Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > await CharacterObject.GetNuyenAsync(token).ConfigureAwait(false))
                            {
                                // Remove the added gear
                                if (objMatchingGear != null)
                                    await objMatchingGear.SetQuantityAsync(objMatchingGear.Quantity + decGearQuantity, token).ConfigureAwait(false);
                                // Remove any Improvements created by the Gear.
                                else
                                    await objGear.DeleteGearAsync(token: token).ConfigureAwait(false);
                                await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: token)
                                            .ConfigureAwait(false),
                                        await LanguageManager
                                            .GetStringAsync("MessageTitle_NotEnoughNuyen", token: token)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: token)
                                    .ConfigureAwait(false);
                                return frmPickGear.MyForm.AddAgain;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                await LanguageManager
                                    .GetStringAsync("String_ExpensePurchaseArmorGear", token: token)
                                    .ConfigureAwait(false)
                                + await LanguageManager.GetStringAsync("String_Space", token: token)
                                    .ConfigureAwait(false)
                                + await objGear.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                ExpenseType.Nuyen,
                                DateTime.Now);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: token)
                                .ConfigureAwait(false);
                            await CharacterObject.ModifyNuyenAsync(-decCost, token).ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddArmorGear,
                                objMatchingGear != null ? objMatchingGear.InternalId : objGear.InternalId,
                                objGear.Quantity);
                            objExpense.Undo = objUndo;
                        }

                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                        }

                        return frmPickGear.MyForm.AddAgain;
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Refresh the currently-selected Lifestyle.
        /// </summary>
        private async Task RefreshSelectedLifestyle(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpLifestyleDetails.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    TreeNode objSelectedNode = await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                                  .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag == null || objSelectedNode.Level == 0
                                                   || !(objSelectedNodeTag is Lifestyle objLifestyle))
                    {
                        await flpLifestyleDetails.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                        await cmdDeleteLifestyle
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                        return;
                    }

                    await flpLifestyleDetails.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    await cmdDeleteLifestyle.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                    string strMonthlyCost =
                        (await objLifestyle.GetTotalMonthlyCostAsync(token: token).ConfigureAwait(false)).ToString(
                            await CharacterObjectSettings.GetNuyenFormatAsync(token)
                                .ConfigureAwait(false),
                            GlobalSettings.CultureInfo)
                        + await LanguageManager.GetStringAsync(
                            "String_NuyenSymbol", token: token).ConfigureAwait(false);
                    await lblLifestyleCost.DoThreadSafeAsync(x => x.Text = strMonthlyCost, token)
                                          .ConfigureAwait(false);
                    int intMonths = await objLifestyle.GetIncrementsAsync(GenericToken).ConfigureAwait(false);
                    await lblLifestyleMonths
                          .DoThreadSafeAsync(x => x.Text = intMonths.ToString(GlobalSettings.CultureInfo),
                                             token).ConfigureAwait(false);
                    await objLifestyle.SetSourceDetailAsync(lblLifestyleSource, token).ConfigureAwait(false);
                    string strCostLabelString;
                    string strIncrementString;
                    // Change the Cost/Month label.
                    switch (await objLifestyle.GetIncrementTypeAsync(token).ConfigureAwait(false))
                    {
                        case LifestyleIncrement.Day:
                            strCostLabelString = await LanguageManager
                                                       .GetStringAsync("Label_SelectLifestyle_CostPerDay", token: token)
                                                       .ConfigureAwait(false);
                            strIncrementString = await LanguageManager.GetStringAsync("String_Days", token: token)
                                                                      .ConfigureAwait(false);
                            break;

                        case LifestyleIncrement.Week:
                            strCostLabelString = await LanguageManager
                                                       .GetStringAsync("Label_SelectLifestyle_CostPerWeek",
                                                                       token: token).ConfigureAwait(false);
                            strIncrementString = await LanguageManager.GetStringAsync("String_Weeks", token: token)
                                                                      .ConfigureAwait(false);
                            break;

                        default:
                            strCostLabelString = await LanguageManager
                                                       .GetStringAsync("Label_SelectLifestyle_CostPerMonth",
                                                                       token: token).ConfigureAwait(false);
                            strIncrementString = await LanguageManager.GetStringAsync("String_Months", token: token)
                                                                      .ConfigureAwait(false);
                            break;
                    }

                    await lblLifestyleCostLabel.DoThreadSafeAsync(x => x.Text = strCostLabelString, token)
                                               .ConfigureAwait(false);
                    string strMonthsLabel = strIncrementString + string.Format(
                        GlobalSettings.CultureInfo,
                        await LanguageManager.GetStringAsync("Label_LifestylePermanent", token: token)
                                             .ConfigureAwait(false),
                        (await objLifestyle.GetIncrementsRequiredForPermanentAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo));
                    await lblLifestyleMonthsLabel.DoThreadSafeAsync(x => x.Text = strMonthsLabel, token)
                                                 .ConfigureAwait(false);
                    await cmdIncreaseLifestyleMonths.SetToolTipTextAsync(string.Format(GlobalSettings.CultureInfo,
                                                                             await LanguageManager.GetStringAsync(
                                                                                 "Tab_IncreaseLifestyleMonths",
                                                                                 token: token).ConfigureAwait(false),
                                                                             strIncrementString), token)
                                                    .ConfigureAwait(false);
                    await cmdDecreaseLifestyleMonths.SetToolTipTextAsync(string.Format(GlobalSettings.CultureInfo,
                                                                             await LanguageManager.GetStringAsync(
                                                                                 "Tab_DecreaseLifestyleMonths",
                                                                                 token: token).ConfigureAwait(false),
                                                                             strIncrementString), token)
                                                    .ConfigureAwait(false);
                    token.ThrowIfCancellationRequested();
                    if (!string.IsNullOrEmpty(await objLifestyle.GetBaseLifestyleAsync(token).ConfigureAwait(false)))
                    {
                        using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdQualities))
                        {
                            await sbdQualities.AppendJoinAsync("," + Environment.NewLine,
                                                               objLifestyle.LifestyleQualities.Select(
                                                                   r => r.GetCurrentFormattedDisplayNameAsync(token)), token).ConfigureAwait(false);
                            foreach (Improvement objImprovement in await ImprovementManager
                                                                         .GetCachedImprovementListForValueOfAsync(
                                                                             CharacterObject,
                                                                             Improvement.ImprovementType.LifestyleCost,
                                                                             token: token).ConfigureAwait(false))
                            {
                                if (sbdQualities.Length > 0)
                                    sbdQualities.AppendLine(',');

                                sbdQualities.Append(await CharacterObject
                                                          .GetObjectNameAsync(objImprovement, token: token)
                                                          .ConfigureAwait(false),
                                                          await LanguageManager.GetStringAsync("String_Space", token: token)
                                                                         .ConfigureAwait(false))
                                            .Append('[',
                                                objImprovement.Value.ToString(
                                                    "+#,0;-#,0;0", GlobalSettings.CultureInfo), "%]");
                            }

                            if (await objLifestyle.GetStyleTypeAsync(token).ConfigureAwait(false) == LifestyleType.Standard)
                            {
                                foreach (Improvement objImprovement in await ImprovementManager
                                             .GetCachedImprovementListForValueOfAsync(
                                                 CharacterObject,
                                                 Improvement.ImprovementType.BasicLifestyleCost,
                                                 token: token).ConfigureAwait(false))
                                {
                                    if (sbdQualities.Length > 0)
                                        sbdQualities.AppendLine(',');

                                    sbdQualities.Append(await CharacterObject
                                            .GetObjectNameAsync(objImprovement, token: token)
                                            .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("String_Space", token: token)
                                            .ConfigureAwait(false)).Append('[',
                                            objImprovement.Value.ToString(
                                                "+#,0;-#,0;0", GlobalSettings.CultureInfo), "%]");
                                }
                            }

                            await lblLifestyleQualities.DoThreadSafeAsync(x => x.Text = sbdQualities.ToString(), token)
                                                       .ConfigureAwait(false);
                        }

                        string strBaseName = await objLifestyle.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                        await lblBaseLifestyle.DoThreadSafeAsync(x => x.Text = strBaseName, token)
                                              .ConfigureAwait(false);
                        await lblLifestyleQualitiesLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                        await lblLifestyleQualities.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                    }
                    else
                    {
                        string strError = await LanguageManager.GetStringAsync("String_Error", token: token)
                                                               .ConfigureAwait(false);
                        await lblBaseLifestyle.DoThreadSafeAsync(x => x.Text = strError, token).ConfigureAwait(false);
                        await lblLifestyleQualitiesLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                        await lblLifestyleQualities.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                    }

                    //Controls Visibility and content of the City, District and Borough Labels
                    string strCity = await objLifestyle.GetCityAsync(token).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strCity))
                    {
                        await lblLifestyleCity.DoThreadSafeAsync(x =>
                        {
                            x.Text = strCity;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await lblLifestyleCityLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                    }
                    else
                    {
                        await lblLifestyleCity.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await lblLifestyleCityLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                    }

                    string strDistrict = await objLifestyle.GetDistrictAsync(token).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strDistrict))
                    {
                        await lblLifestyleDistrict.DoThreadSafeAsync(x =>
                        {
                            x.Text = strDistrict;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await lblLifestyleDistrictLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                       .ConfigureAwait(false);
                    }
                    else
                    {
                        await lblLifestyleDistrict.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                        await lblLifestyleDistrictLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                    }

                    string strBorough = await objLifestyle.GetBoroughAsync(token).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strBorough))
                    {
                        await lblLifestyleBorough.DoThreadSafeAsync(x =>
                        {
                            x.Text = strBorough;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await lblLifestyleBoroughLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                    }
                    else
                    {
                        await lblLifestyleBorough.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                        await lblLifestyleBoroughLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await flpLifestyleDetails.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the currently-selected Vehicle.
        /// </summary>
        private async Task RefreshSelectedVehicle(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpVehicles.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                                .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag == null || objSelectedNode.Level <= 0
                                                   || objSelectedNodeTag.ToString() == "String_WeaponMounts")
                    {
                        await panVehicleCM.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteVehicle
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                        return;
                    }

                    string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token)
                                                           .ConfigureAwait(false);
                    if (objSelectedNodeTag is IHasRating objHasRating)
                    {
                        string strText = string.Format(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Label_RatingFormat", token: token).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync(
                                objHasRating.RatingLabel, token: token).ConfigureAwait(false));
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token)
                                                   .ConfigureAwait(false);
                    }

                    if (objSelectedNodeTag is IHasSource objSelected)
                    {
                        await lblVehicleSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                        await lblVehicleSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await objSelected.SetSourceDetailAsync(lblVehicleSource, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await lblVehicleSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                        await lblVehicleSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    switch (objSelectedNodeTag)
                    {
                        // Locate the selected Vehicle.
                        case Vehicle objVehicle:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteVehicle
                                  .DoThreadSafeAsync(x => x.Enabled = string.IsNullOrEmpty(objVehicle.ParentID), token)
                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesCommon
                            string strName = await objVehicle.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token).ConfigureAwait(false);
                            string strCategory = await objVehicle.DisplayCategoryAsync(GlobalSettings.Language, token).ConfigureAwait(false);
                            await lblVehicleCategory
                                  .DoThreadSafeAsync(x => x.Text = strCategory,
                                                     token).ConfigureAwait(false);
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                            string strAvail = await objVehicle.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objVehicle.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                                    .ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                            .ConfigureAwait(false);
                            if (await CharacterObjectSettings.BookEnabledAsync("R5", token).ConfigureAwait(false))
                            {
                                await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblVehicleSlots.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            }
                            else
                            {
                                int intSlots = await objVehicle.GetSlotsAsync(token).ConfigureAwait(false);
                                string strText = intSlots.ToString(GlobalSettings.CultureInfo) + strSpace
                                    + "("
                                    + (intSlots - await objVehicle.GetSlotsUsedAsync(token).ConfigureAwait(false)).ToString(
                                        GlobalSettings.CultureInfo)
                                    + strSpace + await LanguageManager.GetStringAsync("String_Remaining", token: token)
                                                                      .ConfigureAwait(false)
                                    + ")";
                                await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                await lblVehicleSlots.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strText;
                                }, token).ConfigureAwait(false);
                            }

                            await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                    .ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesVehicle
                            string strHandling = await objVehicle.GetTotalHandlingAsync(token).ConfigureAwait(false);
                            await lblVehicleHandling.DoThreadSafeAsync(x => x.Text = strHandling, token)
                                                    .ConfigureAwait(false);
                            string strAccel = await objVehicle.GetTotalAccelAsync(token).ConfigureAwait(false);
                            await lblVehicleAccel.DoThreadSafeAsync(x => x.Text = strAccel, token)
                                                 .ConfigureAwait(false);
                            string strSpeed = await objVehicle.GetTotalSpeedAsync(token).ConfigureAwait(false);
                            await lblVehicleSpeed.DoThreadSafeAsync(x => x.Text = strSpeed, token)
                                .ConfigureAwait(false);
                            string strPilot =
                                (await objVehicle.GetPilotAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehiclePilot
                                .DoThreadSafeAsync(
                                    x => x.Text = strPilot, token)
                                .ConfigureAwait(false);
                            string strBody =
                                (await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehicleBody
                                  .DoThreadSafeAsync(
                                      x => x.Text = strBody, token)
                                  .ConfigureAwait(false);
                            string strArmor = (await objVehicle.GetTotalArmorAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehicleArmor
                                .DoThreadSafeAsync(
                                    x => x.Text = strArmor, token)
                                .ConfigureAwait(false);
                            string strSeats =
                                (await objVehicle.GetTotalSeatsAsync(token).ConfigureAwait(false)).ToString(
                                    GlobalSettings.CultureInfo);
                            await lblVehicleSeats.DoThreadSafeAsync(x => x.Text = strSeats, token)
                                .ConfigureAwait(false);
                            string strSensor = (await objVehicle.GetCalculatedSensorAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehicleSensor.DoThreadSafeAsync(x => x.Text = strSensor, token)
                                .ConfigureAwait(false);
                            if (await CharacterObjectSettings.BookEnabledAsync("R5", token).ConfigureAwait(false))
                            {
                                if (objVehicle.IsDrone && await CharacterObjectSettings.GetDroneModsAsync(token).ConfigureAwait(false))
                                {
                                    await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                    await lblVehiclePowertrain.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                                    await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                 .ConfigureAwait(false);
                                    await lblVehicleCosmetic.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                    await lblVehicleElectromagneticLabel
                                          .DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                                    await lblVehicleElectromagnetic.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                    await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                                    await lblVehicleBodymod.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                                    await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                    await lblVehicleWeaponsmod.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                                    await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                    await lblVehicleProtection.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                                    await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                      .ConfigureAwait(false);
                                    string strText
                                        = (await objVehicle.GetDroneModSlotsUsedAsync(token).ConfigureAwait(false)).ToString(
                                            GlobalSettings.CultureInfo) + "/"
                                                                        + (await objVehicle
                                                                            .GetDroneModSlotsAsync(token).ConfigureAwait(false))
                                                                        .ToString(GlobalSettings.CultureInfo);
                                    await lblVehicleDroneModSlots.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strText;
                                    }, token).ConfigureAwait(false);
                                }
                                else
                                {
                                    await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                   .ConfigureAwait(false);
                                    string strPowertrain = await objVehicle.PowertrainModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehiclePowertrain.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strPowertrain;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                 .ConfigureAwait(false);
                                    string strCosmetic = await objVehicle.CosmeticModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehicleCosmetic.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strCosmetic;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleElectromagneticLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                        .ConfigureAwait(false);
                                    string strElectromagnetic = await objVehicle.ElectromagneticModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehicleElectromagnetic.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strElectromagnetic;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                .ConfigureAwait(false);
                                    string strBodyMods = await objVehicle.BodyModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehicleBodymod.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strBodyMods;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                   .ConfigureAwait(false);
                                    string strWeapon = await objVehicle.WeaponModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehicleWeaponsmod.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strWeapon;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                   .ConfigureAwait(false);
                                    string strProtection = await objVehicle.ProtectionModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehicleProtection.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strProtection;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                      .ConfigureAwait(false);
                                    await lblVehicleDroneModSlots.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                 .ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehiclePowertrain.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                                await lblVehicleCosmetic.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                                await lblVehicleElectromagneticLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                    .ConfigureAwait(false);
                                await lblVehicleElectromagnetic.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                await lblVehicleBodymod.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                                await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleWeaponsmod.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleProtection.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                  .ConfigureAwait(false);
                                await lblVehicleDroneModSlots.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesMatrix
                            int intDeviceRating = await objVehicle.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblVehicleDevice
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await objVehicle.RefreshMatrixAttributeComboBoxesAsync(
                                                cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing,
                                                cboVehicleFirewall, token)
                                            .ConfigureAwait(false);
                            bool blnIsActiveCommlink = await objVehicle.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objVehicle.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objVehicle.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objVehicle.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                            token.ThrowIfCancellationRequested();
                            await UpdateSensor(objVehicle, token).ConfigureAwait(false);
                            break;
                        }
                        case WeaponMount objWeaponMount:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteVehicle
                                  .DoThreadSafeAsync(x => x.Enabled = !objWeaponMount.IncludedInVehicle, token)
                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesCommon
                            string strCategory = await objWeaponMount.DisplayCategoryAsync(GlobalSettings.Language, token).ConfigureAwait(false);
                            await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strCategory, token).ConfigureAwait(false);
                            string strName = await objWeaponMount.GetCurrentDisplayNameAsync(token)
                                                                 .ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token).ConfigureAwait(false);
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                            string strAvail = await objWeaponMount.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail
                                  .DoThreadSafeAsync(x => x.Text = strAvail, token)
                                  .ConfigureAwait(false);
                            string strCost = (await objWeaponMount.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                .ConfigureAwait(false);
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                            string strSlots = (await objWeaponMount.GetCalculatedSlotsAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strSlots;
                            }, token).ConfigureAwait(false);
                            await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objWeaponMount.Equipped;
                                x.Enabled = !objWeaponMount.IncludedInVehicle;
                            }, token).ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            break;
                        }
                        case VehicleMod objMod:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objMod.IncludedInVehicle, token)
                                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesCommon
                            string strName = await objMod.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token).ConfigureAwait(false);
                            string strText = await LanguageManager
                                                   .GetStringAsync("String_VehicleModification", token: token)
                                                   .ConfigureAwait(false);
                            await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                    .ConfigureAwait(false);
                            int intMaxRating = await objMod.GetMaxRatingAsync(token).ConfigureAwait(false);
                            if (intMaxRating > 0)
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                    .ConfigureAwait(false);
                                int intRating = await objMod.GetRatingAsync(token).ConfigureAwait(false);
                                await lblVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Text = intRating.ToString(GlobalSettings
                                        .CultureInfo);
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                                await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                            string strAvail = await objMod.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objMod.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                        await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                        GlobalSettings.CultureInfo)
                                                    + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                            .ConfigureAwait(false);
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                            string strSlots = (await objMod.GetCalculatedSlotsAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strSlots;
                            }, token).ConfigureAwait(false);
                            await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objMod.Equipped;
                                x.Enabled = !objMod.IncludedInVehicle;
                            }, token).ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            break;
                        }
                        case Weapon objWeapon:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objWeapon.Cyberware
                                                                         && objWeapon.Category != "Gear"
                                                                         && !objWeapon.IncludedInWeapon
                                                                         && string.IsNullOrEmpty(objWeapon.ParentID)
                                                                         && !objWeapon.Category.StartsWith(
                                                                             "Quality", StringComparison.Ordinal),
                                                                     token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesCommon
                            string strName = await objWeapon.GetCurrentDisplayNameShortAsync(token)
                                                            .ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token).ConfigureAwait(false);
                            string strText = await objWeapon.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                            .ConfigureAwait(false);
                            await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token: token)
                                                    .ConfigureAwait(false);
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token: token)
                                                  .ConfigureAwait(false);
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token: token)
                                                   .ConfigureAwait(false);
                            await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                            string strAvail = await objWeapon.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objWeapon.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                .ConfigureAwait(false);
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                            string strMounts = await objWeapon.GetCurrentDisplayAccessoryMounts(token).ConfigureAwait(false);
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Text = strMounts;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);

                            await cmdVehicleMoveToInventory
                                  .DoThreadSafeAsync(x => x.Visible = !objWeapon.IncludedInWeapon, token)
                                  .ConfigureAwait(false);
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objWeapon.Equipped;
                                x.Enabled = objWeapon.ParentID != objWeapon.Parent?.InternalId
                                            && objWeapon.ParentID
                                            != objWeapon.ParentVehicle.InternalId;
                            }, token).ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objWeapon.IncludedInWeapon;
                            }, token).ConfigureAwait(false);
                            // gpbVehiclesWeapon
                            string strDamage = await objWeapon.GetDisplayDamageAsync(token).ConfigureAwait(false);
                            await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                            await lblVehicleWeaponDamage.DoThreadSafeAsync(x =>
                            {
                                x.Text = strDamage;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);
                            string strAP = await objWeapon.GetDisplayTotalAPAsync(token).ConfigureAwait(false);
                            await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                            await lblVehicleWeaponAP.DoThreadSafeAsync(x =>
                            {
                                x.Text = strAP;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);
                            string strAccuracy = await objWeapon.GetDisplayAccuracyAsync(token).ConfigureAwait(false);
                            await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                            await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x =>
                            {
                                x.Text = strAccuracy;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);
                            await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                               .ConfigureAwait(false);
                            int intPool
                                = await objWeapon.GetDicePoolAsync(token: token).ConfigureAwait(false);
                            await dpcVehicleWeaponDicePool.SetDicePoolAsync(intPool, token).ConfigureAwait(false);
                            await dpcVehicleWeaponDicePool.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.CanBeRolled = true;
                            }, token).ConfigureAwait(false);
                            await dpcVehicleWeaponDicePool.SetLabelToolTipAsync(await objWeapon.GetDicePoolTooltipAsync(token).ConfigureAwait(false), token)
                                                          .ConfigureAwait(false);
                            if (objWeapon.RangeType == "Ranged")
                            {
                                string strAmmo = await objWeapon.GetDisplayAmmoAsync(token).ConfigureAwait(false);
                                await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strAmmo;
                                }, token).ConfigureAwait(false);
                                string strMode = await objWeapon.GetDisplayModeAsync(token).ConfigureAwait(false);
                                await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                                await lblVehicleWeaponMode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strMode;
                                }, token).ConfigureAwait(false);
                                await tlpVehiclesWeaponRanges.DoThreadSafeAsync(x => x.Visible = true, token)
                                                             .ConfigureAwait(false);
                                string strRange = await objWeapon.GetCurrentDisplayRangeAsync(token)
                                                                 .ConfigureAwait(false);
                                await lblVehicleWeaponRangeMain
                                      .DoThreadSafeAsync(x => x.Text = strRange, token)
                                      .ConfigureAwait(false);
                                string strAlternateRange = await objWeapon.GetCurrentDisplayAlternateRangeAsync(token)
                                                                          .ConfigureAwait(false);
                                await lblVehicleWeaponRangeAlternate
                                      .DoThreadSafeAsync(x => x.Text = strAlternateRange, token)
                                      .ConfigureAwait(false);
                                Dictionary<string, string> dicRanges
                                    = await objWeapon.GetRangeStringsAsync(GlobalSettings.CultureInfo, token: token)
                                                     .ConfigureAwait(false);
                                string strModifierShort = await objWeapon.RangeModifierAsync("Short", token).ConfigureAwait(false);
                                string strModifierMedium = await objWeapon.RangeModifierAsync("Medium", token).ConfigureAwait(false);
                                string strModifierLong = await objWeapon.RangeModifierAsync("Long", token).ConfigureAwait(false);
                                string strModifierExtreme = await objWeapon.RangeModifierAsync("Extreme", token).ConfigureAwait(false);
                                await lblVehicleWeaponRangeShortLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierShort, token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeMediumLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierMedium, token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeLongLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierLong, token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeExtremeLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierExtreme, token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeShort
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["short"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeMedium
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["medium"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeLong
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["long"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeExtreme
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["extreme"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponAlternateRangeShort
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternateshort"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponAlternateRangeMedium
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternatemedium"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponAlternateRangeLong
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternatelong"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponAlternateRangeExtreme
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternateextreme"], token)
                                      .ConfigureAwait(false);
                                (string strRC, string strRCTooltip) = await objWeapon.GetDisplayTotalRCAsync(token).ConfigureAwait(false);
                                await lblVehicleWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                                await lblVehicleWeaponRC.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strRC;
                                }, token).ConfigureAwait(false);
                                await lblVehicleWeaponRC.SetToolTipTextAsync(strRCTooltip, token).ConfigureAwait(false);
                                await lblVehicleWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                await lblVehicleWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            }
                            else
                            {
                                if (objWeapon.Ammo != "0")
                                {
                                    string strAmmo = await objWeapon.GetDisplayAmmoAsync(token).ConfigureAwait(false);
                                    await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                .ConfigureAwait(false);
                                    await lblVehicleWeaponAmmo.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strAmmo;
                                    }, token).ConfigureAwait(false);
                                }
                                else
                                {
                                    await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                    await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                                }

                                await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await tlpVehiclesWeaponRanges.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                                await lblVehicleWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                .ConfigureAwait(false);
                                string strReach
                                    = (await objWeapon.GetTotalReachAsync(token).ConfigureAwait(false)).ToString(
                                        GlobalSettings.CultureInfo);
                                await lblVehicleWeaponReach.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strReach;
                                }, token).ConfigureAwait(false);
                            }

                            if (objWeapon.RangeType == "Ranged"
                                || objWeapon.RangeType == "Melee" && objWeapon.Ammo != "0")
                            {
                                await tlpVehiclesWeaponCareer.DoThreadSafeAsync(x => x.Visible = true, token)
                                                             .ConfigureAwait(false);
                                await lblVehicleWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text
                                                                       = objWeapon.AmmoRemaining.ToString(
                                                                           GlobalSettings
                                                                               .CultureInfo), token)
                                                                   .ConfigureAwait(false);
                                await cmdFireVehicleWeapon
                                      .DoThreadSafeAsync(x => x.Enabled = objWeapon.AmmoRemaining != 0, token)
                                      .ConfigureAwait(false);
                                await cmdUnloadVehicleWeapon
                                      .DoThreadSafeAsync(
                                          x => x.Enabled = objWeapon.RequireAmmo && objWeapon.AmmoLoaded != null
                                              && objWeapon.AmmoRemaining != 0, token).ConfigureAwait(false);
                                await cboVehicleWeaponFiringMode
                                      .DoThreadSafeAsync(x => x.SelectedValue = objWeapon.FireMode, token)
                                      .ConfigureAwait(false);
                                bool blnAllowSingleShot = await objWeapon.GetAllowSingleShotAsync(token).ConfigureAwait(false);
                                bool blnAllowShortBurst = await objWeapon.GetAllowShortBurstAsync(token).ConfigureAwait(false);
                                bool blnAllowLongBurst = await objWeapon.GetAllowLongBurstAsync(token).ConfigureAwait(false);
                                bool blnAllowFullBurst = await objWeapon.GetAllowFullBurstAsync(token).ConfigureAwait(false);
                                bool blnAllowSuppressive = await objWeapon.GetAllowSuppressiveAsync(token).ConfigureAwait(false);
                                string strSingleShotText
                                    = blnAllowSingleShot
                                        ? string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager.GetStringAsync(
                                                            "String_SingleShot", token: token).ConfigureAwait(false),
                                                        objWeapon.SingleShot.ToString(GlobalSettings.CultureInfo),
                                                        objWeapon.SingleShot == 1
                                                            ? await LanguageManager.GetStringAsync(
                                                                "String_Bullet", token: token).ConfigureAwait(false)
                                                            : await LanguageManager.GetStringAsync(
                                                                "String_Bullets", token: token).ConfigureAwait(false))
                                        : await
                                            LanguageManager.GetStringAsync("String_SingleShotNA", token: token)
                                                           .ConfigureAwait(false);
                                string strShortBurstText
                                    = blnAllowShortBurst
                                        ? string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager.GetStringAsync(
                                                            "String_ShortBurst", token: token).ConfigureAwait(false),
                                                        objWeapon.ShortBurst.ToString(GlobalSettings.CultureInfo),
                                                        objWeapon.ShortBurst == 1
                                                            ? await LanguageManager.GetStringAsync(
                                                                "String_Bullet", token: token).ConfigureAwait(false)
                                                            : await LanguageManager.GetStringAsync(
                                                                "String_Bullets", token: token).ConfigureAwait(false))
                                        : await
                                            LanguageManager.GetStringAsync("String_ShortBurstNA", token: token)
                                                           .ConfigureAwait(false);
                                string strLongBurstText
                                    = blnAllowLongBurst
                                        ? string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager.GetStringAsync(
                                                            "String_LongBurst", token: token).ConfigureAwait(false),
                                                        objWeapon.LongBurst.ToString(GlobalSettings.CultureInfo),
                                                        objWeapon.LongBurst == 1
                                                            ? await LanguageManager.GetStringAsync(
                                                                "String_Bullet", token: token).ConfigureAwait(false)
                                                            : await LanguageManager.GetStringAsync(
                                                                "String_Bullets", token: token).ConfigureAwait(false))
                                        : await
                                            LanguageManager.GetStringAsync("String_LongBurstNA", token: token)
                                                           .ConfigureAwait(false);
                                string strFullBurstText
                                    = blnAllowFullBurst
                                        ? string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager.GetStringAsync(
                                                            "String_FullBurst", token: token).ConfigureAwait(false),
                                                        objWeapon.FullBurst.ToString(GlobalSettings.CultureInfo),
                                                        objWeapon.FullBurst == 1
                                                            ? await LanguageManager.GetStringAsync(
                                                                "String_Bullet", token: token).ConfigureAwait(false)
                                                            : await LanguageManager.GetStringAsync(
                                                                "String_Bullets", token: token).ConfigureAwait(false))
                                        : await
                                            LanguageManager.GetStringAsync("String_FullBurstNA", token: token)
                                                           .ConfigureAwait(false);
                                string strSuppressiveFireText
                                    = blnAllowSuppressive
                                        ? string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager.GetStringAsync(
                                                                                 "String_SuppressiveFire", token: token)
                                                                             .ConfigureAwait(false),
                                                        objWeapon.Suppressive.ToString(GlobalSettings.CultureInfo),
                                                        objWeapon.Suppressive == 1
                                                            ? await LanguageManager.GetStringAsync(
                                                                "String_Bullet", token: token).ConfigureAwait(false)
                                                            : await LanguageManager.GetStringAsync(
                                                                "String_Bullets", token: token).ConfigureAwait(false))
                                        : await
                                            LanguageManager.GetStringAsync("String_SuppressiveFireNA", token: token)
                                                           .ConfigureAwait(false);
                                await cmdVehicleAmmoExpense.DoThreadSafeAsync(() =>
                                {
                                    cmsVehicleAmmoSingleShot.Enabled = blnAllowSingleShot;
                                    cmsVehicleAmmoShortBurst.Enabled = blnAllowShortBurst;
                                    cmsVehicleAmmoLongBurst.Enabled = blnAllowLongBurst;
                                    cmsVehicleAmmoFullBurst.Enabled = blnAllowFullBurst;
                                    cmsVehicleAmmoSuppressiveFire.Enabled = blnAllowSuppressive;
                                    cmsVehicleAmmoSingleShot.Text = strSingleShotText;
                                    cmsVehicleAmmoShortBurst.Text = strShortBurstText;
                                    cmsVehicleAmmoLongBurst.Text = strLongBurstText;
                                    cmsVehicleAmmoFullBurst.Text = strFullBurstText;
                                    cmsVehicleAmmoSuppressiveFire.Text = strSuppressiveFireText;
                                }, token).ConfigureAwait(false);
                                using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstAmmo))
                                {
                                    int intSlot = 0;
                                    foreach (Clip objClip in objWeapon.Clips)
                                    {
                                        ++intSlot;
                                        token.ThrowIfCancellationRequested();
                                        string strAmmoName;
                                        if (objWeapon.RequireAmmo)
                                        {
                                            Gear objGear = objClip.AmmoGear;
                                            strAmmoName = objGear != null
                                                ? await objGear.GetCurrentDisplayNameShortAsync(token)
                                                               .ConfigureAwait(false)
                                                : await LanguageManager.GetStringAsync(objClip.Ammo > 0
                                                    ? "String_ExternalSource"
                                                    : "String_Empty", token: token).ConfigureAwait(false);
                                            if (objWeapon.Clips.Count > 1)
                                                strAmmoName += strSpace + "(" + string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager
                                                            .GetStringAsync("String_SlotNumber", token: token)
                                                            .ConfigureAwait(false),
                                                    intSlot.ToString(GlobalSettings.CultureInfo)) + ")";

                                            string strPlugins = string.Empty;
                                            if (objGear?.Children.Count > 0)
                                            {
                                                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                           out StringBuilder sbdPlugins))
                                                {
                                                    foreach (Gear objChild in objGear.Children)
                                                    {
                                                        sbdPlugins.Append(await objChild
                                                                              .GetCurrentDisplayNameShortAsync(
                                                                                  token).ConfigureAwait(false), ',', strSpace);
                                                    }

                                                    strPlugins = sbdPlugins.ToString();
                                                }
                                            }

                                            // Remove the trailing comma.
                                            if (!string.IsNullOrEmpty(strPlugins))
                                                strPlugins = strPlugins.Substring(
                                                    0, strPlugins.Length - 1 - strSpace.Length);

                                            if (!string.IsNullOrEmpty(strPlugins))
                                                strAmmoName += strSpace + "[" + strPlugins + "]";
                                        }
                                        else
                                            strAmmoName = await LanguageManager.GetStringAsync(objClip.Ammo > 0
                                                ? "String_MountInternal"
                                                : "String_Empty", token: token).ConfigureAwait(false);

                                        token.ThrowIfCancellationRequested();
                                        lstAmmo.Add(new ListItem(intSlot.ToString(GlobalSettings.InvariantCultureInfo),
                                                                 strAmmoName));
                                    }

                                    token.ThrowIfCancellationRequested();
                                    await cboVehicleWeaponAmmo.PopulateWithListItemsAsync(lstAmmo, token)
                                                              .ConfigureAwait(false);
                                    await cboVehicleWeaponAmmo.DoThreadSafeAsync(x =>
                                    {
                                        x.SelectedValue
                                            = objWeapon.ActiveAmmoSlot.ToString(GlobalSettings.InvariantCultureInfo);
                                        if (x.SelectedIndex == -1)
                                            x.SelectedIndex = 0;
                                        x.Enabled = lstAmmo.Count > 1;
                                    }, token).ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                await tlpVehiclesWeaponCareer.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesMatrix
                            int intDeviceRating = await objWeapon.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblVehicleDevice
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await objWeapon.RefreshMatrixAttributeComboBoxesAsync(
                                               cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing,
                                               cboVehicleFirewall, token)
                                           .ConfigureAwait(false);
                            bool blnIsActiveCommlink = await objWeapon.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objWeapon.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objWeapon.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objWeapon.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                                break;
                        }
                        case WeaponAccessory objAccessory:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteVehicle
                                  .DoThreadSafeAsync(x => x.Enabled = !objAccessory.IncludedInWeapon, token)
                                  .ConfigureAwait(false);
                            // gpbVehiclesCommon
                            string strName = await objAccessory.GetCurrentDisplayNameShortAsync(token)
                                                               .ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token).ConfigureAwait(false);
                            string strText = await LanguageManager
                                                   .GetStringAsync("String_VehicleWeaponAccessory", token: token)
                                                   .ConfigureAwait(false);
                            await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                    .ConfigureAwait(false);
                            int intRating = await objAccessory.GetRatingAsync(GenericToken).ConfigureAwait(false);
                            if (intRating > 0)
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                           .ConfigureAwait(false);
                                await lblVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = intRating.ToString(GlobalSettings.CultureInfo);
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                                await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            }

                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                            string strAvail = await objAccessory.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objAccessory.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                .ConfigureAwait(false);
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            string strMountText;
                            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdMount))
                            {
                                sbdMount.Append(await objAccessory.DisplayMountAsync(GlobalSettings.Language, token).ConfigureAwait(false));
                                if (!string.IsNullOrEmpty(objAccessory.ExtraMount) && objAccessory.ExtraMount != "None")
                                {
                                    bool boolHaveAddedItem = false;
                                    foreach (string strCurrentExtraMount in objAccessory.ExtraMount.SplitNoAlloc(
                                                 '/', StringSplitOptions.RemoveEmptyEntries))
                                    {
                                        if (!boolHaveAddedItem)
                                        {
                                            sbdMount.Append(strSpace, '+', strSpace);
                                            boolHaveAddedItem = true;
                                        }

                                        token.ThrowIfCancellationRequested();
                                        sbdMount.Append(await LanguageManager.GetStringAsync(
                                                                                 "String_Mount" + strCurrentExtraMount,
                                                                                 token: token)
                                                                             .ConfigureAwait(false), '/');
                                    }

                                    // Remove the trailing /
                                    if (boolHaveAddedItem)
                                        --sbdMount.Length;
                                }

                                if (!string.IsNullOrEmpty(objAccessory.AddMount))
                                {
                                    sbdMount.Append(strSpace, "(++", strSpace).Append(await LanguageManager.GetStringAsync(
                                                                                "String_Mount" + objAccessory.AddMount,
                                                                                token: token)
                                                                            .ConfigureAwait(false), ')');
                                }

                                strMountText = sbdMount.ToString();
                            }
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Text = strMountText;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);

                            await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Enabled = true;
                                x.Checked = objAccessory.Equipped;
                            }, token).ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objAccessory.IncludedInWeapon;
                            }, token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbWeaponsWeapon
                            string strText3 = await LanguageManager
                                                    .GetStringAsync("String_WeaponAccessory", token: token)
                                                    .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Text = strText3, token)
                                                  .ConfigureAwait(false);
                            if (string.IsNullOrEmpty(objAccessory.Damage))
                            {
                                await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                 .ConfigureAwait(false);
                                await lblVehicleWeaponDamage.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            }
                            else
                            {
                                string strDamageText = (await objAccessory.GetTotalDamageAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                .ConfigureAwait(false);
                                await lblVehicleWeaponDamage.DoThreadSafeAsync(x =>
                                {
                                    x.Text = strDamageText;
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }

                            if (string.IsNullOrEmpty(objAccessory.RC))
                            {
                                await lblVehicleWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                                await lblVehicleWeaponRC.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            }
                            else
                            {
                                string strRCText = (await objAccessory.GetTotalRCAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblVehicleWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                                await lblVehicleWeaponRC.DoThreadSafeAsync(x =>
                                {
                                    x.Text = strRCText;
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }

                            if (string.IsNullOrEmpty(objAccessory.Reach))
                            {
                                await lblVehicleWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                                await lblVehicleWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            }
                            else
                            {
                                string strReachText = (await objAccessory.GetTotalReachAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblVehicleWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                .ConfigureAwait(false);
                                await lblVehicleWeaponReach.DoThreadSafeAsync(x =>
                                {
                                    x.Text = strReachText;
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }

                            if (string.IsNullOrEmpty(objAccessory.AP))
                            {
                                await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                                await lblVehicleWeaponAP.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            }
                            else
                            {
                                string strAPText = (await objAccessory.GetTotalAPAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                                await lblVehicleWeaponAP.DoThreadSafeAsync(x =>
                                {
                                    x.Text = strAPText;
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }

                            if (string.IsNullOrEmpty(objAccessory.Accuracy))
                            {
                                await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                            }
                            else
                            {
                                string strAccuracyText = (await objAccessory.GetTotalAccuracyAsync(token).ConfigureAwait(false))
                                        .ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                .ConfigureAwait(false);
                                await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strAccuracyText;
                                }, token).ConfigureAwait(false);
                            }

                            decimal decDicePool = await objAccessory.GetDicePoolAsync(token).ConfigureAwait(false);
                            if (decDicePool == 0)
                            {
                                await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                await dpcVehicleWeaponDicePool.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                            }
                            else
                            {
                                await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                   .ConfigureAwait(false);
                                await dpcVehicleWeaponDicePool.SetDicePoolAsync(decDicePool, token).ConfigureAwait(false);
                                await dpcVehicleWeaponDicePool.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.CanBeRolled = false;
                                }, token).ConfigureAwait(false);
                                await dpcVehicleWeaponDicePool.SetLabelToolTipAsync(string.Empty, token)
                                                              .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            decimal decAmmoBonus = await objAccessory.GetTotalAmmoBonusAsync(token).ConfigureAwait(false);
                            if (decAmmoBonus != 0
                                || (!string.IsNullOrEmpty(objAccessory.ModifyAmmoCapacity)
                                    && objAccessory.ModifyAmmoCapacity != "0"))
                            {
                                await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                using (new FetchSafelyFromObjectPool<StringBuilder>(
                                           Utils.StringBuilderPool, out StringBuilder sbdAmmoBonus))
                                {
                                    if (decAmmoBonus != 0)
                                        sbdAmmoBonus.Append(
                                            (decAmmoBonus / 100.0m).ToString(
                                                "+#,0.##%;-#,0.##%;0.##%", GlobalSettings.CultureInfo));
                                    if (!string.IsNullOrEmpty(objAccessory.ModifyAmmoCapacity)
                                        && objAccessory.ModifyAmmoCapacity != "0")
                                        sbdAmmoBonus.Append(objAccessory.ModifyAmmoCapacity);
                                    await lblVehicleWeaponAmmo
                                          .DoThreadSafeAsync(x => x.Text = sbdAmmoBonus.ToString(), token)
                                          .ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                            }

                            await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            await lblVehicleWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            await tlpVehiclesWeaponRanges.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                            await tlpVehiclesWeaponCareer.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                            break;
                        }
                        case Cyberware objCyberware:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteVehicle
                                  .DoThreadSafeAsync(x => x.Enabled = string.IsNullOrEmpty(objCyberware.ParentID),
                                                     token).ConfigureAwait(false);
                            // gpbVehiclesCommon
                            string strName = await objCyberware.GetCurrentDisplayNameShortAsync(token)
                                                               .ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token).ConfigureAwait(false);
                            string strText = await objCyberware.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                               .ConfigureAwait(false);
                            await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                    .ConfigureAwait(false);
                            int intMaxRating = await objCyberware.GetMaxRatingAsync(token).ConfigureAwait(false);
                            if (intMaxRating == 0)
                            {
                                await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            }
                            else
                            {
                                int intRating = await objCyberware.GetRatingAsync(token).ConfigureAwait(false);
                                await lblVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = intRating.ToString(GlobalSettings.CultureInfo);
                                }, token).ConfigureAwait(false);
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                           .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                            string strAvail = await objCyberware.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objCyberware.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                                    await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                                    GlobalSettings.CultureInfo)
                                                                + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                       = strCost, token)
                                                .ConfigureAwait(false);
                            await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            bool blnVisible = !string.IsNullOrEmpty(await objCyberware.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false));
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = blnVisible, token).ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                    .ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesMatrix
                            int intDeviceRating = await objCyberware.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblVehicleDevice
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await objCyberware.RefreshMatrixAttributeComboBoxesAsync(
                                                  cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing,
                                                  cboVehicleFirewall, token)
                                              .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            bool blnIsActiveCommlink = await objCyberware.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objCyberware.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objCyberware.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objCyberware.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                            break;
                        }
                        case Gear objGear:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token)
                                                  .ConfigureAwait(false);
                            // gpbVehiclesCommon
                            string strName = await objGear.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token).ConfigureAwait(false);
                            string strCategory = await objGear.GetCurrentDisplayCategoryAsync(token).ConfigureAwait(false);
                            await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strCategory, token).ConfigureAwait(false);
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                       .ConfigureAwait(false);
                            int intRating = await objGear.GetRatingAsync(token).ConfigureAwait(false);
                            await lblVehicleRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = intRating.ToString(GlobalSettings.CultureInfo);
                            }, token).ConfigureAwait(false);
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                            await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            string strQuantity = objGear.DisplayQuantity(GlobalSettings.CultureInfo);
                            if (string.IsNullOrEmpty(strQuantity))
                                strQuantity = 1.ToString(GlobalSettings.CultureInfo);
                            await lblVehicleGearQty.DoThreadSafeAsync(x => x.Text = strQuantity, token)
                                                   .ConfigureAwait(false);
                            await cmdVehicleGearReduceQty
                                  .DoThreadSafeAsync(x => x.Visible = !objGear.IncludedInParent, token)
                                  .ConfigureAwait(false);
                            string strAvail = await objGear.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objGear.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token)
                                                     .ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                .ConfigureAwait(false);
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                            string strText = objGear.CalculatedCapacity
                                             + strSpace + "("
                                             + objGear.CapacityRemaining.ToString(
                                                 "#,0.##", GlobalSettings.CultureInfo)
                                             + strSpace
                                             + await LanguageManager.GetStringAsync("String_Remaining", token: token)
                                                                    .ConfigureAwait(false) + ")";
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strText;
                            }, token).ConfigureAwait(false);
                            await cmdVehicleMoveToInventory
                                  .DoThreadSafeAsync(
                                      x => x.Visible = !objGear.IncludedInParent && objGear.LoadedIntoClip == null,
                                      token).ConfigureAwait(false);
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                    .ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            // gpbVehiclesMatrix
                            int intDeviceRating = await objGear.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblVehicleDevice
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await objGear.RefreshMatrixAttributeComboBoxesAsync(
                                             cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing,
                                             cboVehicleFirewall, token)
                                         .ConfigureAwait(false);
                            bool blnIsActiveCommlink = await objGear.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objGear.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objGear.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objGear.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                            break;
                        }
                        default:
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                  .ConfigureAwait(false);
                            break;
                    }

                    await panVehicleCM.DoThreadSafeAsync(x => x.Visible
                                                             = objSelectedNodeTag is IHasPhysicalConditionMonitor ||
                                                               objSelectedNodeTag is IHasMatrixAttributes, token)
                                      .ConfigureAwait(false);
                    await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible
                                                                  = objSelectedNodeTag is IHasMatrixAttributes ||
                                                                    objSelectedNodeTag is IHasWirelessBonus, token)
                                           .ConfigureAwait(false);
                    if (await panVehicleCM.DoThreadSafeFuncAsync(x => x.Visible, token).ConfigureAwait(false))
                    {
                        if (objSelectedNodeTag is IHasPhysicalConditionMonitor objCM)
                        {
                            await ProcessEquipmentConditionMonitorBoxDisplays(
                                    panVehiclePhysicalCM, objCM.PhysicalCM, objCM.PhysicalCMFilled, token)
                                .ConfigureAwait(false);
                        }

                        if (objSelectedNodeTag is IHasMatrixAttributes objMatrixCM)
                        {
                            await ProcessEquipmentConditionMonitorBoxDisplays(
                                    panVehicleMatrixCM, objMatrixCM.MatrixCM, objMatrixCM.MatrixCMFilled, token)
                                .ConfigureAwait(false);
                        }
                    }
                }
                finally
                {
                    await flpVehicles.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private Task ExpenseEntriesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            return DoExpenseEntriesCollectionChanged(e, token);
        }

        private async Task DoExpenseEntriesCollectionChanged(NotifyCollectionChangedEventArgs e,
                                                                  CancellationToken token = default)
        {
            bool blnDoRepopulateKarmaExpenseList = false;
            bool blnDoRepopulateNuyenExpenseList = false;
            if (e == null || e.Action == NotifyCollectionChangedAction.Reset)
            {
                blnDoRepopulateKarmaExpenseList = true;
                blnDoRepopulateNuyenExpenseList = true;
            }
            else
            {
                switch (e.Action)
                {
                    // TODO: Find a way to add, remove, or replace a single item at a time instead of needing to redraw the entire list
                    case NotifyCollectionChangedAction.Add:
                        foreach (ExpenseLogEntry objEntry in e.NewItems)
                        {
                            switch (objEntry.Type)
                            {
                                case ExpenseType.Karma:
                                    blnDoRepopulateKarmaExpenseList = blnDoRepopulateKarmaExpenseList
                                                                      || objEntry.Amount != 0
                                                                      || await chkShowFreeKarma
                                                                               .DoThreadSafeFuncAsync(
                                                                                   x => x.Checked, token: token)
                                                                               .ConfigureAwait(false);
                                    break;

                                case ExpenseType.Nuyen:
                                    blnDoRepopulateNuyenExpenseList = blnDoRepopulateNuyenExpenseList
                                                                      || objEntry.Amount != 0
                                                                      || await chkShowFreeNuyen
                                                                               .DoThreadSafeFuncAsync(
                                                                                   x => x.Checked, token: token)
                                                                               .ConfigureAwait(false);
                                    break;
                            }

                            if (blnDoRepopulateKarmaExpenseList && blnDoRepopulateNuyenExpenseList)
                                break;
                        }

                        break;

                    case NotifyCollectionChangedAction.Remove:
                        foreach (ExpenseLogEntry objEntry in e.OldItems)
                        {
                            switch (objEntry.Type)
                            {
                                case ExpenseType.Karma:
                                    blnDoRepopulateKarmaExpenseList = blnDoRepopulateKarmaExpenseList
                                                                      || objEntry.Amount != 0
                                                                      || await chkShowFreeKarma
                                                                               .DoThreadSafeFuncAsync(
                                                                                   x => x.Checked, token: token)
                                                                               .ConfigureAwait(false);
                                    break;

                                case ExpenseType.Nuyen:
                                    blnDoRepopulateNuyenExpenseList = blnDoRepopulateNuyenExpenseList
                                                                      || objEntry.Amount != 0
                                                                      || await chkShowFreeNuyen
                                                                               .DoThreadSafeFuncAsync(
                                                                                   x => x.Checked, token: token)
                                                                               .ConfigureAwait(false);
                                    break;
                            }

                            if (blnDoRepopulateKarmaExpenseList && blnDoRepopulateNuyenExpenseList)
                                break;
                        }

                        break;

                    case NotifyCollectionChangedAction.Replace:
                        foreach (ExpenseLogEntry objEntry in e.OldItems)
                        {
                            switch (objEntry.Type)
                            {
                                case ExpenseType.Karma:
                                    blnDoRepopulateKarmaExpenseList = blnDoRepopulateKarmaExpenseList
                                                                      || objEntry.Amount != 0
                                                                      || await chkShowFreeKarma
                                                                               .DoThreadSafeFuncAsync(
                                                                                   x => x.Checked, token: token)
                                                                               .ConfigureAwait(false);
                                    break;

                                case ExpenseType.Nuyen:
                                    blnDoRepopulateNuyenExpenseList = blnDoRepopulateNuyenExpenseList
                                                                      || objEntry.Amount != 0
                                                                      || await chkShowFreeNuyen
                                                                               .DoThreadSafeFuncAsync(
                                                                                   x => x.Checked, token: token)
                                                                               .ConfigureAwait(false);
                                    break;
                            }

                            if (blnDoRepopulateKarmaExpenseList && blnDoRepopulateNuyenExpenseList)
                                break;
                        }

                        if (!blnDoRepopulateKarmaExpenseList || !blnDoRepopulateNuyenExpenseList)
                        {
                            foreach (ExpenseLogEntry objEntry in e.NewItems)
                            {
                                switch (objEntry.Type)
                                {
                                    case ExpenseType.Karma:
                                        blnDoRepopulateKarmaExpenseList = blnDoRepopulateKarmaExpenseList
                                                                          || objEntry.Amount != 0
                                                                          || await chkShowFreeKarma
                                                                              .DoThreadSafeFuncAsync(
                                                                                  x => x.Checked, token: token)
                                                                              .ConfigureAwait(false);
                                        break;

                                    case ExpenseType.Nuyen:
                                        blnDoRepopulateNuyenExpenseList = blnDoRepopulateNuyenExpenseList
                                                                          || objEntry.Amount != 0
                                                                          || await chkShowFreeNuyen
                                                                              .DoThreadSafeFuncAsync(
                                                                                  x => x.Checked, token: token)
                                                                              .ConfigureAwait(false);
                                        break;
                                }

                                if (blnDoRepopulateKarmaExpenseList && blnDoRepopulateNuyenExpenseList)
                                    break;
                            }
                        }

                        break;

                    case NotifyCollectionChangedAction.Move:
                        return;
                }
            }

            if (blnDoRepopulateKarmaExpenseList)
                await RepopulateKarmaExpenseList(token).ConfigureAwait(false);
            if (blnDoRepopulateNuyenExpenseList)
                await RepopulateNuyenExpenseList(token).ConfigureAwait(false);
        }

        private async void chkShowFreeKarma_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                if (await CharacterObject.ExpenseEntries
                                         .AnyAsync(x => x.Type == ExpenseType.Karma && x.Amount == 0, GenericToken)
                                         .ConfigureAwait(false))
                {
                    await RepopulateKarmaExpenseList(GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RepopulateKarmaExpenseList(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                DebuggableSemaphoreSlim objSemaphore = _objKarmaChartSemaphore; // for thread safety
                if (objSemaphore?.IsDisposed == false)
                    await objSemaphore.WaitAsync(token).ConfigureAwait(false);
                try
                {
                    await lstKarma.DoThreadSafeAsync(x =>
                    {
                        x.Items.Clear();
                        x.ContextMenuStrip = null;
                    }, token).ConfigureAwait(false);
                    await chtKarma.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                    try
                    {
                        chtKarma.ExpenseValues.Clear();
                        decimal decKarmaValue = 0;
                        bool blnShowFreeKarma = await chkShowFreeKarma.DoThreadSafeFuncAsync(x => x.Checked, token)
                                                                      .ConfigureAwait(false);
                        //Find the last karma/nuyen entry as well in case a chart only contains one point
                        DateTime KarmaLast = DateTime.MinValue;
                        await (await CharacterObject.GetExpenseEntriesAsync(token).ConfigureAwait(false)).ForEachAsync(async objExpense =>
                        {
                            if (objExpense.Type != ExpenseType.Karma || (objExpense.Amount == 0 && !blnShowFreeKarma))
                                return;
                            ListViewItemWithValue.ListViewSubItemWithValue objAmountItem =
                                new ListViewItemWithValue.ListViewSubItemWithValue
                                {
                                    Value = objExpense.Amount,
                                    Text = objExpense.Amount.ToString("#,0.##", GlobalSettings.CultureInfo)
                                };
                            ListViewItemWithValue.ListViewSubItemWithValue objReasonItem =
                                new ListViewItemWithValue.ListViewSubItemWithValue
                                {
                                    Value = objExpense.Reason,
                                    Text = await objExpense.DisplayReasonAsync(GlobalSettings.Language, token)
                                                           .ConfigureAwait(false)
                                };
                            ListViewItemWithValue.ListViewSubItemWithValue objInternalIdItem =
                                new ListViewItemWithValue.ListViewSubItemWithValue
                                {
                                    Value = objExpense,
                                    Text = objExpense.InternalId
                                };

                            ListViewItemWithValue objItem = new ListViewItemWithValue(objExpense.Date,
                                    objExpense.Date.ToString(GlobalSettings.CustomDateTimeFormats
                                                                 ? GlobalSettings.CustomDateFormat
                                                                   + " " + GlobalSettings.CustomTimeFormat
                                                                 : GlobalSettings.CultureInfo.DateTimeFormat
                                                                                 .ShortDatePattern
                                                                   + " " + GlobalSettings.CultureInfo.DateTimeFormat
                                                                       .ShortTimePattern,
                                                             GlobalSettings.CultureInfo)
                            );
                            objItem.SubItems.Add(objAmountItem);
                            objItem.SubItems.Add(objReasonItem);
                            objItem.SubItems.Add(objInternalIdItem);

                            await lstKarma.DoThreadSafeAsync(x =>
                            {
                                x.Items.Add(objItem);
                                if (objExpense.Undo != null)
                                    x.ContextMenuStrip = cmsUndoKarmaExpense;
                            }, token).ConfigureAwait(false);
                            if (objExpense.Amount == 0)
                                return;
                            // ReSharper disable once AccessToModifiedClosure
                            if (objExpense.Date > KarmaLast)
                                KarmaLast = objExpense.Date;
                            decKarmaValue += objExpense.Amount;
                            chtKarma.ExpenseValues.Add(new DateTimePoint(objExpense.Date, decimal.ToDouble(decKarmaValue)));
                        }, GenericToken).ConfigureAwait(false);

                        if (KarmaLast == DateTime.MinValue)
                        {
                            string strFileName = await CharacterObject.GetFileNameAsync(token).ConfigureAwait(false);
                            KarmaLast = File.Exists(strFileName)
                                ? File.GetCreationTime(strFileName)
                                : new DateTime(DateTime.Now.Ticks - 1000, DateTimeKind.Local);
                        }
                        if (chtKarma.ExpenseValues.Count < 2)
                        {
                            if (chtKarma.ExpenseValues.Count < 1)
                                chtKarma.ExpenseValues.Add(new DateTimePoint(KarmaLast, decimal.ToDouble(decKarmaValue)));
                            chtKarma.ExpenseValues.Add(new DateTimePoint(DateTime.Now, decimal.ToDouble(decKarmaValue)));
                        }

                        await chtKarma.NormalizeYAxis(token).ConfigureAwait(false);
                    }
                    finally
                    {
                        await chtKarma.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    if (objSemaphore?.IsDisposed == false)
                        objSemaphore.Release();
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async void chkShowFreeNuyen_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                if (await CharacterObject.ExpenseEntries
                                         .AnyAsync(x => x.Type == ExpenseType.Nuyen && x.Amount == 0, GenericToken)
                                         .ConfigureAwait(false))
                {
                    await RepopulateNuyenExpenseList(GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RepopulateNuyenExpenseList(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                DebuggableSemaphoreSlim objSemaphore = _objNuyenChartSemaphore; // for thread safety
                if (objSemaphore?.IsDisposed == false)
                    await objSemaphore.WaitAsync(token).ConfigureAwait(false);
                try
                {
                    await lstNuyen.DoThreadSafeAsync(x =>
                    {
                        x.Items.Clear();
                        x.ContextMenuStrip = null;
                    }, token).ConfigureAwait(false);
                    await chtNuyen.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                    try
                    {
                        chtNuyen.ExpenseValues.Clear();
                        decimal decNuyenValue = 0;
                        bool blnShowFreeNuyen = await chkShowFreeNuyen.DoThreadSafeFuncAsync(x => x.Checked, token)
                                                                      .ConfigureAwait(false);
                        //Find the last karma/nuyen entry as well in case a chart only contains one point
                        DateTime NuyenLast = DateTime.MinValue;
                        await (await CharacterObject.GetExpenseEntriesAsync(token).ConfigureAwait(false)).ForEachAsync(async objExpense =>
                        {
                            if (objExpense.Type != ExpenseType.Nuyen || (objExpense.Amount == 0 && !blnShowFreeNuyen))
                                return;
                            ListViewItemWithValue.ListViewSubItemWithValue objAmountItem =
                                new ListViewItemWithValue.ListViewSubItemWithValue
                                {
                                    Value = objExpense.Amount,
                                    Text = objExpense.Amount.ToString("#,0.##", GlobalSettings.CultureInfo)
                                };
                            ListViewItemWithValue.ListViewSubItemWithValue objReasonItem =
                                new ListViewItemWithValue.ListViewSubItemWithValue
                                {
                                    Value = objExpense.Reason,
                                    Text = await objExpense.DisplayReasonAsync(GlobalSettings.Language, token)
                                                           .ConfigureAwait(false)
                                };
                            ListViewItemWithValue.ListViewSubItemWithValue objInternalIdItem =
                                new ListViewItemWithValue.ListViewSubItemWithValue
                                {
                                    Value = objExpense,
                                    Text = objExpense.InternalId
                                };

                            ListViewItemWithValue objItem = new ListViewItemWithValue(objExpense.Date,
                                    objExpense.Date.ToString(GlobalSettings.CustomDateTimeFormats
                                                                 ? GlobalSettings.CustomDateFormat
                                                                   + " " + GlobalSettings.CustomTimeFormat
                                                                 : GlobalSettings.CultureInfo.DateTimeFormat
                                                                                 .ShortDatePattern
                                                                   + " " + GlobalSettings.CultureInfo.DateTimeFormat
                                                                       .ShortTimePattern,
                                                             GlobalSettings.CultureInfo)
                            );
                            objItem.SubItems.Add(objAmountItem);
                            objItem.SubItems.Add(objReasonItem);
                            objItem.SubItems.Add(objInternalIdItem);

                            await lstNuyen.DoThreadSafeAsync(x =>
                            {
                                x.Items.Add(objItem);
                                if (objExpense.Undo != null)
                                    x.ContextMenuStrip = cmsUndoNuyenExpense;
                            }, token).ConfigureAwait(false);
                            if (objExpense.Amount == 0)
                                return;
                            // ReSharper disable once AccessToModifiedClosure
                            if (objExpense.Date > NuyenLast)
                                NuyenLast = objExpense.Date;
                            decNuyenValue += objExpense.Amount;
                            chtNuyen.ExpenseValues.Add(new DateTimePoint(objExpense.Date, decimal.ToDouble(decNuyenValue)));
                        }, GenericToken).ConfigureAwait(false);

                        if (NuyenLast == DateTime.MinValue)
                        {
                            string strFileName = await CharacterObject.GetFileNameAsync(token).ConfigureAwait(false);
                            NuyenLast = File.Exists(strFileName)
                                ? File.GetCreationTime(strFileName)
                                : new DateTime(DateTime.Now.Ticks - 1000, DateTimeKind.Local);
                        }
                        if (chtNuyen.ExpenseValues.Count < 2)
                        {
                            if (chtNuyen.ExpenseValues.Count < 1)
                                chtNuyen.ExpenseValues.Add(new DateTimePoint(NuyenLast, decimal.ToDouble(decNuyenValue)));
                            chtNuyen.ExpenseValues.Add(new DateTimePoint(DateTime.Now, decimal.ToDouble(decNuyenValue)));
                        }

                        await chtNuyen.NormalizeYAxis(token).ConfigureAwait(false);
                    }
                    finally
                    {
                        await chtNuyen.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    if (objSemaphore?.IsDisposed == false)
                        objSemaphore.Release();
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async void UpdateInitiationCostEvent(object sender, EventArgs e)
        {
            try
            {
                await UpdateInitiationCost(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        /// <summary>
        /// Update the karma cost tooltip for Initiation/Submersion.
        /// </summary>
        private async Task UpdateInitiationCost(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strInitTip;
            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterReadLockAsync(token)
                .ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker2 = await CharacterObjectSettings.LockObject.EnterReadLockAsync(token)
                .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    decimal decMultiplier = 1.0m;
                    int intAmount;
                    if (await CharacterObject.GetMAGEnabledAsync(token).ConfigureAwait(false))
                    {
                        if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaMAGInitiationGroupPercentAsync(token).ConfigureAwait(false);
                        if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaMAGInitiationOrdealPercentAsync(token).ConfigureAwait(false);
                        if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaMAGInitiationSchoolingPercentAsync(token).ConfigureAwait(false);
                        int intGrade = await CharacterObject.GetInitiateGradeAsync(token).ConfigureAwait(false);
                        intAmount = ((await CharacterObjectSettings.GetKarmaInitiationFlatAsync(token).ConfigureAwait(false)
                                      + (intGrade + 1) * await CharacterObjectSettings.GetKarmaInitiationAsync(token).ConfigureAwait(false))
                                     * decMultiplier).StandardRound();
                        token.ThrowIfCancellationRequested();
                        strInitTip = string.Format(GlobalSettings.CultureInfo,
                                                   await LanguageManager
                                                         .GetStringAsync("Tip_ImproveInitiateGrade", token: token)
                                                         .ConfigureAwait(false),
                                                   (intGrade + 1).ToString(GlobalSettings.CultureInfo),
                                                   intAmount.ToString(GlobalSettings.CultureInfo));
                    }
                    else
                    {
                        if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaRESInitiationGroupPercentAsync(token).ConfigureAwait(false);
                        if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaRESInitiationOrdealPercentAsync(token).ConfigureAwait(false);
                        if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaRESInitiationSchoolingPercentAsync(token).ConfigureAwait(false);
                        int intGrade = await CharacterObject.GetSubmersionGradeAsync(token).ConfigureAwait(false);
                        intAmount = ((await CharacterObjectSettings.GetKarmaInitiationFlatAsync(token).ConfigureAwait(false)
                                      + (intGrade + 1) * await CharacterObjectSettings.GetKarmaInitiationAsync(token).ConfigureAwait(false))
                                     * decMultiplier).StandardRound();
                        token.ThrowIfCancellationRequested();
                        strInitTip = string.Format(GlobalSettings.CultureInfo,
                                                   await LanguageManager
                                                         .GetStringAsync("Tip_ImproveSubmersionGrade", token: token)
                                                         .ConfigureAwait(false),
                                                   (intGrade + 1).ToString(GlobalSettings.CultureInfo),
                                                   intAmount.ToString(GlobalSettings.CultureInfo));
                    }
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            await cmdAddMetamagic.SetToolTipTextAsync(strInitTip, token).ConfigureAwait(false);
        }

        /// <summary>
        /// Set the ToolTips from the Language file.
        /// </summary>
        private async Task SetTooltips(CancellationToken token = default)
        {
            // Armor Tab.
            await chkArmorEquipped
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_ArmorEquipped", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            // ToolTipFactory.SetToolTip(cmdArmorIncrease, LanguageManager.GetString("Tip_ArmorDegradationAPlus"));
            // ToolTipFactory.SetToolTip(cmdArmorDecrease, LanguageManager.GetString("Tip_ArmorDegradationAMinus"));
            // Weapon Tab.
            await cmdWeaponBuyAmmo
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_BuyAmmo", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await cmdWeaponMoveToVehicle
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_TransferToVehicle", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            // Gear Tab.
            await cmdGearIncreaseQty
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_IncreaseGearQty", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await cmdGearReduceQty
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_DecreaseGearQty", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await cmdGearSplitQty
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_SplitGearQty", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await cmdGearMergeQty
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_MergeGearQty", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await cmdGearMoveToVehicle
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_TransferToVehicle", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await chkGearActiveCommlink
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_ActiveCommlink", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await chkCyberwareActiveCommlink
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_ActiveCommlink", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            // Vehicles Tab.
            await chkVehicleWeaponAccessoryInstalled
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_WeaponInstalled", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await cmdVehicleGearReduceQty
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_DecreaseGearQty", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await cmdVehicleMoveToInventory
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_TransferToInventory", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await chkVehicleActiveCommlink
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_ActiveCommlink", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            // Other Info Tab.
            await lblCMPhysicalLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherCMPhysical", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblCMStunLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherCMStun", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblINILabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherInitiative", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblMatrixINILabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherMatrixInitiative", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblAstralINILabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherAstralInitiative", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblArmorLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherArmor", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await lblESS
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherEssence", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblRemainingNuyenLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherNuyen", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await lblCareerKarmaLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherCareerKarma", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblMovementLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherMovement", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblSwimLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherSwim", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await lblFlyLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherFly", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await lblLiftCarryLimitsLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherLiftAndCarryLimits", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblComposureLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherComposure", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblSurpriseLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherSurprise", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblJudgeIntentionsLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherJudgeIntentions", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblLiftCarryLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherLiftAndCarry", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblMemoryLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherMemory", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            // Condition Monitor Tab.
            await lblCMPenaltyLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_CMPenalty", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await lblCMArmorLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherArmor", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await lblCMDamageResistancePoolLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_CMDamageResistance", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await cmdEdgeGained
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_CMRegainEdge", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await cmdEdgeSpent
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_CMSpendEdge", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            // Common Info Tab.
            await lblStreetCred
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_StreetCred", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await lblNotoriety
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_Notoriety", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            if (await CharacterObjectSettings.GetUseCalculatedPublicAwarenessAsync(token).ConfigureAwait(false))
                await lblPublicAware
                      .SetToolTipTextAsync(
                          await LanguageManager.GetStringAsync("Tip_PublicAwareness", token: token)
                                               .ConfigureAwait(false), token).ConfigureAwait(false);
            await cmdBurnStreetCred
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_BurnStreetCred", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
        }

        /// <summary>
        /// Refresh the information for the currently selected Spell
        /// </summary>
        private async Task RefreshSelectedSpell(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await gpbMagicianSpell.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    object objSelectedNodeTag = await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token)
                                                               .ConfigureAwait(false);
                    if (objSelectedNodeTag is Spell objSpell && await treSpells
                                                                      .DoThreadSafeFuncAsync(
                                                                          x => x.SelectedNode?.Level > 0, token)
                                                                      .ConfigureAwait(false))
                    {
                        await gpbMagicianSpell.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await cmdDeleteSpell.DoThreadSafeAsync(x => x.Enabled = objSpell.Grade == 0, token)
                                            .ConfigureAwait(false);
                        string strText = await objSpell.DisplayDescriptorsAsync(GlobalSettings.Language, token)
                                                       .ConfigureAwait(false);
                        if (string.IsNullOrEmpty(strText))
                            strText = await LanguageManager.GetStringAsync("String_None", token: token)
                                                           .ConfigureAwait(false);
                        await lblSpellDescriptors.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                        string strText2 = await objSpell.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                        .ConfigureAwait(false);
                        await lblSpellCategory.DoThreadSafeAsync(x => x.Text = strText2, token).ConfigureAwait(false);
                        string strText3 = await objSpell.DisplayTypeAsync(GlobalSettings.Language, token)
                                                        .ConfigureAwait(false);
                        await lblSpellType.DoThreadSafeAsync(x => x.Text = strText3, token).ConfigureAwait(false);
                        string strText4 = await objSpell.DisplayRangeAsync(GlobalSettings.Language, token)
                                                        .ConfigureAwait(false);
                        await lblSpellRange.DoThreadSafeAsync(x => x.Text = strText4, token).ConfigureAwait(false);
                        string strText5 = await objSpell.DisplayDamageAsync(GlobalSettings.Language, GlobalSettings.CultureInfo, token)
                                                        .ConfigureAwait(false);
                        await lblSpellDamage.DoThreadSafeAsync(x => x.Text = strText5, token).ConfigureAwait(false);
                        string strText6 = await objSpell.DisplayDurationAsync(GlobalSettings.Language, token)
                                                        .ConfigureAwait(false);
                        await lblSpellDuration.DoThreadSafeAsync(x => x.Text = strText6, token).ConfigureAwait(false);
                        string strText7 = await objSpell.DisplayDvAsync(GlobalSettings.Language, token)
                                                        .ConfigureAwait(false);
                        await lblSpellDV.DoThreadSafeAsync(x => x.Text = strText7, token).ConfigureAwait(false);
                        await lblSpellDV.SetToolTipTextAsync(await objSpell.GetDvTooltipAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                        await objSpell.SetSourceDetailAsync(lblSpellSource, token).ConfigureAwait(false);
                        // Determine the size of the Spellcasting Dice Pool.
                        int intPool = await objSpell.GetDicePoolAsync(token).ConfigureAwait(false);
                        await dpcSpellDicePool.SetDicePoolAsync(intPool, token).ConfigureAwait(false);
                        await dpcSpellDicePool.SetLabelToolTipAsync(await objSpell.GetDicePoolTooltipAsync(token).ConfigureAwait(false), token)
                                              .ConfigureAwait(false);
                    }
                    else
                    {
                        await gpbMagicianSpell.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await cmdDeleteSpell.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                                            .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await gpbMagicianSpell.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Recheck all mods to see if Sensor has changed.
        /// </summary>
        private async Task UpdateSensor(Vehicle objVehicle, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            foreach (Gear objGear in objVehicle.GearChildren)
            {
                if (objGear.Category != "Sensors" || objGear.Name != "Sensor Array" || !objGear.IncludedInParent)
                    continue;
                token.ThrowIfCancellationRequested();
                // Update the name of the item in the TreeView.
                string strName = await objGear.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                await treVehicles.DoThreadSafeAsync(x =>
                {
                    TreeNode objNode = x.FindNode(objGear.InternalId);
                    if (objNode != null)
                        objNode.Text = strName;
                }, token).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Copy the Improvements from a piece of Armor on one character to another.
        /// </summary>
        /// <param name="objSource">Source character.</param>
        /// <param name="objDestination">Destination character.</param>
        /// <param name="objArmor">Armor to copy.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        private static async Task CopyArmorImprovements(Character objSource, Character objDestination, Armor objArmor, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            await objSource.Improvements.ForEachAsync(async objImprovement =>
            {
                if (objImprovement.SourceName == objArmor.InternalId
                    || await objArmor.ArmorMods.AnyAsync(x => objImprovement.SourceName == x.InternalId, token).ConfigureAwait(false))
                    await objDestination.Improvements.AddAsync(objImprovement, token).ConfigureAwait(false);
            }, token: token).ConfigureAwait(false);

            // Look through any Armor Mods and add the Improvements as well.
            await objArmor.ArmorMods.ForEachWithSideEffectsAsync(x =>
                // Look through any children and add their Improvements as well.
                x.GearChildren.ForEachWithSideEffectsAsync(
                    y => CopyGearImprovements(objSource, objDestination, y, token), token: token), token).ConfigureAwait(false);

            // Look through any children and add their Improvements as well.
            await objArmor.Children.ForEachWithSideEffectsAsync(x =>
                CopyGearImprovements(objSource, objDestination, x, token), token: token).ConfigureAwait(false);
        }

        /// <summary>
        /// Copy the Improvements from a piece of Gear on one character to another.
        /// </summary>
        /// <param name="objSource">Source character.</param>
        /// <param name="objDestination">Destination character.</param>
        /// <param name="objGear">Gear to copy.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        private static async Task CopyGearImprovements(Character objSource, Character objDestination, Gear objGear, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            await objSource.Improvements.ForEachAsync(async objImprovement =>
            {
                if (objImprovement.SourceName == objGear.InternalId)
                    await objDestination.Improvements.AddAsync(objImprovement, token).ConfigureAwait(false);
            }, token: token).ConfigureAwait(false);

            // Look through any children and add their Improvements as well.
            await objGear.Children.ForEachWithSideEffectsAsync(x =>
                CopyGearImprovements(objSource, objDestination, x, token), token: token).ConfigureAwait(false);
        }

        /// <summary>
        /// Copy the Improvements from a piece of Cyberware on one character to another.
        /// </summary>
        /// <param name="objSource">Source character.</param>
        /// <param name="objDestination">Destination character.</param>
        /// <param name="objCyberware">Cyberware to copy.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        private static async Task CopyCyberwareImprovements(Character objSource, Character objDestination, Cyberware objCyberware, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            await objSource.Improvements.ForEachAsync(async objImprovement =>
            {
                if (objImprovement.SourceName == objCyberware.InternalId)
                    await objDestination.Improvements.AddAsync(objImprovement, token).ConfigureAwait(false);
            }, token: token).ConfigureAwait(false);

            // Look through any children and add their Improvements as well.
            await (await objCyberware.GetChildrenAsync(token).ConfigureAwait(false)).ForEachWithSideEffectsAsync(x =>
                CopyCyberwareImprovements(objSource, objDestination, x, token), token: token).ConfigureAwait(false);
            await (await objCyberware.GetGearChildrenAsync(token).ConfigureAwait(false)).ForEachWithSideEffectsAsync(x =>
                CopyGearImprovements(objSource, objDestination, x, token), token: token).ConfigureAwait(false);
        }

        /// <summary>
        /// Enable/Disable the Paste Menu and ToolStrip items as appropriate.
        /// </summary>
        private Task DoRefreshPasteStatus(object sender, PropertyChangedEventArgs e, CancellationToken token = default)
        {
            return RefreshPasteStatus(token);
        }

        /// <summary>
        /// Enable/Disable the Paste Menu and ToolStrip items as appropriate.
        /// </summary>
        private async Task RefreshPasteStatus(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            bool blnCopyEnabled = false;

            if (await tabCharacterTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token).ConfigureAwait(false)
                == tabStreetGear)
            {
                // Lifestyle Tab.
                if (await tabStreetGearTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token).ConfigureAwait(false)
                    == tabLifestyle)
                {
                    blnCopyEnabled = await treLifestyles
                                           .DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Lifestyle, token)
                                           .ConfigureAwait(false);
                }
                // Armor Tab.
                else if (await tabStreetGearTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token).ConfigureAwait(false)
                         == tabArmor)
                {
                    blnCopyEnabled
                        = await treArmor
                                .DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Armor || x.SelectedNode?.Tag is Gear,
                                                       token).ConfigureAwait(false);
                }

                // Weapons Tab.
                if (await tabStreetGearTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token).ConfigureAwait(false)
                    == tabWeapons)
                {
                    blnCopyEnabled = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Weapon ||
                                                                                x.SelectedNode?.Tag is Gear, token)
                                                     .ConfigureAwait(false);
                }
                // Gear Tab.
                else if (await tabStreetGearTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token).ConfigureAwait(false)
                         == tabGear)
                {
                    blnCopyEnabled = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Gear, token)
                                                     .ConfigureAwait(false);
                }
            }
            // Cyberware Tab.
            else if (await tabCharacterTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token).ConfigureAwait(false)
                     == tabCyberware)
            {
                blnCopyEnabled = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Cyberware ||
                                                                               x.SelectedNode?.Tag is Gear, token)
                                                   .ConfigureAwait(false);
            }
            // Vehicles Tab.
            else if (await tabCharacterTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token).ConfigureAwait(false)
                     == tabVehicles)
            {
                blnCopyEnabled = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Vehicle ||
                                                                              x.SelectedNode?.Tag is Gear ||
                                                                              x.SelectedNode?.Tag is Weapon, token)
                                                  .ConfigureAwait(false);
            }

            await mnuCreateMenu.DoThreadSafeAsync(() => mnuEditCopy.Enabled = blnCopyEnabled, token)
                               .ConfigureAwait(false);
            await tsMain.DoThreadSafeAsync(() => tsbCopy.Enabled = blnCopyEnabled, token).ConfigureAwait(false);
        }

        /// <summary>
        /// Refresh the information for the currently selected Complex Form.
        /// </summary>
        private async Task RefreshSelectedComplexForm(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    object objSelectedNodeTag = await treComplexForms
                                                      .DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token)
                                                      .ConfigureAwait(false);
                    if (objSelectedNodeTag is ComplexForm objComplexForm && await treComplexForms
                            .DoThreadSafeFuncAsync(x => x.SelectedNode?.Level > 0, token).ConfigureAwait(false))
                    {
                        await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                        await cmdDeleteComplexForm.DoThreadSafeAsync(x => x.Enabled = objComplexForm.Grade == 0, token)
                                                  .ConfigureAwait(false);
                        string strText = await objComplexForm.DisplayTargetAsync(GlobalSettings.Language, token)
                                                             .ConfigureAwait(false);
                        await lblTarget.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                        string strText2 = await objComplexForm.DisplayDurationAsync(GlobalSettings.Language, token)
                                                              .ConfigureAwait(false);
                        await lblDuration.DoThreadSafeAsync(x => x.Text = strText2, token).ConfigureAwait(false);
                        string strText3 = await objComplexForm.DisplayFvAsync(GlobalSettings.Language, token)
                                                              .ConfigureAwait(false);
                        await lblFV.DoThreadSafeAsync(x => x.Text = strText3, token).ConfigureAwait(false);
                        await lblFV.SetToolTipTextAsync(await objComplexForm.GetFvTooltipAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                        await objComplexForm.SetSourceDetailAsync(lblComplexFormSource, token).ConfigureAwait(false);
                        // Determine the size of the Threading Dice Pool.
                        int intPool = await objComplexForm.GetDicePoolAsync(token).ConfigureAwait(false);
                        await dpcComplexFormDicePool.SetDicePoolAsync(intPool, token).ConfigureAwait(false);
                        await dpcComplexFormDicePool.SetLabelToolTipAsync(await objComplexForm.GetDicePoolTooltipAsync(token).ConfigureAwait(false), token)
                                                    .ConfigureAwait(false);
                    }
                    else
                    {
                        await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                        await cmdDeleteComplexForm
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken)
                                                    .ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Create Cyberware from a Cyberware Suite.
        /// </summary>
        /// <param name="xmlSuiteNode">XmlNode for the cyberware suite to add.</param>
        /// <param name="xmlCyberwareNode">XmlNode for the Cyberware to add.</param>
        /// <param name="objGrade">CyberwareGrade to add the item as.</param>
        /// <param name="intRating">Rating of the Cyberware.</param>
        /// <param name="eSource">Source representing whether the suite is cyberware or bioware.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        private async Task<Cyberware> CreateSuiteCyberware(XmlNode xmlSuiteNode, XmlNode xmlCyberwareNode, Grade objGrade,
                                               int intRating, Improvement.ImprovementSource eSource,
                                               CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker =
                await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                string strForced =
                        xmlSuiteNode.SelectSingleNodeAndCacheExpressionAsNavigator("name/@select", token)?.Value ??
                        string.Empty;
                // Create the Cyberware object.
                List<Weapon> lstWeapons = new List<Weapon>(1);
                List<Vehicle> lstVehicles = new List<Vehicle>(1);
                Cyberware objCyberware = new Cyberware(CharacterObject);
                try
                {
                    await objCyberware.CreateAsync(xmlCyberwareNode, objGrade, eSource, intRating, lstWeapons, lstVehicles,
                        true, true,
                        strForced, token: token).ConfigureAwait(false);
                    objCyberware.Suite = true;

                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                    }

                    foreach (Vehicle objVehicle in lstVehicles)
                    {
                        await CharacterObject.Vehicles.AddAsync(objVehicle, token).ConfigureAwait(false);
                    }

                    string strType = eSource == Improvement.ImprovementSource.Cyberware ? "cyberware" : "bioware";
                    string strXPathPrefix = strType + "s/" + strType;
                    using (XmlNodeList xmlChildrenList = xmlSuiteNode.SelectNodes(strXPathPrefix))
                    {
                        if (xmlChildrenList?.Count > 0)
                        {
                            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync(strType + ".xml", token: token)
                                .ConfigureAwait(false);
                            foreach (XmlNode objXmlChild in xmlChildrenList)
                            {
                                string strChildName = objXmlChild["name"]?.InnerTextViaPool(token);
                                if (string.IsNullOrEmpty(strChildName))
                                    continue;
                                XmlNode objXmlChildCyberware
                                    = objXmlDocument.TryGetNodeByNameOrId("/chummer/" + strXPathPrefix, strChildName);
                                int.TryParse(objXmlChild["rating"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intChildRating);

                                await (await objCyberware.GetChildrenAsync(token).ConfigureAwait(false)).AddAsync(await CreateSuiteCyberware(objXmlChild,
                                    objXmlChildCyberware, objGrade,
                                    intChildRating, eSource, token).ConfigureAwait(false), token).ConfigureAwait(false);
                            }
                        }
                    }

                    return objCyberware;
                }
                catch
                {
                    if (lstWeapons.Count > 0)
                    {
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                        }
                    }

                    if (lstVehicles.Count > 0)
                    {
                        foreach (Vehicle objVehicle in lstVehicles)
                        {
                            await objVehicle.DeleteVehicleAsync(token: CancellationToken.None).ConfigureAwait(false);
                        }
                    }

                    await objCyberware.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                    throw;
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async Task AddCyberwareSuite(Improvement.ImprovementSource objSource,
                                                  CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                using (ThreadSafeForm<SelectCyberwareSuite> frmPickCyberwareSuite
                       = await ThreadSafeForm<SelectCyberwareSuite>
                           .GetAsync(() => new SelectCyberwareSuite(CharacterObject, objSource), token)
                           .ConfigureAwait(false))
                {
                    if (await frmPickCyberwareSuite.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    decimal decCost = frmPickCyberwareSuite.MyForm.TotalCost;
                    if (decCost > await CharacterObject.GetNuyenAsync(token).ConfigureAwait(false))
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: token)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen", token: token)
                                    .ConfigureAwait(false), MessageBoxButtons.OK, MessageBoxIcon.Information,
                                token: token)
                            .ConfigureAwait(false);
                        return;
                    }

                    string strType = objSource == Improvement.ImprovementSource.Cyberware ? "cyberware" : "bioware";
                    XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync(strType + ".xml", token: token)
                        .ConfigureAwait(false);

                    XmlNode xmlSuite = objXmlDocument.TryGetNodeByNameOrId("/chummer/suites/suite",
                        frmPickCyberwareSuite.MyForm.SelectedSuite);
                    if (xmlSuite == null)
                        return;

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(decCost * -1,
                        await LanguageManager
                            .GetStringAsync("String_ExpensePurchaseCyberwareSuite", token: token)
                            .ConfigureAwait(false)
                        + await LanguageManager.GetStringAsync("String_Space", token: token)
                            .ConfigureAwait(false) + xmlSuite["name"]?.InnerTextViaPool(token),
                        ExpenseType.Nuyen, DateTime.Now);
                    await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: token)
                        .ConfigureAwait(false);
                    await CharacterObject.ModifyNuyenAsync(-decCost, token).ConfigureAwait(false);

                    Grade objGrade
                        = await Grade
                            .ConvertToCyberwareGradeAsync(xmlSuite["grade"]?.InnerTextViaPool(token), objSource, CharacterObject,
                                token).ConfigureAwait(false);

                    // Run through each of the items in the Suite and add them to the character.
                    using (XmlNodeList xmlItemList = xmlSuite.SelectNodes(strType + "s/" + strType))
                    {
                        if (xmlItemList?.Count > 0)
                        {
                            foreach (XmlNode xmlItem in xmlItemList)
                            {
                                string strItemName = xmlItem["name"]?.InnerTextViaPool(token);
                                if (string.IsNullOrEmpty(strItemName))
                                    continue;
                                XmlNode objXmlCyberware = objXmlDocument.TryGetNodeByNameOrId(
                                    "/chummer/" + strType + "s/" + strType, strItemName);
                                int.TryParse(xmlItem["rating"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intRating);

                                Cyberware objCyberware
                                    = await CreateSuiteCyberware(xmlItem, objXmlCyberware, objGrade, intRating,
                                        objSource, token).ConfigureAwait(false);
                                await CharacterObject.Cyberware.AddAsync(objCyberware, token).ConfigureAwait(false);
                            }
                        }
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Adds a sustained spell
        /// </summary>
        private async Task AddSustainedSpell(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            TreeNode objNode = await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode, token).ConfigureAwait(false);
            // Could be merged with AddSustainedComplex form and create an more or less universal method to add ISustainables from tre viewers. Not worth the trouble and probably not better at the moment.
            if (objNode?.Level > 0 && objNode.Tag is Spell objSpell)
            {
                SustainedObject objSustained = new SustainedObject(CharacterObject, objSpell);
                await CharacterObject.SustainedCollection.AddAsync(objSustained, token).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Adds a sustained complex form
        /// </summary>
        private async Task AddSustainedComplexForm(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            TreeNode objNode = await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode, token).ConfigureAwait(false);
            if (objNode?.Level > 0 && objNode.Tag is ComplexForm objComplexForm)
            {
                SustainedObject objSustained = new SustainedObject(CharacterObject, objComplexForm);
                await CharacterObject.SustainedCollection.AddAsync(objSustained, token).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Add a sustained critter power
        /// </summary>
        private async Task AddSustainedCritterPower(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            TreeNode objNode = await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode, token).ConfigureAwait(false);
            if (objNode?.Level > 0 && objNode.Tag is CritterPower objCritterPower)
            {
                SustainedObject objSustained = new SustainedObject(CharacterObject, objCritterPower);
                await CharacterObject.SustainedCollection.AddAsync(objSustained, token).ConfigureAwait(false);
            }
        }

        #endregion Custom Methods

        private async void cmdIncreasePowerPoints_Click(object sender, EventArgs e)
        {
            try
            {
                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    // Make sure the character has enough Karma to improve the CharacterAttribute.
                    int intKarmaCost = await CharacterObjectSettings.GetKarmaMysticAdeptPowerPointAsync(GenericToken).ConfigureAwait(false);
                    if (intKarmaCost > await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false))
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                .ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                .ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                    }

                    if (await CharacterObject.GetMysticAdeptPowerPointsAsync(GenericToken).ConfigureAwait(false) + 1
                        > await (await CharacterObject.GetAttributeAsync("MAG", token: GenericToken)
                                .ConfigureAwait(false))
                            .GetTotalValueAsync(
                                GenericToken).ConfigureAwait(false))
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_NotEnoughMagic", token: GenericToken)
                                .ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughMagic", token: GenericToken)
                                .ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                    }

                    if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync(
                                        "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync(
                                    "String_PowerPoint", token: GenericToken).ConfigureAwait(false),
                                intKarmaCost.ToString(GlobalSettings.CultureInfo)), GenericToken)
                            .ConfigureAwait(false))
                        return;

                    // Create the Karma expense.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(intKarmaCost * -1,
                        await LanguageManager.GetStringAsync("String_PowerPoint", token: GenericToken)
                            .ConfigureAwait(false),
                        ExpenseType.Karma, DateTime.Now);
                    await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                        .ConfigureAwait(false);
                    await CharacterObject.ModifyKarmaAsync(-intKarmaCost, GenericToken).ConfigureAwait(false);

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.AddPowerPoint, string.Empty);
                    objExpense.Undo = objUndo;

                    await CharacterObject.ModifyMysticAdeptPowerPointsAsync(1, GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicAddMetamagic_Click(object sender, EventArgs e)
        {
            try
            {
                // Character can only have a number of Metamagics/Echoes equal to their Initiate Grade. Additional ones cost Karma.
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        InitiationGrade objGrade))
                    return;

                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    // Evaluate each object
                    bool blnPayWithKarma
                        = await CharacterObject.Metamagics.AnyAsync(
                              objMetamagic => objMetamagic.Grade == objGrade.Grade,
                              GenericToken).ConfigureAwait(false) ||
                          await CharacterObject.Spells
                              .AnyAsync(objSpell => objSpell.Grade == objGrade.Grade, GenericToken)
                              .ConfigureAwait(false);

                    // Additional Metamagics beyond the standard 1 per Grade cost additional Karma, so ask if the user wants to spend the additional Karma.
                    if (blnPayWithKarma && await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false)
                        < await CharacterObjectSettings.GetKarmaMetamagicAsync(GenericToken).ConfigureAwait(false))
                    {
                        // Make sure the Karma expense would not put them over the limit.
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                .ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                .ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                    }

                    if (await CharacterObject.GetMAGEnabledAsync(GenericToken).ConfigureAwait(false) && blnPayWithKarma)
                    {
                        if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(GlobalSettings.CultureInfo,
                                        await LanguageManager.GetStringAsync(
                                                "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                            .ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync(
                                                "String_Metamagic", token: GenericToken)
                                            .ConfigureAwait(false),
                                        (await CharacterObjectSettings.GetKarmaMetamagicAsync(GenericToken).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo)),
                                    GenericToken)
                                .ConfigureAwait(false))
                            return;
                    }
                    else if (blnPayWithKarma && !await CommonFunctions.ConfirmKarmaExpenseAsync(
                                     string.Format(GlobalSettings.CultureInfo,
                                         await LanguageManager
                                             .GetStringAsync(
                                                 "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                             .ConfigureAwait(false),
                                         await LanguageManager
                                             .GetStringAsync("String_Echo", token: GenericToken)
                                             .ConfigureAwait(false),
                                         (await CharacterObjectSettings.GetKarmaMetamagicAsync(GenericToken).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo)),
                                     GenericToken)
                                 .ConfigureAwait(false))
                        return;

                    using (ThreadSafeForm<SelectMetamagic> frmPickMetamagic
                           = await ThreadSafeForm<SelectMetamagic>.GetAsync(
                               () => new SelectMetamagic(CharacterObject, objGrade),
                               GenericToken).ConfigureAwait(false))
                    {
                        // Make sure a value was selected.
                        if (await frmPickMetamagic.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        Metamagic objNewMetamagic = new Metamagic(CharacterObject);

                        XmlNode objXmlMetamagic;
                        Improvement.ImprovementSource objSource;
                        if (await CharacterObject.GetRESEnabledAsync(GenericToken).ConfigureAwait(false))
                        {
                            objXmlMetamagic
                                = (await CharacterObject.LoadDataAsync("echoes.xml", token: GenericToken)
                                    .ConfigureAwait(false))
                                .TryGetNodeByNameOrId("/chummer/echoes/echo",
                                    frmPickMetamagic.MyForm.SelectedMetamagic);
                            objSource = Improvement.ImprovementSource.Echo;
                        }
                        else
                        {
                            objXmlMetamagic
                                = (await CharacterObject.LoadDataAsync("metamagic.xml", token: GenericToken)
                                    .ConfigureAwait(false))
                                .TryGetNodeByNameOrId("/chummer/metamagics/metamagic",
                                    frmPickMetamagic.MyForm.SelectedMetamagic);
                            objSource = Improvement.ImprovementSource.Metamagic;
                        }

                        await objNewMetamagic.CreateAsync(objXmlMetamagic, objSource, token: GenericToken)
                            .ConfigureAwait(false);
                        objNewMetamagic.Grade = objGrade.Grade;
                        if (objNewMetamagic.InternalId.IsEmptyGuid())
                            return;

                        await CharacterObject.Metamagics.AddAsync(objNewMetamagic, GenericToken).ConfigureAwait(false);

                        if (blnPayWithKarma)
                        {
                            string strType = await LanguageManager.GetStringAsync(
                                objNewMetamagic.SourceType == Improvement.ImprovementSource.Echo
                                    ? "String_Echo"
                                    : "String_Metamagic", token: GenericToken).ConfigureAwait(false);
                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(await CharacterObjectSettings.GetKarmaMetamagicAsync(GenericToken).ConfigureAwait(false) * -1,
                                strType + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                            .ConfigureAwait(false)
                                        + await objNewMetamagic.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), ExpenseType.Karma,
                                DateTime.Now);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                .ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateKarma(KarmaExpenseType.AddMetamagic, objNewMetamagic.InternalId);
                            objExpense.Undo = objUndo;

                            // Adjust the character's Karma total.
                            await CharacterObject
                                .ModifyKarmaAsync(-await CharacterObjectSettings.GetKarmaMetamagicAsync(GenericToken).ConfigureAwait(false), GenericToken)
                                .ConfigureAwait(false);
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicAddArt_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                        InitiationGrade objGrade))
                    return;

                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    int intGrade = objGrade.Grade;

                    /*
                    // Character can only have a number of Metamagics/Echoes equal to their Initiate Grade. Additional ones cost Karma.
                    bool blnPayWithKarma = false;
                    if (blnPayWithKarma && CharacterObject.Karma < CharacterObjectSettings.KarmaMetamagic)
                    {
                        // Make sure the Karma expense would not put them over the limit.
                        await Program.ShowScrollableMessageBoxAsync(this, LanguageManager.GetString("Message_NotEnoughKarma"), LanguageManager.GetString("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return;
                    }
                    */

                    using (ThreadSafeForm<SelectArt> frmPickArt
                           = await ThreadSafeForm<SelectArt>.GetAsync(
                                   () => new SelectArt(CharacterObject, SelectArt.Mode.Art),
                                   GenericToken)
                               .ConfigureAwait(false))
                    {
                        // Make sure a value was selected.
                        if (await frmPickArt.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        XmlNode objXmlArt
                            = (await CharacterObject.LoadDataAsync("metamagic.xml", token: GenericToken)
                                .ConfigureAwait(false)).TryGetNodeByNameOrId(
                                "/chummer/arts/art", frmPickArt.MyForm.SelectedItem);

                        Art objArt = new Art(CharacterObject);
                        await objArt.CreateAsync(objXmlArt, Improvement.ImprovementSource.Metamagic, GenericToken)
                            .ConfigureAwait(false);
                        objArt.Grade = intGrade;
                        if (objArt.InternalId.IsEmptyGuid())
                            return;

                        await CharacterObject.Arts.AddAsync(objArt, GenericToken).ConfigureAwait(false);

                        /*
                        if (blnPayWithKarma)
                        {
                            string strType = LanguageManager.GetString("String_Art");
                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(CharacterObjectSettings.KarmaMetamagic * -1, strType + LanguageManager.GetString("String_Space") + await objArt.GetCurrentDisplayNameShortAsync(GenericToken), ExpenseType.Karma, DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateKarma(KarmaExpenseType.AddMetamagic, objArt.InternalId);
                            objExpense.Undo = objUndo;

                            // Adjust the character's Karma total.
                            CharacterObject.Karma -= CharacterObjectSettings.KarmaMetamagic;
                        }
                        */
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicAddEnchantment_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        InitiationGrade objGrade))
                    return;

                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    int intGrade = objGrade.Grade;

                    // Character can only have a number of Metamagics/Echoes equal to their Initiate Grade. Additional ones cost Karma.
                    bool blnPayWithKarma = await CharacterObject.Metamagics
                                               .AnyAsync(x => x.Grade == intGrade, GenericToken).ConfigureAwait(false)
                                           || await CharacterObject.Spells
                                               .AnyAsync(x => x.Grade == intGrade, GenericToken).ConfigureAwait(false);

                    int intSpellKarmaCost = await CharacterObject.SpellKarmaCostAsync("Enchantments", GenericToken)
                        .ConfigureAwait(false);

                    if (blnPayWithKarma)
                    {
                        if (await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false) < intSpellKarmaCost)
                        {
                            // Make sure the Karma expense would not put them over the limit.
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            return;
                        }

                        if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(GlobalSettings.CultureInfo,
                                    await LanguageManager.GetStringAsync(
                                            "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync(
                                            "String_Enchantment", token: GenericToken)
                                        .ConfigureAwait(false),
                                    intSpellKarmaCost.ToString(GlobalSettings.CultureInfo)), token: GenericToken)
                                .ConfigureAwait(false))
                            return;
                    }

                    XmlNode objXmlArt;
                    using (ThreadSafeForm<SelectArt> frmPickArt
                           = await ThreadSafeForm<SelectArt>.GetAsync(
                                   () => new SelectArt(CharacterObject,
                                       SelectArt.Mode.Enchantment), GenericToken)
                               .ConfigureAwait(false))
                    {
                        // Make sure a value was selected.
                        if (await frmPickArt.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        objXmlArt = (await CharacterObject.LoadDataAsync("spells.xml", token: GenericToken)
                                .ConfigureAwait(false))
                            .TryGetNodeByNameOrId("/chummer/spells/spell", frmPickArt.MyForm.SelectedItem);
                    }

                    Spell objNewSpell = new Spell(CharacterObject);
                    try
                    {
                        await objNewSpell.CreateAsync(objXmlArt, string.Empty, false, false, false,
                            Improvement.ImprovementSource.Initiation, GenericToken).ConfigureAwait(false);
                        objNewSpell.Grade = intGrade;
                        if (objNewSpell.InternalId.IsEmptyGuid())
                        {
                            await objNewSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            return;
                        }

                        await CharacterObject.Spells.AddAsync(objNewSpell, GenericToken).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objNewSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }

                    if (blnPayWithKarma)
                    {
                        string strType = await LanguageManager.GetStringAsync("String_Enhancement", token: GenericToken)
                            .ConfigureAwait(false);
                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(-intSpellKarmaCost,
                            strType + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                        .ConfigureAwait(false)
                                    + await objNewSpell.GetCurrentDisplayNameShortAsync(GenericToken)
                                        .ConfigureAwait(false), ExpenseType.Karma,
                            DateTime.Now);
                        await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                            .ConfigureAwait(false);

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateKarma(KarmaExpenseType.AddSpell, objNewSpell.InternalId);
                        objExpense.Undo = objUndo;

                        // Adjust the character's Karma total.
                        await CharacterObject.ModifyKarmaAsync(-intSpellKarmaCost, GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicAddRitual_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        InitiationGrade objGrade))
                    return;

                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    int intGrade = objGrade.Grade;

                    // Character can only have a number of Metamagics/Echoes equal to their Initiate Grade. Additional ones cost Karma.
                    // Evaluate each object
                    bool blnPayWithKarma
                        = await CharacterObject.Metamagics.AnyAsync(objMetamagic => objMetamagic.Grade == intGrade,
                              GenericToken).ConfigureAwait(false)
                          || await CharacterObject.Spells.AnyAsync(objSpell => objSpell.Grade == intGrade, GenericToken)
                              .ConfigureAwait(false);

                    int intSpellKarmaCost = await CharacterObject.SpellKarmaCostAsync("Rituals", GenericToken)
                        .ConfigureAwait(false);
                    if (blnPayWithKarma)
                    {
                        if (await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false) < intSpellKarmaCost)
                        {
                            // Make sure the Karma expense would not put them over the limit.
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            return;
                        }

                        if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(GlobalSettings.CultureInfo,
                                    await LanguageManager.GetStringAsync(
                                            "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync(
                                        "String_Ritual", token: GenericToken).ConfigureAwait(false),
                                    intSpellKarmaCost.ToString(GlobalSettings.CultureInfo)), token: GenericToken)
                                .ConfigureAwait(false))
                            return;
                    }

                    XmlNode objXmlArt;
                    using (ThreadSafeForm<SelectArt> frmPickArt
                           = await ThreadSafeForm<SelectArt>.GetAsync(
                                   () => new SelectArt(CharacterObject, SelectArt.Mode.Ritual),
                                   GenericToken)
                               .ConfigureAwait(false))
                    {
                        // Make sure a value was selected.
                        if (await frmPickArt.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        objXmlArt = (await CharacterObject.LoadDataAsync("spells.xml", token: GenericToken)
                                .ConfigureAwait(false))
                            .TryGetNodeByNameOrId("/chummer/spells/spell", frmPickArt.MyForm.SelectedItem);
                    }

                    Spell objNewSpell = new Spell(CharacterObject);
                    try
                    {
                        await objNewSpell.CreateAsync(objXmlArt, string.Empty, false, false, false,
                            Improvement.ImprovementSource.Initiation, GenericToken).ConfigureAwait(false);
                        objNewSpell.Grade = intGrade;
                        if (objNewSpell.InternalId.IsEmptyGuid())
                        {
                            await objNewSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            return;
                        }

                        await CharacterObject.Spells.AddAsync(objNewSpell, GenericToken).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objNewSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }

                    if (blnPayWithKarma)
                    {
                        string strType = await LanguageManager.GetStringAsync("String_Ritual", token: GenericToken)
                            .ConfigureAwait(false);
                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(-intSpellKarmaCost,
                            strType + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                        .ConfigureAwait(false)
                                    + await objNewSpell.GetCurrentDisplayNameShortAsync(GenericToken)
                                        .ConfigureAwait(false), ExpenseType.Karma,
                            DateTime.Now);
                        await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                            .ConfigureAwait(false);

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateKarma(KarmaExpenseType.AddSpell, objNewSpell.InternalId);
                        objExpense.Undo = objUndo;

                        // Adjust the character's Karma total.
                        await CharacterObject.ModifyKarmaAsync(-intSpellKarmaCost, GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsInitiationNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                                 GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicAddEnhancement_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        InitiationGrade objGrade))
                    return;

                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    int intGrade = objGrade.Grade;

                    if (await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false)
                        < await CharacterObjectSettings.GetKarmaEnhancementAsync(GenericToken).ConfigureAwait(false))
                    {
                        // Make sure the Karma expense would not put them over the limit.
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                .ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                .ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                    }

                    if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(GlobalSettings.CultureInfo,
                                    await LanguageManager.GetStringAsync(
                                            "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync(
                                        "String_Enhancement", token: GenericToken).ConfigureAwait(false),
                                    (await CharacterObjectSettings.GetKarmaEnhancementAsync(GenericToken).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo)),
                                token: GenericToken)
                            .ConfigureAwait(false))
                        return;

                    XmlNode objXmlArt;
                    using (ThreadSafeForm<SelectArt> frmPickArt
                           = await ThreadSafeForm<SelectArt>.GetAsync(
                                   () => new SelectArt(CharacterObject,
                                       SelectArt.Mode.Enhancement), GenericToken)
                               .ConfigureAwait(false))
                    {
                        // Make sure a value was selected.
                        if (await frmPickArt.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        objXmlArt
                            = (await CharacterObject.LoadDataAsync("powers.xml", token: GenericToken)
                                .ConfigureAwait(false))
                            .TryGetNodeByNameOrId(
                                "/chummer/enhancements/enhancement", frmPickArt.MyForm.SelectedItem);
                    }

                    if (objXmlArt == null)
                        return;

                    Enhancement objEnhancement = new Enhancement(CharacterObject);
                    await objEnhancement
                        .CreateAsync(objXmlArt, Improvement.ImprovementSource.Initiation, token: GenericToken)
                        .ConfigureAwait(false);
                    objEnhancement.Grade = intGrade;
                    if (objEnhancement.InternalId.IsEmptyGuid())
                        return;

                    // Find the associated Power
                    string strPower = objXmlArt["power"]?.InnerTextViaPool(GenericToken);
                    Power objPower = await CharacterObject.Powers
                        .FirstOrDefaultAsync(
                            x => x.Name == strPower
                                 || string.Equals(
                                     x.SourceIDString, strPower,
                                     StringComparison.OrdinalIgnoreCase), GenericToken)
                        .ConfigureAwait(false);
                    if (objPower != null)
                    {
                        await objPower.Enhancements.AddAsync(objEnhancement, GenericToken).ConfigureAwait(false);
                    }
                    else
                    {
                        // Add it to the character instead
                        await CharacterObject.Enhancements.AddAsync(objEnhancement, GenericToken).ConfigureAwait(false);
                    }

                    string strType = await LanguageManager.GetStringAsync("String_Enhancement", token: GenericToken)
                        .ConfigureAwait(false);
                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(await CharacterObjectSettings.GetKarmaEnhancementAsync(GenericToken).ConfigureAwait(false) * -1,
                        strType + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                    .ConfigureAwait(false)
                                + await objEnhancement.GetCurrentDisplayNameShortAsync(GenericToken)
                                    .ConfigureAwait(false), ExpenseType.Karma,
                        DateTime.Now);
                    await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                        .ConfigureAwait(false);

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.AddSpell, objEnhancement.InternalId);
                    objExpense.Undo = objUndo;

                    // Adjust the character's Karma total.
                    await CharacterObject.ModifyKarmaAsync(-await CharacterObjectSettings.GetKarmaEnhancementAsync(GenericToken).ConfigureAwait(false), GenericToken)
                        .ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void panContacts_Click(object sender, EventArgs e)
        {
            panContacts.Focus();
        }

        private void panEnemies_Click(object sender, EventArgs e)
        {
            panEnemies.Focus();
        }

        private async void cboGearOverclocker_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing)
                return;
            try
            {
                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    if (!await CharacterObject.GetOverclockerAsync(GenericToken).ConfigureAwait(false))
                        return;
                    if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                .ConfigureAwait(false)
                            is Gear objCommlink))
                        return;
                    string strOldOverClocked =
                        await objCommlink.GetOverclockedAsync(GenericToken).ConfigureAwait(false);
                    objCommlink.Overclocked
                        = await cboGearOverclocker.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString(), GenericToken)
                            .ConfigureAwait(false);
                    await objCommlink.RefreshMatrixAttributeComboBoxesAsync(cboGearAttack, cboGearSleaze,
                        cboGearDataProcessing, cboGearFirewall,
                        GenericToken).ConfigureAwait(false);
                    if (await objCommlink.IsActiveCommlinkAsync(CharacterObject, GenericToken).ConfigureAwait(false) ||
                        await objCommlink.IsHomeNodeAsync(CharacterObject, GenericToken).ConfigureAwait(false))
                    {
                        if (strOldOverClocked == "Data Processing" ||
                            await objCommlink.GetOverclockedAsync(GenericToken).ConfigureAwait(false) ==
                            "Data Processing")
                        {
                            if (await objCommlink.IsActiveCommlinkAsync(CharacterObject, GenericToken)
                                    .ConfigureAwait(false))
                            {
                                if (await objCommlink.IsHomeNodeAsync(CharacterObject, GenericToken)
                                        .ConfigureAwait(false))
                                    await CharacterObject.OnMultiplePropertyChangedAsync(GenericToken,
                                        nameof(Character.MatrixInitiativeValue),
                                        nameof(Character.MatrixInitiativeColdValue),
                                        nameof(Character.MatrixInitiativeHotValue)).ConfigureAwait(false);
                                else
                                    await CharacterObject.OnMultiplePropertyChangedAsync(GenericToken,
                                        nameof(Character.MatrixInitiativeColdValue),
                                        nameof(Character.MatrixInitiativeHotValue)).ConfigureAwait(false);
                            }
                            else
                                await CharacterObject
                                    .OnPropertyChangedAsync(nameof(Character.MatrixInitiativeValue), GenericToken)
                                    .ConfigureAwait(false);
                        }

                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboArmorOverclocker_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing)
                return;
            try
            {
                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    if (!await CharacterObject.GetOverclockerAsync(GenericToken).ConfigureAwait(false))
                        return;
                    if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                .ConfigureAwait(false) is
                            IHasMatrixAttributes objCommlink))
                        return;
                    string strOldOverClocked =
                        await objCommlink.GetOverclockedAsync(GenericToken).ConfigureAwait(false);
                    objCommlink.Overclocked
                        = await cboArmorOverclocker.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString(), GenericToken)
                            .ConfigureAwait(false);
                    await objCommlink.RefreshMatrixAttributeComboBoxesAsync(cboArmorAttack, cboArmorSleaze,
                        cboArmorDataProcessing, cboArmorFirewall,
                        GenericToken).ConfigureAwait(false);
                    if (await objCommlink.IsActiveCommlinkAsync(CharacterObject, GenericToken).ConfigureAwait(false) ||
                        await objCommlink.IsHomeNodeAsync(CharacterObject, GenericToken).ConfigureAwait(false))
                    {
                        if (strOldOverClocked == "Data Processing" ||
                            await objCommlink.GetOverclockedAsync(GenericToken).ConfigureAwait(false) ==
                            "Data Processing")
                        {
                            if (await objCommlink.IsActiveCommlinkAsync(CharacterObject, GenericToken)
                                    .ConfigureAwait(false))
                            {
                                if (await objCommlink.IsHomeNodeAsync(CharacterObject, GenericToken)
                                        .ConfigureAwait(false))
                                    await CharacterObject.OnMultiplePropertyChangedAsync(GenericToken,
                                        nameof(Character.MatrixInitiativeValue),
                                        nameof(Character.MatrixInitiativeColdValue),
                                        nameof(Character.MatrixInitiativeHotValue)).ConfigureAwait(false);
                                else
                                    await CharacterObject.OnMultiplePropertyChangedAsync(GenericToken,
                                        nameof(Character.MatrixInitiativeColdValue),
                                        nameof(Character.MatrixInitiativeHotValue)).ConfigureAwait(false);
                            }
                            else
                                await CharacterObject
                                    .OnPropertyChangedAsync(nameof(Character.MatrixInitiativeValue), GenericToken)
                                    .ConfigureAwait(false);
                        }

                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboWeaponOverclocker_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing)
                return;
            try
            {
                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    if (!await CharacterObject.GetOverclockerAsync(GenericToken).ConfigureAwait(false))
                        return;
                    if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                .ConfigureAwait(false) is
                            IHasMatrixAttributes objCommlink))
                        return;
                    string strOldOverClocked =
                        await objCommlink.GetOverclockedAsync(GenericToken).ConfigureAwait(false);
                    objCommlink.Overclocked
                        = await cboWeaponOverclocker
                            .DoThreadSafeFuncAsync(x => x.SelectedValue.ToString(), GenericToken)
                            .ConfigureAwait(false);
                    await objCommlink.RefreshMatrixAttributeComboBoxesAsync(cboWeaponGearAttack, cboWeaponGearSleaze,
                            cboWeaponGearDataProcessing,
                            cboWeaponGearFirewall, GenericToken)
                        .ConfigureAwait(false);
                    if (await objCommlink.IsActiveCommlinkAsync(CharacterObject, GenericToken).ConfigureAwait(false) ||
                        await objCommlink.IsHomeNodeAsync(CharacterObject, GenericToken).ConfigureAwait(false))
                    {
                        if (strOldOverClocked == "Data Processing" ||
                            await objCommlink.GetOverclockedAsync(GenericToken).ConfigureAwait(false) ==
                            "Data Processing")
                        {
                            if (await objCommlink.IsActiveCommlinkAsync(CharacterObject, GenericToken)
                                    .ConfigureAwait(false))
                            {
                                if (await objCommlink.IsHomeNodeAsync(CharacterObject, GenericToken)
                                        .ConfigureAwait(false))
                                    await CharacterObject.OnMultiplePropertyChangedAsync(GenericToken,
                                        nameof(Character.MatrixInitiativeValue),
                                        nameof(Character.MatrixInitiativeColdValue),
                                        nameof(Character.MatrixInitiativeHotValue)).ConfigureAwait(false);
                                else
                                    await CharacterObject.OnMultiplePropertyChangedAsync(GenericToken,
                                        nameof(Character.MatrixInitiativeColdValue),
                                        nameof(Character.MatrixInitiativeHotValue)).ConfigureAwait(false);
                            }
                            else
                                await CharacterObject
                                    .OnPropertyChangedAsync(nameof(Character.MatrixInitiativeValue), GenericToken)
                                    .ConfigureAwait(false);
                        }

                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboCyberwareOverclocker_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing)
                return;
            try
            {
                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    if (!await CharacterObject.GetOverclockerAsync(GenericToken).ConfigureAwait(false))
                        return;
                    if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                .ConfigureAwait(false) is
                            IHasMatrixAttributes objCommlink))
                        return;
                    string strOldOverClocked =
                        await objCommlink.GetOverclockedAsync(GenericToken).ConfigureAwait(false);
                    objCommlink.Overclocked
                        = await cboCyberwareOverclocker.DoThreadSafeFuncAsync(
                            x => x.SelectedValue.ToString(), GenericToken).ConfigureAwait(false);
                    await objCommlink.RefreshMatrixAttributeComboBoxesAsync(cboCyberwareAttack, cboCyberwareSleaze,
                            cboCyberwareDataProcessing,
                            cboCyberwareFirewall, GenericToken)
                        .ConfigureAwait(false);
                    if (await objCommlink.IsActiveCommlinkAsync(CharacterObject, GenericToken).ConfigureAwait(false) ||
                        await objCommlink.IsHomeNodeAsync(CharacterObject, GenericToken).ConfigureAwait(false))
                    {
                        if (strOldOverClocked == "Data Processing" ||
                            await objCommlink.GetOverclockedAsync(GenericToken).ConfigureAwait(false) ==
                            "Data Processing")
                        {
                            if (await objCommlink.IsActiveCommlinkAsync(CharacterObject, GenericToken)
                                    .ConfigureAwait(false))
                            {
                                if (await objCommlink.IsHomeNodeAsync(CharacterObject, GenericToken)
                                        .ConfigureAwait(false))
                                    await CharacterObject.OnMultiplePropertyChangedAsync(GenericToken,
                                        nameof(Character.MatrixInitiativeValue),
                                        nameof(Character.MatrixInitiativeColdValue),
                                        nameof(Character.MatrixInitiativeHotValue)).ConfigureAwait(false);
                                else
                                    await CharacterObject.OnMultiplePropertyChangedAsync(GenericToken,
                                        nameof(Character.MatrixInitiativeColdValue),
                                        nameof(Character.MatrixInitiativeHotValue)).ConfigureAwait(false);
                            }
                            else
                                await CharacterObject
                                    .OnPropertyChangedAsync(nameof(Character.MatrixInitiativeValue), GenericToken)
                                    .ConfigureAwait(false);
                        }

                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddAIProgram_Click(object sender, EventArgs e)
        {
            try
            {
                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    int intNewAIProgramCost = await CharacterObject.GetAIProgramKarmaCostAsync(GenericToken).ConfigureAwait(false);
                    int intNewAIAdvancedProgramCost =
                        await CharacterObject.GetAIAdvancedProgramKarmaCostAsync(GenericToken).ConfigureAwait(false);
                    XmlDocument objXmlDocument = await CharacterObject
                        .LoadDataAsync("programs.xml", token: GenericToken)
                        .ConfigureAwait(false);
                    bool blnAddAgain;
                    do
                    {
                        // Make sure the character has enough Karma before letting them select a Spell.
                        int intKarma = await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false);
                        if (intKarma < Math.Min(intNewAIProgramCost, intNewAIAdvancedProgramCost))
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughKarma", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            break;
                        }

                        // Let the user select a Program.
                        using (ThreadSafeForm<SelectAIProgram> frmPickProgram
                               = await ThreadSafeForm<SelectAIProgram>.GetAsync(
                                   () => new SelectAIProgram(CharacterObject,
                                       intKarma >= intNewAIAdvancedProgramCost),
                                   GenericToken).ConfigureAwait(false))
                        {
                            // Make sure the dialogue window was not canceled.
                            if (await frmPickProgram.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;

                            blnAddAgain = frmPickProgram.MyForm.AddAgain;

                            XmlNode objXmlProgram = objXmlDocument.TryGetNodeByNameOrId(
                                "/chummer/programs/program", frmPickProgram.MyForm.SelectedProgram);
                            if (objXmlProgram == null)
                                continue;

                            // Check for SelectText.
                            string strExtra = string.Empty;
                            XPathNavigator xmlSelectText =
                                objXmlProgram.SelectSingleNodeAndCacheExpressionAsNavigator("bonus/selecttext",
                                    GenericToken);
                            if (xmlSelectText != null)
                            {
                                string strDescription = string.Format(GlobalSettings.CultureInfo,
                                    await LanguageManager.GetStringAsync(
                                            "String_Improvement_SelectText", token: GenericToken)
                                        .ConfigureAwait(false),
                                    objXmlProgram["translate"]?.InnerTextViaPool(GenericToken) ?? objXmlProgram["name"]?.InnerTextViaPool(GenericToken) ??
                                    await LanguageManager.GetStringAsync("String_Unknown", token: GenericToken)
                                        .ConfigureAwait(false));
                                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>
                                           .GetAsync(
                                               () => new SelectText
                                               {
                                                   Description = strDescription
                                               }, GenericToken).ConfigureAwait(false))
                                {
                                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                        == DialogResult.Cancel)
                                        continue;
                                    strExtra = frmPickText.MyForm.SelectedValue;
                                }
                            }

                            AIProgram objProgram = new AIProgram(CharacterObject);
                            await objProgram.CreateAsync(objXmlProgram, strExtra, token: GenericToken)
                                .ConfigureAwait(false);
                            if (objProgram.InternalId.IsEmptyGuid())
                                continue;

                            bool boolIsAdvancedProgram = objProgram.IsAdvancedProgram;
                            if (!await CommonFunctions.ConfirmKarmaExpenseAsync(string.Format(
                                        GlobalSettings.CultureInfo,
                                        await LanguageManager.GetStringAsync(
                                                "Message_ConfirmKarmaExpenseSpend", token: GenericToken)
                                            .ConfigureAwait(false),
                                        await objProgram
                                            .GetCurrentDisplayNameShortAsync(
                                                GenericToken)
                                            .ConfigureAwait(false),
                                        (boolIsAdvancedProgram ? intNewAIAdvancedProgramCost : intNewAIProgramCost)
                                        .ToString(GlobalSettings.CultureInfo)), GenericToken)
                                    .ConfigureAwait(false))
                                continue;

                            await CharacterObject.AIPrograms.AddAsync(objProgram, GenericToken).ConfigureAwait(false);

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(
                                (boolIsAdvancedProgram ? intNewAIAdvancedProgramCost : intNewAIProgramCost) * -1,
                                await LanguageManager.GetStringAsync("String_ExpenseLearnProgram", token: GenericToken)
                                    .ConfigureAwait(false)
                                + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                    .ConfigureAwait(false)
                                + await objProgram.GetCurrentDisplayNameShortAsync(GenericToken).ConfigureAwait(false),
                                ExpenseType.Karma, DateTime.Now);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                                .ConfigureAwait(false);
                            await CharacterObject
                                .ModifyKarmaAsync(
                                    boolIsAdvancedProgram ? -intNewAIAdvancedProgramCost : -intNewAIProgramCost,
                                    GenericToken).ConfigureAwait(false);

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateKarma(
                                boolIsAdvancedProgram
                                    ? KarmaExpenseType.AddAIAdvancedProgram
                                    : KarmaExpenseType.AddAIProgram, objProgram.InternalId);
                            objExpense.Undo = objUndo;
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteAIProgram_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treAIPrograms_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedAIProgram(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedAIProgram(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                // Locate the Program that is selected in the tree.
                if (await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                    AIProgram objProgram)
                {
                    string strText = await objProgram.DisplayRequiresProgramAsync(GlobalSettings.Language, token)
                                                     .ConfigureAwait(false);
                    await lblAIProgramsRequires.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                    await objProgram.SetSourceDetailAsync(lblAIProgramsSource, token).ConfigureAwait(false);
                }
                else
                {
                    await lblAIProgramsRequires.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                               .ConfigureAwait(false);
                    await SourceString.Blank.SetControlAsync(lblAIProgramsSource, this, token).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void tsAIProgramNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboPrimaryArm_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsLoading || IsRefreshing
                              || await CharacterObject.GetAmbidextrousAsync(GenericToken).ConfigureAwait(false))
                    return;
                await CharacterObject
                    .SetPrimaryArmAsync(
                        await cboPrimaryArm.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString(), GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void picMugshot_SizeChanged(object sender, EventArgs e)
        {
            try
            {
                await ProcessMugshot(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ProcessMugshot(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (await this.DoThreadSafeFuncAsync(x => x.IsNullOrDisposed(), token).ConfigureAwait(false))
                return;
            await picMugshot.DoThreadSafeAsync(x =>
            {
                if (x.Disposing || x.IsDisposed)
                    return;
                try
                {
                    x.SizeMode = x.Image != null && x.Height >= x.Image.Height
                                                 && x.Width >= x.Image.Width
                        ? PictureBoxSizeMode.CenterImage
                        : PictureBoxSizeMode.Zoom;
                }
                catch (ArgumentException) // No other way to catch when the Image is not null, but is disposed
                {
                    x.SizeMode = PictureBoxSizeMode.Zoom;
                }
            }, token).ConfigureAwait(false);
        }

        private async void cmdCyberwareChangeMount_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is Cyberware objModularCyberware))
                    return;
                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    string strSelectedParentID;
                    using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                               Utils.ListItemListPool, out List<ListItem> lstModularMounts))
                    {
                        List<ListItem> lstModularCyberlimbList = await CharacterObject
                            .ConstructModularCyberlimbListAsync(
                                objModularCyberware, true, GenericToken).ConfigureAwait(false);
                        try
                        {
                            lstModularMounts.AddRange(lstModularCyberlimbList);
                        }
                        finally
                        {
                            Utils.ListItemListPool.Return(ref lstModularCyberlimbList);
                        }
                        //Mounted cyberware should always be allowed to be dismounted.
                        //Unmounted cyberware requires that a valid mount be present.
                        if (!await objModularCyberware.GetIsModularCurrentlyEquippedAsync(GenericToken)
                                .ConfigureAwait(false)
                            && (lstModularMounts.Count == 0 || lstModularMounts.TrueForAll(
                                x => !string.Equals(x.Value.ToString(), "None", StringComparison.OrdinalIgnoreCase))))
                        {
                            await Program.ShowScrollableMessageBoxAsync(this,
                                await LanguageManager.GetStringAsync("Message_NoValidModularMount", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NoValidModularMount",
                                        token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            return;
                        }

                        string strDescription = await LanguageManager
                            .GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken)
                            .ConfigureAwait(false);
                        using (ThreadSafeForm<SelectItem> frmPickMount = await ThreadSafeForm<SelectItem>.GetAsync(
                                   () => new SelectItem(), GenericToken).ConfigureAwait(false))
                        {
                            await frmPickMount.MyForm.DoThreadSafeAsync(x => x.Description = strDescription, GenericToken).ConfigureAwait(false);
                            frmPickMount.MyForm.SetGeneralItemsMode(lstModularMounts);

                            // Make sure the dialogue window was not canceled.
                            if (await frmPickMount.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                            {
                                return;
                            }

                            strSelectedParentID = await frmPickMount.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, GenericToken).ConfigureAwait(false);
                        }
                    }

                    Cyberware objOldParent = await objModularCyberware.GetParentAsync(GenericToken).ConfigureAwait(false);
                    if (objOldParent != null)
                        await objModularCyberware.ChangeModularEquipAsync(false, token: GenericToken)
                            .ConfigureAwait(false);
                    if (strSelectedParentID == "None")
                    {
                        if (objOldParent != null)
                        {
                            await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                .ConfigureAwait(false);

                            await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                                .ConfigureAwait(false);
                        }
                    }
                    else
                    {
                        Cyberware objNewParent = await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false))
                            .DeepFindByIdAsync(strSelectedParentID, GenericToken).ConfigureAwait(false);
                        if (objNewParent != null)
                        {
                            if (objOldParent != null)
                                await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                    .ConfigureAwait(false);
                            else
                                await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                    .ConfigureAwait(false);

                            await (await objNewParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                                .ConfigureAwait(false);

                            await objModularCyberware.ChangeModularEquipAsync(true, token: GenericToken)
                                .ConfigureAwait(false);
                        }
                        else
                        {
                            ThreadSafeObservableCollection<Vehicle> lstVehicles
                                = await CharacterObject.GetVehiclesAsync(GenericToken).ConfigureAwait(false);
                            VehicleMod objNewVehicleModParent
                                = (await lstVehicles
                                    .FindVehicleModAsync(x => x.InternalId == strSelectedParentID, GenericToken)
                                    .ConfigureAwait(false)).Item1;
                            if (objNewVehicleModParent == null)
                                (objNewParent, objNewVehicleModParent)
                                    = await lstVehicles.FindVehicleCyberwareAsync(
                                        x => x.InternalId == strSelectedParentID, GenericToken).ConfigureAwait(false);
                            if (objNewVehicleModParent != null || objNewParent != null)
                            {
                                if (objOldParent != null)
                                    await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);
                                else
                                    await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);

                                if (objNewParent != null)
                                    await (await objNewParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);
                                else
                                    await objNewVehicleModParent.Cyberware.AddAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);
                            }
                            else if (objOldParent != null)
                            {
                                await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                    .ConfigureAwait(false);

                                await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdVehicleCyberwareChangeMount_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is Cyberware objModularCyberware))
                    return;
                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    string strSelectedParentID;
                    using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                               Utils.ListItemListPool, out List<ListItem> lstModularMounts))
                    {
                        List<ListItem> lstModularCyberlimbList = await CharacterObject
                            .ConstructModularCyberlimbListAsync(
                                objModularCyberware, true, GenericToken).ConfigureAwait(false);
                        try
                        {
                            lstModularMounts.AddRange(lstModularCyberlimbList);
                        }
                        finally
                        {
                            Utils.ListItemListPool.Return(ref lstModularCyberlimbList);
                        }
                        //Mounted cyberware should always be allowed to be dismounted.
                        //Unmounted cyberware requires that a valid mount be present.
                        if (!await objModularCyberware.GetIsModularCurrentlyEquippedAsync(GenericToken)
                                .ConfigureAwait(false)
                            && (lstModularMounts.Count == 0 || lstModularMounts.TrueForAll(
                                x => !string.Equals(x.Value.ToString(), "None", StringComparison.OrdinalIgnoreCase))))
                        {
                            await Program.ShowScrollableMessageBoxAsync(this,
                                await LanguageManager.GetStringAsync("Message_NoValidModularMount", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NoValidModularMount",
                                        token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            return;
                        }

                        string strDescription = await LanguageManager
                            .GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken)
                            .ConfigureAwait(false);
                        using (ThreadSafeForm<SelectItem> frmPickMount = await ThreadSafeForm<SelectItem>.GetAsync(
                                   () => new SelectItem(), GenericToken).ConfigureAwait(false))
                        {
                            await frmPickMount.MyForm.DoThreadSafeAsync(x => x.Description = strDescription, GenericToken).ConfigureAwait(false);
                            frmPickMount.MyForm.SetGeneralItemsMode(lstModularMounts);

                            // Make sure the dialogue window was not canceled.
                            if (await frmPickMount.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                            {
                                return;
                            }

                            strSelectedParentID = await frmPickMount.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, GenericToken).ConfigureAwait(false);
                        }
                    }

                    VehicleMod objOldParentVehicleMod = (await CharacterObject.Vehicles
                        .FindVehicleCyberwareAsync(x => x.InternalId == objModularCyberware.InternalId, GenericToken)
                        .ConfigureAwait(false)).Item2;

                    Cyberware objOldParent = await objModularCyberware.GetParentAsync(GenericToken).ConfigureAwait(false);
                    if (objOldParent != null)
                        await objModularCyberware.ChangeModularEquipAsync(false, token: GenericToken)
                            .ConfigureAwait(false);
                    if (strSelectedParentID == "None")
                    {
                        if (objOldParent != null)
                            await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                .ConfigureAwait(false);
                        else
                            await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware, GenericToken)
                                .ConfigureAwait(false);

                        await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                            .ConfigureAwait(false);
                    }
                    else
                    {
                        Cyberware objNewParent = await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false))
                            .DeepFindByIdAsync(strSelectedParentID, GenericToken).ConfigureAwait(false);
                        if (objNewParent != null)
                        {
                            if (objOldParent != null)
                                await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                    .ConfigureAwait(false);
                            else
                                await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware, GenericToken)
                                    .ConfigureAwait(false);

                            await (await objNewParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                                .ConfigureAwait(false);

                            await objModularCyberware.ChangeModularEquipAsync(true, token: GenericToken)
                                .ConfigureAwait(false);
                        }
                        else
                        {
                            ThreadSafeObservableCollection<Vehicle> lstVehicles
                                = await CharacterObject.GetVehiclesAsync(GenericToken).ConfigureAwait(false);
                            VehicleMod objNewVehicleModParent
                                = (await lstVehicles
                                    .FindVehicleModAsync(x => x.InternalId == strSelectedParentID, GenericToken)
                                    .ConfigureAwait(false)).Item1;
                            if (objNewVehicleModParent == null)
                                (objNewParent, objNewVehicleModParent)
                                    = await lstVehicles.FindVehicleCyberwareAsync(
                                        x => x.InternalId == strSelectedParentID, GenericToken).ConfigureAwait(false);
                            if (objNewVehicleModParent != null || objNewParent != null)
                            {
                                if (objOldParent != null)
                                    await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);
                                else
                                    await objOldParentVehicleMod.Cyberware
                                        .RemoveAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);

                                if (objNewParent != null)
                                    await (await objNewParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);
                                else
                                    await objNewVehicleModParent.Cyberware.AddAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);
                            }
                            else
                            {
                                if (objOldParent != null)
                                    await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);
                                else
                                    await objOldParentVehicleMod.Cyberware
                                        .RemoveAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);

                                await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboAttributeCategory_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    await CharacterObject.AttributeSection.SetAttributeCategoryAsync(
                        AttributeSection.ConvertAttributeCategory(
                            await cboAttributeCategory
                                .DoThreadSafeFuncAsync(x => x.SelectedValue.ToString(), GenericToken)
                                .ConfigureAwait(false)), GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdContactsExpansionToggle_Click(object sender, EventArgs e)
        {
            try
            {
                Control.ControlCollection lstControls
                    = await panContacts.DoThreadSafeFuncAsync(x => x.Controls, GenericToken).ConfigureAwait(false);
                if (lstControls.Count == 0)
                    return;
                await panContacts.DoThreadSafeAsync(x => x.SuspendLayout(), GenericToken).ConfigureAwait(false);
                try
                {
                    bool toggle = await ((ContactControl) lstControls[0]).GetExpandedAsync(GenericToken)
                                                                         .ConfigureAwait(false);

                    foreach (ContactControl c in lstControls)
                    {
                        await c.SetExpandedAsync(!toggle, GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await panContacts.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void cmdSwapContactOrder_Click(object sender, EventArgs e)
        {
            panContacts.FlowDirection = panContacts.FlowDirection == FlowDirection.LeftToRight
                ? FlowDirection.TopDown
                : FlowDirection.LeftToRight;
        }

        private async void tsGearLocationAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is Location
                        objLocation))
                    return;
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickGear(null, objLocation, token: GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleLocationAddVehicle_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddVehicle(
                        await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                         .ConfigureAwait(false) as Location,
                        GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponLocationAddWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickWeapon(
                        await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) as Location,
                        GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void tsVehicleLocationAddWeapon_Click(object sender, EventArgs e)
        {
            //TODO: Where should weapons attached to locations of vehicles go?
            //PickWeapon(treVehicles.SelectedNode);
        }

        private async void cboVehicleWeaponFiringMode_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Weapon
                        objWeapon))
                    return;
                objWeapon.FireMode = await cboVehicleWeaponFiringMode.DoThreadSafeFuncAsync(x => x.SelectedIndex >= 0
                    ? (FiringMode) x.SelectedValue
                    : FiringMode.DogBrain, GenericToken).ConfigureAwait(false);
                await RefreshSelectedVehicle(GenericToken).ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void OpenSourceFromLabel(object sender, EventArgs e)
        {
            await CommonFunctions.OpenPdfFromControl(sender, GenericToken).ConfigureAwait(false);
        }

        private async void btnCreateCustomDrug_Click(object sender, EventArgs e)
        {
            try
            {
                using (ThreadSafeForm<CreateCustomDrug> form
                       = await ThreadSafeForm<CreateCustomDrug>.GetAsync(
                           () => new CreateCustomDrug(CharacterObject), GenericToken).ConfigureAwait(false))
                {
                    if (await form.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    Drug objCustomDrug = form.MyForm.CustomDrug;
                    if (objCustomDrug != null)
                    {
                        try
                        {
                            await CharacterObject.Drugs.AddAsync(objCustomDrug, GenericToken).ConfigureAwait(false);
                        }
                        catch
                        {
                            await objCustomDrug.DisposeAsync().ConfigureAwait(false);
                            throw;
                        }
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void btnIncreaseDrugQty_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode
                    = await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                          .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Drug selectedDrug))
                    return;

                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    decimal decCost = selectedDrug.Cost;
                    /* Apply a markup if applicable.
                    if (frmPickArmor.Markup != 0)
                    {
                        decCost *= 1 + (frmPickArmor.Markup / 100.0m);
                    }*/

                    // Multiply the cost if applicable.
                    char chrAvail = (await selectedDrug.TotalAvailTupleAsync(token: GenericToken).ConfigureAwait(false))
                        .Suffix;
                    switch (chrAvail)
                    {
                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                            break;

                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                            break;
                    }

                    // Check the item's Cost and make sure the character can afford it.
                    if (decCost > await CharacterObject.GetNuyenAsync(GenericToken).ConfigureAwait(false))
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_NotEnoughNuyen", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken)
                            .ConfigureAwait(false);
                    }

                    if (!await CharacterObject.Improvements.AnyAsync(imp =>
                                imp.ImproveSource == Improvement.ImprovementSource
                                    .Drug && imp.SourceName
                                == selectedDrug.InternalId, GenericToken)
                            .ConfigureAwait(false))
                    {
                        await selectedDrug.GenerateImprovement(GenericToken).ConfigureAwait(false);
                    }

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(decCost * -1,
                        await LanguageManager.GetStringAsync("String_ExpensePurchaseDrug", token: GenericToken)
                            .ConfigureAwait(false) +
                        await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                            .ConfigureAwait(false) +
                        await selectedDrug.GetCurrentDisplayNameShortAsync(GenericToken)
                            .ConfigureAwait(false), ExpenseType.Nuyen, DateTime.Now);
                    await CharacterObject.ExpenseEntries.AddWithSortAsync(objExpense, token: GenericToken)
                        .ConfigureAwait(false);
                    await CharacterObject.ModifyNuyenAsync(-decCost, GenericToken).ConfigureAwait(false);
                    selectedDrug.Quantity++;
                    string strText = await selectedDrug.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                    await treCustomDrugs.DoThreadSafeAsync(() => objSelectedNode.Text = strText,
                        GenericToken).ConfigureAwait(false);
                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateNuyen(NuyenExpenseType.AddGear, selectedDrug.InternalId);
                    objExpense.Undo = objUndo;

                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void btnDecreaseDrugQty_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode
                    = await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                          .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Drug objDrug))
                    return;

                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    string strDescription = await LanguageManager
                        .GetStringAsync("String_ReduceGear", token: GenericToken).ConfigureAwait(false);
                    using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                               () => new SelectNumber
                               {
                                   Minimum = 0,
                                   Maximum = objDrug.Quantity,
                                   Description = strDescription
                               }, GenericToken).ConfigureAwait(false))
                    {
                        if (await frmPickNumber.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        decimal decSelectedValue = frmPickNumber.MyForm.SelectedValue;

                        if (!await CommonFunctions.ConfirmDeleteAsync(string.Format(GlobalSettings.CultureInfo,
                                    await LanguageManager.GetStringAsync(
                                        "Message_ReduceQty", token: GenericToken).ConfigureAwait(false),
                                    decSelectedValue.ToString(
                                        GlobalSettings.CultureInfo)), token: GenericToken)
                                .ConfigureAwait(false))
                            return;

                        objDrug.Quantity -= decSelectedValue;
                        string strText = await objDrug.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                        await treCustomDrugs.DoThreadSafeAsync(() => objSelectedNode.Text = strText,
                            GenericToken).ConfigureAwait(false);
                    }

                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #region Wireless Toggles

        private void chkGearWireless_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            if (treGear.SelectedNode?.Tag is IHasWirelessBonus obj)
            {
                obj.WirelessOn = chkGearWireless.Checked;
            }
        }

        private void chkCyberwareWireless_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            if (treCyberware.SelectedNode?.Tag is IHasWirelessBonus obj)
            {
                obj.WirelessOn = chkCyberwareWireless.Checked;
            }
        }

        private void chkWeaponWireless_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            if (treWeapons.SelectedNode?.Tag is IHasWirelessBonus obj)
            {
                obj.WirelessOn = chkWeaponWireless.Checked;
            }
        }

        private void chkArmorWireless_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            if (treArmor.SelectedNode?.Tag is IHasWirelessBonus obj)
            {
                obj.WirelessOn = chkArmorWireless.Checked;
            }
        }

        #endregion Wireless Toggles

        private void pnlAttributes_Layout(object sender, LayoutEventArgs e)
        {
            pnlAttributes.SuspendLayout();
            foreach (Control objAttributeControl in pnlAttributes.Controls)
            {
                if (pnlAttributes.ClientSize.Width < objAttributeControl.MinimumSize.Height)
                    objAttributeControl.MinimumSize
                        = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MinimumSize.Height);
                if (pnlAttributes.ClientSize.Width != objAttributeControl.MaximumSize.Height)
                    objAttributeControl.MaximumSize
                        = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MaximumSize.Height);
                if (pnlAttributes.ClientSize.Width > objAttributeControl.MinimumSize.Height)
                    objAttributeControl.MinimumSize
                        = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MinimumSize.Height);
            }

            pnlAttributes.ResumeLayout();
        }

        private async void tsCyberwareUpgrade_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                             .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Cyberware objCyberware))
                {
                    Utils.BreakIfDebug();
                    return;
                }

                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await objCyberware.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    if (objCyberware.Capacity == "[*]" && await objCyberware.GetParentAsync(GenericToken).ConfigureAwait(false) != null)
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager
                                    .GetStringAsync("Message_CannotRemoveCyberware", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager
                                    .GetStringAsync("MessageTitle_CannotRemoveCyberware", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken)
                            .ConfigureAwait(false);
                        return;
                    }

                    using (ThreadSafeForm<SellItem> frmSell
                           = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem(), GenericToken)
                               .ConfigureAwait(false))
                    {
                        if (await frmSell.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        string strName = await objCyberware.GetCurrentDisplayNameShortAsync(GenericToken)
                            .ConfigureAwait(false);
                        Improvement.ImprovementSource eSourceType = await objCyberware.GetSourceTypeAsync(GenericToken).ConfigureAwait(false);
                        using (ThreadSafeForm<SelectCyberware> frmCyberware
                               = await ThreadSafeForm<SelectCyberware>.GetAsync(
                                   () => new SelectCyberware(CharacterObject, eSourceType)
                                   {
                                       DefaultSearchText = strName,
                                       Upgrading = true
                                   }, GenericToken).ConfigureAwait(false))
                        {
                            if (await frmCyberware.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                return;

                            await objCyberware.Upgrade(frmCyberware.MyForm.SelectedGrade,
                                    frmCyberware.MyForm.SelectedRating,
                                    frmSell.MyForm.SellPercent, frmCyberware.MyForm.FreeCost, GenericToken)
                                .ConfigureAwait(false);
                        }
                    }

                    //TODO: Bind displayname to selectednode text properly.
                    string strNewName
                        = await objCyberware.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                    await treCyberware.DoThreadSafeAsync(x =>
                    {
                        if (objSelectedNode.Tag != objCyberware)
                        {
                            x.FindNodeByTag(objCyberware).Text = strNewName;
                        }
                        else
                        {
                            objSelectedNode.Text = strNewName;
                        }
                    }, GenericToken).ConfigureAwait(false);

                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        // Data binding doesn't work for some reason, so handle visibility toggles through events

        private void chkShowKarmaChart_CheckedChanged(object sender, EventArgs e)
        {
            chtKarma.Visible = chkShowKarmaChart.Checked;
        }

        private void chkShowNuyenChart_CheckedChanged(object sender, EventArgs e)
        {
            chtNuyen.Visible = chkShowNuyenChart.Checked;
        }

        private async void mnuSpecialChangeOptions_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    using (ThreadSafeForm<SelectBuildMethod> frmPickBP
                           = await ThreadSafeForm<SelectBuildMethod>.GetAsync(
                               () => new SelectBuildMethod(CharacterObject, true), GenericToken).ConfigureAwait(false))
                    {
                        await frmPickBP.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }
    }
}
