/*  This file is part of Chummer5a.
 *
 *  Chummer5a is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Chummer5a is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Chummer5a.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  You can obtain the full source code for Chummer5a at
 *  https://github.com/chummer5a/chummer5a
 */

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Xml;
using System.Xml.XPath;
using Chummer.Backend.Attributes;
using Chummer.Backend.Equipment;
using Chummer.Backend.Skills;
using Chummer.Backend.Uniques;
using LiveCharts.Defaults;
using NLog;

namespace Chummer
{
    [DesignerCategory("Form")]
    public partial class CharacterCareer : CharacterShared
    {
        private static Logger Log { get; } = LogManager.GetCurrentClassLogger();

        private bool _blnReapplyImprovements;
        private int _intDragLevel;

        private readonly ListViewColumnSorter _lvwKarmaColumnSorter;
        private readonly ListViewColumnSorter _lvwNuyenColumnSorter;

        public TabControl TabCharacterTabs => tabCharacterTabs;

        #region Form Events

        [Obsolete("This constructor is for use by form designers only.", true)]
        public CharacterCareer()
        {
            InitializeComponent();
        }

        public CharacterCareer(Character objCharacter) : base(objCharacter)
        {
            InitializeComponent();

            // Add EventHandlers for the MAG and RES enabled events and tab enabled events.
            CharacterObject.PropertyChanged += OnCharacterPropertyChanged;
            CharacterObject.SettingsPropertyChanged += OnCharacterSettingsPropertyChanged;
            CharacterObject.AttributeSection.PropertyChanged += MakeDirtyWithCharacterUpdate;
            
            tabSkillsUc.MakeDirtyWithCharacterUpdate += MakeDirtyWithCharacterUpdate;
            lmtControl.MakeDirtyWithCharacterUpdate += MakeDirtyWithCharacterUpdate;
            lmtControl.MakeDirty += MakeDirty;

            this.UpdateLightDarkMode();
            this.TranslateWinForm();

            ContextMenuStrip[] lstCMSToTranslate = {
                cmsAdvancedLifestyle,
                cmsAdvancedProgram,
                cmsAmmoExpense,
                cmsArmor,
                cmsArmorGear,
                cmsArmorLocation,
                cmsArmorMod,
                cmsBioware,
                cmsComplexForm,
                cmsCritterPowers,
                cmsCyberware,
                cmsCyberwareGear,
                cmsVehicleCyberware,
                cmsVehicleCyberwareGear,
                cmsDeleteArmor,
                cmsDeleteCyberware,
                cmsDeleteGear,
                cmsDeleteVehicle,
                cmsDeleteWeapon,
                cmsGear,
                cmsGearButton,
                cmsGearLocation,
                cmsGearPlugin,
                cmsImprovement,
                cmsImprovementLocation,
                cmsInitiationNotes,
                cmsLifestyle,
                cmsLifestyleNotes,
                cmsMartialArts,
                cmsMetamagic,
                cmsQuality,
                cmsSpell,
                cmsSpellButton,
                cmsTechnique,
                cmsUndoKarmaExpense,
                cmsUndoNuyenExpense,
                cmsVehicle,
                cmsVehicleGear,
                cmsVehicleLocation,
                cmsVehicleWeapon,
                cmsVehicleWeaponAccessory,
                cmsVehicleWeaponAccessoryGear,
                cmsVehicleWeaponMod,
                cmsWeapon,
                cmsWeaponAccessory,
                cmsWeaponAccessoryGear,
                cmsWeaponLocation,
                cmsWeaponMount
            };
            // Update the text in the Menus so they can be merged with frmMain properly.
            foreach (ToolStripMenuItem tssItem in mnuCreateMenu.Items.OfType<ToolStripMenuItem>())
            {
                tssItem.UpdateLightDarkMode();
                tssItem.TranslateToolStripItemsRecursively();
            }
            foreach (ContextMenuStrip objCMS in lstCMSToTranslate)
            {
                if (objCMS == null)
                    continue;
                foreach (ToolStripMenuItem tssItem in objCMS.Items.OfType<ToolStripMenuItem>())
                {
                    tssItem.UpdateLightDarkMode();
                    tssItem.TranslateToolStripItemsRecursively();
                }
            }

            _lvwKarmaColumnSorter = new ListViewColumnSorter
            {
                SortColumn = 0,
                Order = SortOrder.Descending
            };
            lstKarma.ListViewItemSorter = _lvwKarmaColumnSorter;
            _lvwNuyenColumnSorter = new ListViewColumnSorter
            {
                SortColumn = 0,
                Order = SortOrder.Descending
            };
            lstNuyen.ListViewItemSorter = _lvwNuyenColumnSorter;
        }

        private void TreeView_MouseDown(object sender, MouseEventArgs e)
        {
            // Generic event for all TreeViews to allow right-clicking to select a TreeNode so the proper ContextMenu is shown.
            //if (e.Button == System.Windows.Forms.MouseButtons.Right)
            //{
            TreeView objTree = (TreeView)sender;
            objTree.SelectedNode = objTree.HitTest(e.X, e.Y).Node;
            //}
            if (ModifierKeys == Keys.Control)
            {
                if (objTree.SelectedNode?.IsExpanded == false)
                {
                    foreach (TreeNode objNode in objTree.SelectedNode.Nodes)
                    {
                        objNode.ExpandAll();
                    }
                }
                else if (objTree.SelectedNode?.Nodes != null)
                {
                    foreach (TreeNode objNode in objTree.SelectedNode.Nodes)
                    {
                        objNode.Collapse();
                    }
                }
            }
        }

        private async void CharacterCareer_Load(object sender, EventArgs e)
        {
            try
            {
                using (await CursorWait.NewAsync(this, token: GenericToken))
                {
                    using (CustomActivity op_load_frm_career = await Timekeeper.StartSyncronAsync(
                               "load_frm_career", null, CustomActivity.OperationType.RequestOperation,
                               CharacterObject?.FileName))
                    {
                        try
                        {
                            try
                            {
                                if (CharacterObject == null)
                                {
                                    // Stupid hack to get the MDI icon to show up properly.
                                    await this.DoThreadSafeFuncAsync(x => x.Icon = x.Icon.Clone() as Icon, GenericToken);
                                    return;
                                }

                                using (_ = await Timekeeper.StartSyncronAsync("load_frm_career_databinding",
                                                                              op_load_frm_career))
                                {
                                    // Set the visibility of the Bioware Suites menu options.
                                    await mnuCreateMenu.DoThreadSafeAsync(
                                        () => mnuSpecialAddBiowareSuite.Visible
                                            = CharacterObjectSettings.AllowBiowareSuites, GenericToken);

                                    txtGroupName.DoDataBinding("Text", CharacterObject, nameof(Character.GroupName));
                                    txtGroupNotes.DoDataBinding("Text", CharacterObject, nameof(Character.GroupNotes));

                                    txtCharacterName.DoDataBinding("Text", CharacterObject, nameof(Character.Name));
                                    txtGender.DoDataBinding("Text", CharacterObject, nameof(Character.Gender));
                                    txtAge.DoDataBinding("Text", CharacterObject, nameof(Character.Age));
                                    txtEyes.DoDataBinding("Text", CharacterObject, nameof(Character.Eyes));
                                    txtHeight.DoDataBinding("Text", CharacterObject, nameof(Character.Height));
                                    txtWeight.DoDataBinding("Text", CharacterObject, nameof(Character.Weight));
                                    txtSkin.DoDataBinding("Text", CharacterObject, nameof(Character.Skin));
                                    txtHair.DoDataBinding("Text", CharacterObject, nameof(Character.Hair));
                                    rtfDescription.DoDataBinding("Rtf", CharacterObject, nameof(Character.Description));
                                    rtfBackground.DoDataBinding("Rtf", CharacterObject, nameof(Character.Background));
                                    rtfConcept.DoDataBinding("Rtf", CharacterObject, nameof(Character.Concept));
                                    rtfNotes.DoDataBinding("Rtf", CharacterObject, nameof(Character.Notes));
                                    rtfGameNotes.DoDataBinding("Rtf", CharacterObject, nameof(Character.GameNotes));
                                    txtAlias.DoDataBinding("Text", CharacterObject, nameof(Character.Alias));
                                    txtPlayerName.DoDataBinding("Text", CharacterObject, nameof(Character.PlayerName));

                                    await chkJoinGroup.DoThreadSafeAsync(x => x.Checked = CharacterObject.GroupMember, GenericToken);
                                    chkInitiationGroup.DoOneWayDataBinding("Enabled", CharacterObject,
                                                                           nameof(Character.GroupMember));

                                    // If the character has a mugshot, decode it and put it in the PictureBox.
                                    if (CharacterObject.Mugshots.Count > 0)
                                    {
                                        await nudMugshotIndex.DoThreadSafeAsync(x =>
                                        {
                                            x.Minimum = 1;
                                            x.Maximum = CharacterObject.Mugshots.Count;
                                            x.Value = Math.Max(CharacterObject.MainMugshotIndex, 0) + 1;
                                        }, GenericToken);
                                    }
                                    else
                                    {
                                        await nudMugshotIndex.DoThreadSafeAsync(x =>
                                        {
                                            x.Minimum = 0;
                                            x.Maximum = 0;
                                            x.Value = 0;
                                        }, GenericToken);
                                    }

                                    string strNumMugshots = await LanguageManager.GetStringAsync("String_Of") +
                                                            CharacterObject.Mugshots.Count.ToString(
                                                                GlobalSettings.CultureInfo);
                                    await lblNumMugshots.DoThreadSafeAsync(x => x.Text = strNumMugshots, GenericToken);

                                    nudStreetCred.DoDataBinding("Value", CharacterObject, nameof(Character.StreetCred));
                                    nudNotoriety.DoDataBinding("Value", CharacterObject, nameof(Character.Notoriety));
                                    nudPublicAware.DoDataBinding("Value", CharacterObject,
                                                                 nameof(Character.PublicAwareness));
                                    nudAstralReputation.DoDataBinding("Value", CharacterObject,
                                                                      nameof(Character.AstralReputation));
                                    nudWildReputation.DoDataBinding("Value", CharacterObject,
                                                                    nameof(Character.WildReputation));
                                    cmdAddMetamagic.DoOneWayDataBinding("Enabled", CharacterObject,
                                                                        nameof(Character.AddInitiationsAllowed));
                                    lblPossessed.DoOneWayDataBinding("Visible", CharacterObject,
                                                                     nameof(Character.Possessed));
                                    lblMetatype.DoOneWayDataBinding("Text", CharacterObject,
                                                                    nameof(Character.FormattedMetatype));

                                    chkPsycheActiveMagician.DoDataBinding("Checked", CharacterObject,
                                                                          nameof(CharacterObject.PsycheActive));
                                    chkPsycheActiveTechnomancer.DoDataBinding("Checked", CharacterObject,
                                                                              nameof(CharacterObject.PsycheActive));
                                }

                                if (!CharacterObjectSettings.BookEnabled("RF"))
                                {
                                    await cmdAddLifestyle.DoThreadSafeAsync(x => x.SplitMenuStrip = null, GenericToken);
                                }

                                if (!CharacterObjectSettings.BookEnabled("FA"))
                                {
                                    await lblWildReputation.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                    await nudWildReputation.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                    await lblWildReputationTotal.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                    if (!CharacterObjectSettings.BookEnabled("SG"))
                                    {
                                        await lblAstralReputation.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                        await nudAstralReputation.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                        await lblAstralReputationTotal.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                    }
                                }

                                if (!CharacterObjectSettings.EnableEnemyTracking)
                                {
                                    await tabPeople.DoThreadSafeAsync(x => x.TabPages.Remove(tabEnemies), GenericToken);
                                }

                                await splitKarmaNuyen.DoThreadSafeAsync(
                                    x => x.SplitterDistance
                                        = Math.Max(x.SplitterDistance, (x.Width - x.SplitterWidth + 1) / 2),
                                    GenericToken);
                                await splitMagician.DoThreadSafeAsync(x => x.SplitterDistance
                                                                          = Math.Max(x.SplitterDistance,
                                                                              ((x.Height - x.SplitterWidth) * 2 + 2)
                                                                              / 3), GenericToken);
                                await splitTechnomancer.DoThreadSafeAsync(
                                    x => x.SplitterDistance
                                        = Math.Max(x.SplitterDistance, ((x.Height - x.SplitterWidth) * 2 + 2) / 3),
                                    GenericToken);

                                using (_ = await Timekeeper.StartSyncronAsync(
                                           "load_frm_career_refresh", op_load_frm_career))
                                {
                                    await RefreshQualities(treQualities, cmsQuality);
                                    await RefreshSpirits(panSpirits, panSprites);
                                    await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes);
                                    await RefreshSustainedSpells(flpSustainedSpells, flpSustainedComplexForms,
                                                           flpSustainedCritterPowers, chkPsycheActiveMagician,
                                                           chkPsycheActiveTechnomancer);
                                    await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm,
                                                        cmsInitiationNotes);
                                    await RefreshPowerCollectionListChanged(treMetamagic, cmsMetamagic, cmsInitiationNotes);
                                    await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes);
                                    await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram);
                                    await RefreshCritterPowers(treCritterPowers, cmsCritterPowers);
                                    await CharacterObject.CritterPowers
                                                         .AnyAsync(x => x.Name == "Inhabitation"
                                                                        || x.Name == "Possession", GenericToken)
                                                         .ContinueWith(
                                                             y => mnuCreateMenu.DoThreadSafeAsync(
                                                                 () => mnuSpecialPossess.Visible = y.Result,
                                                                 GenericToken), GenericToken).Unwrap();
                                    await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique);
                                    await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle);
                                    await RefreshCustomImprovements(treImprovements, lmtControl.LimitTreeView,
                                                              cmsImprovementLocation,
                                                              cmsImprovement, lmtControl.LimitContextMenuStrip);
                                    await RefreshCalendar(lstCalendar);
                                    await RefreshContacts(panContacts, panEnemies, panPets);

                                    await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod, cmsArmorGear);
                                    await RefreshGears(treGear, cmsGearLocation, cmsGear,
                                        await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, GenericToken),
                                        await chkHideLoadedAmmo.DoThreadSafeFuncAsync(x => x.Checked, GenericToken));
                                    await RefreshFociFromGear(treFoci, null);
                                    await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear);
                                    await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon, cmsWeaponAccessory,
                                                   cmsWeaponAccessoryGear);
                                    await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle, cmsVehicleWeapon,
                                                    cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear,
                                                    cmsVehicleGear,
                                                    cmsWeaponMount,
                                                    cmsVehicleCyberware, cmsVehicleCyberwareGear);
                                    await RefreshDrugs(treCustomDrugs);

                                    await DoExpenseEntriesCollectionChanged(null);
                                }

                                using (_ = await Timekeeper.StartSyncronAsync("load_frm_career_sortAndCallbacks",
                                                                              op_load_frm_career))
                                {
                                    await treWeapons.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treArmor.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treGear.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treLifestyles.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treCustomDrugs.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treCyberware.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treVehicles.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treCritterPowers.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treImprovements.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);

                                    // Set up events that would change various lists
                                    CharacterObject.Spells.CollectionChanged += SpellCollectionChanged;
                                    CharacterObject.ComplexForms.CollectionChanged += ComplexFormCollectionChanged;
                                    CharacterObject.Arts.CollectionChanged += ArtCollectionChanged;
                                    CharacterObject.Enhancements.CollectionChanged += EnhancementCollectionChanged;
                                    CharacterObject.Metamagics.CollectionChanged += MetamagicCollectionChanged;
                                    CharacterObject.InitiationGrades.CollectionChanged
                                        += InitiationGradeCollectionChanged;
                                    CharacterObject.Powers.ListChanged += PowersListChanged;
                                    CharacterObject.Powers.BeforeRemove += PowersBeforeRemove;
                                    CharacterObject.AIPrograms.CollectionChanged += AIProgramCollectionChanged;
                                    CharacterObject.CritterPowers.CollectionChanged += CritterPowerCollectionChanged;
                                    CharacterObject.Qualities.CollectionChanged += QualityCollectionChanged;
                                    CharacterObject.MartialArts.CollectionChanged += MartialArtCollectionChanged;
                                    CharacterObject.Lifestyles.CollectionChanged += LifestylesCollectionChanged;
                                    CharacterObject.Contacts.CollectionChanged += ContactCollectionChanged;
                                    CharacterObject.Armor.CollectionChanged += ArmorCollectionChanged;
                                    CharacterObject.ArmorLocations.CollectionChanged += ArmorLocationCollectionChanged;
                                    CharacterObject.Weapons.CollectionChanged += WeaponCollectionChanged;
                                    CharacterObject.WeaponLocations.CollectionChanged
                                        += WeaponLocationCollectionChanged;
                                    CharacterObject.Gear.CollectionChanged += GearCollectionChanged;
                                    CharacterObject.GearLocations.CollectionChanged += GearLocationCollectionChanged;
                                    CharacterObject.Cyberware.CollectionChanged += CyberwareCollectionChanged;
                                    CharacterObject.Vehicles.CollectionChanged += VehicleCollectionChanged;
                                    CharacterObject.VehicleLocations.CollectionChanged
                                        += VehicleLocationCollectionChanged;
                                    CharacterObject.Spirits.CollectionChanged += SpiritCollectionChanged;
                                    CharacterObject.Improvements.CollectionChanged += ImprovementCollectionChanged;
                                    CharacterObject.ImprovementGroups.CollectionChanged
                                        += ImprovementGroupCollectionChanged;
                                    CharacterObject.Calendar.ListChanged += CalendarWeekListChanged;
                                    CharacterObject.Drugs.CollectionChanged += DrugCollectionChanged;
                                    CharacterObject.SustainedCollection.CollectionChanged
                                        += SustainedSpellCollectionChanged;
                                    CharacterObject.ExpenseEntries.CollectionChanged += ExpenseEntriesCollectionChanged;

                                    SetupCommonCollectionDatabindings(true);
                                }

                                using (_ = await Timekeeper.StartSyncronAsync("load_frm_career_magictradition",
                                                                              op_load_frm_career))
                                {
                                    // Populate the Magician Traditions list.
                                    XPathNavigator xmlTraditionsBaseChummerNode =
                                        await (await CharacterObject.LoadDataXPathAsync("traditions.xml", token: GenericToken))
                                            .SelectSingleNodeAndCacheExpressionAsync("/chummer");
                                    using (new FetchSafelyFromPool<List<ListItem>>(
                                               Utils.ListItemListPool, out List<ListItem> lstTraditions))
                                    {
                                        if (xmlTraditionsBaseChummerNode != null)
                                        {
                                            foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                         "traditions/tradition[" + CharacterObjectSettings.BookXPath()
                                                         + ']'))
                                            {
                                                string strName
                                                    = (await xmlTradition.SelectSingleNodeAndCacheExpressionAsync(
                                                        "name"))
                                                    ?.Value;
                                                if (!string.IsNullOrEmpty(strName))
                                                    lstTraditions.Add(new ListItem(
                                                                          (await xmlTradition
                                                                              .SelectSingleNodeAndCacheExpressionAsync(
                                                                                  "id"))
                                                                          ?.Value ?? strName,
                                                                          (await xmlTradition
                                                                              .SelectSingleNodeAndCacheExpressionAsync(
                                                                                  "translate"))
                                                                          ?.Value ?? strName));
                                            }
                                        }

                                        if (lstTraditions.Count > 1)
                                        {
                                            lstTraditions.Sort(CompareListItems.CompareNames);
                                            lstTraditions.Insert(0,
                                                                 new ListItem(
                                                                     "None",
                                                                     await LanguageManager
                                                                         .GetStringAsync("String_None")));
                                            await cboTradition.PopulateWithListItemsAsync(lstTraditions, GenericToken);
                                        }
                                        else
                                        {
                                            await this.DoThreadSafeAsync(() =>
                                            {
                                                cboTradition.Visible = false;
                                                lblTraditionLabel.Visible = false;
                                            }, GenericToken);
                                        }
                                    }

                                    // Populate the Magician Custom Drain Options list.
                                    using (new FetchSafelyFromPool<List<ListItem>>(
                                               Utils.ListItemListPool, out List<ListItem> lstDrainAttributes))
                                    {
                                        if (xmlTraditionsBaseChummerNode != null)
                                        {
                                            foreach (XPathNavigator xmlDrain in await xmlTraditionsBaseChummerNode
                                                         .SelectAndCacheExpressionAsync(
                                                             "drainattributes/drainattribute"))
                                            {
                                                string strName
                                                    = (await xmlDrain.SelectSingleNodeAndCacheExpressionAsync("name"))
                                                    ?.Value;
                                                if (!string.IsNullOrEmpty(strName)
                                                    && lstDrainAttributes.All(x => x.Value.ToString() != strName))
                                                {
                                                    string strTranslatedName = (await xmlDrain
                                                        .SelectSingleNodeAndCacheExpressionAsync(
                                                            "translate"))?.Value ?? strName;
                                                    lstDrainAttributes.Add(new ListItem(strName, strTranslatedName));
                                                }
                                            }
                                        }

                                        lstDrainAttributes.Sort(CompareListItems.CompareNames);
                                        lstDrainAttributes.Insert(0, ListItem.Blank);
                                        await cboDrain.PopulateWithListItemsAsync(lstDrainAttributes, GenericToken);
                                        cboDrain.DoDataBinding("SelectedValue", CharacterObject.MagicTradition,
                                                               nameof(Tradition.DrainExpression));
                                    }

                                    lblDrainAttributes.DoOneWayDataBinding("Text", CharacterObject.MagicTradition,
                                                                           nameof(Tradition.DisplayDrainExpression));
                                    dpcDrainAttributes.DoOneWayDataBinding("DicePool", CharacterObject.MagicTradition,
                                                                           nameof(Tradition.DrainValue));
                                    dpcDrainAttributes.DoOneWayDataBinding(
                                        "ToolTipText", CharacterObject.MagicTradition,
                                        nameof(Tradition.DrainValueToolTip));
                                    await CharacterObject.MagicTradition.SetSourceDetailAsync(lblTraditionSource, GenericToken);

                                    lblFadingAttributes.DoOneWayDataBinding("Text", CharacterObject.MagicTradition,
                                                                            nameof(Tradition.DisplayDrainExpression));
                                    dpcFadingAttributes.DoOneWayDataBinding("DicePool", CharacterObject.MagicTradition,
                                                                            nameof(Tradition.DrainValue));
                                    dpcFadingAttributes.DoOneWayDataBinding(
                                        "ToolTipText", CharacterObject.MagicTradition,
                                        nameof(Tradition.DrainValueToolTip));

                                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                               out HashSet<string> limit))
                                    {
                                        foreach (Improvement improvement in await ImprovementManager
                                                     .GetCachedImprovementListForValueOfAsync(
                                                         CharacterObject,
                                                         Improvement.ImprovementType.LimitSpiritCategory))
                                        {
                                            limit.Add(improvement.ImprovedName);
                                        }

                                        // Populate the Magician Custom Spirits lists - Combat.
                                        using (new FetchSafelyFromPool<List<ListItem>>(
                                                   Utils.ListItemListPool, out List<ListItem> lstSpirit))
                                        {
                                            lstSpirit.Add(ListItem.Blank);
                                            if (xmlTraditionsBaseChummerNode != null)
                                            {
                                                foreach (XPathNavigator xmlSpirit in await xmlTraditionsBaseChummerNode
                                                             .SelectAndCacheExpressionAsync("spirits/spirit"))
                                                {
                                                    string strSpiritName
                                                        = (await xmlSpirit.SelectSingleNodeAndCacheExpressionAsync(
                                                            "name"))
                                                        ?.Value;
                                                    if (!string.IsNullOrEmpty(strSpiritName)
                                                        && (limit.Count == 0 || limit.Contains(strSpiritName)))
                                                    {
                                                        lstSpirit.Add(new ListItem(strSpiritName,
                                                                          (await xmlSpirit
                                                                              .SelectSingleNodeAndCacheExpressionAsync(
                                                                                  "translate"))?.Value
                                                                          ?? strSpiritName));
                                                    }
                                                }
                                            }

                                            lstSpirit.Sort(CompareListItems.CompareNames);

                                            await cboSpiritCombat.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                            cboSpiritCombat.DoDataBinding(
                                                "SelectedValue", CharacterObject.MagicTradition,
                                                nameof(Tradition.SpiritCombat));
                                            await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible
                                                = CharacterObject.MagicTradition.Type == TraditionType.MAG, GenericToken);
                                            await cboSpiritCombat.DoThreadSafeAsync(x =>
                                            {
                                                x.Visible
                                                    = CharacterObject.MagicTradition.Type == TraditionType.MAG;
                                                x.Enabled = CharacterObject.MagicTradition.IsCustomTradition;
                                            }, GenericToken);

                                            await cboSpiritDetection.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                            cboSpiritDetection.DoDataBinding(
                                                "SelectedValue", CharacterObject.MagicTradition,
                                                nameof(Tradition.SpiritDetection));
                                            await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible
                                                = CharacterObject.MagicTradition.Type == TraditionType.MAG, GenericToken);
                                            await cboSpiritDetection.DoThreadSafeAsync(x =>
                                            {
                                                x.Visible
                                                    = CharacterObject.MagicTradition.Type == TraditionType.MAG;
                                                x.Enabled
                                                    = CharacterObject.MagicTradition.IsCustomTradition;
                                            }, GenericToken);

                                            await cboSpiritHealth.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                            cboSpiritHealth.DoDataBinding(
                                                "SelectedValue", CharacterObject.MagicTradition,
                                                nameof(Tradition.SpiritHealth));
                                            await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible
                                                = CharacterObject.MagicTradition.Type == TraditionType.MAG, GenericToken);
                                            await cboSpiritDetection.DoThreadSafeAsync(x =>
                                            {
                                                x.Visible
                                                    = CharacterObject.MagicTradition.Type == TraditionType.MAG;
                                                x.Enabled
                                                    = CharacterObject.MagicTradition.IsCustomTradition;
                                            }, GenericToken);

                                            await cboSpiritIllusion.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                            cboSpiritIllusion.DoDataBinding(
                                                "SelectedValue", CharacterObject.MagicTradition,
                                                nameof(Tradition.SpiritIllusion));
                                            await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible
                                                = CharacterObject.MagicTradition.Type == TraditionType.MAG, GenericToken);
                                            await cboSpiritIllusion.DoThreadSafeAsync(x =>
                                            {
                                                x.Visible
                                                    = CharacterObject.MagicTradition.Type == TraditionType.MAG;
                                                x.Enabled
                                                    = CharacterObject.MagicTradition.IsCustomTradition;
                                            }, GenericToken);

                                            await cboSpiritManipulation.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                            cboSpiritManipulation.DoDataBinding(
                                                "SelectedValue", CharacterObject.MagicTradition,
                                                nameof(Tradition.SpiritManipulation));
                                            await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible
                                                = CharacterObject.MagicTradition.Type == TraditionType.MAG, GenericToken);
                                            await cboSpiritManipulation.DoThreadSafeAsync(x =>
                                            {
                                                x.Visible
                                                    = CharacterObject.MagicTradition.Type == TraditionType.MAG;
                                                x.Enabled
                                                    = CharacterObject.MagicTradition.IsCustomTradition;
                                            }, GenericToken);
                                        }
                                    }

                                    // Populate the Technomancer Streams list.
                                    xmlTraditionsBaseChummerNode =
                                        await (await CharacterObject.LoadDataXPathAsync("streams.xml", token: GenericToken))
                                            .SelectSingleNodeAndCacheExpressionAsync("/chummer");
                                    using (new FetchSafelyFromPool<List<ListItem>>(
                                               Utils.ListItemListPool, out List<ListItem> lstStreams))
                                    {
                                        if (xmlTraditionsBaseChummerNode != null)
                                        {
                                            foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                         "traditions/tradition[" + CharacterObjectSettings.BookXPath()
                                                         + ']'))
                                            {
                                                string strName
                                                    = (await xmlTradition.SelectSingleNodeAndCacheExpressionAsync(
                                                        "name"))
                                                    ?.Value;
                                                if (!string.IsNullOrEmpty(strName))
                                                    lstStreams.Add(new ListItem(
                                                                       (await xmlTradition
                                                                           .SelectSingleNodeAndCacheExpressionAsync(
                                                                               "id"))
                                                                       ?.Value
                                                                       ?? strName,
                                                                       (await xmlTradition
                                                                           .SelectSingleNodeAndCacheExpressionAsync(
                                                                               "translate"))
                                                                       ?.Value ?? strName));
                                            }
                                        }

                                        if (lstStreams.Count > 1)
                                        {
                                            lstStreams.Sort(CompareListItems.CompareNames);
                                            lstStreams.Insert(0,
                                                              new ListItem(
                                                                  "None",
                                                                  await LanguageManager.GetStringAsync("String_None")));
                                            await cboStream.PopulateWithListItemsAsync(lstStreams, GenericToken);
                                        }
                                        else
                                        {
                                            await cboStream.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                            await lblStreamLabel.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                        }
                                    }
                                }

                                using (_ = await Timekeeper.StartSyncronAsync("load_frm_career_shapeshifter",
                                                                              op_load_frm_career))
                                {
                                    await cboAttributeCategory.DoThreadSafeAsync(x => x.Visible = CharacterObject.MetatypeCategory == "Shapeshifter", GenericToken);
                                    if (CharacterObject.MetatypeCategory == "Shapeshifter")
                                    {
                                        XPathNavigator objDoc
                                            = await CharacterObject.LoadDataXPathAsync("metatypes.xml", token: GenericToken);
                                        XPathNavigator node =
                                            objDoc.SelectSingleNode(
                                                "/chummer/metatypes/metatype[name = "
                                                + CharacterObject.Metatype.CleanXPath()
                                                + ']');
                                        using (new FetchSafelyFromPool<List<ListItem>>(
                                                   Utils.ListItemListPool, out List<ListItem> lstAttributeCategories))
                                        {
                                            lstAttributeCategories.Add(new ListItem("Standard",
                                                                           node != null
                                                                               ? (await node
                                                                                   .SelectSingleNodeAndCacheExpressionAsync(
                                                                                       "name/@translate"))?.Value
                                                                               ?? CharacterObject.Metatype
                                                                               : CharacterObject.Metatype));

                                            node = node?.SelectSingleNode(
                                                "metavariants/metavariant[name = "
                                                + CharacterObject.Metavariant.CleanXPath()
                                                + "]/name/@translate");

                                            //The Shapeshifter attribute category is treated as the METAHUMAN form of a shapeshifter.
                                            lstAttributeCategories.Add(new ListItem("Shapeshifter",
                                                                           node?.Value ?? CharacterObject
                                                                               .Metavariant));

                                            lstAttributeCategories.Sort(CompareListItems.CompareNames);
                                            await cboAttributeCategory.PopulateWithListItemsAsync(
                                                lstAttributeCategories, GenericToken);
                                            await cboAttributeCategory.DoThreadSafeAsync(x => x.SelectedValue = "Standard", GenericToken);
                                        }
                                    }

                                    lblMysticAdeptMAGAdept.DoOneWayDataBinding("Text", CharacterObject,
                                                                               nameof(Character
                                                                                   .MysticAdeptPowerPoints));
                                    cmdIncreasePowerPoints.DoOneWayDataBinding("Enabled", CharacterObject,
                                                                               nameof(Character.CanAffordCareerPP));
                                }

                                using (_ = await Timekeeper.StartSyncronAsync(
                                           "load_frm_career_vehicle", op_load_frm_career))
                                {
                                    // Populate vehicle weapon fire mode list.
                                    using (new FetchSafelyFromPool<List<ListItem>>(
                                               Utils.ListItemListPool, out List<ListItem> lstFireModes))
                                    {
                                        foreach (Weapon.FiringMode mode in Enum.GetValues(typeof(Weapon.FiringMode)))
                                        {
                                            if (mode == Weapon.FiringMode.NumFiringModes)
                                                continue;
                                            lstFireModes.Add(new ListItem(mode,
                                                                          await LanguageManager
                                                                              .GetStringAsync("Enum_" + mode)));
                                        }

                                        await cboVehicleWeaponFiringMode.PopulateWithListItemsAsync(lstFireModes, GenericToken);
                                    }
                                }

                                using (_ = await Timekeeper.StartSyncronAsync("load_frm_career_selectStuff",
                                                                              op_load_frm_career))
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        if (CharacterObject.MagicTradition.Type == TraditionType.MAG)
                                            cboTradition.SelectedValue = CharacterObject.MagicTradition.SourceIDString;
                                        else if (cboTradition.SelectedIndex == -1 && cboTradition.Items.Count > 0)
                                            cboTradition.SelectedIndex = 0;
                                        if (CharacterObject.MagicTradition.Type == TraditionType.RES)
                                            cboStream.SelectedValue = CharacterObject.MagicTradition.SourceIDString;
                                        else if (cboStream.SelectedIndex == -1 && cboStream.Items.Count > 0)
                                            cboStream.SelectedIndex = 0;
                                    }, GenericToken);
                                    txtTraditionName.DoDataBinding("Text", CharacterObject.MagicTradition,
                                                                   nameof(Tradition.Name));
                                }

                                using (CustomActivity op_load_frm_career_longloads
                                       = await Timekeeper.StartSyncronAsync("load_frm_career_longloads",
                                                                            op_load_frm_career))
                                {
                                    using (_ = await Timekeeper.StartSyncronAsync(
                                               "load_frm_career_tabSkillsUc.RealLoad()",
                                               op_load_frm_career_longloads))
                                    {
                                        await tabSkillsUc.RealLoad();
                                    }

                                    using (_ = await Timekeeper.StartSyncronAsync(
                                               "load_frm_career_tabPowerUc.RealLoad()",
                                               op_load_frm_career_longloads))
                                    {
                                        await tabPowerUc.RealLoad();
                                    }

                                    using (_ = await Timekeeper.StartSyncronAsync(
                                               "load_frm_career_Run through all appropriate property changers",
                                               op_load_frm_career_longloads))
                                    {
                                        // Run through all appropriate property changers
                                        foreach (PropertyInfo objProperty in typeof(Character).GetProperties())
                                            await DoOnCharacterPropertyChanged(
                                                new PropertyChangedEventArgs(objProperty.Name));
                                    }
                                }

                                using (_ = await Timekeeper.StartSyncronAsync("load_frm_career_databindingCallbacks2",
                                                                              op_load_frm_career))
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        treGear.ItemDrag += treGear_ItemDrag;
                                        treGear.DragEnter += treGear_DragEnter;
                                        treGear.DragDrop += treGear_DragDrop;
                                        /*
                                        treLifestyles.ItemDrag += treLifestyles_ItemDrag;
                                        treLifestyles.DragEnter += treLifestyles_DragEnter;
                                        treLifestyles.DragDrop += treLifestyles_DragDrop;
                                        */
                                        treArmor.ItemDrag += treArmor_ItemDrag;
                                        treArmor.DragEnter += treArmor_DragEnter;
                                        treArmor.DragDrop += treArmor_DragDrop;
                                        treWeapons.ItemDrag += treWeapons_ItemDrag;
                                        treWeapons.DragEnter += treWeapons_DragEnter;
                                        treWeapons.DragDrop += treWeapons_DragDrop;
                                        treVehicles.ItemDrag += treVehicles_ItemDrag;
                                        treVehicles.DragEnter += treVehicles_DragEnter;
                                        treVehicles.DragDrop += treVehicles_DragDrop;
                                        treImprovements.ItemDrag += treImprovements_ItemDrag;
                                        treImprovements.DragEnter += treImprovements_DragEnter;
                                        treImprovements.DragDrop += treImprovements_DragDrop;
                                    }, GenericToken);

                                    // Merge the ToolStrips.
                                    ToolStripManager.RevertMerge("toolStrip");
                                    ToolStripManager.Merge(tsMain, "toolStrip");

                                    lblCMPenalty.DoOneWayDataBinding("Text", CharacterObject,
                                                                     nameof(Character.WoundModifier));
                                    lblCMPhysical.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                      nameof(Character.PhysicalCMToolTip));
                                    lblCMPhysical.DoOneWayDataBinding("Text", CharacterObject,
                                                                      nameof(Character.PhysicalCM));
                                    lblCMPhysicalLabel.DoOneWayDataBinding("Text", CharacterObject,
                                                                           nameof(Character.PhysicalCMLabelText));
                                    await lblCMStun.DoThreadSafeAsync(x => x.Visible = true, GenericToken); // Needed to make sure data bindings go through
                                    lblCMStun.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                  nameof(Character.StunCMToolTip));
                                    lblCMStun.DoOneWayDataBinding("Text", CharacterObject, nameof(Character.StunCM));
                                    lblCMStun.DoOneWayDataBinding("Visible", CharacterObject,
                                                                  nameof(Character.StunCMVisible));
                                    lblCMStunLabel.DoOneWayDataBinding("Text", CharacterObject,
                                                                       nameof(Character.StunCMLabelText));

                                    lblESSMax.DoOneWayDataBinding("Text", CharacterObject,
                                                                  nameof(Character.DisplayEssence));
                                    lblCyberwareESS.DoOneWayDataBinding("Text", CharacterObject,
                                                                        nameof(Character.DisplayCyberwareEssence));
                                    lblBiowareESS.DoOneWayDataBinding("Text", CharacterObject,
                                                                      nameof(Character.DisplayBiowareEssence));
                                    lblEssenceHoleESS.DoOneWayDataBinding("Text", CharacterObject,
                                                                          nameof(Character.DisplayEssenceHole));

                                    lblArmor.DoOneWayDataBinding("Text", CharacterObject,
                                                                 nameof(Character.TotalArmorRating));
                                    lblArmor.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                 nameof(Character.TotalArmorRatingToolTip));
                                    lblCMArmor.DoOneWayDataBinding("Text", CharacterObject,
                                                                   nameof(Character.TotalArmorRating));
                                    lblCMArmor.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                   nameof(Character.TotalArmorRatingToolTip));

                                    lblDodge.DoOneWayDataBinding("Text", CharacterObject,
                                                                 nameof(Character.DisplayDodge));
                                    lblDodge.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                 nameof(Character.DodgeToolTip));

                                    lblCMDodge.DoOneWayDataBinding("Text", CharacterObject,
                                                                   nameof(Character.DisplayDodge));
                                    lblCMDodge.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                   nameof(Character.DodgeToolTip));

                                    lblSpellDefenseIndirectDodge.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseIndirectDodge));
                                    lblSpellDefenseIndirectDodge.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseIndirectDodgeToolTip));
                                    lblSpellDefenseIndirectSoak.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseIndirectSoak));
                                    lblSpellDefenseIndirectSoak.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseIndirectSoakToolTip));
                                    lblSpellDefenseDirectSoakMana.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseDirectSoakMana));
                                    lblSpellDefenseDirectSoakMana.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseDirectSoakManaToolTip));
                                    lblSpellDefenseDirectSoakPhysical.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character.DisplaySpellDefenseDirectSoakPhysical));
                                    lblSpellDefenseDirectSoakPhysical.DoOneWayDataBinding(
                                        "ToolTipText", CharacterObject,
                                        nameof(Character.SpellDefenseDirectSoakPhysicalToolTip));
                                    lblSpellDefenseDetection.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseDetection));
                                    lblSpellDefenseDetection.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseDetectionToolTip));
                                    lblSpellDefenseDecAttBOD.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseBOD));
                                    lblSpellDefenseDecAttBOD.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseBODToolTip));
                                    lblSpellDefenseDecAttAGI.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseAGI));
                                    lblSpellDefenseDecAttAGI.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseAGIToolTip));
                                    lblSpellDefenseDecAttREA.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseREA));
                                    lblSpellDefenseDecAttREA.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseREAToolTip));
                                    lblSpellDefenseDecAttSTR.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseSTR));
                                    lblSpellDefenseDecAttSTR.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseSTRToolTip));
                                    lblSpellDefenseDecAttCHA.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseCHA));
                                    lblSpellDefenseDecAttCHA.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseCHAToolTip));
                                    lblSpellDefenseDecAttINT.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseINT));
                                    lblSpellDefenseDecAttINT.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseINTToolTip));
                                    lblSpellDefenseDecAttLOG.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseLOG));
                                    lblSpellDefenseDecAttLOG.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseLOGToolTip));
                                    lblSpellDefenseDecAttWIL.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseWIL));
                                    lblSpellDefenseDecAttWIL.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseWILToolTip));
                                    lblSpellDefenseIllusionMana.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseIllusionMana));
                                    lblSpellDefenseIllusionMana.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseIllusionManaToolTip));
                                    lblSpellDefenseIllusionPhysical.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character.DisplaySpellDefenseIllusionPhysical));
                                    lblSpellDefenseIllusionPhysical.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character.SpellDefenseIllusionPhysicalToolTip));
                                    lblSpellDefenseManipMental.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseManipulationMental));
                                    lblSpellDefenseManipMental.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseManipulationMentalToolTip));
                                    lblSpellDefenseManipPhysical.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseManipulationPhysical));
                                    lblSpellDefenseManipPhysical.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseManipulationPhysicalToolTip));
                                    nudCounterspellingDice.DoDataBinding("Value", CharacterObject,
                                                                         nameof(Character.CurrentCounterspellingDice));

                                    nudLiftCarryHits.DoDataBinding("Value", CharacterObject,
                                                                   nameof(Character.CurrentLiftCarryHits));

                                    lblMovement.DoOneWayDataBinding("Text", CharacterObject,
                                                                    nameof(Character.DisplayMovement));
                                    lblSwim.DoOneWayDataBinding("Text", CharacterObject, nameof(Character.DisplaySwim));
                                    lblFly.DoOneWayDataBinding("Text", CharacterObject, nameof(Character.DisplayFly));

                                    lblRemainingNuyen.DoOneWayDataBinding("Text", CharacterObject,
                                                                          nameof(Character.DisplayNuyen));
                                    lblCareerKarma.DoOneWayDataBinding("Text", CharacterObject,
                                                                       nameof(Character.DisplayCareerKarma));
                                    lblCareerNuyen.DoOneWayDataBinding("Text", CharacterObject,
                                                                       nameof(Character.DisplayCareerNuyen));

                                    lblStreetCredTotal.DoOneWayDataBinding("Text", CharacterObject,
                                                                           nameof(Character.TotalStreetCred));
                                    lblStreetCredTotal.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                           nameof(Character.StreetCredTooltip));
                                    lblNotorietyTotal.DoOneWayDataBinding("Text", CharacterObject,
                                                                          nameof(Character.TotalNotoriety));
                                    lblNotorietyTotal.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                          nameof(Character.NotorietyTooltip));
                                    lblPublicAwareTotal.DoOneWayDataBinding("Text", CharacterObject,
                                                                            nameof(Character.TotalPublicAwareness));
                                    lblPublicAwareTotal.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                            nameof(Character.PublicAwarenessTooltip));
                                    lblAstralReputationTotal.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character.TotalAstralReputation));
                                    lblAstralReputationTotal.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character.AstralReputationTooltip));
                                    lblWildReputationTotal.DoOneWayDataBinding("Text", CharacterObject,
                                                                               nameof(Character.TotalWildReputation));
                                    lblWildReputationTotal.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                               nameof(Character.WildReputationTooltip));

                                    lblMentorSpirit.DoOneWayDataBinding("Text", CharacterObject,
                                                                        nameof(Character.FirstMentorSpiritDisplayName));
                                    lblMentorSpiritInformation.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .FirstMentorSpiritDisplayInformation));
                                    lblParagon.DoOneWayDataBinding("Text", CharacterObject,
                                                                   nameof(Character.FirstMentorSpiritDisplayName));
                                    lblParagonInformation.DoOneWayDataBinding("Text", CharacterObject,
                                                                              nameof(Character
                                                                                  .FirstMentorSpiritDisplayInformation));

                                    lblSurprise.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                    nameof(Character.SurpriseToolTip));
                                    lblSurprise.DoOneWayDataBinding("Text", CharacterObject,
                                                                    nameof(Character.Surprise));
                                    lblComposure.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                     nameof(Character.ComposureToolTip));
                                    lblComposure.DoOneWayDataBinding("Text", CharacterObject,
                                                                     nameof(Character.Composure));
                                    lblJudgeIntentions.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                           nameof(Character.JudgeIntentionsToolTip));
                                    lblJudgeIntentions.DoOneWayDataBinding("Text", CharacterObject,
                                                                           nameof(Character.JudgeIntentions));
                                    lblLiftCarry.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                     nameof(Character.LiftAndCarryToolTip));
                                    lblLiftCarry.DoOneWayDataBinding("Text", CharacterObject,
                                                                     nameof(Character.LiftAndCarry));
                                    lblMemory.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                  nameof(Character.MemoryToolTip));
                                    lblMemory.DoOneWayDataBinding("Text", CharacterObject, nameof(Character.Memory));

                                    lblLiftCarryLimits.DoOneWayDataBinding("Text", CharacterObject,
                                                                           nameof(Character.LiftAndCarryLimits));

                                    lblINI.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                               nameof(Character.InitiativeToolTip));
                                    lblINI.DoOneWayDataBinding("Text", CharacterObject, nameof(Character.Initiative));
                                    lblAstralINI.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                     nameof(Character.AstralInitiativeToolTip));
                                    lblAstralINI.DoOneWayDataBinding("Text", CharacterObject,
                                                                     nameof(Character.AstralInitiative));
                                    lblMatrixINI.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                     nameof(Character.MatrixInitiativeToolTip));
                                    lblMatrixINI.DoOneWayDataBinding("Text", CharacterObject,
                                                                     nameof(Character.MatrixInitiative));
                                    lblMatrixINICold.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                         nameof(Character.MatrixInitiativeColdToolTip));
                                    lblMatrixINICold.DoOneWayDataBinding("Text", CharacterObject,
                                                                         nameof(Character.MatrixInitiativeCold));
                                    lblMatrixINIHot.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                        nameof(Character.MatrixInitiativeHotToolTip));
                                    lblMatrixINIHot.DoOneWayDataBinding("Text", CharacterObject,
                                                                        nameof(Character.MatrixInitiativeHot));
                                    lblRiggingINI.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                      nameof(Character.InitiativeToolTip));
                                    lblRiggingINI.DoOneWayDataBinding("Text", CharacterObject,
                                                                      nameof(Character.Initiative));

                                    cmdBurnStreetCred.DoOneWayDataBinding("Enabled", CharacterObject,
                                                                          nameof(Character.CanBurnStreetCred));

                                    lblEDGInfo.DoOneWayDataBinding("Text", CharacterObject,
                                                                   nameof(Character.EdgeRemainingString));
                                    lblCMDamageResistancePool.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .DamageResistancePoolToolTip));
                                    lblCMDamageResistancePool.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character.DamageResistancePool));
                                    lblCMPhysicalRecoveryPool.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character.PhysicalCMNaturalRecovery));
                                    lblCMStunRecoveryPool.DoOneWayDataBinding("Text", CharacterObject,
                                                                              nameof(Character.StunCMNaturalRecovery));
                                }
                            }
                            finally
                            {
                                IsLoading = false;
                            }

                            using (CustomActivity op_load_frm_career_finishingStuff =
                                   await Timekeeper.StartSyncronAsync("load_frm_career_finishingStuff",
                                                                      op_load_frm_career))
                            {
                                await SetTooltips();

                                await RefreshAttributes(pnlAttributes, null, lblAttributes, -1,
                                                  await lblAttributesAug.DoThreadSafeFuncAsync(x => x.PreferredWidth, GenericToken),
                                                  await lblAttributesMetatype.DoThreadSafeFuncAsync(x => x.PreferredWidth, GenericToken));

                                CharacterObject.AttributeSection.Attributes.CollectionChanged
                                    += AttributeCollectionChanged;

                                // Condition Monitor.
                                await ProcessCharacterConditionMonitorBoxDisplays(
                                    panPhysicalCM, CharacterObject.PhysicalCM,
                                    CharacterObject.CMThreshold,
                                    CharacterObject.PhysicalCMThresholdOffset,
                                    CharacterObject.CMOverflow,
                                    chkPhysicalCM_CheckedChanged, true,
                                    CharacterObject.PhysicalCMFilled, GenericToken);
                                await ProcessCharacterConditionMonitorBoxDisplays(panStunCM, CharacterObject.StunCM,
                                    CharacterObject.CMThreshold,
                                    CharacterObject.StunCMThresholdOffset, 0,
                                    chkStunCM_CheckedChanged,
                                    true, CharacterObject.StunCMFilled, GenericToken);

                                await RequestCharacterUpdate();
                                // Directly awaiting here so that we can properly unset the dirty flag after the update
                                try
                                {
                                    await UpdateCharacterInfoTask;
                                }
                                catch (OperationCanceledException)
                                {
                                    return;
                                }

                                // Clear the Dirty flag which gets set when creating a new Character.
                                if (!CharacterObject.LoadAsDirty)
                                    IsDirty = false;
                                await RefreshPasteStatus(GenericToken);
                                await ProcessMugshot(GenericToken);
                                // Stupid hack to get the MDI icon to show up properly.
                                await this.DoThreadSafeFuncAsync(x => x.Icon = x.Icon.Clone() as Icon, GenericToken);

                                Program.PluginLoader.CallPlugins(this, op_load_frm_career_finishingStuff);
                            }

                            if (CharacterObject.InternalIdsNeedingReapplyImprovements.Count > 0 && !Utils.IsUnitTest
                                && Program.ShowMessageBox(this,
                                                          await LanguageManager.GetStringAsync(
                                                              "Message_ImprovementLoadError"),
                                                          await LanguageManager.GetStringAsync(
                                                              "MessageTitle_ImprovementLoadError"),
                                                          MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation)
                                == DialogResult.Yes)
                            {
                                await DoReapplyImprovements(CharacterObject.InternalIdsNeedingReapplyImprovements, GenericToken);
                                await CharacterObject.InternalIdsNeedingReapplyImprovements.ClearAsync();
                            }

                            op_load_frm_career.SetSuccess(true);
                        }
                        catch (Exception ex)
                        {
                            if (op_load_frm_career != null)
                            {
                                op_load_frm_career.SetSuccess(false);
                                op_load_frm_career.MyTelemetryClient.TrackException(ex);
                            }

                            Log.Error(ex);
                            throw;
                        }
                    }
                }
            }
            finally
            {
                IsFinishedInitializing = true;
            }
        }

        private async void PowersBeforeRemove(object sender, RemovingOldEventArgs e)
        {
            await RefreshPowerCollectionBeforeRemove(treMetamagic, e);
        }

        private async void PowersListChanged(object sender, ListChangedEventArgs e)
        {
            try
            {
                await RefreshPowerCollectionListChanged(treMetamagic, cmsMetamagic, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void SpellCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ComplexFormCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ArtCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshArtCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void EnhancementCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshEnhancementCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void MetamagicCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshMetamagicCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void InitiationGradeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void AIProgramCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void CritterPowerCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshCritterPowers(treCritterPowers, cmsCritterPowers, e);
                bool blnVisible
                    = await CharacterObject.CritterPowers.AnyAsync(x => x.Name == "Inhabitation" || x.Name == "Possession", GenericToken);
                await mnuCreateMenu.DoThreadSafeAsync(() => mnuSpecialPossess.Visible = blnVisible, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void QualityCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshQualities(treQualities, cmsQuality, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void MartialArtCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void LifestylesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ImprovementCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshCustomImprovements(treImprovements, lmtControl.LimitTreeView, cmsImprovementLocation, cmsImprovement, lmtControl.LimitContextMenuStrip, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ImprovementGroupCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshCustomImprovementLocations(treImprovements, cmsImprovementLocation, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void CalendarWeekListChanged(object sender, ListChangedEventArgs listChangedEventArgs)
        {
            try
            {
                await RefreshCalendar(lstCalendar, listChangedEventArgs);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ContactCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshContacts(panContacts, panEnemies, panPets, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void SpiritCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshSpirits(panSpirits, panSprites, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void SustainedSpellCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshSustainedSpells(flpSustainedSpells, flpSustainedComplexForms, flpSustainedCritterPowers, chkPsycheActiveMagician, chkPsycheActiveTechnomancer, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void AttributeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshAttributes(pnlAttributes, e, lblAttributes, -1,
                                        await lblAttributesAug.DoThreadSafeFuncAsync(x => x.PreferredWidth, GenericToken),
                                        await lblAttributesMetatype.DoThreadSafeFuncAsync(x => x.PreferredWidth, GenericToken));
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ArmorCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod, cmsArmorGear, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ArmorLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshArmorLocations(treArmor, cmsArmorLocation, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void WeaponCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon, cmsWeaponAccessory, cmsWeaponAccessoryGear, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void WeaponLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshWeaponLocations(treWeapons, cmsWeaponLocation, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void GearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshGears(treGear, cmsGearLocation, cmsGear,
                    await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, GenericToken),
                    await chkHideLoadedAmmo.DoThreadSafeFuncAsync(x => x.Checked, GenericToken),
                    e);
                await RefreshFociFromGear(treFoci, null, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void DrugCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshDrugs(treCustomDrugs, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void GearLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshGearLocations(treGear, cmsGearLocation, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void CyberwareCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void VehicleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle, cmsVehicleWeapon,
                                      cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear, cmsVehicleGear,
                                      cmsWeaponMount, cmsVehicleCyberware, cmsVehicleCyberwareGear, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void VehicleLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshVehicleLocations(treVehicles, cmsVehicleLocation, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void CharacterCareer_FormClosing(object sender, FormClosingEventArgs e)
        {
            using (await CursorWait.NewAsync(this))
            {
                IsLoading = true;
                try
                {
                    // If there are unsaved changes to the character, as the user if they would like to save their changes.
                    if (IsDirty && !Utils.IsUnitTest)
                    {
                        string strCharacterName = CharacterObject.CharacterName;
                        DialogResult objResult = Program.ShowMessageBox(
                            this,
                            string.Format(GlobalSettings.CultureInfo,
                                          await LanguageManager.GetStringAsync("Message_UnsavedChanges"),
                                          strCharacterName),
                            await LanguageManager.GetStringAsync("MessageTitle_UnsavedChanges"),
                            MessageBoxButtons.YesNoCancel, MessageBoxIcon.Question);
                        switch (objResult)
                        {
                            case DialogResult.Yes:
                            {
                                // Attempt to save the Character. If the user cancels the Save As dialogue that may open, cancel the closing event so that changes are not lost.
                                bool blnResult = await SaveCharacter();
                                if (!blnResult)
                                    e.Cancel = true;
                                break;
                            }
                            case DialogResult.Cancel:
                                e.Cancel = true;
                                break;
                        }
                    }

                    // Reset the ToolStrip so the Save button is removed for the currently closing window.
                    if (e.Cancel)
                        return;

                    GenericCancellationTokenSource?.Cancel(false);

                    if (Program.MainForm.ActiveMdiChild == this)
                        ToolStripManager.RevertMerge("toolStrip");

                    // Unsubscribe from events.
                    CharacterObject.AttributeSection.Attributes.CollectionChanged -= AttributeCollectionChanged;
                    CharacterObject.Spells.CollectionChanged -= SpellCollectionChanged;
                    CharacterObject.ComplexForms.CollectionChanged -= ComplexFormCollectionChanged;
                    CharacterObject.Arts.CollectionChanged -= ArtCollectionChanged;
                    CharacterObject.Enhancements.CollectionChanged -= EnhancementCollectionChanged;
                    CharacterObject.Metamagics.CollectionChanged -= MetamagicCollectionChanged;
                    CharacterObject.InitiationGrades.CollectionChanged -= InitiationGradeCollectionChanged;
                    CharacterObject.Powers.ListChanged -= PowersListChanged;
                    CharacterObject.Powers.BeforeRemove -= PowersBeforeRemove;
                    CharacterObject.AIPrograms.CollectionChanged -= AIProgramCollectionChanged;
                    CharacterObject.CritterPowers.CollectionChanged -= CritterPowerCollectionChanged;
                    CharacterObject.Qualities.CollectionChanged -= QualityCollectionChanged;
                    CharacterObject.MartialArts.CollectionChanged -= MartialArtCollectionChanged;
                    CharacterObject.Lifestyles.CollectionChanged -= LifestylesCollectionChanged;
                    CharacterObject.Contacts.CollectionChanged -= ContactCollectionChanged;
                    CharacterObject.Armor.CollectionChanged -= ArmorCollectionChanged;
                    CharacterObject.ArmorLocations.CollectionChanged -= ArmorLocationCollectionChanged;
                    CharacterObject.Weapons.CollectionChanged -= WeaponCollectionChanged;
                    CharacterObject.WeaponLocations.CollectionChanged -= WeaponLocationCollectionChanged;
                    CharacterObject.Gear.CollectionChanged -= GearCollectionChanged;
                    CharacterObject.GearLocations.CollectionChanged -= GearLocationCollectionChanged;
                    CharacterObject.Cyberware.CollectionChanged -= CyberwareCollectionChanged;
                    CharacterObject.Vehicles.CollectionChanged -= VehicleCollectionChanged;
                    CharacterObject.VehicleLocations.CollectionChanged -= VehicleLocationCollectionChanged;
                    CharacterObject.Spirits.CollectionChanged -= SpiritCollectionChanged;
                    CharacterObject.Improvements.CollectionChanged -= ImprovementCollectionChanged;
                    CharacterObject.ImprovementGroups.CollectionChanged -= ImprovementGroupCollectionChanged;
                    CharacterObject.Calendar.ListChanged -= CalendarWeekListChanged;
                    CharacterObject.Drugs.CollectionChanged -= DrugCollectionChanged;
                    CharacterObject.SustainedCollection.CollectionChanged -= SustainedSpellCollectionChanged;
                    CharacterObject.ExpenseEntries.CollectionChanged -= ExpenseEntriesCollectionChanged;
                    CharacterObject.AttributeSection.PropertyChanged -= MakeDirtyWithCharacterUpdate;
                    CharacterObject.PropertyChanged -= OnCharacterPropertyChanged;
                    CharacterObject.SettingsPropertyChanged -= OnCharacterSettingsPropertyChanged;

                    SetupCommonCollectionDatabindings(false);

                    treGear.ItemDrag -= treGear_ItemDrag;
                    treGear.DragEnter -= treGear_DragEnter;
                    treGear.DragDrop -= treGear_DragDrop;

                    /*
                        treLifestyles.ItemDrag -= treLifestyles_ItemDrag;
                        treLifestyles.DragEnter -= treLifestyles_DragEnter;
                        treLifestyles.DragDrop -= treLifestyles_DragDrop;
                        */

                    treArmor.ItemDrag -= treArmor_ItemDrag;
                    treArmor.DragEnter -= treArmor_DragEnter;
                    treArmor.DragDrop -= treArmor_DragDrop;

                    treWeapons.ItemDrag -= treWeapons_ItemDrag;
                    treWeapons.DragEnter -= treWeapons_DragEnter;
                    treWeapons.DragDrop -= treWeapons_DragDrop;

                    treVehicles.ItemDrag -= treVehicles_ItemDrag;
                    treVehicles.DragEnter -= treVehicles_DragEnter;
                    treVehicles.DragDrop -= treVehicles_DragDrop;

                    treImprovements.ItemDrag -= treImprovements_ItemDrag;
                    treImprovements.DragEnter -= treImprovements_DragEnter;
                    treImprovements.DragDrop -= treImprovements_DragDrop;

                    foreach (ContactControl objContactControl in panContacts.Controls.OfType<ContactControl>())
                    {
                        objContactControl.ContactDetailChanged -= MakeDirtyWithCharacterUpdate;
                        objContactControl.DeleteContact -= DeleteContact;
                        objContactControl.MouseDown -= DragContactControl;
                    }

                    foreach (ContactControl objContactControl in panEnemies.Controls.OfType<ContactControl>())
                    {
                        objContactControl.ContactDetailChanged -= MakeDirtyWithCharacterUpdate;
                        objContactControl.DeleteContact -= DeleteEnemy;
                        objContactControl.MouseDown -= DragContactControl;
                    }

                    foreach (PetControl objContactControl in panPets.Controls.OfType<PetControl>())
                    {
                        objContactControl.DeleteContact -= DeletePet;
                        objContactControl.ContactDetailChanged -= MakeDirtyWithCharacterUpdate;
                    }

                    foreach (SpiritControl objSpiritControl in panSpirits.Controls.OfType<SpiritControl>())
                    {
                        objSpiritControl.ContactDetailChanged -= MakeDirtyWithCharacterUpdate;
                        objSpiritControl.DeleteSpirit -= DeleteSpirit;
                    }

                    foreach (SpiritControl objSpiritControl in panSprites.Controls.OfType<SpiritControl>())
                    {
                        objSpiritControl.ContactDetailChanged -= MakeDirtyWithCharacterUpdate;
                        objSpiritControl.DeleteSpirit -= DeleteSpirit;
                    }

                    foreach (SustainedObjectControl objSustainedSpellControl in flpSustainedSpells.Controls
                                 .OfType<SustainedObjectControl>())
                    {
                        objSustainedSpellControl.SustainedObjectDetailChanged -= MakeDirtyWithCharacterUpdate;
                        objSustainedSpellControl.UnsustainObject -= DeleteSustainedObject;
                    }

                    try
                    {
                        await UpdateCharacterInfoTask;
                    }
                    catch (OperationCanceledException)
                    {
                        // Swallow this
                    }
                }
                finally
                {
                    IsLoading = false;
                }
            }
        }

        private void CharacterCareer_Activated(object sender, EventArgs e)
        {
            // Merge the ToolStrips.
            ToolStripManager.RevertMerge("toolStrip");
            ToolStripManager.Merge(tsMain, "toolStrip");
        }

        #endregion Form Events

        #region Character Events

        private async void OnCharacterPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            await DoOnCharacterPropertyChanged(e);
        }

        private async ValueTask DoOnCharacterPropertyChanged(PropertyChangedEventArgs e)
        {
            if (_blnReapplyImprovements)
                return;
            await SetDirty(true);
            try
            {
                switch (e.PropertyName)
                {
                    case nameof(Character.CharacterName):
                        await UpdateWindowTitleAsync(false, GenericToken);
                        break;

                    case nameof(Character.DisplayNuyen):
                        await StatusStrip.DoThreadSafeAsync(() => tslNuyen.Text = CharacterObject.DisplayNuyen, GenericToken);
                        break;

                    case nameof(Character.DisplayKarma):
                        await StatusStrip.DoThreadSafeAsync(() => tslKarma.Text = CharacterObject.DisplayKarma, GenericToken);
                        break;

                    case nameof(Character.DisplayEssence):
                        await StatusStrip.DoThreadSafeAsync(() => tslEssence.Text = CharacterObject.DisplayEssence, GenericToken);
                        break;

                    case nameof(Character.DisplayTotalCarriedWeight):
                        await StatusStrip.DoThreadSafeAsync(
                            () => tslCarriedWeight.Text = CharacterObject.DisplayTotalCarriedWeight, GenericToken);
                        break;

                    case nameof(Character.Encumbrance):
                        Color objControlTextColor = await ColorManager.ControlTextAsync;
                        await StatusStrip.DoThreadSafeAsync(() => tslCarriedWeight.ForeColor
                                                                = CharacterObject.Encumbrance > 0
                                                                    ? ColorManager.ErrorColor
                                                                    : objControlTextColor, GenericToken);
                        break;

                    case nameof(Character.NuyenBP):
                    case nameof(Character.MetatypeBP):
                    case nameof(Character.ContactPoints):
                    case nameof(Character.FreeSpells):
                    case nameof(Character.CFPLimit):
                    case nameof(Character.AIAdvancedProgramLimit):
                    case nameof(Character.SpellKarmaCost):
                    case nameof(Character.ComplexFormKarmaCost):
                    case nameof(Character.AIProgramKarmaCost):
                    case nameof(Character.AIAdvancedProgramKarmaCost):
                    case nameof(Character.MysticAdeptPowerPoints):
                    case nameof(Character.MagicTradition):
                    case nameof(Character.HomeNode):
                    case nameof(Character.ActiveCommlink):
                    case nameof(Character.Nuyen):
                    case nameof(Character.Karma):
                        await RequestCharacterUpdate();
                        break;

                    case nameof(Character.Source):
                    case nameof(Character.Page):
                        await CharacterObject.SetSourceDetailAsync(lblMetatypeSource, GenericToken);
                        break;

                    case nameof(Character.CMOverflow):
                    case nameof(Character.CMThreshold):
                    case nameof(Character.CMThresholdOffsets):
                        await ProcessCharacterConditionMonitorBoxDisplays(panPhysicalCM, CharacterObject.PhysicalCM,
                                                                          CharacterObject.CMThreshold,
                                                                          CharacterObject.PhysicalCMThresholdOffset,
                                                                          CharacterObject.CMOverflow,
                                                                          chkPhysicalCM_CheckedChanged, true,
                                                                          CharacterObject.PhysicalCMFilled, GenericToken);
                        await ProcessCharacterConditionMonitorBoxDisplays(panStunCM, CharacterObject.StunCM,
                                                                          CharacterObject.CMThreshold,
                                                                          CharacterObject.StunCMThresholdOffset, 0,
                                                                          chkStunCM_CheckedChanged,
                                                                          true, CharacterObject.StunCMFilled, GenericToken);
                        break;

                    case nameof(Character.StunCM):
                    case nameof(Character.StunCMFilled):
                    case nameof(Character.StunCMThresholdOffset):
                        await ProcessCharacterConditionMonitorBoxDisplays(panStunCM, CharacterObject.StunCM,
                                                                          CharacterObject.CMThreshold,
                                                                          CharacterObject.StunCMThresholdOffset, 0,
                                                                          chkStunCM_CheckedChanged,
                                                                          true, CharacterObject.StunCMFilled, GenericToken);
                        break;

                    case nameof(Character.PhysicalCM):
                    case nameof(Character.PhysicalCMFilled):
                    case nameof(Character.PhysicalCMThresholdOffset):
                        await ProcessCharacterConditionMonitorBoxDisplays(panPhysicalCM, CharacterObject.PhysicalCM,
                                                                          CharacterObject.CMThreshold,
                                                                          CharacterObject.PhysicalCMThresholdOffset,
                                                                          CharacterObject.CMOverflow,
                                                                          chkPhysicalCM_CheckedChanged, true,
                                                                          CharacterObject.PhysicalCMFilled, GenericToken);
                        break;

                    case nameof(Character.MAGEnabled):
                    {
                        if (CharacterObject.MAGEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabInitiation))
                                    x.TabPages.Insert(3, tabInitiation);
                            }, GenericToken);

                            await UpdateInitiationCost(GenericToken);

                            await LanguageManager.GetStringAsync("Tab_Initiation")
                                                 .ContinueWith(
                                                     y => tabInitiation.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("Button_AddMetamagic")
                                                 .ContinueWith(
                                                     y => cmsMetamagic.DoThreadSafeAsync(
                                                         () => tsMetamagicAddMetamagic.Text = y.Result, GenericToken),
                                                     GenericToken)
                                                 .Unwrap();
                            await LanguageManager.GetStringAsync("Button_AddInitiateGrade")
                                                 .ContinueWith(
                                                     y => cmdAddMetamagic.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("Button_RemoveInitiateGrade")
                                                 .ContinueWith(
                                                     y => cmdDeleteMetamagic.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("String_InitiationType")
                                                 .ContinueWith(
                                                     y => gpbInitiationType.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("String_InitiationGroup")
                                                 .ContinueWith(
                                                     y => gpbInitiationGroup.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            string strText1 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_InitiationOrdeal"),
                                                    CharacterObjectSettings.KarmaMAGInitiationOrdealPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationOrdeal.DoThreadSafeAsync(x => x.Text = strText1, GenericToken);
                            string strText2 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_InitiationGroup"),
                                                    CharacterObjectSettings.KarmaMAGInitiationGroupPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationGroup.DoThreadSafeAsync(x => x.Text = strText2, GenericToken);
                            string strText3 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_InitiationSchooling"),
                                                    CharacterObjectSettings.KarmaMAGInitiationSchoolingPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationSchooling.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText3;
                                x.Enabled = true;
                            }, GenericToken);
                            await cmsMetamagic.DoThreadSafeAsync(() =>
                            {
                                tsMetamagicAddArt.Visible = true;
                                tsMetamagicAddEnchantment.Visible = true;
                                tsMetamagicAddEnhancement.Visible = true;
                                tsMetamagicAddRitual.Visible = true;
                            }, GenericToken);
                            string strInitTip = string.Format(GlobalSettings.CultureInfo,
                                                              await LanguageManager.GetStringAsync(
                                                                  "Tip_ImproveInitiateGrade")
                                                              , CharacterObject.InitiateGrade + 1
                                                              , CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.InitiateGrade + 1) * CharacterObjectSettings.KarmaInitiation);
                            await cmdAddMetamagic.SetToolTipAsync(strInitTip, GenericToken);
                            await LanguageManager.GetStringAsync("Checkbox_JoinedGroup")
                                                 .ContinueWith(
                                                     y => chkJoinGroup.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();

                            if (!await CharacterObject.AttributeSection.Attributes.ContainsAsync(CharacterObject.MAG))
                            {
                                await CharacterObject.AttributeSection.Attributes.AddAsync(CharacterObject.MAG);
                            }

                            if (CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept)
                            {
                                CharacterAttrib objMAGAdept =
                                    CharacterObject.AttributeSection.GetAttributeByName("MAGAdept");
                                if (!await CharacterObject.AttributeSection.Attributes.ContainsAsync(objMAGAdept))
                                {
                                    await CharacterObject.AttributeSection.Attributes.AddAsync(objMAGAdept);
                                }
                            }
                        }
                        else
                        {
                            if (!CharacterObject.RESEnabled)
                                await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation), GenericToken);

                            if (CharacterObject.AttributeSection.Attributes != null)
                            {
                                await CharacterObject.AttributeSection.Attributes.RemoveAsync(CharacterObject.MAG);
                                await CharacterObject.AttributeSection.Attributes.RemoveAsync(CharacterObject.MAGAdept);
                            }
                        }

                        await gpbGearBondedFoci.DoThreadSafeAsync(x => x.Visible = CharacterObject.MAGEnabled, GenericToken);
                        await lblAstralINI.DoThreadSafeAsync(x => x.Visible = CharacterObject.MAGEnabled, GenericToken);

                        await RequestCharacterUpdate();
                    }
                        break;

                    case nameof(Character.RESEnabled):
                    {
                        if (CharacterObject.RESEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabInitiation))
                                    x.TabPages.Insert(3, tabInitiation);
                            }, GenericToken);

                            /*
                            int intEssenceLoss = 0;
                            if (!CharacterObjectSettings.ESSLossReducesMaximumOnly)
                                intEssenceLoss = _objCharacter.EssencePenalty;
                            // If the character options permit submersion in create mode, show the Initiation page.
                            */

                            await UpdateInitiationCost(GenericToken);

                            await LanguageManager.GetStringAsync("Tab_Submersion")
                                                 .ContinueWith(
                                                     y => tabInitiation.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("Button_AddEcho")
                                                 .ContinueWith(
                                                     y => cmsMetamagic.DoThreadSafeAsync(
                                                         () => tsMetamagicAddMetamagic.Text = y.Result, GenericToken),
                                                     GenericToken)
                                                 .Unwrap();
                            await LanguageManager.GetStringAsync("Button_AddSubmersionGrade")
                                                 .ContinueWith(
                                                     y => cmdAddMetamagic.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("Button_RemoveSubmersionGrade")
                                                 .ContinueWith(
                                                     y => cmdDeleteMetamagic.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("String_SubmersionType")
                                                 .ContinueWith(
                                                     y => gpbInitiationType.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("String_SubmersionNetwork")
                                                 .ContinueWith(
                                                     y => gpbInitiationGroup.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            string strText1 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_SubmersionTask"),
                                                    CharacterObjectSettings.KarmaRESInitiationOrdealPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationOrdeal.DoThreadSafeAsync(x => x.Text = strText1, GenericToken);
                            string strText2 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_NetworkSubmersion"),
                                                    CharacterObjectSettings.KarmaRESInitiationGroupPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationGroup.DoThreadSafeAsync(x => x.Text = strText2, GenericToken);
                            string strText3 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_InitiationSchooling"),
                                                    CharacterObjectSettings.KarmaRESInitiationSchoolingPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationSchooling.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText3;
                                x.Enabled = CharacterObjectSettings.AllowTechnomancerSchooling;
                            }, GenericToken);
                            await cmsMetamagic.DoThreadSafeAsync(() =>
                            {
                                tsMetamagicAddArt.Visible = false;
                                tsMetamagicAddEnchantment.Visible = false;
                                tsMetamagicAddEnhancement.Visible = false;
                                tsMetamagicAddRitual.Visible = false;
                            }, GenericToken);
                            string strInitTip = string.Format(GlobalSettings.CultureInfo,
                                                              await LanguageManager.GetStringAsync(
                                                                  "Tip_ImproveSubmersionGrade")
                                                              , CharacterObject.SubmersionGrade + 1
                                                              , CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.SubmersionGrade + 1) * CharacterObjectSettings.KarmaInitiation);
                            await cmdAddMetamagic.SetToolTipAsync(strInitTip, GenericToken);
                            await LanguageManager.GetStringAsync("Checkbox_JoinedNetwork")
                                                 .ContinueWith(
                                                     y => chkJoinGroup.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();

                            if (CharacterObject.AttributeSection.Attributes != null && !await CharacterObject.AttributeSection.Attributes.ContainsAsync(
                                    CharacterObject.RES))
                            {
                                await CharacterObject.AttributeSection.Attributes.AddAsync(CharacterObject.RES);
                            }
                        }
                        else
                        {
                            if (!CharacterObject.MAGEnabled)
                                await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation), GenericToken);
                            if (CharacterObject.AttributeSection.Attributes != null)
                            {
                                await CharacterObject.AttributeSection.Attributes.RemoveAsync(CharacterObject.RES);
                            }
                        }
                        await RequestCharacterUpdate();
                    }
                        break;

                    case nameof(Character.DEPEnabled):
                    {
                        if (CharacterObject.AttributeSection.Attributes != null)
                        {
                            if (CharacterObject.DEPEnabled)
                            {
                                if (!await CharacterObject.AttributeSection.Attributes.ContainsAsync(
                                        CharacterObject.DEP))
                                {
                                    await CharacterObject.AttributeSection.Attributes.AddAsync(CharacterObject.DEP);
                                }
                            }
                            else
                            {
                                await CharacterObject.AttributeSection.Attributes.RemoveAsync(CharacterObject.DEP);
                            }
                        }
                    }
                        break;

                    case nameof(Character.Ambidextrous):
                    {
                        using (new FetchSafelyFromPool<List<ListItem>>(
                                   Utils.ListItemListPool, out List<ListItem> lstPrimaryArm))
                        {
                            if (CharacterObject.Ambidextrous)
                            {
                                lstPrimaryArm.Add(new ListItem("Ambidextrous",
                                                               await LanguageManager.GetStringAsync(
                                                                   "String_Ambidextrous")));
                                await cboPrimaryArm.DoThreadSafeAsync(x => x.Enabled = false, GenericToken);
                            }
                            else
                            {
                                //Create the dropdown for the character's primary arm.
                                lstPrimaryArm.Add(new ListItem(
                                                      "Left",
                                                      await LanguageManager.GetStringAsync(
                                                          "String_Improvement_SideLeft")));
                                lstPrimaryArm.Add(new ListItem(
                                                      "Right",
                                                      await LanguageManager.GetStringAsync(
                                                          "String_Improvement_SideRight")));
                                lstPrimaryArm.Sort(CompareListItems.CompareNames);
                                await cboPrimaryArm.DoThreadSafeAsync(x => x.Enabled = true, GenericToken);
                            }

                            string strPrimaryArm = CharacterObject.PrimaryArm;

                            await cboPrimaryArm.PopulateWithListItemsAsync(lstPrimaryArm, GenericToken);
                            await cboPrimaryArm.DoThreadSafeAsync(x =>
                            {
                                x.SelectedValue = strPrimaryArm;
                                if (x.SelectedIndex == -1)
                                    x.SelectedIndex = 0;
                            }, GenericToken);
                        }
                    }
                        break;

                    case nameof(Character.MagicianEnabled):
                    {
                        // Change to the status of Magician being enabled.
                        if (CharacterObject.MagicianEnabled || CharacterObject.AdeptEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabMagician))
                                    x.TabPages.Insert(3, tabMagician);
                            }, GenericToken);
                            await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, GenericToken);
                            if (CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept)
                            {
                                CharacterAttrib objMAGAdept =
                                    CharacterObject.AttributeSection.GetAttributeByName("MAGAdept");
                                if (!await CharacterObject.AttributeSection.Attributes.ContainsAsync(objMAGAdept))
                                {
                                    await CharacterObject.AttributeSection.Attributes.AddAsync(objMAGAdept);
                                }
                            }
                        }
                        else
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabMagician), GenericToken);
                            await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = false, GenericToken);
                            if (CharacterObjectSettings.MysAdeptSecondMAGAttribute)
                            {
                                CharacterAttrib objMAGAdept =
                                    CharacterObject.AttributeSection.GetAttributeByName("MAGAdept");
                                if (await CharacterObject.AttributeSection.Attributes.ContainsAsync(objMAGAdept))
                                {
                                    await CharacterObject.AttributeSection.Attributes.RemoveAsync(objMAGAdept);
                                }
                            }
                        }

                        await cmdAddSpirit.DoThreadSafeAsync(x => x.Visible = CharacterObject.MagicianEnabled, GenericToken);
                        await panSpirits.DoThreadSafeAsync(x => x.Visible = CharacterObject.MagicianEnabled, GenericToken);
                    }
                        break;

                    case nameof(Character.AdeptEnabled):
                    {
                        // Change to the status of Adept being enabled.
                        if (CharacterObject.AdeptEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabMagician))
                                    x.TabPages.Insert(3, tabMagician);
                            }, GenericToken);
                            await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, GenericToken);
                            if (CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept)
                            {
                                CharacterAttrib objMAGAdept =
                                    CharacterObject.AttributeSection.GetAttributeByName("MAGAdept");
                                if (!await CharacterObject.AttributeSection.Attributes.ContainsAsync(objMAGAdept))
                                {
                                    await CharacterObject.AttributeSection.Attributes.AddAsync(objMAGAdept);
                                }
                            }

                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabAdept))
                                    x.TabPages.Insert(3, tabAdept);
                            }, GenericToken);
                        }
                        else
                        {
                            if (!CharacterObject.MagicianEnabled)
                            {
                                await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabMagician), GenericToken);
                                await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = false, GenericToken);
                                if (CharacterObjectSettings.MysAdeptSecondMAGAttribute)
                                {
                                    CharacterAttrib objMAGAdept =
                                        CharacterObject.AttributeSection.GetAttributeByName("MAGAdept");
                                    if (await CharacterObject.AttributeSection.Attributes.ContainsAsync(objMAGAdept))
                                    {
                                        await CharacterObject.AttributeSection.Attributes.RemoveAsync(objMAGAdept);
                                    }
                                }
                            }
                            else
                                await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, GenericToken);

                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabAdept), GenericToken);
                        }
                    }
                        break;

                    case nameof(Character.TechnomancerEnabled):
                    {
                        // Change to the status of Technomancer being enabled.
                        if (CharacterObject.TechnomancerEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabTechnomancer))
                                    x.TabPages.Insert(3, tabTechnomancer);
                            }, GenericToken);
                        }
                        else
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabTechnomancer), GenericToken);
                        }
                    }
                        break;

                    case nameof(Character.AdvancedProgramsEnabled):
                    {
                        // Change to the status of Advanced Programs being enabled.
                        if (CharacterObject.AdvancedProgramsEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabAdvancedPrograms))
                                    x.TabPages.Insert(3, tabAdvancedPrograms);
                            }, GenericToken);
                        }
                        else
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabAdvancedPrograms), GenericToken);
                        }
                    }
                        break;

                    case nameof(Character.CritterEnabled):
                    {
                        // Change the status of Critter being enabled.
                        if (CharacterObject.CritterEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabCritter))
                                    x.TabPages.Insert(3, tabCritter);
                            }, GenericToken);
                        }
                        else
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabCritter), GenericToken);
                        }
                    }
                        break;

                    case nameof(Character.AddBiowareEnabled):
                    {
                        if (!CharacterObject.AddBiowareEnabled)
                        {
                            string strBiowareDisabledSource = string.Empty;
                            Improvement objDisablingImprovement = (await ImprovementManager
                                    .GetCachedImprovementListForValueOfAsync(
                                        CharacterObject,
                                        Improvement.ImprovementType.DisableBioware))
                                .FirstOrDefault();
                            if (objDisablingImprovement != null)
                            {
                                strBiowareDisabledSource =
                                    await LanguageManager.GetStringAsync("String_Space") + '(' +
                                    await CharacterObject.GetObjectNameAsync(objDisablingImprovement, token: GenericToken) + ')' +
                                    await LanguageManager.GetStringAsync("String_Space");
                            }

                            foreach (Cyberware objCyberware in CharacterObject.Cyberware.DeepWhere(x => x.Children,
                                         x => x.SourceType == Improvement.ImprovementSource.Bioware
                                              && x.SourceID != Cyberware.EssenceHoleGUID
                                              && x.SourceID != Cyberware.EssenceAntiHoleGUID
                                              && x.IsModularCurrentlyEquipped).ToList())
                            {
                                if (!string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount))
                                {
                                    if (!objCyberware.CanRemoveThroughImprovements)
                                        continue;
                                    if (objCyberware.Parent != null)
                                        await objCyberware.Parent.Children.RemoveAsync(objCyberware);
                                    await CharacterObject.Cyberware.AddAsync(objCyberware);
                                    objCyberware.ChangeModularEquip(false);
                                }
                                else if (objCyberware.CanRemoveThroughImprovements)
                                {
                                    objCyberware.DeleteCyberware();
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    string strEntry = await LanguageManager.GetStringAsync("String_ExpenseSoldBioware");
                                    objExpense.Create(0,
                                                      strEntry + strBiowareDisabledSource +
                                                      objCyberware.CurrentDisplayNameShort,
                                                      ExpenseType.Nuyen,
                                                      DateTime.Now);
                                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                                }
                            }
                        }

                        break;
                    }
                    case nameof(Character.AddCyberwareEnabled):
                    {
                        if (!CharacterObject.AddCyberwareEnabled)
                        {
                            string strCyberwareDisabledSource = string.Empty;
                            Improvement objDisablingImprovement = (await ImprovementManager
                                    .GetCachedImprovementListForValueOfAsync(
                                        CharacterObject,
                                        Improvement.ImprovementType.DisableCyberware))
                                .FirstOrDefault();
                            if (objDisablingImprovement != null)
                            {
                                strCyberwareDisabledSource =
                                    await LanguageManager.GetStringAsync("String_Space") + '(' +
                                    await CharacterObject.GetObjectNameAsync(objDisablingImprovement, token: GenericToken) + ')' +
                                    await LanguageManager.GetStringAsync("String_Space");
                            }

                            foreach (Cyberware objCyberware in CharacterObject.Cyberware.DeepWhere(x => x.Children,
                                         x => x.SourceType == Improvement.ImprovementSource.Cyberware
                                              && x.SourceID != Cyberware.EssenceHoleGUID
                                              && x.SourceID != Cyberware.EssenceAntiHoleGUID
                                              && x.IsModularCurrentlyEquipped).ToList())
                            {
                                if (!string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount))
                                {
                                    if (!objCyberware.CanRemoveThroughImprovements)
                                        continue;
                                    if (objCyberware.Parent != null)
                                        await objCyberware.Parent.Children.RemoveAsync(objCyberware);
                                    await CharacterObject.Cyberware.AddAsync(objCyberware);
                                    objCyberware.ChangeModularEquip(false);
                                }
                                else if (objCyberware.CanRemoveThroughImprovements)
                                {
                                    objCyberware.DeleteCyberware();
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    string strEntry
                                        = await LanguageManager.GetStringAsync("String_ExpenseSoldCyberware");
                                    objExpense.Create(0,
                                                      strEntry + strCyberwareDisabledSource +
                                                      objCyberware.CurrentDisplayNameShort,
                                                      ExpenseType.Nuyen,
                                                      DateTime.Now);
                                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                                }
                            }
                        }

                        break;
                    }
                    case nameof(Character.ExCon):
                    {
                        if (CharacterObject.ExCon)
                        {
                            string strExConString = string.Empty;
                            Improvement objExConImprovement = (await ImprovementManager
                                    .GetCachedImprovementListForValueOfAsync(
                                        CharacterObject,
                                        Improvement.ImprovementType.ExCon))
                                .FirstOrDefault();
                            if (objExConImprovement != null)
                            {
                                strExConString = await LanguageManager.GetStringAsync("String_Space") + '(' +
                                                 await CharacterObject.GetObjectNameAsync(objExConImprovement, token: GenericToken) + ')' +
                                                 await LanguageManager.GetStringAsync("String_Space");
                            }

                            foreach (Cyberware objCyberware in CharacterObject.Cyberware.DeepWhere(x => x.Children,
                                         x => x.Grade.Name != "None"
                                              && x.SourceID != Cyberware.EssenceHoleGUID
                                              && x.SourceID != Cyberware.EssenceAntiHoleGUID
                                              && x.IsModularCurrentlyEquipped).ToList())
                            {
                                char chrAvail = objCyberware.TotalAvailTuple(false).Suffix;
                                if (chrAvail != 'R' && chrAvail != 'F')
                                    continue;
                                if (!string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount))
                                {
                                    if (!objCyberware.CanRemoveThroughImprovements)
                                        continue;
                                    if (objCyberware.Parent != null)
                                        await objCyberware.Parent.Children.RemoveAsync(objCyberware);
                                    await CharacterObject.Cyberware.AddAsync(objCyberware);
                                    objCyberware.ChangeModularEquip(false);
                                }
                                else if (objCyberware.CanRemoveThroughImprovements)
                                {
                                    objCyberware.DeleteCyberware();
                                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                                    string strEntry = await LanguageManager.GetStringAsync(
                                        objCyberware.SourceType == Improvement.ImprovementSource.Cyberware
                                            ? "String_ExpenseSoldCyberware"
                                            : "String_ExpenseSoldBioware");
                                    objExpense.Create(0,
                                                      strEntry + strExConString
                                                               + objCyberware.CurrentDisplayNameShort,
                                                      ExpenseType.Nuyen, DateTime.Now);
                                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                                }
                            }
                        }
                    }
                        break;

                    case nameof(Character.InitiationEnabled):
                    {
                        // Change the status of the Initiation tab being show.
                        if (CharacterObject.InitiationEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabInitiation))
                                    x.TabPages.Insert(3, tabInitiation);
                            }, GenericToken);
                        }
                        else
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation), GenericToken);
                        }

                        await gpbInitiationType.DoThreadSafeAsync(x => x.Visible = CharacterObject.InitiationEnabled, GenericToken);
                        await gpbInitiationGroup.DoThreadSafeAsync(x => x.Visible = CharacterObject.InitiationEnabled, GenericToken);
                    }
                        break;

                    case nameof(Character.QuickeningEnabled):
                    {
                        await cmdQuickenSpell.DoThreadSafeAsync(x => x.Visible = CharacterObject.QuickeningEnabled, GenericToken);
                        break;
                    }
                    case nameof(Character.FirstMentorSpiritDisplayName):
                    {
                        MentorSpirit objMentor = await CharacterObject.MentorSpirits.FirstOrDefaultAsync(GenericToken);
                        if (objMentor != null)
                        {
                            await objMentor.SetSourceDetailAsync(lblMentorSpiritSource, GenericToken);
                            await objMentor.SetSourceDetailAsync(lblParagonSource, GenericToken);
                        }

                        break;
                    }
                    case nameof(Character.HasMentorSpirit):
                    {
                        await gpbMagicianMentorSpirit.DoThreadSafeAsync(
                            x => x.Visible = CharacterObject.HasMentorSpirit, GenericToken);
                        await gpbTechnomancerParagon.DoThreadSafeAsync(
                            x => x.Visible = CharacterObject.HasMentorSpirit, GenericToken);
                        break;
                    }
                    case nameof(Character.UseMysticAdeptPPs):
                    {
                        await lblMysticAdeptAssignment.DoThreadSafeAsync(
                            x => x.Visible = CharacterObject.UseMysticAdeptPPs, GenericToken);
                        await lblMysticAdeptMAGAdept.DoThreadSafeAsync(
                            x => x.Visible = CharacterObject.UseMysticAdeptPPs, GenericToken);
                        break;
                    }
                    case nameof(Character.MysAdeptAllowPPCareer):
                    {
                        await cmdIncreasePowerPoints.DoThreadSafeAsync(
                            x => x.Visible = CharacterObject.MysAdeptAllowPPCareer, GenericToken);
                        break;
                    }
                    case nameof(Character.MetatypeCategory):
                    {
                        await RequestCharacterUpdate();
                        await mnuCreateMenu.DoThreadSafeAsync(
                            () => mnuSpecialCyberzombie.Visible = CharacterObject.MetatypeCategory != "Cyberzombie", GenericToken);
                        break;
                    }
                    case nameof(Character.IsSprite):
                    {
                        await RequestCharacterUpdate();
                        await mnuCreateMenu.DoThreadSafeAsync(
                            () => mnuSpecialConvertToFreeSprite.Visible = CharacterObject.IsSprite, GenericToken);
                        break;
                    }
                    case nameof(Character.Settings):
                    {
                        if (!IsLoading)
                        {
                            foreach (PropertyInfo objProperty in typeof(CharacterSettings).GetProperties())
                                await DoOnCharacterSettingsPropertyChanged(
                                    new PropertyChangedEventArgs(objProperty.Name));
                        }

                        break;
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void OnCharacterSettingsPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            await DoOnCharacterSettingsPropertyChanged(e);
        }

        private async ValueTask DoOnCharacterSettingsPropertyChanged(PropertyChangedEventArgs e)
        {
            try
            {
                switch (e.PropertyName)
                {
                    case nameof(CharacterSettings.ArmorDegradation):
                        await this.DoThreadSafeAsync(() =>
                        {
                            cmdArmorDecrease.Visible = CharacterObjectSettings.ArmorDegradation;
                            cmdArmorIncrease.Visible = CharacterObjectSettings.ArmorDegradation;
                        }, GenericToken);
                        break;
                    case nameof(CharacterSettings.Books):
                    {
                        if (IsLoading)
                            break;
                        using (await CursorWait.NewAsync(this, token: GenericToken))
                        {
                            await this.DoThreadSafeAsync(x => x.SuspendLayout(), GenericToken);
                            try
                            {
                                await cmdAddLifestyle.DoThreadSafeAsync(x => x.SplitMenuStrip =
                                                                            CharacterObjectSettings.BookEnabled("RF")
                                                                                ? cmsAdvancedLifestyle
                                                                                : null, GenericToken);

                                if (!CharacterObjectSettings.BookEnabled("FA"))
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        lblWildReputation.Visible = false;
                                        nudWildReputation.Visible = false;
                                        lblWildReputationTotal.Visible = false;
                                        if (!CharacterObjectSettings.BookEnabled("SG"))
                                        {
                                            lblAstralReputation.Visible = false;
                                            nudAstralReputation.Visible = false;
                                            lblAstralReputationTotal.Visible = false;
                                        }
                                        else
                                        {
                                            lblAstralReputation.Visible = true;
                                            nudAstralReputation.Visible = true;
                                            lblAstralReputationTotal.Visible = true;
                                        }
                                    }, GenericToken);
                                }
                                else
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        lblWildReputation.Visible = true;
                                        nudWildReputation.Visible = true;
                                        lblWildReputationTotal.Visible = true;
                                        lblAstralReputation.Visible = true;
                                        nudAstralReputation.Visible = true;
                                        lblAstralReputationTotal.Visible = true;
                                    }, GenericToken);
                                }

                                // Refresh all trees because enabled sources can change the nodes that are visible
                                await RefreshQualities(treQualities, cmsQuality);
                                await RefreshSpirits(panSpirits, panSprites);
                                await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes);
                                await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm, cmsInitiationNotes);
                                await RefreshPowerCollectionListChanged(treMetamagic, cmsMetamagic, cmsInitiationNotes);
                                await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes);
                                await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram);
                                await RefreshCritterPowers(treCritterPowers, cmsCritterPowers);
                                await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique);
                                await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle);
                                await RefreshContacts(panContacts, panEnemies, panPets);
                                await RefreshSustainedSpells(flpSustainedSpells, flpSustainedComplexForms,
                                                       flpSustainedCritterPowers, chkPsycheActiveMagician,
                                                       chkPsycheActiveTechnomancer);

                                await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod, cmsArmorGear);
                                await RefreshGears(treGear, cmsGearLocation, cmsGear,
                                    await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, GenericToken),
                                    await chkHideLoadedAmmo.DoThreadSafeFuncAsync(x => x.Checked, GenericToken));
                                await RefreshFociFromGear(treFoci, null);
                                await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear);
                                await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon, cmsWeaponAccessory,
                                               cmsWeaponAccessoryGear);
                                await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle, cmsVehicleWeapon,
                                                cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear,
                                                cmsVehicleGear,
                                                cmsWeaponMount,
                                                cmsVehicleCyberware, cmsVehicleCyberwareGear);
                                await RefreshDrugs(treCustomDrugs);
                                await this.DoThreadSafeAsync(() =>
                                {
                                    treWeapons.SortCustomOrder();
                                    treArmor.SortCustomOrder();
                                    treGear.SortCustomOrder();
                                    treLifestyles.SortCustomOrder();
                                    treCustomDrugs.SortCustomOrder();
                                    treCyberware.SortCustomOrder();
                                    treVehicles.SortCustomOrder();
                                    treCritterPowers.SortCustomOrder();
                                }, GenericToken);

                                XPathNavigator xmlTraditionsBaseChummerNode =
                                    await (await CharacterObject.LoadDataXPathAsync("traditions.xml", token: GenericToken))
                                        .SelectSingleNodeAndCacheExpressionAsync("/chummer");
                                using (new FetchSafelyFromPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstTraditions))
                                {
                                    if (xmlTraditionsBaseChummerNode != null)
                                    {
                                        foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                     "traditions/tradition[" + CharacterObjectSettings.BookXPath()
                                                                             + ']'))
                                        {
                                            string strName
                                                = (await xmlTradition.SelectSingleNodeAndCacheExpressionAsync("name"))
                                                ?.Value;
                                            if (!string.IsNullOrEmpty(strName))
                                                lstTraditions.Add(new ListItem(
                                                                      (await xmlTradition
                                                                          .SelectSingleNodeAndCacheExpressionAsync(
                                                                              "id"))
                                                                      ?.Value ?? strName,
                                                                      (await xmlTradition
                                                                          .SelectSingleNodeAndCacheExpressionAsync(
                                                                              "translate"))
                                                                      ?.Value ?? strName));
                                        }
                                    }

                                    if (lstTraditions.Count > 1)
                                    {
                                        lstTraditions.Sort(CompareListItems.CompareNames);
                                        lstTraditions.Insert(
                                            0,
                                            new ListItem("None", await LanguageManager.GetStringAsync("String_None")));
                                        if (!lstTraditions.SequenceEqual(
                                                await cboTradition.DoThreadSafeFuncAsync(
                                                    x => x.Items.Cast<ListItem>(), GenericToken)))
                                        {
                                            await cboTradition.PopulateWithListItemsAsync(lstTraditions, GenericToken);
                                            await cboTradition.DoThreadSafeAsync(x =>
                                            {
                                                if (CharacterObject.MagicTradition.Type == TraditionType.MAG)
                                                    x.SelectedValue
                                                        = CharacterObject.MagicTradition.SourceID.ToString();
                                                else if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                    x.SelectedIndex = 0;
                                            }, GenericToken);
                                        }
                                    }
                                    else
                                    {
                                        await this.DoThreadSafeAsync(() =>
                                        {
                                            cboTradition.Visible = false;
                                            lblTraditionLabel.Visible = false;
                                        }, GenericToken);
                                    }
                                }

                                using (new FetchSafelyFromPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstDrainAttributes))
                                {
                                    if (xmlTraditionsBaseChummerNode != null)
                                    {
                                        foreach (XPathNavigator xmlDrain in await xmlTraditionsBaseChummerNode
                                                     .SelectAndCacheExpressionAsync(
                                                         "drainattributes/drainattribute"))
                                        {
                                            string strName
                                                = (await xmlDrain.SelectSingleNodeAndCacheExpressionAsync("name"))
                                                ?.Value;
                                            if (!string.IsNullOrEmpty(strName)
                                                && lstDrainAttributes.All(x => x.Value.ToString() != strName))
                                            {
                                                string strTranslatedName = (await xmlDrain
                                                    .SelectSingleNodeAndCacheExpressionAsync(
                                                        "translate"))?.Value ?? strName;
                                                lstDrainAttributes.Add(new ListItem(strName, strTranslatedName));
                                            }
                                        }
                                    }

                                    lstDrainAttributes.Sort(CompareListItems.CompareNames);
                                    lstDrainAttributes.Insert(0, ListItem.Blank);
                                    await cboDrain.PopulateWithListItemsAsync(lstDrainAttributes, GenericToken);
                                }

                                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                           out HashSet<string> limit))
                                {
                                    foreach (Improvement improvement in await ImprovementManager
                                                 .GetCachedImprovementListForValueOfAsync(
                                                     CharacterObject, Improvement.ImprovementType.LimitSpiritCategory))
                                    {
                                        limit.Add(improvement.ImprovedName);
                                    }

                                    using (new FetchSafelyFromPool<List<ListItem>>(
                                               Utils.ListItemListPool, out List<ListItem> lstSpirit))
                                    {
                                        lstSpirit.Add(ListItem.Blank);
                                        if (xmlTraditionsBaseChummerNode != null)
                                        {
                                            foreach (XPathNavigator xmlSpirit in await xmlTraditionsBaseChummerNode
                                                         .SelectAndCacheExpressionAsync("spirits/spirit"))
                                            {
                                                string strSpiritName
                                                    = (await xmlSpirit.SelectSingleNodeAndCacheExpressionAsync("name"))
                                                    ?.Value;
                                                if (!string.IsNullOrEmpty(strSpiritName)
                                                    && (limit.Count == 0 || limit.Contains(strSpiritName)))
                                                {
                                                    lstSpirit.Add(new ListItem(strSpiritName,
                                                                               (await xmlSpirit
                                                                                   .SelectSingleNodeAndCacheExpressionAsync(
                                                                                       "translate"))?.Value
                                                                               ?? strSpiritName));
                                                }
                                            }
                                        }

                                        lstSpirit.Sort(CompareListItems.CompareNames);
                                        await cboSpiritCombat.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                        await cboSpiritDetection.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                        await cboSpiritHealth.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                        await cboSpiritIllusion.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                        await cboSpiritManipulation.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                    }
                                }

                                // Populate the Technomancer Streams list.
                                xmlTraditionsBaseChummerNode =
                                    await (await CharacterObject.LoadDataXPathAsync("streams.xml", token: GenericToken))
                                        .SelectSingleNodeAndCacheExpressionAsync("/chummer");
                                using (new FetchSafelyFromPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstStreams))
                                {
                                    if (xmlTraditionsBaseChummerNode != null)
                                    {
                                        foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                     "traditions/tradition[" + CharacterObjectSettings.BookXPath()
                                                                             + ']'))
                                        {
                                            string strName
                                                = (await xmlTradition.SelectSingleNodeAndCacheExpressionAsync("name"))
                                                ?.Value;
                                            if (!string.IsNullOrEmpty(strName))
                                                lstStreams.Add(new ListItem(
                                                                   (await xmlTradition
                                                                       .SelectSingleNodeAndCacheExpressionAsync("id"))
                                                                   ?.Value ?? strName,
                                                                   (await xmlTradition
                                                                       .SelectSingleNodeAndCacheExpressionAsync(
                                                                           "translate"))
                                                                   ?.Value ?? strName));
                                        }
                                    }

                                    if (lstStreams.Count > 1)
                                    {
                                        lstStreams.Sort(CompareListItems.CompareNames);
                                        lstStreams.Insert(
                                            0,
                                            new ListItem("None", await LanguageManager.GetStringAsync("String_None")));
                                        if (!lstStreams.SequenceEqual(
                                                await cboStream.DoThreadSafeFuncAsync(x => x.Items.Cast<ListItem>(), GenericToken)))
                                        {
                                            await cboStream.PopulateWithListItemsAsync(lstStreams, GenericToken);
                                            await cboStream.DoThreadSafeAsync(x =>
                                            {
                                                if (CharacterObject.MagicTradition.Type == TraditionType.RES)
                                                    x.SelectedValue
                                                        = CharacterObject.MagicTradition.SourceID.ToString();
                                                else if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                    x.SelectedIndex = 0;
                                            }, GenericToken);
                                        }
                                    }
                                    else
                                    {
                                        await this.DoThreadSafeAsync(() =>
                                        {
                                            cboStream.Visible = false;
                                            lblStreamLabel.Visible = false;
                                        }, GenericToken);
                                    }
                                }

                                await RefreshSelectedVehicle(GenericToken);
                            }
                            finally
                            {
                                await this.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken);
                            }
                        }

                        break;
                    }
                    case nameof(CharacterSettings.AllowFreeGrids):
                    {
                        if (!CharacterObjectSettings.BookEnabled("HT"))
                        {
                            using (await CursorWait.NewAsync(this, token: GenericToken))
                            {
                                await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle);
                                await treLifestyles.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                            }
                        }

                        break;
                    }
                    case nameof(CharacterSettings.EnableEnemyTracking):
                    {
                        using (await CursorWait.NewAsync(this, token: GenericToken))
                        {
                            await this.DoThreadSafeAsync(x =>
                                      {
                                          x.SuspendLayout();
                                          try
                                          {
                                              if (!CharacterObjectSettings.EnableEnemyTracking)
                                              {
                                                  tabPeople.TabPages.Remove(tabEnemies);
                                              }
                                              else
                                              {
                                                  if (!tabPeople.TabPages.Contains(tabEnemies))
                                                      tabPeople.TabPages.Insert(
                                                          tabPeople.TabPages.IndexOf(tabContacts) + 1,
                                                          tabEnemies);
                                              }
                                          }
                                          finally
                                          {
                                              x.ResumeLayout();
                                          }
                                      }, GenericToken)
                                      .ContinueWith(y => RefreshContacts(panContacts, panEnemies, panPets),
                                                    GenericToken)
                                      .Unwrap();
                        }

                        break;
                    }
                }
            }
            finally
            {
                await RequestCharacterUpdate();
            }
        }

        /*
        //TODO: UpdatePowerRelatedInfo method? Powers hook into so much stuff that it may need to wait for outbound improvement events?
        private readonly Stopwatch PowerPropertyChanged_StopWatch = Stopwatch.StartNew();
        private void PowerPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            await SetDirty(true);

            if (PowerPropertyChanged_StopWatch.ElapsedMilliseconds < 4) return;
            PowerPropertyChanged_StopWatch.Restart();
            tabPowerUc.CalculatePowerPoints();
            await RequestCharacterUpdate();
        }

        private readonly Stopwatch SkillPropertyChanged_StopWatch = Stopwatch.StartNew();
        private void SkillPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            //HACK PERFORMANCE
            //So, skills tell if anything maybe interesting have happened, but this don't have any way to see if it is relevant. Instead of redrawing EVERY FYCKING THING we do it only every 5 ms
            if (SkillPropertyChanged_StopWatch.ElapsedMilliseconds < 4) return;
            SkillPropertyChanged_StopWatch.Restart();

            await RequestCharacterUpdate();

            await SetDirty(true);
        }
        */

        #endregion Character Events

        #region Menu Events

        private async void mnuFileSave_Click(object sender, EventArgs e)
        {
            try
            {
                await SaveCharacter(token: GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuFileSaveAs_Click(object sender, EventArgs e)
        {
            try
            {
                await SaveCharacterAs(token: GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void mnuFileClose_Click(object sender, EventArgs e)
        {
            Close();
        }

        private async void mnuFilePrint_Click(object sender, EventArgs e)
        {
            try
            {
                await DoPrint(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuFileExport_Click(object sender, EventArgs e)
        {
            try
            {
                await DoExport(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialCyberzombie_Click(object sender, EventArgs e)
        {
            await CharacterObject.ConvertCyberzombie();
        }

        private async void mnuSpecialReduceAttribute_Click(object sender, EventArgs e)
        {
            List<string> lstAbbrevs = new List<string>(AttributeSection.AttributeStrings);

            lstAbbrevs.Remove("ESS");
            if (!CharacterObject.MAGEnabled)
            {
                lstAbbrevs.Remove("MAG");
                lstAbbrevs.Remove("MAGAdept");
            }
            else if (!CharacterObject.IsMysticAdept || !CharacterObjectSettings.MysAdeptSecondMAGAttribute)
                lstAbbrevs.Remove("MAGAdept");

            if (!CharacterObject.RESEnabled)
                lstAbbrevs.Remove("RES");
            if (!CharacterObject.DEPEnabled)
                lstAbbrevs.Remove("DEP");

            string strDescription = await LanguageManager.GetStringAsync("String_CyberzombieReduceAttribute");
            // Display the Select CharacterAttribute window and record which Skill was selected.
            using (ThreadSafeForm<SelectAttribute> frmPickAttribute = await ThreadSafeForm<SelectAttribute>.GetAsync(() => new SelectAttribute(lstAbbrevs.ToArray())
                   {
                       Description = strDescription,
                       ShowMetatypeMaximum = true
                   }))
            {
                if (await frmPickAttribute.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // Create an Improvement to reduce the CharacterAttribute's Metatype Maximum.
                if (!frmPickAttribute.MyForm.DoNotAffectMetatypeMaximum)
                {
                    await ImprovementManager.CreateImprovementAsync(CharacterObject, frmPickAttribute.MyForm.SelectedAttribute, Improvement.ImprovementSource.AttributeLoss, string.Empty, Improvement.ImprovementType.Attribute, string.Empty, 0, 1, 0, -1);
                    await ImprovementManager.CommitAsync(CharacterObject);
                }

                // Permanently reduce the CharacterAttribute's value.
                CharacterObject.GetAttribute(frmPickAttribute.MyForm.SelectedAttribute).Degrade(1);
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void mnuSpecialCloningMachine_Click(object sender, EventArgs e)
        {
            string strDescription = await LanguageManager.GetStringAsync("String_CloningMachineNumber");
            try
            {
                int intClones;
                using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(() => new SelectNumber(0)
                       {
                           Description = strDescription,
                           Minimum = 1
                       }, GenericToken))
                {
                    if (await frmPickNumber.ShowDialogSafeAsync(this, GenericToken) == DialogResult.Cancel)
                        return;

                    intClones = frmPickNumber.MyForm.SelectedValue.ToInt32();
                }

                if (intClones <= 0)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CloningMachineNumberRequired"), await LanguageManager.GetStringAsync("MessageTitle_CloningMachineNumberRequired"), MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                using (await CursorWait.NewAsync(this, token: GenericToken))
                {
                    Character[] lstClones = new Character[intClones];
                    using (ThreadSafeForm<LoadingBar> frmLoadingBar = await Program.CreateAndShowProgressBarAsync(CharacterObject.Alias, Character.NumLoadingSections * intClones))
                    {
                        string strSpace = await LanguageManager.GetStringAsync("String_Space");
                        Task<Character>[] tskLoadingTasks = new Task<Character>[intClones];
                        for (int i = 0; i < intClones; ++i)
                        {
                            string strNewName = CharacterObject.Alias + strSpace + i.ToString(GlobalSettings.CultureInfo);
                            tskLoadingTasks[i]
                                // ReSharper disable once AccessToDisposedClosure
                                = Task.Run(() => Program.LoadCharacterAsync(CharacterObject.FileName, strNewName, true, frmLoadingBar: frmLoadingBar.MyForm));
                        }

                        // Await structure prevents UI thread lock-ups if the LoadCharacter() function shows any messages
                        await Task.WhenAll(tskLoadingTasks);
                        for (int i = 0; i < intClones; ++i)
                            lstClones[i] = await tskLoadingTasks[i];
                    }
                    await Program.OpenCharacterList(lstClones, false, GenericToken);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialReapplyImprovements_Click(object sender, EventArgs e)
        {
            // This only re-applies the Improvements for everything the character has. If a match is not found in the data files, the current Improvement information is left as-is.
            // Verify that the user wants to go through with it.
            if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ConfirmReapplyImprovements"), await LanguageManager.GetStringAsync("MessageTitle_ConfirmReapplyImprovements"), MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                return;

            try
            {
                await DoReapplyImprovements(token: GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async ValueTask DoReapplyImprovements(ICollection<string> lstInternalIdFilter = null, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            using (await CursorWait.NewAsync(this, token: token))
            {
                IAsyncDisposable objLocker
                    = await CharacterObject.LockObject.EnterWriteLockAsync(token);
                try
                {
                    token.ThrowIfCancellationRequested();
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdOutdatedItems))
                    {
                        // Record the status of any flags that normally trigger character events.
                        bool blnMAGEnabled = CharacterObject.MAGEnabled;
                        bool blnRESEnabled = CharacterObject.RESEnabled;
                        bool blnDEPEnabled = CharacterObject.DEPEnabled;
                        decimal decEssenceAtSpecialStart = CharacterObject.EssenceAtSpecialStart;

                        _blnReapplyImprovements = true;

                        // Wipe all improvements that we will reapply, this is mainly to eliminate orphaned improvements caused by certain bugs and also for a performance increase
                        if (lstInternalIdFilter == null)
                            await ImprovementManager.RemoveImprovementsAsync(
                                CharacterObject, CharacterObject.Improvements.Where(
                                                                    x =>
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource.AIProgram
                                                                        ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource.Armor ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource.ArmorMod
                                                                        ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource.Bioware
                                                                        ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource
                                                                            .ComplexForm
                                                                        ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource
                                                                            .CritterPower
                                                                        ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource.Cyberware
                                                                        ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource.Echo ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource.Gear ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource
                                                                            .MartialArt ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource
                                                                            .MartialArtTechnique ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource.Metamagic
                                                                        ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource.Power ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource.Quality
                                                                        ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource.Spell ||
                                                                        x.ImproveSource
                                                                        == Improvement.ImprovementSource
                                                                            .StackedFocus)
                                                                .ToList(), _blnReapplyImprovements);
                        else
                            await ImprovementManager.RemoveImprovementsAsync(
                                CharacterObject, CharacterObject.Improvements.Where(
                                    x => lstInternalIdFilter.Contains(x.SourceName) &&
                                         (x.ImproveSource
                                          == Improvement.ImprovementSource.AIProgram
                                          ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.Armor ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.ArmorMod ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.Bioware ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.ComplexForm
                                          ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource
                                                        .CritterPower ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.Cyberware
                                          ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.Echo ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.Gear ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.MartialArt
                                          ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource
                                                        .MartialArtTechnique ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.Metamagic
                                          ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.Power ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.Quality ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource.Spell ||
                                          x.ImproveSource
                                          == Improvement.ImprovementSource
                                                        .StackedFocus)).ToList(),
                                _blnReapplyImprovements);

                        // Refresh Qualities.
                        // We cannot use foreach because qualities can add more qualities
                        for (int j = 0; j < CharacterObject.Qualities.Count; j++)
                        {
                            Quality objQuality = CharacterObject.Qualities[j];
                            if (objQuality.OriginSource == QualitySource.Improvement
                                || objQuality.OriginSource == QualitySource.MetatypeRemovedAtChargen)
                                continue;
                            // We're only re-apply improvements a list of items, not all of them
                            if (lstInternalIdFilter?.Contains(objQuality.InternalId) == false)
                                continue;

                            XmlNode objNode = await objQuality.GetNodeAsync(token);
                            if (objNode != null)
                            {
                                string strSelected = objQuality.Extra;
                                objQuality.Bonus = objNode["bonus"];
                                if (objQuality.Bonus != null)
                                {
                                    ImprovementManager.ForcedValue = strSelected;
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                        objQuality.Bonus, 1, objQuality.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objQuality.Extra = ImprovementManager.SelectedValue;
                                        await treQualities.DoThreadSafeAsync(x =>
                                        {
                                            TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                            if (objTreeNode != null)
                                                objTreeNode.Text = objQuality.CurrentDisplayName;
                                        }, token);
                                    }
                                }

                                objQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                if (objQuality.FirstLevelBonus?.HasChildNodes == true)
                                {
                                    bool blnDoFirstLevel = true;
                                    for (int k = 0; k < CharacterObject.Qualities.Count; ++k)
                                    {
                                        Quality objCheckQuality = CharacterObject.Qualities[k];
                                        if (j != k
                                            && objCheckQuality.SourceIDString == objQuality.SourceIDString
                                            && objCheckQuality.Extra == objQuality.Extra
                                            && objCheckQuality.SourceName == objQuality.SourceName
                                            && (k < j
                                                || objCheckQuality.OriginSource == QualitySource.Improvement
                                                || (lstInternalIdFilter?.Contains(objCheckQuality.InternalId)
                                                    == false)))
                                        {
                                            blnDoFirstLevel = false;
                                            break;
                                        }
                                    }

                                    if (blnDoFirstLevel)
                                    {
                                        ImprovementManager.ForcedValue = strSelected;
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.Quality,
                                            objQuality.InternalId, objQuality.FirstLevelBonus, 1,
                                            objQuality.CurrentDisplayNameShort);
                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                        {
                                            objQuality.Extra = ImprovementManager.SelectedValue;
                                            await treQualities.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                                if (objTreeNode != null)
                                                    objTreeNode.Text = objQuality.CurrentDisplayName;
                                            }, token);
                                        }
                                    }
                                }

                                objQuality.NaturalWeaponsNode = objNode["naturalweapons"];
                                if (objQuality.NaturalWeaponsNode != null)
                                {
                                    ImprovementManager.ForcedValue = strSelected;
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                        objQuality.NaturalWeaponsNode, 1, objQuality.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objQuality.Extra = ImprovementManager.SelectedValue;
                                        await treQualities.DoThreadSafeAsync(x =>
                                        {
                                            TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                            if (objTreeNode != null)
                                                objTreeNode.Text = objQuality.CurrentDisplayName;
                                        }, token);
                                    }
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objQuality.CurrentDisplayName);
                            }
                        }

                        // Refresh Martial Art Techniques.
                        foreach (MartialArt objMartialArt in CharacterObject.MartialArts)
                        {
                            XmlNode objMartialArtNode = await objMartialArt.GetNodeAsync(token);
                            if (objMartialArtNode != null)
                            {
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objMartialArt.InternalId) != false
                                    && objMartialArtNode["bonus"] != null)
                                {
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, Improvement.ImprovementSource.MartialArt,
                                        objMartialArt.InternalId, objMartialArtNode["bonus"], 1,
                                        objMartialArt.CurrentDisplayName);
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objMartialArt.CurrentDisplayName);
                            }

                            foreach (MartialArtTechnique objTechnique in objMartialArt.Techniques.Where(
                                         x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                            {
                                XmlNode objNode = await objTechnique.GetNodeAsync(token);
                                if (objNode != null)
                                {
                                    if (objNode["bonus"] != null)
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.MartialArtTechnique,
                                            objTechnique.InternalId, objNode["bonus"], 1,
                                            objTechnique.CurrentDisplayName);
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(objMartialArt.CurrentDisplayName);
                                }
                            }
                        }

                        // Refresh Spells.
                        foreach (Spell objSpell in CharacterObject.Spells.Where(
                                     x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                        {
                            XmlNode objNode = await objSpell.GetNodeAsync(token);
                            if (objNode != null)
                            {
                                if (objNode["bonus"] != null)
                                {
                                    ImprovementManager.ForcedValue = objSpell.Extra;
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, Improvement.ImprovementSource.Spell, objSpell.InternalId,
                                        objNode["bonus"], 1, objSpell.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objSpell.Extra = ImprovementManager.SelectedValue;
                                        await treSpells.DoThreadSafeAsync(x =>
                                        {
                                            TreeNode objSpellNode = x.FindNode(objSpell.InternalId);
                                            if (objSpellNode != null)
                                                objSpellNode.Text = objSpell.CurrentDisplayName;
                                        }, token);
                                    }
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objSpell.CurrentDisplayName);
                            }
                        }

                        // Refresh Adept Powers.
                        foreach (Power objPower in CharacterObject.Powers.Where(
                                     x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                        {
                            XmlNode objNode = await objPower.GetNodeAsync(token);
                            if (objNode != null)
                            {
                                objPower.Bonus = objNode["bonus"];
                                if (objPower.Bonus != null)
                                {
                                    ImprovementManager.ForcedValue = objPower.Extra;
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, Improvement.ImprovementSource.Power, objPower.InternalId,
                                        objPower.Bonus, objPower.TotalRating,
                                        objPower.CurrentDisplayNameShort);
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objPower.CurrentDisplayName);
                            }
                        }

                        // Refresh Complex Forms.
                        foreach (ComplexForm objComplexForm in CharacterObject.ComplexForms.Where(
                                     x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                        {
                            XmlNode objNode = await objComplexForm.GetNodeAsync(token);
                            if (objNode != null)
                            {
                                if (objNode["bonus"] != null)
                                {
                                    ImprovementManager.ForcedValue = objComplexForm.Extra;
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, Improvement.ImprovementSource.ComplexForm,
                                        objComplexForm.InternalId, objNode["bonus"], 1,
                                        objComplexForm.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objComplexForm.Extra = ImprovementManager.SelectedValue;
                                        await treComplexForms.DoThreadSafeAsync(x =>
                                        {
                                            TreeNode objCFNode = x.FindNode(objComplexForm.InternalId);
                                            if (objCFNode != null)
                                                objCFNode.Text = objComplexForm.CurrentDisplayName;
                                        }, token);
                                    }
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objComplexForm.CurrentDisplayName);
                            }
                        }

                        // Refresh AI Programs and Advanced Programs
                        foreach (AIProgram objProgram in CharacterObject.AIPrograms.Where(
                                     x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                        {
                            XmlNode objNode = await objProgram.GetNodeAsync(token);
                            if (objNode != null)
                            {
                                if (objNode["bonus"] != null)
                                {
                                    ImprovementManager.ForcedValue = objProgram.Extra;
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, Improvement.ImprovementSource.AIProgram, objProgram.InternalId,
                                        objNode["bonus"], 1, objProgram.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objProgram.Extra = ImprovementManager.SelectedValue;
                                        await treAIPrograms.DoThreadSafeAsync(x =>
                                        {
                                            TreeNode objProgramNode = x.FindNode(objProgram.InternalId);
                                            if (objProgramNode != null)
                                                objProgramNode.Text = objProgram.CurrentDisplayNameShort;
                                        }, token);
                                    }
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objProgram.CurrentDisplayNameShort);
                            }
                        }

                        // Refresh Critter Powers.
                        foreach (CritterPower objPower in CharacterObject.CritterPowers.Where(
                                     x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                        {
                            XmlNode objNode = await objPower.GetNodeAsync(token);
                            if (objNode != null)
                            {
                                objPower.Bonus = objNode["bonus"];
                                if (objPower.Bonus != null)
                                {
                                    string strSelected = objPower.Extra;
                                    if (!int.TryParse(strSelected, out int intRating))
                                    {
                                        intRating = 1;
                                        ImprovementManager.ForcedValue = strSelected;
                                    }

                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, Improvement.ImprovementSource.CritterPower,
                                        objPower.InternalId, objPower.Bonus, intRating,
                                        objPower.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objPower.Extra = ImprovementManager.SelectedValue;
                                        await treCritterPowers.DoThreadSafeAsync(x =>
                                        {
                                            TreeNode objPowerNode = x.FindNode(objPower.InternalId);
                                            if (objPowerNode != null)
                                                objPowerNode.Text = objPower.CurrentDisplayName;
                                        }, token);
                                    }
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objPower.CurrentDisplayName);
                            }
                        }

                        // Refresh Metamagics and Echoes.
                        // We cannot use foreach because metamagics/echoes can add more metamagics/echoes
                        // ReSharper disable once ForCanBeConvertedToForeach
                        for (int j = 0; j < CharacterObject.Metamagics.Count; j++)
                        {
                            Metamagic objMetamagic = CharacterObject.Metamagics[j];
                            if (objMetamagic.Grade < 0)
                                continue;
                            // We're only re-apply improvements a list of items, not all of them
                            if (lstInternalIdFilter?.Contains(objMetamagic.InternalId) == false)
                                continue;
                            XmlNode objNode = await objMetamagic.GetNodeAsync(token);
                            if (objNode != null)
                            {
                                objMetamagic.Bonus = objNode["bonus"];
                                if (objMetamagic.Bonus != null)
                                {
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, objMetamagic.SourceType, objMetamagic.InternalId,
                                        objMetamagic.Bonus, 1, objMetamagic.CurrentDisplayNameShort);
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objMetamagic.CurrentDisplayName);
                            }
                        }

                        // Refresh Cyberware and Bioware.
                        Dictionary<Cyberware, int> dicPairableCyberwares
                            = new Dictionary<Cyberware, int>(CharacterObject.Cyberware.Count);
                        foreach (Cyberware objCyberware in CharacterObject.Cyberware.GetAllDescendants(x => x.Children))
                        {
                            // We're only re-apply improvements a list of items, not all of them
                            if (lstInternalIdFilter?.Contains(objCyberware.InternalId) != false)
                            {
                                XmlNode objNode = await objCyberware.GetNodeAsync(token);
                                if (objNode != null)
                                {
                                    objCyberware.Bonus = objNode["bonus"];
                                    objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                    objCyberware.PairBonus = objNode["pairbonus"];
                                    if (!string.IsNullOrEmpty(objCyberware.Forced) && objCyberware.Forced != "Right"
                                        && objCyberware.Forced != "Left")
                                        ImprovementManager.ForcedValue = objCyberware.Forced;
                                    if (objCyberware.Bonus != null)
                                    {
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, objCyberware.SourceType, objCyberware.InternalId,
                                            objCyberware.Bonus, objCyberware.Rating,
                                            objCyberware.CurrentDisplayNameShort);
                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                            objCyberware.Extra = ImprovementManager.SelectedValue;
                                    }

                                    if (!objCyberware.IsModularCurrentlyEquipped)
                                        objCyberware.ChangeModularEquip(false);
                                    else
                                    {
                                        objCyberware.RefreshWirelessBonuses();
                                        if (objCyberware.PairBonus != null)
                                        {
                                            Cyberware objMatchingCyberware
                                                = dicPairableCyberwares.Keys.FirstOrDefault(
                                                    x => objCyberware.IncludePair.Contains(x.Name)
                                                         && x.Extra == objCyberware.Extra);
                                            if (objMatchingCyberware != null)
                                                ++dicPairableCyberwares[objMatchingCyberware];
                                            else
                                                dicPairableCyberwares.Add(objCyberware, 1);
                                        }
                                    }

                                    TreeNode objWareNode = objCyberware.SourceID == Cyberware.EssenceHoleGUID
                                                           || objCyberware.SourceID == Cyberware.EssenceAntiHoleGUID
                                        ? await treCyberware.DoThreadSafeFuncAsync(x => x.FindNode(objCyberware.SourceIDString), token)
                                        : await treCyberware.DoThreadSafeFuncAsync(x => x.FindNode(objCyberware.InternalId), token);
                                    if (objWareNode != null)
                                        await treCyberware.DoThreadSafeAsync(() => objWareNode.Text = objCyberware.CurrentDisplayName, token);
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(objCyberware.CurrentDisplayName);
                                }
                            }

                            foreach (Gear objGear in objCyberware.GearChildren)
                            {
                                await objGear.ReaddImprovements(treCyberware, sbdOutdatedItems, lstInternalIdFilter);
                            }
                        }

                        // Separate Pass for PairBonuses
                        foreach (KeyValuePair<Cyberware, int> objItem in dicPairableCyberwares)
                        {
                            Cyberware objCyberware = objItem.Key;
                            int intCyberwaresCount = objItem.Value;
                            List<Cyberware> lstPairableCyberwares = CharacterObject.Cyberware
                                .DeepWhere(x => x.Children,
                                           x => objCyberware.IncludePair.Contains(x.Name)
                                                && x.Extra == objCyberware.Extra && x.IsModularCurrentlyEquipped)
                                .ToList();
                            // Need to use slightly different logic if this cyberware has a location (Left or Right) and only pairs with itself because Lefts can only be paired with Rights and Rights only with Lefts
                            if (!string.IsNullOrEmpty(objCyberware.Location)
                                && objCyberware.IncludePair.All(x => x == objCyberware.Name))
                            {
                                int intMatchLocationCount = 0;
                                int intNotMatchLocationCount = 0;
                                foreach (Cyberware objPairableCyberware in lstPairableCyberwares)
                                {
                                    if (objPairableCyberware.Location != objCyberware.Location)
                                        ++intNotMatchLocationCount;
                                    else
                                        ++intMatchLocationCount;
                                }

                                // Set the count to the total number of cyberwares in matching pairs, which would mean 2x the number of whichever location contains the fewest members (since every single one of theirs would have a pair)
                                intCyberwaresCount = Math.Min(intNotMatchLocationCount, intMatchLocationCount) * 2;
                            }

                            if (intCyberwaresCount > 0)
                            {
                                foreach (Cyberware objLoopCyberware in lstPairableCyberwares)
                                {
                                    if ((intCyberwaresCount & 1) == 0)
                                    {
                                        if (!string.IsNullOrEmpty(objCyberware.Forced) && objCyberware.Forced != "Right"
                                            && objCyberware.Forced != "Left")
                                            ImprovementManager.ForcedValue = objCyberware.Forced;
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, objLoopCyberware.SourceType,
                                            objLoopCyberware.InternalId + "Pair", objLoopCyberware.PairBonus,
                                            objLoopCyberware.Rating,
                                            objLoopCyberware.CurrentDisplayNameShort);
                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue)
                                            && string.IsNullOrEmpty(objCyberware.Extra))
                                            objCyberware.Extra = ImprovementManager.SelectedValue;
                                        TreeNode objNode = objLoopCyberware.SourceID == Cyberware.EssenceHoleGUID
                                                           || objCyberware.SourceID == Cyberware.EssenceAntiHoleGUID
                                            ? await treCyberware.DoThreadSafeFuncAsync(x => x.FindNode(objCyberware.SourceIDString), token)
                                            : await treCyberware.DoThreadSafeFuncAsync(x => x.FindNode(objLoopCyberware.InternalId), token);
                                        if (objNode != null)
                                            await treCyberware.DoThreadSafeAsync(() => objNode.Text = objLoopCyberware.CurrentDisplayName, token);
                                    }

                                    --intCyberwaresCount;
                                    if (intCyberwaresCount <= 0)
                                        break;
                                }
                            }
                        }

                        // Refresh Armors.
                        foreach (Armor objArmor in CharacterObject.Armor)
                        {
                            // We're only re-apply improvements a list of items, not all of them
                            if (lstInternalIdFilter?.Contains(objArmor.InternalId) != false)
                            {
                                XmlNode objNode = await objArmor.GetNodeAsync(token);
                                if (objNode != null)
                                {
                                    objArmor.Bonus = objNode["bonus"];
                                    if (objArmor.Bonus != null && objArmor.Equipped)
                                    {
                                        ImprovementManager.ForcedValue = objArmor.Extra;
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.Armor, objArmor.InternalId,
                                            objArmor.Bonus, objArmor.Rating, objArmor.CurrentDisplayNameShort);
                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                        {
                                            objArmor.Extra = ImprovementManager.SelectedValue;
                                            await treArmor.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objArmorNode = x.FindNode(objArmor.InternalId);
                                                if (objArmorNode != null)
                                                    objArmorNode.Text = objArmor.CurrentDisplayName;
                                            }, token);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(objArmor.CurrentDisplayName);
                                }
                            }

                            foreach (ArmorMod objMod in objArmor.ArmorMods)
                            {
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objMod.InternalId) != false)
                                {
                                    XmlNode objChild = await objMod.GetNodeAsync(token);

                                    if (objChild != null)
                                    {
                                        objMod.Bonus = objChild["bonus"];
                                        if (objMod.Bonus != null && objMod.Equipped)
                                        {
                                            ImprovementManager.ForcedValue = objMod.Extra;
                                            await ImprovementManager.CreateImprovementsAsync(
                                                CharacterObject, Improvement.ImprovementSource.ArmorMod,
                                                objMod.InternalId, objMod.Bonus, objMod.Rating,
                                                objMod.CurrentDisplayNameShort);
                                            if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                            {
                                                objMod.Extra = ImprovementManager.SelectedValue;
                                                await treArmor.DoThreadSafeAsync(x =>
                                                {
                                                    TreeNode objPluginNode = x.FindNode(objMod.InternalId);
                                                    if (objPluginNode != null)
                                                        objPluginNode.Text = objMod.CurrentDisplayName;
                                                }, token);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        sbdOutdatedItems.AppendLine(objMod.CurrentDisplayName);
                                    }
                                }

                                foreach (Gear objGear in objMod.GearChildren)
                                {
                                    await objGear.ReaddImprovements(treArmor, sbdOutdatedItems, lstInternalIdFilter);
                                }
                            }

                            foreach (Gear objGear in objArmor.GearChildren)
                            {
                                await objGear.ReaddImprovements(treArmor, sbdOutdatedItems, lstInternalIdFilter);
                            }

                            objArmor.RefreshWirelessBonuses();
                        }

                        // Refresh Gear.
                        foreach (Gear objGear in CharacterObject.Gear)
                        {
                            await objGear.ReaddImprovements(treGear, sbdOutdatedItems, lstInternalIdFilter);
                            objGear.RefreshWirelessBonuses();
                        }

                        // Refresh Weapons Gear
                        foreach (Weapon objWeapon in CharacterObject.Weapons)
                        {
                            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                            {
                                foreach (Gear objGear in objAccessory.GearChildren)
                                {
                                    await objGear.ReaddImprovements(treWeapons, sbdOutdatedItems, lstInternalIdFilter);
                                }
                            }

                            objWeapon.RefreshWirelessBonuses();
                        }

                        _blnReapplyImprovements = false;

                        // If the status of any Character Event flags has changed, manually trigger those events.
                        if (blnMAGEnabled != CharacterObject.MAGEnabled)
                        {
                            CharacterObject.EssenceAtSpecialStart = decEssenceAtSpecialStart;
                            await DoOnCharacterPropertyChanged(
                                new PropertyChangedEventArgs(nameof(Character.MAGEnabled)));
                        }

                        if (blnRESEnabled != CharacterObject.RESEnabled)
                        {
                            CharacterObject.EssenceAtSpecialStart = decEssenceAtSpecialStart;
                            await DoOnCharacterPropertyChanged(
                                new PropertyChangedEventArgs(nameof(Character.RESEnabled)));
                        }

                        if (blnDEPEnabled != CharacterObject.DEPEnabled)
                        {
                            CharacterObject.EssenceAtSpecialStart = decEssenceAtSpecialStart;
                            await DoOnCharacterPropertyChanged(
                                new PropertyChangedEventArgs(nameof(Character.DEPEnabled)));
                        }

                        await RequestCharacterUpdate();
                        // Immediately await character update because it re-applies essence loss improvements
                        try
                        {
                            await UpdateCharacterInfoTask;
                        }
                        catch (OperationCanceledException)
                        {
                            return;
                        }

                        if (sbdOutdatedItems.Length > 0 && !Utils.IsUnitTest)
                        {
                            Program.ShowMessageBox(
                                this, await LanguageManager.GetStringAsync(
                                          "Message_ReapplyImprovementsFoundOutdatedItems_Top") +
                                      sbdOutdatedItems +
                                      await LanguageManager.GetStringAsync(
                                          "Message_ReapplyImprovementsFoundOutdatedItems_Bottom"),
                                await LanguageManager.GetStringAsync("MessageTitle_ConfirmReapplyImprovements"),
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync();
                }
            }

            await SetDirty(true);
        }

        private async void mnuSpecialPossess_Click(object sender, EventArgs e)
        {
            // Make sure the Spirit has been saved first.
            if (IsDirty && Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_PossessionSave"), await LanguageManager.GetStringAsync("MessageTitle_Possession"), MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                return;

            if (Utils.IsUnitTest)
            {
                Utils.BreakIfDebug();
                return;
            }

            try
            {
                string strFileName;
                // Prompt the user to select a save file to possess.
                using (OpenFileDialog dlgOpenFile = await this.DoThreadSafeFuncAsync(() => new OpenFileDialog(), GenericToken))
                {
                    dlgOpenFile.Filter = await LanguageManager.GetStringAsync("DialogFilter_Chum5") + '|'
                        + await LanguageManager.GetStringAsync("DialogFilter_All");
                    if (await this.DoThreadSafeFuncAsync(x => dlgOpenFile.ShowDialog(x), GenericToken) != DialogResult.OK)
                        return;
                    strFileName = dlgOpenFile.FileName;
                }

                string strOpenFile = string.Empty;
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken);
                try
                {
                    Character objMerge = new Character {FileName = CharacterObject.FileName};
                    try
                    {
                        Character objVessel = new Character {FileName = strFileName};
                        try
                        {
                            using (ThreadSafeForm<LoadingBar> frmLoadingBar
                                   = await Program.CreateAndShowProgressBarAsync(
                                       Path.GetFileName(objVessel.FileName), Character.NumLoadingSections * 2 + 7))
                            {
                                bool blnSuccess = await objVessel.LoadAsync(frmLoadingBar.MyForm, token: GenericToken);
                                if (!blnSuccess)
                                {
                                    Program.ShowMessageBox(this,
                                                           await LanguageManager.GetStringAsync(
                                                               "Message_Load_Error_Warning"),
                                                           await LanguageManager.GetStringAsync("String_Error"),
                                                           MessageBoxButtons.OK,
                                                           MessageBoxIcon.Error);
                                    return;
                                }

                                // Make sure the Vessel is in Career Mode.
                                if (!objVessel.Created)
                                {
                                    Program.ShowMessageBox(this,
                                                           await LanguageManager.GetStringAsync(
                                                               "Message_VesselInCareerMode"),
                                                           await LanguageManager.GetStringAsync(
                                                               "MessageTitle_Possession"),
                                                           MessageBoxButtons.OK,
                                                           MessageBoxIcon.Error);
                                    return;
                                }

                                // Load the Spirit's save file into a new Merge character.
                                frmLoadingBar.MyForm.CharacterFile = objMerge.FileName;
                                blnSuccess = await objMerge.LoadAsync(frmLoadingBar.MyForm, token: GenericToken);
                                if (!blnSuccess)
                                {
                                    Program.ShowMessageBox(this,
                                                           await LanguageManager.GetStringAsync(
                                                               "Message_Load_Error_Warning"),
                                                           await LanguageManager.GetStringAsync("String_Error"),
                                                           MessageBoxButtons.OK,
                                                           MessageBoxIcon.Error);
                                    return;
                                }

                                objMerge.Possessed = true;
                                objMerge.Alias = objVessel.CharacterName
                                                 + await LanguageManager.GetStringAsync("String_Space") + '('
                                                 + await LanguageManager.GetStringAsync("String_Possessed") + ')';

                                // Give the Critter the Immunity to Normal Weapons Power if they don't already have it.
                                bool blnHasImmunity = false;
                                foreach (CritterPower objCritterPower in objMerge.CritterPowers)
                                {
                                    if (objCritterPower.Name == "Immunity" && objCritterPower.Extra == "Normal Weapons")
                                    {
                                        blnHasImmunity = true;
                                        break;
                                    }
                                }

                                if (!blnHasImmunity)
                                {
                                    XmlDocument objPowerDoc
                                        = await CharacterObject.LoadDataAsync("critterpowers.xml", token: GenericToken);
                                    XmlNode objPower
                                        = objPowerDoc.SelectSingleNode("/chummer/powers/power[name = \"Immunity\"]");

                                    CritterPower objCritterPower = new CritterPower(objMerge);
                                    objCritterPower.Create(objPower, 0, "Normal Weapons");
                                    await objMerge.CritterPowers.AddAsync(objCritterPower);
                                }

                                //TOD: Implement Possession attribute bonuses.
                                /*
                            // Add the Vessel's Physical Attributes to the Spirit's Force.
                            objMerge.BOD.MetatypeMaximum = objVessel.BOD.Value + objMerge.MAG.TotalValue;
                            objMerge.BOD.Value = objVessel.BOD.Value + objMerge.MAG.TotalValue;
                            objMerge.AGI.MetatypeMaximum = objVessel.AGI.Value + objMerge.MAG.TotalValue;
                            objMerge.AGI.Value = objVessel.AGI.Value + objMerge.MAG.TotalValue;
                            objMerge.REA.MetatypeMaximum = objVessel.REA.Value + objMerge.MAG.TotalValue;
                            objMerge.REA.Value = objVessel.REA.Value + objMerge.MAG.TotalValue;
                            objMerge.STR.MetatypeMaximum = objVessel.STR.Value + objMerge.MAG.TotalValue;
                            objMerge.STR.Value = objVessel.STR.Value + objMerge.MAG.TotalValue;
                            */

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("String_SelectPACKSKit_Lifestyles"),
                                    token: GenericToken);
                                // Copy any Lifestyles the Vessel has.
                                foreach (Lifestyle objLifestyle in objVessel.Lifestyles)
                                    await objMerge.Lifestyles.AddAsync(objLifestyle);

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("Tab_Armor"), token: GenericToken);
                                // Copy any Armor the Vessel has.
                                foreach (Armor objArmor in objVessel.Armor)
                                {
                                    await objMerge.Armor.AddAsync(objArmor);
                                    CopyArmorImprovements(objVessel, objMerge, objArmor);
                                }

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("Tab_Gear"), token: GenericToken);
                                // Copy any Gear the Vessel has.
                                foreach (Gear objGear in objVessel.Gear)
                                {
                                    await objMerge.Gear.AddAsync(objGear);
                                    CopyGearImprovements(objVessel, objMerge, objGear);
                                }

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("Tab_Cyberware"), token: GenericToken);
                                // Copy any Cyberware/Bioware the Vessel has.
                                foreach (Cyberware objCyberware in objVessel.Cyberware)
                                {
                                    await objMerge.Cyberware.AddAsync(objCyberware);
                                    CopyCyberwareImprovements(objVessel, objMerge, objCyberware);
                                }

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("Tab_Weapons"), token: GenericToken);
                                // Copy any Weapons the Vessel has.
                                foreach (Weapon objWeapon in objVessel.Weapons)
                                    await objMerge.Weapons.AddAsync(objWeapon);

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("Tab_Vehicles"), token: GenericToken);
                                // Copy and Vehicles the Vessel has.
                                foreach (Vehicle objVehicle in objVessel.Vehicles)
                                    await objMerge.Vehicles.AddAsync(objVehicle);

                                await frmLoadingBar.MyForm.PerformStepAsync(
                                    await LanguageManager.GetStringAsync("String_Settings"), token: GenericToken);
                                // Copy the character info.
                                objMerge.Gender = objVessel.Gender;
                                objMerge.Age = objVessel.Age;
                                objMerge.Eyes = objVessel.Eyes;
                                objMerge.Hair = objVessel.Hair;
                                objMerge.Height = objVessel.Height;
                                objMerge.Weight = objVessel.Weight;
                                objMerge.Skin = objVessel.Skin;
                                objMerge.Name = objVessel.Name;
                                objMerge.StreetCred = objVessel.StreetCred;
                                objMerge.BurntStreetCred = objVessel.BurntStreetCred;
                                objMerge.Notoriety = objVessel.Notoriety;
                                objMerge.PublicAwareness = objVessel.PublicAwareness;
                                foreach (Image objMugshot in objVessel.Mugshots)
                                    await objMerge.Mugshots.AddAsync(objMugshot);
                            }
                        }
                        finally
                        {
                            await objVessel.DisposeAsync();
                        }

                        string strShowFileName = Path.GetFileName(objMerge.FileName);
                        if (string.IsNullOrEmpty(strShowFileName))
                            strShowFileName = objMerge.CharacterName;
                        strShowFileName = strShowFileName.TrimEndOnce(".chum5")
                                          + await LanguageManager.GetStringAsync("String_Space") + '('
                                          + await LanguageManager.GetStringAsync("String_Possessed") + ')';

                        // Now that everything is done, save the merged character and open them.
                        dlgSaveFile.FileName = strShowFileName;
                        if (await this.DoThreadSafeFuncAsync(x => dlgSaveFile.ShowDialog(x), GenericToken)
                            != DialogResult.OK)
                            return;
                        using (ThreadSafeForm<LoadingBar> frmLoadingBar = await Program.CreateAndShowProgressBarAsync())
                        {
                            await frmLoadingBar.MyForm.PerformStepAsync(objMerge.CharacterName,
                                                                        LoadingBar.ProgressBarTextPatterns.Saving,
                                                                        token: GenericToken);
                            objMerge.FileName = dlgSaveFile.FileName;
                            if (await objMerge.SaveAsync(token: GenericToken))
                            {
                                // Get the name of the file and destroy the references to the Vessel and the merged character.
                                strOpenFile = objMerge.FileName;
                            }
                        }
                    }
                    finally
                    {
                        await objMerge
                            .DisposeAsync(); // Fine here because Dispose()/DisposeAsync() code is skipped if the character is open in a form
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync();
                }

                if (!string.IsNullOrEmpty(strOpenFile))
                {
                    objCursorWait = await CursorWait.NewAsync(this, token: GenericToken);
                    try
                    {
                        Character objOpenCharacter;
                        using (ThreadSafeForm<LoadingBar> frmLoadingBar
                               = await Program.CreateAndShowProgressBarAsync(strOpenFile, Character.NumLoadingSections))
                            objOpenCharacter
                                = await Program.LoadCharacterAsync(strOpenFile, frmLoadingBar: frmLoadingBar.MyForm,
                                                                   token: GenericToken);
                        await Program.OpenCharacter(objOpenCharacter, token: GenericToken);
                    }
                    finally
                    {
                        await objCursorWait.DisposeAsync();
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialPossessInanimate_Click(object sender, EventArgs e)
        {
            // Make sure the Spirit has been saved first.
            if (IsDirty && Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_PossessionSave"),
                                                  await LanguageManager.GetStringAsync("MessageTitle_Possession"),
                                                  MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                return;

            if (Utils.IsUnitTest)
            {
                Utils.BreakIfDebug();
                return;
            }

            try
            {
                string strSelectedVessel;
                // Prompt the user to select an inanimate Vessel.
                XPathNavigator xmlVesselsNavigator = await CharacterObject.LoadDataXPathAsync("vessels.xml", token: GenericToken);
                using (new FetchSafelyFromPool<List<ListItem>>(Utils.ListItemListPool, out List<ListItem> lstMetatype))
                {
                    foreach (XPathNavigator xmlMetatype in await xmlVesselsNavigator.SelectAndCacheExpressionAsync(
                                 "/chummer/metatypes/metatype"))
                    {
                        string strName = (await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync("name"))?.Value;
                        if (!string.IsNullOrEmpty(strName))
                        {
                            ListItem objItem
                                = new ListItem(
                                    strName, (await xmlMetatype.SelectSingleNodeAndCacheExpressionAsync("translate"))?.Value ?? strName);
                            lstMetatype.Add(objItem);
                        }
                    }

                    using (ThreadSafeForm<SelectItem> frmSelectVessel = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem(), GenericToken))
                    {
                        frmSelectVessel.MyForm.SetGeneralItemsMode(lstMetatype);

                        if (await frmSelectVessel.ShowDialogSafeAsync(this, GenericToken) == DialogResult.Cancel)
                            return;

                        strSelectedVessel = frmSelectVessel.MyForm.SelectedItem;
                    }
                }

                // Get the Node for the selected Vessel.
                XmlDocument xmlVessels = await CharacterObject.LoadDataAsync("vessels.xml", token: GenericToken);
                XmlNode objSelected = xmlVessels.SelectSingleNode("/chummer/metatypes/metatype[name = " + strSelectedVessel.CleanXPath() + ']');
                if (objSelected == null)
                    return;

                string strOpenFile = string.Empty;
                using (await CursorWait.NewAsync(this, token: GenericToken))
                {
                    // Load the Spirit's save file into a new Merge character.
                    Character objMerge = new Character {FileName = CharacterObject.FileName};
                    try
                    {
                        using (ThreadSafeForm<LoadingBar> frmLoadingBar = await Program.CreateAndShowProgressBarAsync(objMerge.FileName, Character.NumLoadingSections + 1))
                        {
                            await objMerge.LoadAsync(frmLoadingBar.MyForm, token: GenericToken);
                            await frmLoadingBar.MyForm.PerformStepAsync(await LanguageManager.GetStringAsync("String_UI"));
                            objMerge.Possessed = true;
                            objMerge.Alias = strSelectedVessel + await LanguageManager.GetStringAsync("String_Space") + '('
                                             + await LanguageManager.GetStringAsync("String_Possessed") + ')';

                            int intHalfMAGRoundedUp = CharacterObject.MAG.TotalValue.DivAwayFromZero(2);
                            await ImprovementManager.CreateImprovementAsync(
                                objMerge, "BOD", Improvement.ImprovementSource.Metatype, "Possession",
                                Improvement.ImprovementType.Attribute, string.Empty, intHalfMAGRoundedUp, 1, 0, 0,
                                intHalfMAGRoundedUp, intHalfMAGRoundedUp);
                            await ImprovementManager.CreateImprovementAsync(
                                objMerge, "AGI", Improvement.ImprovementSource.Metatype, "Possession",
                                Improvement.ImprovementType.Attribute, string.Empty, intHalfMAGRoundedUp, 1, 0, 0,
                                intHalfMAGRoundedUp, intHalfMAGRoundedUp);
                            await ImprovementManager.CreateImprovementAsync(
                                objMerge, "STR", Improvement.ImprovementSource.Metatype, "Possession",
                                Improvement.ImprovementType.Attribute, string.Empty, intHalfMAGRoundedUp, 1, 0, 0,
                                intHalfMAGRoundedUp, intHalfMAGRoundedUp);
                            await ImprovementManager.CreateImprovementAsync(
                                objMerge, "REA", Improvement.ImprovementSource.Metatype, "Possession",
                                Improvement.ImprovementType.Attribute, string.Empty, intHalfMAGRoundedUp, 1, 0, 0,
                                intHalfMAGRoundedUp, intHalfMAGRoundedUp);
                            await ImprovementManager.CreateImprovementAsync(
                                objMerge, "INT", Improvement.ImprovementSource.Metatype, "Possession",
                                Improvement.ImprovementType.ReplaceAttribute, string.Empty, 0, 1,
                                CharacterObject.INT.MetatypeMinimum,
                                CharacterObject.INT.MetatypeMaximum, 0, CharacterObject.INT.MetatypeAugmentedMaximum);
                            await ImprovementManager.CreateImprovementAsync(
                                objMerge, "WIL", Improvement.ImprovementSource.Metatype, "Possession",
                                Improvement.ImprovementType.ReplaceAttribute, string.Empty, 0, 1,
                                CharacterObject.WIL.MetatypeMinimum,
                                CharacterObject.WIL.MetatypeMaximum, 0, CharacterObject.WIL.MetatypeAugmentedMaximum);
                            await ImprovementManager.CreateImprovementAsync(
                                objMerge, "LOG", Improvement.ImprovementSource.Metatype, "Possession",
                                Improvement.ImprovementType.ReplaceAttribute, string.Empty, 0, 1,
                                CharacterObject.LOG.MetatypeMinimum,
                                CharacterObject.LOG.MetatypeMaximum, 0, CharacterObject.LOG.MetatypeAugmentedMaximum);
                            await ImprovementManager.CreateImprovementAsync(
                                objMerge, "CHA", Improvement.ImprovementSource.Metatype, "Possession",
                                Improvement.ImprovementType.ReplaceAttribute, string.Empty, 0, 1,
                                CharacterObject.CHA.MetatypeMinimum,
                                CharacterObject.CHA.MetatypeMaximum, 0, CharacterObject.CHA.MetatypeAugmentedMaximum);
                            await ImprovementManager.CommitAsync(objMerge);
                            XmlDocument xmlPowerDoc = await CharacterObject.LoadDataAsync("critterpowers.xml");

                            // Update the Movement if the Vessel has one.
                            string strMovement = objSelected["movement"]?.InnerText;
                            if (!string.IsNullOrEmpty(strMovement))
                                objMerge.Movement = strMovement;

                            // Add any additional Critter Powers the Vessel grants.
                            XmlNode xmlPowersNode = objSelected["powers"];
                            if (xmlPowersNode != null)
                            {
                                using (XmlNodeList xmlPowerList = xmlPowersNode.SelectNodes("power"))
                                {
                                    if (xmlPowerList?.Count > 0)
                                    {
                                        foreach (XmlNode objXmlPower in xmlPowerList)
                                        {
                                            XmlNode objXmlCritterPower
                                                = xmlPowerDoc.SelectSingleNode(
                                                    "/chummer/powers/power[name = " + objXmlPower.InnerText.CleanXPath()
                                                    + ']');
                                            CritterPower objPower = new CritterPower(objMerge);
                                            string strSelect = objXmlPower.Attributes?["select"]?.InnerText ?? string.Empty;
                                            int intRating = Convert.ToInt32(objXmlPower.Attributes?["rating"]?.InnerText,
                                                                            GlobalSettings.InvariantCultureInfo);

                                            objPower.Create(objXmlCritterPower, intRating, strSelect);

                                            await objMerge.CritterPowers.AddAsync(objPower);
                                        }
                                    }
                                }
                            }

                            // Give the Critter the Immunity to Normal Weapons Power if they don't already have it.
                            if (!objMerge.CritterPowers.Any(objCritterPower =>
                                                                objCritterPower.Name == "Immunity"
                                                                && objCritterPower.Extra == "Normal Weapons"))
                            {
                                XmlNode objPower
                                    = xmlPowerDoc.SelectSingleNode("/chummer/powers/power[name = \"Immunity\"]");

                                CritterPower objCritterPower = new CritterPower(objMerge);
                                objCritterPower.Create(objPower, 0, "Normal Weapons");
                                await objMerge.CritterPowers.AddAsync(objCritterPower);
                            }

                            // Add any Improvements the Vessel grants.
                            if (objSelected["bonus"] != null)
                            {
                                await ImprovementManager.CreateImprovementsAsync(
                                    objMerge, Improvement.ImprovementSource.Metatype, strSelectedVessel,
                                    objSelected["bonus"], 1, strSelectedVessel);
                            }
                        }

                        // Now that everything is done, save the merged character and open them.
                        string strShowFileName = objMerge.FileName
                                                         .SplitNoAlloc(Path.DirectorySeparatorChar,
                                                                       StringSplitOptions.RemoveEmptyEntries)
                                                         .LastOrDefault();

                        if (string.IsNullOrEmpty(strShowFileName))
                            strShowFileName = objMerge.CharacterName;
                        strShowFileName = strShowFileName.TrimEndOnce(".chum5");

                        strShowFileName += await LanguageManager.GetStringAsync("String_Space") + '('
                            + await LanguageManager.GetStringAsync("String_Possessed") + ')';
                        dlgSaveFile.FileName = strShowFileName;
                        if (await this.DoThreadSafeFuncAsync(x => dlgSaveFile.ShowDialog(x)) != DialogResult.OK)
                            return;
                        using (ThreadSafeForm<LoadingBar> frmLoadingBar = await Program.CreateAndShowProgressBarAsync())
                        {
                            await frmLoadingBar.MyForm.PerformStepAsync(objMerge.CharacterName,
                                                                        LoadingBar.ProgressBarTextPatterns.Saving, token: GenericToken);
                            objMerge.FileName = dlgSaveFile.FileName;
                            if (await objMerge.SaveAsync(token: GenericToken))
                            {
                                // Get the name of the file and destroy the references to the Vessel and the merged character.
                                strOpenFile = objMerge.FileName;
                            }
                        }
                    }
                    finally
                    {
                        await objMerge
                            .DisposeAsync(); // Fine here because Dispose()/DisposeAsync() code is skipped if the character is open in a form
                    }
                }

                if (!string.IsNullOrEmpty(strOpenFile))
                {
                    using (await CursorWait.NewAsync(this, token: GenericToken))
                    {
                        Character objOpenCharacter;
                        using (ThreadSafeForm<LoadingBar> frmLoadingBar = await Program.CreateAndShowProgressBarAsync(strOpenFile, Character.NumLoadingSections))
                            objOpenCharacter = await Program.LoadCharacterAsync(strOpenFile, frmLoadingBar: frmLoadingBar.MyForm, token: GenericToken);
                        await Program.OpenCharacter(objOpenCharacter, token: GenericToken);
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void mnuEditCopy_Click(object sender, EventArgs e)
        {
            object selectedObject = null;
            if (tabCharacterTabs.SelectedTab == tabStreetGear)
            {
                // Lifestyle Tab.
                if (tabStreetGearTabs.SelectedTab == tabLifestyle)
                {
                    selectedObject = treLifestyles.SelectedNode?.Tag;
                }
                // Armor Tab.
                else if (tabStreetGearTabs.SelectedTab == tabArmor)
                {
                    selectedObject = treArmor.SelectedNode?.Tag;
                }
                // Weapons Tab.
                else if (tabStreetGearTabs.SelectedTab == tabWeapons)
                {
                    selectedObject = treWeapons.SelectedNode?.Tag;
                }
                // Gear Tab.
                else if (tabStreetGearTabs.SelectedTab == tabGear)
                {
                    selectedObject = treGear.SelectedNode?.Tag;
                }
            }
            // Cyberware Tab.
            else if (tabCharacterTabs.SelectedTab == tabCyberware)
            {
                selectedObject = treCyberware.SelectedNode?.Tag;
            }
            // Vehicles Tab.
            else if (tabCharacterTabs.SelectedTab == tabVehicles)
            {
                selectedObject = treVehicles.SelectedNode?.Tag;
            }

            CopyObject(selectedObject);
        }

        private async void mnuSpecialConvertToFreeSprite_Click(object sender, EventArgs e)
        {
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("critterpowers.xml");
            XmlNode objXmlPower = objXmlDocument.SelectSingleNode("/chummer/powers/power[name = \"Denial\"]");
            CritterPower objPower = new CritterPower(CharacterObject);
            objPower.Create(objXmlPower);
            objPower.CountTowardsLimit = false;
            if (objPower.InternalId.IsEmptyGuid())
                return;

            await CharacterObject.CritterPowers.AddAsync(objPower);

            CharacterObject.MetatypeCategory = "Free Sprite";
        }

        private async void mnuSpecialAddCyberwareSuite_Click(object sender, EventArgs e)
        {
            await AddCyberwareSuite(Improvement.ImprovementSource.Cyberware);
        }

        private async void mnuSpecialAddBiowareSuite_Click(object sender, EventArgs e)
        {
            await AddCyberwareSuite(Improvement.ImprovementSource.Bioware);
        }

        #endregion Menu Events

        #region Martial Tab Control Events

        private async void treMartialArts_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedMartialArt(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedMartialArt(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                object objSelectedNodeTag = await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token);
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblMartialArtSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblMartialArtSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblMartialArtSource, token);
                }
                else
                {
                    await lblMartialArtSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblMartialArtSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                switch (objSelectedNodeTag)
                {
                    case MartialArt objMartialArt:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = !objMartialArt.IsQuality, token);
                        break;

                    case ICanRemove _:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = true, token);
                        break;

                    default:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = false, token);
                        await SourceString.Blank.SetControlAsync(lblMartialArtSource, token);
                        break;
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        #endregion Martial Tab Control Events

        #region Button Events

        private void panContacts_DragDrop(object sender, DragEventArgs e)
        {
            Point mousePosition = panContacts.PointToClient(new Point(e.X, e.Y));
            Control destination = panContacts.GetChildAtPoint(mousePosition);

            if (destination != null)
            {
                TransportWrapper wrapper = (TransportWrapper)e.Data.GetData(typeof(TransportWrapper));
                Control source = wrapper.Control;
                int indexDestination = panContacts.Controls.IndexOf(destination);
                if (panContacts.Controls.IndexOf(source) < indexDestination)
                    indexDestination--;

                panContacts.Controls.SetChildIndex(source, indexDestination);
            }

            foreach (ContactControl objControl in panContacts.Controls)
            {
                objControl.BackColor = ColorManager.Control;
            }
        }

        private void panContacts_DragOver(object sender, DragEventArgs e)
        {
            Point mousePosition = panContacts.PointToClient(new Point(e.X, e.Y));
            Control destination = panContacts.GetChildAtPoint(mousePosition);

            if (destination == null)
                return;

            destination.BackColor = ColorManager.ControlDarker;
            foreach (ContactControl objControl in panContacts.Controls)
            {
                if (objControl != destination as ContactControl)
                {
                    objControl.BackColor = ColorManager.Control;
                }
            }
            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
        }

        private void panContacts_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private async void cmdAddSpell_Click(object sender, EventArgs e)
        {
            // Open the Spells XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("spells.xml");
            bool blnAddAgain;

            do
            {
                (bool blnCanTouchOnlySpellBeFree, bool blnCanGenericSpellBeFree) = await CharacterObject.AllowFreeSpellsAsync();
                int intSpellKarmaCost = CharacterObject.SpellKarmaCost("Spells");
                // Make sure the character has enough Karma before letting them select a Spell.
                if (CharacterObject.Karma < intSpellKarmaCost && !(blnCanTouchOnlySpellBeFree || blnCanGenericSpellBeFree))
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK,
                        MessageBoxIcon.Information);
                    break;
                }

                using (ThreadSafeForm<SelectSpell> frmPickSpell = await ThreadSafeForm<SelectSpell>.GetAsync(() => new SelectSpell(CharacterObject)
                       {
                           FreeOnly = CharacterObject.Karma < intSpellKarmaCost &&
                                      (blnCanTouchOnlySpellBeFree || blnCanGenericSpellBeFree)
                       }))
                {
                    // Make sure the dialogue window was not canceled.
                    if (await frmPickSpell.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        break;
                    blnAddAgain = frmPickSpell.MyForm.AddAgain;

                    XmlNode objXmlSpell = objXmlDocument.SelectSingleNode("/chummer/spells/spell[id = " + frmPickSpell.MyForm.SelectedSpell.CleanXPath() + ']');

                    Spell objSpell = new Spell(CharacterObject);
                    objSpell.Create(objXmlSpell, string.Empty, frmPickSpell.MyForm.Limited, frmPickSpell.MyForm.Extended, frmPickSpell.MyForm.Alchemical);
                    if (objSpell.Alchemical)
                    {
                        intSpellKarmaCost = CharacterObject.SpellKarmaCost("Preparations");
                    }
                    else if (objSpell.Category == "Rituals")
                    {
                        intSpellKarmaCost = CharacterObject.SpellKarmaCost("Rituals");
                    }

                    if (objSpell.InternalId.IsEmptyGuid())
                    {
                        objSpell.Dispose();
                        continue;
                    }

                    objSpell.FreeBonus = frmPickSpell.MyForm.FreeBonus;
                    if (!objSpell.FreeBonus)
                    {
                        if (CharacterObject.Karma < intSpellKarmaCost)
                        {
                            objSpell.Dispose();
                            Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                            break;
                        }
                        if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend")
                            , objSpell.CurrentDisplayName
                            , intSpellKarmaCost.ToString(GlobalSettings.CultureInfo))))
                        {
                            objSpell.Dispose();
                            continue;
                        }
                    }
                    // Barehanded Adept
                    else if (CharacterObject.AdeptEnabled && !CharacterObject.MagicianEnabled && (objSpell.Range == "T" || objSpell.Range == "T (A)"))
                    {
                        objSpell.BarehandedAdept = true;
                    }

                    await CharacterObject.Spells.AddAsync(objSpell);
                    if (!objSpell.FreeBonus)
                    {
                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(-intSpellKarmaCost, await LanguageManager.GetStringAsync("String_ExpenseLearnSpell") + await LanguageManager.GetStringAsync("String_Space") + objSpell.Name, ExpenseType.Karma, DateTime.Now);
                        CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                        CharacterObject.Karma -= intSpellKarmaCost;

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateKarma(KarmaExpenseType.AddSpell, objSpell.InternalId);
                        objExpense.Undo = objUndo;
                    }
                }
            }
            while (blnAddAgain);
        }

        private void cmdDeleteSpell_Click(object sender, EventArgs e)
        {
            // Locate the Spell that is selected in the tree.
            if (!(treSpells.SelectedNode?.Tag is Spell objSpell))
                return;
            // Spells that come from Initiation Grades can't be deleted normally.
            if (objSpell.Grade != 0)
                return;
            objSpell.Remove();
        }

        private async void cmdAddSpirit_Click(object sender, EventArgs e)
        {
            await AddSpirit();
        }

        private async void cmdAddSprite_Click(object sender, EventArgs e)
        {
            await AddSprite();
        }

        private async void cmdAddContact_Click(object sender, EventArgs e)
        {
            await AddContact();
        }

        private async void cmdAddEnemy_Click(object sender, EventArgs e)
        {
            await AddEnemy();
        }

        private async void cmdAddPet_Click(object sender, EventArgs e)
        {
            await AddPet();
        }

        private async void tsAddFromFile_Click(object sender, EventArgs e)
        {
            try
            {
                await AddContactsFromFile(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddCyberware_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickCyberware(null, Improvement.ImprovementSource.Cyberware);
            }
            while (blnAddAgain);
        }

        private void cmdDeleteCyberware_Click(object sender, EventArgs e)
        {
            if (treCyberware.SelectedNode == null || treCyberware.SelectedNode.Level <= 0)
                return;
            // Locate the piece of Cyberware that is selected in the tree.
            if (!(treCyberware.SelectedNode?.Tag is ICanRemove objToRemove))
                return;
            objToRemove.Remove();
        }

        private async void cmdAddComplexForm_Click(object sender, EventArgs e)
        {
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("complexforms.xml");
            bool blnAddAgain;

            do
            {
                // The number of Complex Forms cannot exceed twice the character's RES.
                if (CharacterObject.ComplexForms.Count >= CharacterObject.RES.Value * 2 + await ImprovementManager.ValueOfAsync(CharacterObject, Improvement.ImprovementType.ComplexFormLimit) && !CharacterObjectSettings.IgnoreComplexFormLimit)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ComplexFormLimit"), await LanguageManager.GetStringAsync("MessageTitle_ComplexFormLimit"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    break;
                }
                int intComplexFormKarmaCost = CharacterObject.ComplexFormKarmaCost;

                // Make sure the character has enough Karma before letting them select a Complex Form.
                if (CharacterObject.Karma < intComplexFormKarmaCost)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    break;
                }

                XmlNode objXmlComplexForm;
                // Let the user select a Program.
                using (ThreadSafeForm<SelectComplexForm> frmPickComplexForm
                       = await ThreadSafeForm<SelectComplexForm>.GetAsync(() => new SelectComplexForm(CharacterObject)))
                {
                    // Make sure the dialogue window was not canceled.
                    if (await frmPickComplexForm.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        break;
                    blnAddAgain = frmPickComplexForm.MyForm.AddAgain;

                    objXmlComplexForm = objXmlDocument.SelectSingleNode("/chummer/complexforms/complexform[id = " + frmPickComplexForm.MyForm.SelectedComplexForm.CleanXPath() + ']');
                }

                if (objXmlComplexForm == null)
                    continue;
                ComplexForm objComplexForm = new ComplexForm(CharacterObject);
                objComplexForm.Create(objXmlComplexForm);
                if (objComplexForm.InternalId.IsEmptyGuid())
                    continue;

                await CharacterObject.ComplexForms.AddAsync(objComplexForm);

                if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend"), objComplexForm.CurrentDisplayNameShort, intComplexFormKarmaCost.ToString(GlobalSettings.CultureInfo))))
                {
                    // Remove the Improvements created by the Complex Form.
                    await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.ComplexForm, objComplexForm.InternalId);
                    continue;
                }

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(intComplexFormKarmaCost * -1, await LanguageManager.GetStringAsync("String_ExpenseLearnComplexForm") + await LanguageManager.GetStringAsync("String_Space") + objComplexForm.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                CharacterObject.Karma -= intComplexFormKarmaCost;

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.AddComplexForm, objComplexForm.InternalId);
                objExpense.Undo = objUndo;
            }
            while (blnAddAgain);
        }

        private async void cmdAddArmor_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickArmor();
            }
            while (blnAddAgain);
        }

        private void cmdDeleteArmor_Click(object sender, EventArgs e)
        {
            RemoveSelectedObject(treArmor.SelectedNode?.Tag);
        }

        private void cmdDeleteCustomDrug_Click(object sender, EventArgs e)
        {
            RemoveSelectedObject(treCustomDrugs.SelectedNode?.Tag);
        }

        private async void cmdAddBioware_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickCyberware(null, Improvement.ImprovementSource.Bioware);
            }
            while (blnAddAgain);
        }

        private async ValueTask<bool> PickWeapon(object destObject)
        {
            using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(() => new SelectWeapon(CharacterObject)))
            {
                // Make sure the dialogue window was not canceled.
                if (await frmPickWeapon.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return false;

                // Open the Weapons XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("weapons.xml");

                XmlNode objXmlWeapon = objXmlDocument.SelectSingleNode("/chummer/weapons/weapon[id = " + frmPickWeapon.MyForm.SelectedWeapon.CleanXPath() + ']');

                List<Weapon> lstWeapons = new List<Weapon>(1);
                Weapon objWeapon = new Weapon(CharacterObject);
                objWeapon.Create(objXmlWeapon, lstWeapons);
                objWeapon.DiscountCost = frmPickWeapon.MyForm.BlackMarketDiscount;

                // Check the item's Cost and make sure the character can afford it.
                if (!frmPickWeapon.MyForm.FreeCost)
                {
                    decimal decCost = objWeapon.TotalCost;
                    // Apply a markup if applicable.
                    if (frmPickWeapon.MyForm.Markup != 0)
                    {
                        decCost *= 1 + frmPickWeapon.MyForm.Markup / 100.0m;
                    }

                    // Multiply the cost if applicable.
                    char chrAvail = objWeapon.TotalAvailTuple().Suffix;
                    switch (chrAvail)
                    {
                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                            break;

                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                            break;
                    }

                    if (decCost > CharacterObject.Nuyen)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return frmPickWeapon.MyForm.AddAgain;
                    }

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(decCost * -1, await LanguageManager.GetStringAsync("String_ExpensePurchaseWeapon") + await LanguageManager.GetStringAsync("String_Space") + objWeapon.CurrentDisplayNameShort, ExpenseType.Nuyen,
                        DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                    CharacterObject.Nuyen -= decCost;

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateNuyen(NuyenExpenseType.AddWeapon, objWeapon.InternalId);
                    objExpense.Undo = objUndo;
                }

                if (destObject is Location objLocation)
                {
                    objWeapon.Location = objLocation;
                    foreach (Weapon objExtraWeapon in lstWeapons)
                    {
                        objExtraWeapon.Location = objLocation;
                    }
                }

                foreach (Weapon objExtraWeapon in lstWeapons)
                {
                    await CharacterObject.Weapons.AddAsync(objExtraWeapon);
                }

                await CharacterObject.Weapons.AddAsync(objWeapon);

                return frmPickWeapon.MyForm.AddAgain;
            }
        }

        private async void cmdAddWeapon_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickWeapon(string.Empty);
            }
            while (blnAddAgain);
        }

        private void cmdDeleteWeapon_Click(object sender, EventArgs e)
        {
            // Delete the selected Weapon.
            RemoveSelectedObject(treWeapons.SelectedNode?.Tag);
        }

        private static void RemoveSelectedObject(object selectedObject)
        {
            if (!(selectedObject is ICanRemove iRemovable))
                return;
            iRemovable.Remove();
        }

        private async void cmdAddLifestyle_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;

            do
            {
                using (ThreadSafeForm<SelectLifestyle> frmPickLifestyle = await ThreadSafeForm<SelectLifestyle>.GetAsync(() => new SelectLifestyle(CharacterObject)))
                {
                    // Make sure the dialogue window was not canceled.
                    if (await frmPickLifestyle.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    {
                        frmPickLifestyle.MyForm.SelectedLifestyle.Dispose();
                        return;
                    }

                    blnAddAgain = frmPickLifestyle.MyForm.AddAgain;
                    Lifestyle objLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;
                    objLifestyle.Increments = 0;
                    await CharacterObject.Lifestyles.AddAsync(objLifestyle);
                }
            }
            while (blnAddAgain);
        }

        private void cmdDeleteLifestyle_Click(object sender, EventArgs e)
        {
            RemoveSelectedObject(treLifestyles.SelectedNode?.Tag);
        }

        private async void cmdAddGear_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickGear(null, await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag as Location));
            }
            while (blnAddAgain);
        }

        private void cmdDeleteGear_Click(object sender, EventArgs e)
        {
            RemoveSelectedObject(treGear.SelectedNode?.Tag);
        }

        private async ValueTask<bool> AddVehicle(Location objLocation = null, CancellationToken token = default)
        {
            using (ThreadSafeForm<SelectVehicle> frmPickVehicle = await ThreadSafeForm<SelectVehicle>.GetAsync(() => new SelectVehicle(CharacterObject), token))
            {
                // Make sure the dialogue window was not canceled.
                if (await frmPickVehicle.ShowDialogSafeAsync(this, token) == DialogResult.Cancel)
                    return false;

                // Open the Vehicles XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("vehicles.xml", token: token);

                XmlNode objXmlVehicle = objXmlDocument.SelectSingleNode("/chummer/vehicles/vehicle[id = " + frmPickVehicle.MyForm.SelectedVehicle.CleanXPath() + ']');
                Vehicle objVehicle = new Vehicle(CharacterObject);
                objVehicle.Create(objXmlVehicle);
                // Update the Used Vehicle information if applicable.
                if (frmPickVehicle.MyForm.UsedVehicle)
                {
                    objVehicle.Avail = frmPickVehicle.MyForm.UsedAvail;
                    objVehicle.Cost = frmPickVehicle.MyForm.UsedCost.ToString(GlobalSettings.InvariantCultureInfo);
                }

                objVehicle.DiscountCost = frmPickVehicle.MyForm.BlackMarketDiscount;

                // Check the item's Cost and make sure the character can afford it.
                if (!frmPickVehicle.MyForm.FreeCost)
                {
                    decimal decCost = objVehicle.TotalCost;
                    // Apply a markup if applicable.
                    if (frmPickVehicle.MyForm.Markup != 0)
                    {
                        decCost *= 1 + frmPickVehicle.MyForm.Markup / 100.0m;
                    }

                    // Multiply the cost if applicable.
                    char chrAvail = objVehicle.TotalAvailTuple().Suffix;
                    switch (chrAvail)
                    {
                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                            break;

                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                            break;
                    }

                    if (decCost > CharacterObject.Nuyen)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return frmPickVehicle.MyForm.AddAgain;
                    }

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(decCost * -1, await LanguageManager.GetStringAsync("String_ExpensePurchaseVehicle") + await LanguageManager.GetStringAsync("String_Space") + objVehicle.CurrentDisplayNameShort, ExpenseType.Nuyen,
                        DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                    CharacterObject.Nuyen -= decCost;

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateNuyen(NuyenExpenseType.AddVehicle, objVehicle.InternalId);
                    objExpense.Undo = objUndo;
                }

                objVehicle.DiscountCost = frmPickVehicle.MyForm.BlackMarketDiscount;

                //objVehicle.Location = objLocation;
                if (objLocation != null)
                    await objLocation.Children.AddAsync(objVehicle);
                await CharacterObject.Vehicles.AddAsync(objVehicle);

                return frmPickVehicle.MyForm.AddAgain;
            }
        }

        private async void cmdAddVehicle_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await AddVehicle(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) as Location);
            }
            while (blnAddAgain);
        }

        private async void cmdDeleteVehicle_Click(object sender, EventArgs e)
        {
            await DoDeleteVehicle();
        }

        private async ValueTask DoDeleteVehicle(CancellationToken token = default)
        {
            if (!await cmdDeleteVehicle.DoThreadSafeFuncAsync(x => x.Enabled, token))
                return;
            // Delete the selected Vehicle.
            TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, token);
            // Delete the selected Vehicle.
            if (objSelectedNode == null)
            {
                return;
            }

            switch (objSelectedNode.Tag)
            {
                // If this is the Obsolete Mod, the user must select a percentage. This will create an Expense that costs X% of the Vehicle's base cost to remove the special Obsolete Mod.
                case VehicleMod objMod when objMod.Name == "Obsolete" || objMod.Name == "Obsolescent" && CharacterObjectSettings.AllowObsolescentUpgrade:
                {
                    string strRetrofit = await LanguageManager.GetStringAsync("String_Retrofit");
                        using (ThreadSafeForm<SelectNumber> frmModPercent = await ThreadSafeForm<SelectNumber>.GetAsync(() => new SelectNumber
                               {
                                   Minimum = 0,
                                   Maximum = 1000000,
                                   Description = strRetrofit
                               }, token))
                        {
                            if (await frmModPercent.ShowDialogSafeAsync(this, token) == DialogResult.Cancel)
                                return;

                            decimal decPercentage = frmModPercent.MyForm.SelectedValue;

                            decimal decVehicleCost = objMod.Parent.OwnCost;

                            // Make sure the character has enough Nuyen for the expense.
                            decimal decCost = decVehicleCost * decPercentage / 100;

                            // Create a Vehicle Mod for the Retrofit.
                            VehicleMod objRetrofit = new VehicleMod(CharacterObject);

                            XmlDocument objVehiclesDoc = await CharacterObject.LoadDataAsync("vehicles.xml", token: token);
                            XmlNode objXmlNode = objVehiclesDoc.SelectSingleNode("/chummer/mods/mod[name = \"Retrofit\"]");
                            objRetrofit.Create(objXmlNode, 0, objMod.Parent);
                            objRetrofit.Cost = decCost.ToString(GlobalSettings.InvariantCultureInfo);
                            objRetrofit.IncludedInVehicle = true;
                            await objMod.Parent.Mods.AddAsync(objRetrofit);

                            // Create an Expense Log Entry for removing the Obsolete Mod.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1, string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("String_ExpenseVehicleRetrofit"), objMod.Parent.CurrentDisplayName), ExpenseType.Nuyen, DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                            // Adjust the character's Nuyen total.
                            CharacterObject.Nuyen += decCost * -1;
                        }

                    break;
                }
                case ICanRemove selectedObject:
                    selectedObject.Remove();
                    break;
            }
        }

        private void cmdAddMartialArt_Click(object sender, EventArgs e)
        {
            MartialArt.Purchase(CharacterObject);
        }

        private void cmdDeleteMartialArt_Click(object sender, EventArgs e)
        {
            RemoveSelectedObject(treMartialArts.SelectedNode?.Tag);
        }

        private async void cmdAddMugshot_Click(object sender, EventArgs e)
        {
            try
            {
                if (!await AddMugshot(GenericToken))
                    return;
                string strText = await LanguageManager.GetStringAsync("String_Of")
                                 + CharacterObject.Mugshots.Count.ToString(GlobalSettings.CultureInfo);
                await lblNumMugshots.DoThreadSafeAsync(x => x.Text = strText, GenericToken);
                await nudMugshotIndex.DoThreadSafeAsync(x =>
                {
                    ++x.Maximum;
                    x.Value = CharacterObject.Mugshots.Count;
                }, GenericToken);
                await SetDirty(true);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteMugshot_Click(object sender, EventArgs e)
        {
            if (CharacterObject.Mugshots.Count == 0)
                return;
            try
            {
                RemoveMugshot(await nudMugshotIndex.DoThreadSafeFuncAsync(x => x.ValueAsInt) - 1);
                string strText = await LanguageManager.GetStringAsync("String_Of")
                                 + CharacterObject.Mugshots.Count.ToString(GlobalSettings.CultureInfo);
                await lblNumMugshots.DoThreadSafeAsync(x => x.Text = strText, GenericToken);
                await nudMugshotIndex.DoThreadSafeAsync(x =>
                {
                    --x.Maximum;
                    if (x.Value > x.Maximum)
                        x.Value = x.Maximum;
                    else
                    {
                        chkIsMainMugshot.DoThreadSafe(y =>
                        {
                            if (x.ValueAsInt - 1 == CharacterObject.MainMugshotIndex)
                                y.Checked = true;
                            else if (y.Checked)
                                y.Checked = false;
                        });

                        UpdateMugshot(picMugshot, x.ValueAsInt - 1);
                    }
                }, GenericToken);
                await SetDirty(true);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void nudMugshotIndex_ValueChanged(object sender, EventArgs e)
        {
            if (CharacterObject.Mugshots.Count == 0)
            {
                nudMugshotIndex.Minimum = 0;
                nudMugshotIndex.Maximum = 0;
                nudMugshotIndex.Value = 0;
            }
            else
            {
                nudMugshotIndex.Minimum = 1;
                if (nudMugshotIndex.Value < nudMugshotIndex.Minimum)
                    nudMugshotIndex.Value = nudMugshotIndex.Maximum;
                else if (nudMugshotIndex.Value > nudMugshotIndex.Maximum)
                    nudMugshotIndex.Value = nudMugshotIndex.Minimum;
            }

            if (nudMugshotIndex.ValueAsInt - 1 == CharacterObject.MainMugshotIndex)
                chkIsMainMugshot.Checked = true;
            else if (chkIsMainMugshot.Checked)
                chkIsMainMugshot.Checked = false;

            UpdateMugshot(picMugshot, nudMugshotIndex.ValueAsInt - 1);
        }

        private async void chkIsMainMugshot_CheckedChanged(object sender, EventArgs e)
        {
            bool blnStatusChanged = false;
            int intSelectedIndex = await nudMugshotIndex.DoThreadSafeFuncAsync(x => x.ValueAsInt);
            switch (await chkIsMainMugshot.DoThreadSafeFuncAsync(x => x.Checked))
            {
                case true when CharacterObject.MainMugshotIndex != intSelectedIndex - 1:
                    CharacterObject.MainMugshotIndex = intSelectedIndex - 1;
                    blnStatusChanged = true;
                    break;

                case false when intSelectedIndex - 1 == CharacterObject.MainMugshotIndex:
                    CharacterObject.MainMugshotIndex = -1;
                    blnStatusChanged = true;
                    break;
            }

            if (blnStatusChanged)
            {
                await SetDirty(true);
            }
        }

        private async void cmdAddMetamagic_Click(object sender, EventArgs e)
        {
            if (CharacterObject.MAGEnabled)
            {
                // Make sure that the Initiate Grade is not attempting to go above the character's MAG CharacterAttribute.
                if (CharacterObject.InitiateGrade + 1 > CharacterObject.MAG.TotalValue ||
                    CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept && CharacterObject.InitiateGrade + 1 > CharacterObject.MAGAdept.TotalValue)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotIncreaseInitiateGrade"), await LanguageManager.GetStringAsync("MessageTitle_CannotIncreaseInitiateGrade"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                // Make sure the character has enough Karma.
                decimal decMultiplier = 1.0m;
                if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked))
                    decMultiplier -= CharacterObjectSettings.KarmaMAGInitiationGroupPercent;
                if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked))
                    decMultiplier -= CharacterObjectSettings.KarmaMAGInitiationOrdealPercent;
                if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked))
                    decMultiplier -= CharacterObjectSettings.KarmaMAGInitiationSchoolingPercent;

                int intKarmaExpense = ((CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.InitiateGrade + 1) * CharacterObjectSettings.KarmaInitiation) * decMultiplier).StandardRound();

                if (intKarmaExpense > CharacterObject.Karma)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked))
                {
                    if (10000 > CharacterObject.Nuyen)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return;
                    }
                    if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaandNuyenExpense")
                        , await LanguageManager.GetStringAsync("String_InitiateGrade")
                        , (CharacterObject.InitiateGrade + 1).ToString(GlobalSettings.CultureInfo)
                        , intKarmaExpense.ToString(GlobalSettings.CultureInfo)
                        , 10000.ToString(CharacterObjectSettings.NuyenFormat, GlobalSettings.CultureInfo) + await LanguageManager.GetStringAsync("String_NuyenSymbol"))))
                        return;
                }
                else if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpense")
                    , await LanguageManager.GetStringAsync("String_InitiateGrade")
                    , (CharacterObject.InitiateGrade + 1).ToString(GlobalSettings.CultureInfo)
                    , intKarmaExpense.ToString(GlobalSettings.CultureInfo))))
                    return;

                string strSpace = await LanguageManager.GetStringAsync("String_Space");

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(intKarmaExpense * -1, await LanguageManager.GetStringAsync("String_ExpenseInitiateGrade")
                                                        + strSpace + CharacterObject.InitiateGrade.ToString(GlobalSettings.CultureInfo)
                                                        + strSpace + "->" + strSpace
                                                        + (CharacterObject.InitiateGrade + 1).ToString(GlobalSettings.CultureInfo), ExpenseType.Karma, DateTime.Now);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                CharacterObject.Karma -= intKarmaExpense;

                // Create the Initiate Grade object.
                InitiationGrade objGrade = new InitiationGrade(CharacterObject);
                objGrade.Create(CharacterObject.InitiateGrade + 1, false,
                                await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked),
                                await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked),
                                await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked));
                CharacterObject.InitiationGrades.AddWithSort(objGrade);

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.ImproveInitiateGrade, objGrade.InternalId);
                objExpense.Undo = objUndo;

                if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked))
                {
                    ExpenseLogEntry objNuyenExpense = new ExpenseLogEntry(CharacterObject);
                    objNuyenExpense.Create(-10000, await LanguageManager.GetStringAsync("String_ExpenseInitiateGrade")
                                                   + strSpace + CharacterObject.InitiateGrade.ToString(GlobalSettings.CultureInfo)
                                                   + strSpace + "->" + strSpace
                                                   + (CharacterObject.InitiateGrade + 1).ToString(GlobalSettings.CultureInfo), ExpenseType.Nuyen, DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objNuyenExpense);
                    CharacterObject.Nuyen -= 10000;

                    ExpenseUndo objNuyenUndo = new ExpenseUndo();
                    objNuyenUndo.CreateNuyen(NuyenExpenseType.ImproveInitiateGrade, objGrade.InternalId, 10000);
                    objNuyenExpense.Undo = objNuyenUndo;
                }

                int intAmount = ((CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.InitiateGrade + 1) * CharacterObjectSettings.KarmaInitiation) * decMultiplier).StandardRound();

                string strInitTip = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_ImproveInitiateGrade")
                    , (CharacterObject.InitiateGrade + 1).ToString(GlobalSettings.CultureInfo)
                    , intAmount.ToString(GlobalSettings.CultureInfo));
                await cmdAddMetamagic.SetToolTipAsync(strInitTip);
            }
            else if (CharacterObject.RESEnabled)
            {
                // Make sure that the Initiate Grade is not attempting to go above the character's RES CharacterAttribute.
                if (CharacterObject.SubmersionGrade + 1 > CharacterObject.RES.TotalValue)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotIncreaseSubmersionGrade"), await LanguageManager.GetStringAsync("MessageTitle_CannotIncreaseSubmersionGrade"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                // Make sure the character has enough Karma.
                decimal decMultiplier = 1.0m;
                if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked))
                    decMultiplier -= CharacterObjectSettings.KarmaRESInitiationGroupPercent;
                if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked))
                    decMultiplier -= CharacterObjectSettings.KarmaRESInitiationOrdealPercent;
                if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked))
                    decMultiplier -= CharacterObjectSettings.KarmaRESInitiationSchoolingPercent;

                int intKarmaExpense = ((CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.SubmersionGrade + 1) * CharacterObjectSettings.KarmaInitiation) * decMultiplier).StandardRound();

                if (intKarmaExpense > CharacterObject.Karma)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpense")
                    , await LanguageManager.GetStringAsync("String_SubmersionGrade")
                    , (CharacterObject.SubmersionGrade + 1).ToString(GlobalSettings.CultureInfo)
                    , intKarmaExpense.ToString(GlobalSettings.CultureInfo))))
                    return;

                string strSpace = await LanguageManager.GetStringAsync("String_Space");

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(intKarmaExpense * -1, await LanguageManager.GetStringAsync("String_ExpenseSubmersionGrade")
                                                        + strSpace + CharacterObject.SubmersionGrade.ToString(GlobalSettings.CultureInfo)
                                                        + strSpace + "->" + strSpace
                                                        + (CharacterObject.SubmersionGrade + 1).ToString(GlobalSettings.CultureInfo), ExpenseType.Karma, DateTime.Now);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                CharacterObject.Karma -= intKarmaExpense;

                // Create the Initiate Grade object.
                InitiationGrade objGrade = new InitiationGrade(CharacterObject);
                objGrade.Create(CharacterObject.SubmersionGrade + 1, true,
                                await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked),
                                await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked),
                                await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked));
                CharacterObject.InitiationGrades.AddWithSort(objGrade);

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.ImproveInitiateGrade, objGrade.InternalId);
                objExpense.Undo = objUndo;

                int intAmount = ((CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.SubmersionGrade + 1) * CharacterObjectSettings.KarmaInitiation) * decMultiplier).StandardRound();

                string strInitTip = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_ImproveSubmersionGrade")
                    , (CharacterObject.SubmersionGrade + 1).ToString(GlobalSettings.CultureInfo)
                    , intAmount.ToString(GlobalSettings.CultureInfo));
                await cmdAddMetamagic.SetToolTipAsync(strInitTip);
            }
        }

        private void cmdDeleteMetamagic_Click(object sender, EventArgs e)
        {
            RemoveSelectedObject(treMetamagic.SelectedNode?.Tag);
        }

        private async void cmdKarmaGained_Click(object sender, EventArgs e)
        {
            string strText = await LanguageManager.GetStringAsync("String_WorkingForThePeople");
            using (ThreadSafeForm<CreateExpense> frmNewExpense = await ThreadSafeForm<CreateExpense>.GetAsync(() => new CreateExpense(CharacterObjectSettings)
                   {
                       KarmaNuyenExchangeString = strText
                   }))
            {
                if (await frmNewExpense.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(frmNewExpense.MyForm.Amount, frmNewExpense.MyForm.Reason, ExpenseType.Karma, frmNewExpense.MyForm.SelectedDate, frmNewExpense.MyForm.Refund);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.ManualAdd, string.Empty);
                objExpense.Undo = objUndo;

                // Adjust the character's Karma total.
                CharacterObject.Karma += frmNewExpense.MyForm.Amount.ToInt32();

                if (frmNewExpense.MyForm.KarmaNuyenExchange)
                {
                    // Create the Expense Log Entry.
                    objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(frmNewExpense.MyForm.Amount * -CharacterObjectSettings.NuyenPerBPWftP, frmNewExpense.MyForm.Reason, ExpenseType.Nuyen, frmNewExpense.MyForm.SelectedDate);
                    objExpense.ForceCareerVisible = frmNewExpense.MyForm.ForceCareerVisible;
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                    objUndo = new ExpenseUndo();
                    objUndo.CreateNuyen(NuyenExpenseType.ManualSubtract, string.Empty);
                    objExpense.Undo = objUndo;

                    // Adjust the character's Nuyen total.
                    CharacterObject.Nuyen += frmNewExpense.MyForm.Amount * -CharacterObjectSettings.NuyenPerBPWftP;
                }
            }
        }

        private async void cmdKarmaSpent_Click(object sender, EventArgs e)
        {
            string strText = await LanguageManager.GetStringAsync("String_WorkingForTheMan");
            using (ThreadSafeForm<CreateExpense> frmNewExpense = await ThreadSafeForm<CreateExpense>.GetAsync(() => new CreateExpense(CharacterObjectSettings)
                   {
                       KarmaNuyenExchangeString = strText
                   }))
            {
                if (await frmNewExpense.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // Make sure the Karma expense would not put the character's remaining Karma amount below 0.
                if (CharacterObject.Karma - frmNewExpense.MyForm.Amount < 0)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(frmNewExpense.MyForm.Amount * -1, frmNewExpense.MyForm.Reason, ExpenseType.Karma, frmNewExpense.MyForm.SelectedDate, frmNewExpense.MyForm.Refund);
                objExpense.ForceCareerVisible = frmNewExpense.MyForm.ForceCareerVisible;
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.ManualSubtract, string.Empty);
                objExpense.Undo = objUndo;

                // Adjust the character's Karma total.
                CharacterObject.Karma -= frmNewExpense.MyForm.Amount.ToInt32();

                if (frmNewExpense.MyForm.KarmaNuyenExchange)
                {
                    // Create the Expense Log Entry.
                    objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(frmNewExpense.MyForm.Amount * CharacterObjectSettings.NuyenPerBPWftM, frmNewExpense.MyForm.Reason, ExpenseType.Nuyen, frmNewExpense.MyForm.SelectedDate);
                    objExpense.ForceCareerVisible = frmNewExpense.MyForm.ForceCareerVisible;
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                    objUndo = new ExpenseUndo();
                    objUndo.CreateNuyen(NuyenExpenseType.ManualSubtract, string.Empty);
                    objExpense.Undo = objUndo;

                    // Adjust the character's Nuyen total.
                    CharacterObject.Nuyen += frmNewExpense.MyForm.Amount * CharacterObjectSettings.NuyenPerBPWftM;
                }
            }
        }

        private async void cmdNuyenGained_Click(object sender, EventArgs e)
        {
            string strText = await LanguageManager.GetStringAsync("String_WorkingForTheMan");
            using (ThreadSafeForm<CreateExpense> frmNewExpense = await ThreadSafeForm<CreateExpense>.GetAsync(() => new CreateExpense(CharacterObjectSettings)
                   {
                       Mode = ExpenseType.Nuyen,
                       KarmaNuyenExchangeString = strText
                   }))
            {
                if (await frmNewExpense.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(frmNewExpense.MyForm.Amount, frmNewExpense.MyForm.Reason, ExpenseType.Nuyen, frmNewExpense.MyForm.SelectedDate);
                objExpense.Refund = frmNewExpense.MyForm.Refund;
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateNuyen(NuyenExpenseType.ManualAdd, string.Empty);
                objExpense.Undo = objUndo;

                // Adjust the character's Nuyen total.
                CharacterObject.Nuyen += frmNewExpense.MyForm.Amount;

                if (frmNewExpense.MyForm.KarmaNuyenExchange)
                {
                    // Create the Expense Log Entry.
                    objExpense = new ExpenseLogEntry(CharacterObject);
                    int intAmount = (frmNewExpense.MyForm.Amount / CharacterObjectSettings.NuyenPerBPWftM).ToInt32();
                    objExpense.Create(-intAmount, frmNewExpense.MyForm.Reason, ExpenseType.Karma, frmNewExpense.MyForm.SelectedDate, frmNewExpense.MyForm.Refund);
                    objExpense.ForceCareerVisible = frmNewExpense.MyForm.ForceCareerVisible;
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                    objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.ManualSubtract, string.Empty);
                    objExpense.Undo = objUndo;

                    // Adjust the character's Karma total.
                    CharacterObject.Karma -= intAmount;
                }
            }
        }

        private async void cmdNuyenSpent_Click(object sender, EventArgs e)
        {
            string strText = await LanguageManager.GetStringAsync("String_WorkingForThePeople");
            using (ThreadSafeForm<CreateExpense> frmNewExpense = await ThreadSafeForm<CreateExpense>.GetAsync(() => new CreateExpense(CharacterObjectSettings)
                   {
                       Mode = ExpenseType.Nuyen,
                       KarmaNuyenExchangeString = strText
                   }))
            {
                if (await frmNewExpense.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // Make sure the Nuyen expense would not put the character's remaining Nuyen amount below 0.
                if (CharacterObject.Nuyen - frmNewExpense.MyForm.Amount < 0)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(frmNewExpense.MyForm.Amount * -1, frmNewExpense.MyForm.Reason, ExpenseType.Nuyen, frmNewExpense.MyForm.SelectedDate);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateNuyen(NuyenExpenseType.ManualSubtract, string.Empty);
                objExpense.Undo = objUndo;

                // Adjust the character's Nuyen total.
                CharacterObject.Nuyen += frmNewExpense.MyForm.Amount * -1;

                if (frmNewExpense.MyForm.KarmaNuyenExchange)
                {
                    // Create the Expense Log Entry.
                    objExpense = new ExpenseLogEntry(CharacterObject);
                    int intAmount = (frmNewExpense.MyForm.Amount / CharacterObjectSettings.NuyenPerBPWftP).ToInt32();
                    objExpense.Create(intAmount, frmNewExpense.MyForm.Reason, ExpenseType.Karma, frmNewExpense.MyForm.SelectedDate, frmNewExpense.MyForm.Refund);
                    objExpense.ForceCareerVisible = frmNewExpense.MyForm.ForceCareerVisible;
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                    objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.ManualSubtract, string.Empty);
                    objExpense.Undo = objUndo;

                    // Adjust the character's Karma total.
                    CharacterObject.Karma += intAmount;
                }
            }
        }

        private async void cmdDecreaseLifestyleMonths_Click(object sender, EventArgs e)
        {
            // Locate the selected Lifestyle.
            if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Lifestyle objLifestyle))
                return;

            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
            objExpense.Create(0, await LanguageManager.GetStringAsync("String_ExpenseDecreaseLifestyle") + await LanguageManager.GetStringAsync("String_Space") + objLifestyle.CurrentDisplayNameShort, ExpenseType.Nuyen, DateTime.Now);
            CharacterObject.ExpenseEntries.AddWithSort(objExpense);

            --objLifestyle.Increments;

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdIncreaseLifestyleMonths_Click(object sender, EventArgs e)
        {
            // Locate the selected Lifestyle.
            if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Lifestyle objLifestyle))
                return;

            objLifestyle.IncrementMonths();

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdAddCritterPower_Click(object sender, EventArgs e)
        {
            // Make sure the Critter is allowed to have Optional Powers.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("critterpowers.xml");

            bool blnAddAgain;
            do
            {
                using (ThreadSafeForm<SelectCritterPower> frmPickCritterPower = await ThreadSafeForm<SelectCritterPower>.GetAsync(() => new SelectCritterPower(CharacterObject)))
                {
                    if (await frmPickCritterPower.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        break;
                    blnAddAgain = frmPickCritterPower.MyForm.AddAgain;

                    XmlNode objXmlPower = objXmlDocument.SelectSingleNode("/chummer/powers/power[id = " + frmPickCritterPower.MyForm.SelectedPower.CleanXPath() + ']');
                    CritterPower objPower = new CritterPower(CharacterObject);
                    objPower.Create(objXmlPower, frmPickCritterPower.MyForm.SelectedRating);
                    objPower.PowerPoints = frmPickCritterPower.MyForm.PowerPoints;
                    if (objPower.InternalId.IsEmptyGuid())
                        continue;

                    if (objPower.Karma > CharacterObject.Karma)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        continue;
                    }

                    if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend")
                        , objPower.CurrentDisplayName
                        , objPower.Karma.ToString(GlobalSettings.CultureInfo))))
                        continue;

                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(objPower.Karma * -1, await LanguageManager.GetStringAsync("String_ExpensePurchaseCritterPower") + await LanguageManager.GetStringAsync("String_Space") + objPower.CurrentDisplayNameShort, ExpenseType.Karma,
                        DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.AddCritterPower, objPower.InternalId);
                    objExpense.Undo = objUndo;

                    CharacterObject.Karma -= objPower.Karma;
                    await CharacterObject.CritterPowers.AddAsync(objPower);
                }
            }
            while (blnAddAgain);
        }

        private void cmdDeleteCritterPower_Click(object sender, EventArgs e)
        {
            // If the selected object is not a complex form or it comes from an initiate grade, we don't want to remove it.
            if (!(treCritterPowers.SelectedNode?.Tag is CritterPower objCritterPower) || objCritterPower.Grade != 0)
                return;
            objCritterPower.Remove();
        }

        private void cmdDeleteComplexForm_Click(object sender, EventArgs e)
        {
            // If the selected object is not a complex form or it comes from an initiate grade, we don't want to remove it.
            if (!(treComplexForms.SelectedNode?.Tag is ComplexForm objComplexForm) || objComplexForm.Grade != 0)
                return;
            objComplexForm.Remove();
        }

        private async void cmdGearReduceQty_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode);
            if (!(objSelectedNode?.Tag is Gear objGear))
                return;

            int intDecimalPlaces = 0;
            if (objGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
            {
                intDecimalPlaces = CharacterObjectSettings.MaxNuyenDecimals;
            }
            else if (objGear.Category == "Currency")
            {
                intDecimalPlaces = 2;
            }

            decimal decSelectedValue;
            string strDescription = await LanguageManager.GetStringAsync("String_ReduceGear");
            using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                       () => new SelectNumber(intDecimalPlaces)
                       {
                           Minimum = 0,
                           Maximum = objGear.Quantity,
                           Description = strDescription
                       }))
            {
                if (await frmPickNumber.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                decSelectedValue = frmPickNumber.MyForm.SelectedValue;
            }

            if (!CommonFunctions.ConfirmDelete(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ReduceQty"), decSelectedValue.ToString(GlobalSettings.CultureInfo))))
                return;

            objGear.Quantity -= decSelectedValue;

            if (objGear.Quantity > 0)
            {
                objSelectedNode.Text = objGear.CurrentDisplayName;
                await RequestCharacterUpdate();
                await SetDirty(true);
            }
            else
            {
                // Remove any Weapons that came with it.
                objGear.DeleteGear();
            }
        }

        private async void cmdGearSplitQty_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode);
            if (!(objSelectedNode?.Tag is Gear objSelectedGear))
                return;

            decimal decMinimumAmount = 1.0m;
            int intDecimalPlaces = 0;
            if (objSelectedGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
            {
                intDecimalPlaces = Math.Max(0, CharacterObjectSettings.MaxNuyenDecimals);
                // Need a for loop instead of a power system to maintain exact precision
                for (int i = 0; i < intDecimalPlaces; ++i)
                    decMinimumAmount /= 10.0m;
            }
            else if (objSelectedGear.Category == "Currency")
            {
                intDecimalPlaces = 2;
                decMinimumAmount = 0.01m;
            }
            // Cannot split a stack of 1 item.
            if (objSelectedGear.Quantity <= decMinimumAmount)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotSplitGear"), await LanguageManager.GetStringAsync("MessageTitle_CannotSplitGear"), MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_SplitGear");
            using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                       () => new SelectNumber(intDecimalPlaces)
                       {
                           Minimum = decMinimumAmount,
                           Maximum = objSelectedGear.Quantity - decMinimumAmount,
                           Description = strDescription
                       }))
            {
                if (await frmPickNumber.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // Create a new piece of Gear.
                Gear objGear = new Gear(CharacterObject);

                objGear.Copy(objSelectedGear);

                objGear.Quantity = frmPickNumber.MyForm.SelectedValue;
                objGear.Equipped = objSelectedGear.Equipped;
                objGear.Location = objSelectedGear.Location;
                objGear.Notes = objSelectedGear.Notes;

                // Update the selected item.
                objSelectedGear.Quantity -= objGear.Quantity;
                objSelectedNode.Text = objSelectedGear.CurrentDisplayName;

                await CharacterObject.Gear.AddAsync(objGear);
            }
        }

        private async void cmdGearMergeQty_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode);
            if (!(objSelectedNode?.Tag is Gear objGear))
                return;
            List<Gear> lstGear = new List<Gear>(CharacterObject.Gear.Count);

            foreach (Gear objCharacterGear in CharacterObject.Gear)
            {
                if (objCharacterGear.InternalId != objGear.InternalId
                    && objCharacterGear.IsIdenticalToOtherGear(objGear, true))
                    lstGear.Add(objCharacterGear);
            }

            // If there were no matches, don't try to merge anything.
            if (lstGear.Count == 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotMergeGear"), await LanguageManager.GetStringAsync("MessageTitle_CannotMergeGear"), MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            Gear objSelectedGear;
            // Show the Select Item window.
            using (ThreadSafeForm<SelectItem> frmPickItem = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem()))
            {
                frmPickItem.MyForm.SetGearMode(lstGear);

                if (await frmPickItem.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objSelectedGear = CharacterObject.Gear.DeepFindById(frmPickItem.MyForm.SelectedItem);
            }

            decimal decMinimumAmount = 1.0m;
            int intDecimalPlaces = 0;
            if (objSelectedGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
            {
                intDecimalPlaces = Math.Max(0, CharacterObjectSettings.MaxNuyenDecimals);
                // Need a for loop instead of a power system to maintain exact precision
                for (int i = 0; i < intDecimalPlaces; ++i)
                    decMinimumAmount /= 10.0m;
            }
            else if (objSelectedGear.Category == "Currency")
            {
                intDecimalPlaces = 2;
                decMinimumAmount = 0.01m;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_MergeGear");
            using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(() => new SelectNumber(intDecimalPlaces)
                   {
                       Minimum = decMinimumAmount,
                       Maximum = objGear.Quantity,
                       Description = strDescription
                   }))
            {
                if (await frmPickNumber.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // Increase the quantity for the selected item.
                objSelectedGear.Quantity += frmPickNumber.MyForm.SelectedValue;
                // Located the item in the Tree and update its display information.
                TreeNode objNode = treGear.FindNode(objSelectedGear.InternalId);
                if (objNode != null)
                    objNode.Text = objSelectedGear.CurrentDisplayName;

                // Reduce the quantity for the selected item.
                objGear.Quantity -= frmPickNumber.MyForm.SelectedValue;
            }

            // If the quantity has reached 0, delete the item and any Weapons it created.
            if (objGear.Quantity <= 0)
            {
                // Remove the Gear if its quantity has been reduced to 0.
                objGear.DeleteGear();
            }
            else
            {
                objSelectedNode.Text = objGear.CurrentDisplayName;
                await RequestCharacterUpdate();
                await SetDirty(true);
            }
        }

        private async void cmdGearMoveToVehicle_Click(object sender, EventArgs e)
        {
            Vehicle objVehicle;
            using (ThreadSafeForm<SelectItem> frmPickItem = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem()))
            {
                frmPickItem.MyForm.SetVehiclesMode(CharacterObject.Vehicles);

                if (await frmPickItem.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // Locate the selected Vehicle.
                objVehicle = await CharacterObject.Vehicles.FirstOrDefaultAsync(x => x.InternalId == frmPickItem.MyForm.SelectedItem);
            }

            if (objVehicle == null)
                return;

            TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode);
            if (!(objSelectedNode?.Tag is Gear objSelectedGear))
                return;

            decimal decMinimumAmount = 1.0m;
            int intDecimalPlaces = 0;
            if (objSelectedGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
            {
                intDecimalPlaces = Math.Max(0, CharacterObjectSettings.MaxNuyenDecimals);
                // Need a for loop instead of a power system to maintain exact precision
                for (int i = 0; i < intDecimalPlaces; ++i)
                    decMinimumAmount /= 10.0m;
            }
            else if (objSelectedGear.Category == "Currency")
            {
                intDecimalPlaces = 2;
                decMinimumAmount = 0.01m;
            }

            decimal decMove;
            if (objSelectedGear.Quantity == decMinimumAmount)
                decMove = decMinimumAmount;
            else
            {
                string strDescription = await LanguageManager.GetStringAsync("String_MoveGear");
                using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                           () => new SelectNumber(intDecimalPlaces)
                           {
                               Minimum = decMinimumAmount,
                               Maximum = objSelectedGear.Quantity,
                               Description = strDescription
                           }))
                {
                    if (await frmPickNumber.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return;

                    decMove = frmPickNumber.MyForm.SelectedValue;
                }
            }

            // See if the Vehicle already has a matching piece of Gear.
            Gear objFoundGear = objVehicle.GearChildren.FirstOrDefault(x => x.IsIdenticalToOtherGear(objSelectedGear));

            if (objFoundGear == null)
            {
                // Create a new piece of Gear.
                Gear objGear = new Gear(CharacterObject);

                objGear.Copy(objSelectedGear);

                objGear.Quantity = decMove;
                objGear.Location = null;

                objGear.Parent = objVehicle;
                await objVehicle.GearChildren.AddAsync(objGear);
            }
            else
            {
                // Everything matches up, so just increase the quantity.
                objFoundGear.Quantity += decMove;
                await treVehicles.DoThreadSafeAsync(x =>
                {
                    TreeNode objFoundNode = x.FindNode(objFoundGear.InternalId);
                    if (objFoundNode != null)
                        objFoundNode.Text = objFoundGear.CurrentDisplayName;
                });
            }

            // Update the selected item.
            objSelectedGear.Quantity -= decMove;
            if (objSelectedGear.Quantity <= 0)
            {
                objSelectedGear.DeleteGear();
            }
            else
            {
                objSelectedNode.Text = objSelectedGear.CurrentDisplayName;
                await RequestCharacterUpdate();
                await SetDirty(true);
            }
        }

        private async void cmdVehicleMoveToInventory_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode);
            if (objSelectedNode == null)
                return;
            switch (objSelectedNode.Tag)
            {
                // Locate the selected Weapon.
                case Weapon objWeapon:
                    {
                        CharacterObject.Vehicles.FindVehicleWeapon(objWeapon.InternalId, out Vehicle objVehicle, out WeaponMount objMount, out VehicleMod objMod);
                        // Move the Weapons from the Vehicle Mod (or Vehicle) to the character.
                        Weapon objParent = objWeapon.Parent;
                        if (objParent != null)
                            await objParent.Children.RemoveAsync(objWeapon);
                        else if (objMount != null)
                            await objMount.Weapons.RemoveAsync(objWeapon);
                        else if (objMod != null)
                            await objMod.Weapons.RemoveAsync(objWeapon);
                        else
                            await objVehicle.Weapons.RemoveAsync(objWeapon);

                        await CharacterObject.Weapons.AddAsync(objWeapon);

                        objWeapon.ParentVehicle = null;

                        List<Gear> lstGearToMove = new List<Gear>();
                        foreach (Clip objClip in objWeapon.Clips)
                        {
                            if (objClip.AmmoGear != null)
                            {
                                lstGearToMove.Add(objClip.AmmoGear);
                            }
                        }
                        foreach (Clip objClip in objWeapon.Children.GetAllDescendants(x => x.Children).SelectMany(x => x.Clips))
                        {
                            if (objClip.AmmoGear != null)
                            {
                                lstGearToMove.Add(objClip.AmmoGear);
                            }
                        }
                        foreach (Gear objGear in lstGearToMove)
                        {
                            switch (objGear.Parent)
                            {
                                case IHasGear objHasChildren:
                                    await objHasChildren.GearChildren.RemoveAsync(objGear);
                                    break;

                                case IHasChildren<Gear> objHasChildren:
                                    await objHasChildren.Children.RemoveAsync(objGear);
                                    break;

                                default:
                                    continue;
                            }

                            await CharacterObject.Gear.AddAsync(objGear);
                        }

                        break;
                    }
                case Gear objSelectedGear:
                    {
                        // Locate the selected Gear.
                        CharacterObject.Vehicles.FindVehicleGear(objSelectedGear.InternalId);

                        decimal decMinimumAmount = 1.0m;
                        int intDecimalPlaces = 0;
                        if (objSelectedGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
                        {
                            intDecimalPlaces = Math.Max(0, CharacterObjectSettings.MaxNuyenDecimals);
                            // Need a for loop instead of a power system to maintain exact precision
                            for (int i = 0; i < intDecimalPlaces; ++i)
                                decMinimumAmount /= 10.0m;
                        }
                        else if (objSelectedGear.Category == "Currency")
                        {
                            intDecimalPlaces = 2;
                            decMinimumAmount = 0.01m;
                        }

                        decimal decMove;
                        if (objSelectedGear.Quantity == decMinimumAmount)
                            decMove = decMinimumAmount;
                        else
                        {
                            string strDescription = await LanguageManager.GetStringAsync("String_MoveGear");
                            using (ThreadSafeForm<SelectNumber> frmPickNumber
                                   = await ThreadSafeForm<SelectNumber>.GetAsync(
                                       () => new SelectNumber(intDecimalPlaces)
                                       {
                                           Minimum = decMinimumAmount,
                                           Maximum = objSelectedGear.Quantity,
                                           Description = strDescription
                                       }))
                            {
                                if (await frmPickNumber.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                                    return;

                                decMove = frmPickNumber.MyForm.SelectedValue;
                            }
                        }

                        // See if the character already has a matching piece of Gear.
                        Gear objFoundGear = CharacterObject.Gear.FirstOrDefault(x => objSelectedGear.IsIdenticalToOtherGear(x));

                        if (objFoundGear == null)
                        {
                            // Create a new piece of Gear.
                            Gear objGear = new Gear(CharacterObject);

                            objGear.Copy(objSelectedGear);

                            objGear.Quantity = decMove;

                            await CharacterObject.Gear.AddAsync(objGear);

                            objGear.AddGearImprovements();
                        }
                        else
                        {
                            // Everything matches up, so just increase the quantity.
                            objFoundGear.Quantity += decMove;
                            await treGear.DoThreadSafeAsync(x =>
                            {
                                TreeNode objFoundNode = x.FindNode(objFoundGear.InternalId);
                                if (objFoundNode != null)
                                    objFoundNode.Text = objFoundGear.CurrentDisplayName;
                            });
                        }

                        // Update the selected item.
                        objSelectedGear.Quantity -= decMove;
                        if (objSelectedGear.Quantity <= 0)
                        {
                            objSelectedGear.DeleteGear();
                        }
                        else
                        {
                            objSelectedNode.Text = objSelectedGear.CurrentDisplayName;
                            await RequestCharacterUpdate();
                            await SetDirty(true);
                        }

                        break;
                    }
            }
        }

        private async void cmdGearIncreaseQty_Click(object sender, EventArgs e)
        {
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objGear))
                return;
            bool blnAddAgain;
            do
            {
                // Select the root Gear node then open the Select Gear window.
                blnAddAgain = await PickGear(objGear.Parent as IHasChildren<Gear>, objGear.Location, objGear, objGear.CurrentDisplayNameShort);
            }
            while (blnAddAgain);
        }

        private async void cmdVehicleGearReduceQty_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode);
            if (!(objSelectedNode?.Tag is Gear objGear))
                return;
            int intDecimalPlaces = 0;
            if (objGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
            {
                intDecimalPlaces = Math.Max(0, CharacterObjectSettings.MaxNuyenDecimals);
            }
            else if (objGear.Category == "Currency")
            {
                intDecimalPlaces = 2;
            }

            decimal decSelectedValue;
            string strDescription = await LanguageManager.GetStringAsync("String_ReduceGear");
            using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                       () => new SelectNumber(intDecimalPlaces)
                       {
                           Minimum = 0,
                           Maximum = objGear.Quantity,
                           Description = strDescription
                       }))
            {
                if (await frmPickNumber.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                decSelectedValue = frmPickNumber.MyForm.SelectedValue;
            }

            if (!CommonFunctions.ConfirmDelete(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ReduceQty"), decSelectedValue.ToString(GlobalSettings.CultureInfo))))
                return;

            objGear.Quantity -= decSelectedValue;

            if (objGear.Quantity > 0)
            {
                await treVehicles.DoThreadSafeAsync(() => objSelectedNode.Text = objGear.CurrentDisplayName);
                await RequestCharacterUpdate();
                await SetDirty(true);
            }
            else
            {
                // Remove the Gear if its quantity has been reduced to 0.
                objGear.DeleteGear();
            }
        }

        private async void cmdAddQuality_Click(object sender, EventArgs e)
        {
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("qualities.xml");
            bool blnAddAgain;
            do
            {
                bool blnFreeCost;
                XmlNode objXmlQuality;
                int intRatingToAdd;
                using (ThreadSafeForm<SelectQuality> frmPickQuality = await ThreadSafeForm<SelectQuality>.GetAsync(() => new SelectQuality(CharacterObject)))
                {
                    // Don't do anything else if the form was canceled.
                    if (await frmPickQuality.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        break;
                    blnAddAgain = frmPickQuality.MyForm.AddAgain;
                    blnFreeCost = frmPickQuality.MyForm.FreeCost;

                    objXmlQuality = objXmlDocument.SelectSingleNode("/chummer/qualities/quality[id = " + frmPickQuality.MyForm.SelectedQuality.CleanXPath() + ']');
                    intRatingToAdd = frmPickQuality.MyForm.SelectedRating;
                    int intDummy = 0;
                    if (objXmlQuality != null && objXmlQuality["nolevels"] == null && objXmlQuality.TryGetInt32FieldQuickly("limit", ref intDummy))
                    {
                        intRatingToAdd -= CharacterObject.Qualities.Count(x =>
                            x.SourceIDString.Equals(frmPickQuality.MyForm.SelectedQuality,
                                StringComparison.InvariantCultureIgnoreCase) && string.IsNullOrEmpty(x.SourceName));
                    }
                }

                if (objXmlQuality == null)
                    continue;

                QualityType eQualityType = QualityType.Positive;
                string strTemp = string.Empty;
                if (objXmlQuality.TryGetStringFieldQuickly("category", ref strTemp))
                    eQualityType = Quality.ConvertToQualityType(strTemp);

                for (int i = 1; i <= intRatingToAdd; ++i)
                {
                    // Positive Metagenetic Qualities are free if you're a Changeling.
                    if (CharacterObject.MetagenicLimit > 0 && objXmlQuality["metagenic"]?.InnerText == bool.TrueString)
                        blnFreeCost = true;
                    // The Beast's Way and the Spiritual Way get the Mentor Spirit for free.
                    else if (objXmlQuality["name"]?.InnerText == "Mentor Spirit" &&
                             CharacterObject.Qualities.Any(x =>
                                 x.Name == "The Beast's Way" || x.Name == "The Spiritual Way"))
                        blnFreeCost = true;

                    int intQualityBP = 0;
                    if (!blnFreeCost)
                    {
                        objXmlQuality.TryGetInt32FieldQuickly("karma", ref intQualityBP);
                        XmlNode xmlDiscountNode = objXmlQuality["costdiscount"];
                        if (xmlDiscountNode?.CreateNavigator().RequirementsMet(CharacterObject) == true)
                        {
                            int intTemp = 0;
                            xmlDiscountNode.TryGetInt32FieldQuickly("value", ref intTemp);
                            switch (eQualityType)
                            {
                                case QualityType.Positive:
                                    intQualityBP += intTemp;
                                    break;

                                case QualityType.Negative:
                                    intQualityBP -= intTemp;
                                    break;
                            }
                        }
                    }

                    int intKarmaCost = intQualityBP * CharacterObjectSettings.KarmaQuality;
                    if (!CharacterObjectSettings.DontDoubleQualityPurchases &&
                        objXmlQuality["doublecareer"]?.InnerText != bool.FalseString)
                        intKarmaCost *= 2;

                    // Make sure the character has enough Karma to pay for the Quality.
                    if (eQualityType == QualityType.Positive)
                    {
                        if (!blnFreeCost)
                        {
                            if (intKarmaCost > CharacterObject.Karma &&
                                objXmlQuality["stagedpurchase"]?.InnerText != bool.TrueString)
                            {
                                Program.ShowMessageBox(this,
                                    await LanguageManager.GetStringAsync("Message_NotEnoughKarma"),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK,
                                    MessageBoxIcon.Information);
                                break;
                            }

                            string strDisplayName = objXmlQuality["translate"]?.InnerText ??
                                                    objXmlQuality["name"]?.InnerText ??
                                                    await LanguageManager.GetStringAsync("String_Unknown");
                            if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend"), strDisplayName,
                                intKarmaCost.ToString(GlobalSettings.CultureInfo))))
                                break;
                        }
                    }
                    else if (Program.ShowMessageBox(this,
                        await LanguageManager.GetStringAsync("Message_AddNegativeQuality"),
                        await LanguageManager.GetStringAsync("MessageTitle_AddNegativeQuality"), MessageBoxButtons.YesNo,
                        MessageBoxIcon.Question) == DialogResult.No)
                        break;

                    List<Weapon> lstWeapons = new List<Weapon>(1);
                    Quality objQuality = new Quality(CharacterObject);

                    objQuality.Create(objXmlQuality, QualitySource.Selected, lstWeapons);
                    if (objQuality.InternalId.IsEmptyGuid())
                    {
                        // If the Quality could not be added, remove the Improvements that were added during the Quality Creation process.
                        await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Quality,
                                                                         objQuality.InternalId);
                        break;
                    }

                    // Make sure the character has enough Karma to pay for the Quality.
                    if (objQuality.Type == QualityType.Positive)
                    {
                        if (objQuality.ContributeToBP)
                        {
                            // Create the Karma expense.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(intKarmaCost * -1,
                                await LanguageManager.GetStringAsync("String_ExpenseAddPositiveQuality") +
                                await LanguageManager.GetStringAsync("String_Space") +
                                objQuality.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                            CharacterObject.Karma -= intKarmaCost;

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateKarma(KarmaExpenseType.AddQuality, objQuality.InternalId);
                            objExpense.Undo = objUndo;
                        }
                    }
                    else
                    {
                        // Create a Karma Expense for the Negative Quality.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(0,
                            await LanguageManager.GetStringAsync("String_ExpenseAddNegativeQuality") +
                            await LanguageManager.GetStringAsync("String_Space") +
                            objQuality.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
                        CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateKarma(KarmaExpenseType.AddQuality, objQuality.InternalId);
                        objExpense.Undo = objUndo;
                    }

                    await CharacterObject.Qualities.AddAsync(objQuality);

                    // Add any created Weapons to the character.
                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objWeapon);
                    }
                }
            }
            while (blnAddAgain);
        }

        private async void cmdDeleteQuality_Click(object sender, EventArgs e)
        {
            await DoDeleteQuality();
        }

        private async ValueTask DoDeleteQuality()
        {
            // Locate the selected Quality.
            if (!(await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Quality objSelectedQuality))
                return;
            string strInternalIDToRemove = objSelectedQuality.InternalId;
            // Can't do a foreach because we're removing items, this is the next best thing
            Quality objQualityToRemove =
                CharacterObject.Qualities.LastOrDefault(x => x.InternalId == strInternalIDToRemove);
            await RemoveQuality(objQualityToRemove);
        }

        private async void cmdSwapQuality_Click(object sender, EventArgs e)
        {
            // Locate the selected Quality.
            Quality objQuality = await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) as Quality;
            if (objQuality?.InternalId.IsEmptyGuid() != false)
                return;

            switch (objQuality.OriginSource)
            {
                // Qualities that come from a Metatype cannot be removed.
                case QualitySource.Metatype:
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_MetavariantQualitySwap"),
                        await LanguageManager.GetStringAsync("MessageTitle_MetavariantQualitySwap"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                // Neither can qualities from Improvements
                case QualitySource.Improvement:
                    Program.ShowMessageBox(this, string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ImprovementQuality"), await objQuality.GetSourceNameAsync(GlobalSettings.Language)),
                        await LanguageManager.GetStringAsync("MessageTitle_MetavariantQuality"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
            }

            XmlNode objXmlQuality;
            int intRatingToAdd;
            using (ThreadSafeForm<SelectQuality> frmPickQuality = await ThreadSafeForm<SelectQuality>.GetAsync(
                       () => new SelectQuality(CharacterObject)
                       {
                           ForceCategory = objQuality.Type.ToString(),
                           IgnoreQuality = objQuality.Name
                       }))
            {
                // Don't do anything else if the form was canceled.
                if (await frmPickQuality.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objXmlQuality = (await CharacterObject.LoadDataAsync("qualities.xml")).SelectSingleNode("/chummer/qualities/quality[id = " + frmPickQuality.MyForm.SelectedQuality.CleanXPath() + ']');
                intRatingToAdd = frmPickQuality.MyForm.SelectedRating;
                int intDummy = 0;
                if (objXmlQuality != null && objXmlQuality["nolevels"] == null && objXmlQuality.TryGetInt32FieldQuickly("limit", ref intDummy))
                {
                    intRatingToAdd -= CharacterObject.Qualities.Count(x =>
                        x.SourceIDString.Equals(frmPickQuality.MyForm.SelectedQuality,
                            StringComparison.InvariantCultureIgnoreCase) && string.IsNullOrEmpty(x.SourceName));
                }
            }

            if (intRatingToAdd > 0)
            {
                Quality objNewQuality = new Quality(CharacterObject);

                objNewQuality.Swap(objQuality, objXmlQuality, intRatingToAdd);
            }
        }

        private async ValueTask<bool> RemoveQuality(Quality objSelectedQuality, bool blnConfirmDelete = true, bool blnCompleteDelete = true)
        {
            XPathNavigator objXmlDeleteQuality = await objSelectedQuality.GetNodeXPathAsync();
            bool blnMetatypeQuality = false;

            switch (objSelectedQuality.OriginSource)
            {
                // Qualities that come from a Metatype cannot be removed.
                case QualitySource.Metatype:
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_MetavariantQuality"), await LanguageManager.GetStringAsync("MessageTitle_MetavariantQuality"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return false;

                case QualitySource.Improvement:
                    Program.ShowMessageBox(this, string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ImprovementQuality"), await objSelectedQuality.GetSourceNameAsync(GlobalSettings.Language)), await LanguageManager.GetStringAsync("MessageTitle_MetavariantQuality"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return false;

                case QualitySource.MetatypeRemovable:
                    {
                        // Look up the cost of the Quality.
                        int intBP = 0;
                        if (objSelectedQuality.Type == QualityType.Negative || await objXmlDeleteQuality.SelectSingleNodeAndCacheExpressionAsync("refundkarmaonremove") != null)
                        {
                            intBP = Convert.ToInt32((await objXmlDeleteQuality.SelectSingleNodeAndCacheExpressionAsync("karma"))?.Value, GlobalSettings.InvariantCultureInfo) * CharacterObjectSettings.KarmaQuality;
                            if (blnCompleteDelete)
                                intBP *= objSelectedQuality.Levels;
                            if (!CharacterObjectSettings.DontDoubleQualityPurchases && objSelectedQuality.DoubleCost)
                            {
                                intBP *= 2;
                            }
                            if (objSelectedQuality.Type == QualityType.Positive)
                                intBP *= -1;
                        }
                        string strBP = intBP.ToString(GlobalSettings.CultureInfo) + await LanguageManager.GetStringAsync("String_Space") + await LanguageManager.GetStringAsync("String_Karma");

                        if (blnConfirmDelete && !CommonFunctions.ConfirmDelete(
                            string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(blnCompleteDelete ? "Message_DeleteMetatypeQuality" : "Message_LowerMetatypeQualityLevel"), strBP)))
                            return false;

                        blnMetatypeQuality = true;
                        break;
                    }
            }

            if (objSelectedQuality.Type == QualityType.Positive)
            {
                if (await objXmlDeleteQuality.SelectSingleNodeAndCacheExpressionAsync("refundkarmaonremove") != null)
                {
                    int intKarmaCost = objSelectedQuality.BP * CharacterObjectSettings.KarmaQuality;

                    if (!CharacterObjectSettings.DontDoubleQualityPurchases && objSelectedQuality.DoubleCost)
                    {
                        intKarmaCost *= 2;
                    }

                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(intKarmaCost, string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("String_ExpenseSwapPositiveQuality")
                        , objSelectedQuality.CurrentDisplayNameShort
                        , await LanguageManager.GetStringAsync("String_Karma")), ExpenseType.Karma, DateTime.Now, true);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                    CharacterObject.Karma += intKarmaCost;

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.RemoveQuality, objSelectedQuality.SourceIDString);
                    objUndo.Extra = objSelectedQuality.Extra;
                    objExpense.Undo = objUndo;
                }
                else if (!blnMetatypeQuality && blnConfirmDelete && !CommonFunctions.ConfirmDelete(blnCompleteDelete
                    ? await LanguageManager.GetStringAsync("Message_DeletePositiveQualityCareer")
                    : await LanguageManager.GetStringAsync("Message_LowerPositiveQualityLevelCareer")))
                    return false;
            }
            else
            {
                // Make sure the character has enough Karma to buy off the Quality.
                int intKarmaCost = -(objSelectedQuality.BP * CharacterObjectSettings.KarmaQuality);
                if (!CharacterObjectSettings.DontDoubleQualityRefunds)
                {
                    intKarmaCost *= 2;
                }
                int intTotalKarmaCost = intKarmaCost;
                if (blnCompleteDelete)
                    intTotalKarmaCost *= objSelectedQuality.Levels;
                if (intTotalKarmaCost > CharacterObject.Karma)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return false;
                }

                if (!blnMetatypeQuality && blnConfirmDelete && !CommonFunctions.ConfirmKarmaExpense(
                    string.Format(GlobalSettings.CultureInfo, blnCompleteDelete
                        ? await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseRemove") : await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseLowerLevel"),
                        objSelectedQuality.CurrentDisplayNameShort, intTotalKarmaCost)))
                    return false;

                // Create the Karma expense.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(-intTotalKarmaCost, await LanguageManager.GetStringAsync("String_ExpenseRemoveNegativeQuality") + await LanguageManager.GetStringAsync("String_Space") + objSelectedQuality.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                CharacterObject.Karma -= intTotalKarmaCost;

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.RemoveQuality, objSelectedQuality.SourceIDString);
                objUndo.Extra = objSelectedQuality.Extra;
                objExpense.Undo = objUndo;
            }

            // Remove any Critter Powers that are gained through the Quality (Infected).
            if (await objXmlDeleteQuality.SelectSingleNodeAndCacheExpressionAsync("powers/power") != null)
            {
                foreach (XPathNavigator objXmlPower in await (await CharacterObject.LoadDataXPathAsync("critterpowers.xml")).SelectAndCacheExpressionAsync("optionalpowers/optionalpower"))
                {
                    string strExtra = (await objXmlPower.SelectSingleNodeAndCacheExpressionAsync("@select"))?.Value;

                    foreach (CritterPower objPower in CharacterObject.CritterPowers)
                    {
                        if (objPower.Name != objXmlPower.Value || objPower.Extra != strExtra)
                            continue;
                        // Remove any Improvements created by the Critter Power.
                        await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.CritterPower, objPower.InternalId);

                        // Remove the Critter Power from the character.
                        await CharacterObject.CritterPowers.RemoveAsync(objPower);
                        break;
                    }
                }
            }

            // Fix for legacy characters with old addqualities improvements.
            await RemoveAddedQualities(objXmlDeleteQuality.Select("addqualities/addquality"));

            // Perform removal
            objSelectedQuality.DeleteQuality(blnCompleteDelete);
            return true;
        }

        private async ValueTask UpdateQualityLevelValue(Quality objSelectedQuality = null, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objSelectedQuality == null
                || objSelectedQuality.OriginSource == QualitySource.Improvement
                || objSelectedQuality.OriginSource == QualitySource.Metatype
                || objSelectedQuality.Levels == 0)
            {
                await nudQualityLevel.DoThreadSafeAsync(x =>
                {
                    x.Value = 1;
                    x.Enabled = false;
                }, token);
                return;
            }
            token.ThrowIfCancellationRequested();
            XPathNavigator objQualityNode = await objSelectedQuality.GetNodeXPathAsync(token);
            string strLimitString = objQualityNode != null
                ? (await objQualityNode.SelectSingleNodeAndCacheExpressionAsync("limit"))?.Value ?? string.Empty
                : string.Empty;
            token.ThrowIfCancellationRequested();
            if (!string.IsNullOrWhiteSpace(strLimitString) && await objQualityNode.SelectSingleNodeAndCacheExpressionAsync("nolevels") == null && int.TryParse(strLimitString, out int intMaxRating))
            {
                await nudQualityLevel.DoThreadSafeAsync(x =>
                {
                    x.Maximum = intMaxRating;
                    x.Value = objSelectedQuality.Levels;
                    x.Enabled = true;
                }, token);
            }
            else
            {
                await nudQualityLevel.DoThreadSafeAsync(x =>
                {
                    x.Value = 1;
                    x.Enabled = false;
                }, token);
            }
        }

        private async void nudQualityLevel_ValueChanged(object sender, EventArgs e)
        {
            // Locate the selected Quality.
            if (await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Quality objSelectedQuality)
            {
                int intCurrentLevels = objSelectedQuality.Levels;
                int intSelectedLevels = await nudQualityLevel.DoThreadSafeFuncAsync(x => x.ValueAsInt);
                // Adding a new level
                for (; intSelectedLevels > intCurrentLevels; ++intCurrentLevels)
                {
                    XPathNavigator objXmlSelectedQuality = await objSelectedQuality.GetNodeXPathAsync();
                    if (!objXmlSelectedQuality.RequirementsMet(CharacterObject, await LanguageManager.GetStringAsync("String_Quality")))
                    {
                        await UpdateQualityLevelValue(objSelectedQuality);
                        break;
                    }

                    bool blnFreeCost = objSelectedQuality.BP == 0 || !objSelectedQuality.ContributeToBP;

                    QualityType eQualityType = objSelectedQuality.Type;

                    int intQualityBP = 0;
                    if (!blnFreeCost)
                    {
                        objXmlSelectedQuality.TryGetInt32FieldQuickly("karma", ref intQualityBP);
                        XPathNavigator xpnDiscountNode = await objXmlSelectedQuality.SelectSingleNodeAndCacheExpressionAsync("costdiscount");
                        if (xpnDiscountNode?.RequirementsMet(CharacterObject) == true)
                        {
                            int intTemp = 0;
                            xpnDiscountNode.TryGetInt32FieldQuickly("value", ref intTemp);
                            switch (eQualityType)
                            {
                                case QualityType.Positive:
                                    intQualityBP += intTemp;
                                    break;

                                case QualityType.Negative:
                                    intQualityBP -= intTemp;
                                    break;
                            }
                        }
                    }

                    int intKarmaCost = intQualityBP * CharacterObjectSettings.KarmaQuality;
                    if (!CharacterObjectSettings.DontDoubleQualityPurchases && objSelectedQuality.DoubleCost)
                        intKarmaCost *= 2;

                    // Make sure the character has enough Karma to pay for the Quality.
                    if (eQualityType == QualityType.Positive)
                    {
                        if (!blnFreeCost)
                        {
                            if (intKarmaCost > CharacterObject.Karma && !objSelectedQuality.StagedPurchase)
                            {
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK,
                                    MessageBoxIcon.Information);
                                await UpdateQualityLevelValue(objSelectedQuality);
                                break;
                            }

                            string strDisplayName
                                = (await objXmlSelectedQuality.SelectSingleNodeAndCacheExpressionAsync("translate"))?.Value
                                  ?? (await objXmlSelectedQuality.SelectSingleNodeAndCacheExpressionAsync("name"))?.Value
                                  ?? await LanguageManager.GetStringAsync("String_Unknown");
                            if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend")
                                , strDisplayName
                                , intKarmaCost.ToString(GlobalSettings.CultureInfo))))
                            {
                                await UpdateQualityLevelValue(objSelectedQuality);
                                break;
                            }
                        }
                    }
                    else if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_AddNegativeQuality"), await LanguageManager.GetStringAsync("MessageTitle_AddNegativeQuality"), MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                    {
                        await UpdateQualityLevelValue(objSelectedQuality);
                        break;
                    }

                    List<Weapon> lstWeapons = new List<Weapon>(1);
                    Quality objQuality = new Quality(CharacterObject);

                    objQuality.Create(await objSelectedQuality.GetNodeAsync(), QualitySource.Selected, lstWeapons, objSelectedQuality.Extra);
                    if (objQuality.InternalId.IsEmptyGuid())
                    {
                        // If the Quality could not be added, remove the Improvements that were added during the Quality Creation process.
                        await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Quality, objQuality.InternalId);
                        await UpdateQualityLevelValue(objSelectedQuality);
                        break;
                    }

                    objQuality.BP = objSelectedQuality.BP;
                    objQuality.ContributeToLimit = objSelectedQuality.ContributeToLimit;

                    // Make sure the character has enough Karma to pay for the Quality.
                    if (objQuality.Type == QualityType.Positive)
                    {
                        // Create the Karma expense.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(intKarmaCost * -1, await LanguageManager.GetStringAsync("String_ExpenseAddPositiveQuality") + await LanguageManager.GetStringAsync("String_Space") + objQuality.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
                        CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                        CharacterObject.Karma -= intKarmaCost;

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateKarma(KarmaExpenseType.AddQuality, objQuality.InternalId);
                        objExpense.Undo = objUndo;
                    }
                    else
                    {
                        // Create a Karma Expense for the Negative Quality.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(0, await LanguageManager.GetStringAsync("String_ExpenseAddNegativeQuality") + await LanguageManager.GetStringAsync("String_Space") + objQuality.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
                        CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateKarma(KarmaExpenseType.AddQuality, objQuality.InternalId);
                        objExpense.Undo = objUndo;
                    }

                    // Add the Quality to the appropriate parent node.
                    await CharacterObject.Qualities.AddAsync(objQuality);

                    // Add any created Weapons to the character.
                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objWeapon);
                    }
                }
                // Removing a level
                for (; intSelectedLevels < intCurrentLevels; --intCurrentLevels)
                {
                    Quality objInvisibleQuality = CharacterObject.Qualities.FirstOrDefault(x => x.SourceIDString == objSelectedQuality.SourceIDString && x.Extra == objSelectedQuality.Extra && x.SourceName == objSelectedQuality.SourceName && x.InternalId != objSelectedQuality.InternalId);
                    if (objInvisibleQuality == null || !await RemoveQuality(objInvisibleQuality, false, false))
                    {
                        if (!await RemoveQuality(objSelectedQuality, false, false))
                        {
                            await UpdateQualityLevelValue(objSelectedQuality);
                        }
                        break;
                    }
                }
            }
        }

        private async void cmdAddLocation_Click(object sender, EventArgs e)
        {
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            // Add a new location to the Gear Tree.
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                    return;

                Location objLocation = new Location(CharacterObject, CharacterObject.GearLocations, frmPickText.MyForm.SelectedValue);
                await CharacterObject.GearLocations.AddAsync(objLocation);
            }
        }

        private async void cmdAddWeaponLocation_Click(object sender, EventArgs e)
        {
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            // Add a new location to the Gear Tree.
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                    return;

                Location objLocation = new Location(CharacterObject, CharacterObject.WeaponLocations, frmPickText.MyForm.SelectedValue);
                await CharacterObject.WeaponLocations.AddAsync(objLocation);
            }
        }

        private async void cmdAddWeek_Click(object sender, EventArgs e)
        {
            CalendarWeek objWeek = new CalendarWeek();
            CalendarWeek objLastWeek = CharacterObject.Calendar?.FirstOrDefault();
            if (objLastWeek != null)
            {
                objWeek.Year = objLastWeek.Year;
                objWeek.Week = objLastWeek.Week + 1;
                if (objWeek.Week > 52)
                {
                    objWeek.Week = 1;
                    ++objWeek.Year;
                }
            }
            else
            {
                using (ThreadSafeForm<SelectCalendarStart> frmPickStart
                       = await ThreadSafeForm<SelectCalendarStart>.GetAsync(() => new SelectCalendarStart()))
                {
                    if (await frmPickStart.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return;

                    objWeek.Year = frmPickStart.MyForm.SelectedYear;
                    objWeek.Week = frmPickStart.MyForm.SelectedWeek;
                }
            }

            CharacterObject.Calendar.AddWithSort(objWeek, (x, y) => y.CompareTo(x));
        }

        private async void cmdDeleteWeek_Click(object sender, EventArgs e)
        {
            if (lstCalendar == null || await lstCalendar.DoThreadSafeFuncAsync(x => x.SelectedItems.Count == 0))
            {
                return;
            }

            string strWeekId = await lstCalendar.DoThreadSafeFuncAsync(x => x.SelectedItems[0].SubItems[2].Text);

            CalendarWeek objCharacterWeek = CharacterObject.Calendar.FirstOrDefault(x => x.InternalId == strWeekId);

            if (objCharacterWeek == null)
                return;
            if (!CommonFunctions.ConfirmDelete(await LanguageManager.GetStringAsync("Message_DeleteCalendarWeek")))
                return;

            await CharacterObject.Calendar.RemoveAsync(objCharacterWeek);
        }

        private async void cmdEditWeek_Click(object sender, EventArgs e)
        {
            if (lstCalendar == null || await lstCalendar.DoThreadSafeFuncAsync(x => x.SelectedItems.Count == 0))
            {
                return;
            }

            string strWeekId = await lstCalendar.DoThreadSafeFuncAsync(x => x.SelectedItems[0].SubItems[2].Text);

            CalendarWeek objWeek = CharacterObject.Calendar.FirstOrDefault(x => x.InternalId == strWeekId);

            if (objWeek == null)
                return;
            using (ThreadSafeForm<EditNotes> frmItemNotes = await ThreadSafeForm<EditNotes>.GetAsync(() => new EditNotes(objWeek.Notes, objWeek.NotesColor)))
            {
                if (await frmItemNotes.ShowDialogSafeAsync(this) != DialogResult.OK)
                    return;
                objWeek.Notes = frmItemNotes.MyForm.Notes;
                objWeek.NotesColor = frmItemNotes.MyForm.NotesColor;
                await SetDirty(true);
            }
        }

        private async void cmdChangeStartWeek_Click(object sender, EventArgs e)
        {
            // Find the first date.
            CalendarWeek objStart = CharacterObject.Calendar?.LastOrDefault();
            if (objStart == null)
            {
                return;
            }

            int intYear;
            int intWeek;
            using (ThreadSafeForm<SelectCalendarStart> frmPickStart = await ThreadSafeForm<SelectCalendarStart>.GetAsync(() => new SelectCalendarStart(objStart)))
            {
                if (await frmPickStart.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                intYear = frmPickStart.MyForm.SelectedYear;
                intWeek = frmPickStart.MyForm.SelectedWeek;
            }

            // Determine the difference between the starting value and selected values for year and week.
            int intYearDiff = intYear - objStart.Year;
            int intWeekDiff = intWeek - objStart.Week;

            // Update each of the CalendarWeek entries for the character.
            foreach (CalendarWeek objWeek in CharacterObject.Calendar)
            {
                objWeek.Week += intWeekDiff;
                objWeek.Year += intYearDiff;

                // If the date range goes outside of 52 weeks, increase or decrease the year as necessary.
                if (objWeek.Week < 1)
                {
                    --objWeek.Year;
                    objWeek.Week += 52;
                }
                else if (objWeek.Week > 52)
                {
                    ++objWeek.Year;
                    objWeek.Week -= 52;
                }
            }

            await SetDirty(true);
        }

        private async void cmdAddImprovement_Click(object sender, EventArgs e)
        {
            await DoAddImprovement();
        }

        private async ValueTask DoAddImprovement()
        {
            string location
                = await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is string strSelectedId
                  && strSelectedId != "Node_SelectedImprovements"
                    ? strSelectedId
                    : string.Empty;
            using (ThreadSafeForm<CreateImprovement> frmPickImprovement = await ThreadSafeForm<CreateImprovement>.GetAsync(() => new CreateImprovement(CharacterObject, location)))
            {
                if (await frmPickImprovement.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;
            }

            await RefreshCustomImprovements(treImprovements, lmtControl.LimitTreeView, cmsImprovementLocation, cmsImprovement, lmtControl.LimitContextMenuStrip);
        }

        private async void cmdCreateStackedFocus_Click(object sender, EventArgs e)
        {
            int intFree = 0;
            List<Gear> lstGear = new List<Gear>(CharacterObject.Gear.Count);

            // Run through all of the Foci the character has and count the un-Bonded ones.
            foreach (Gear objGear in CharacterObject.Gear)
            {
                if ((objGear.Category == "Foci" || objGear.Category == "Metamagic Foci") && !objGear.Bonded)
                {
                    ++intFree;
                    lstGear.Add(objGear);
                }
            }

            // If the character does not have at least 2 un-Bonded Foci, display an error and leave.
            if (intFree < 2)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotStackFoci"), await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            List<Gear> lstStack = new List<Gear>(lstGear.Count);
            string strDescription = await LanguageManager.GetStringAsync("String_SelectItemFocus");
            using (ThreadSafeForm<SelectItem> frmPickItem = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem
                   {
                       Description = strDescription,
                       AllowAutoSelect = false
                   }))
            {
                // Let the character select the Foci they'd like to stack, stopping when they either click Cancel or there are no more items left in the list.
                DialogResult eResult;
                do
                {
                    frmPickItem.MyForm.SetGearMode(lstGear);
                    eResult = await frmPickItem.ShowDialogSafeAsync(this);
                    if (eResult != DialogResult.OK)
                        continue;
                    // Move the item from the Gear list to the Stack list.
                    foreach (Gear objGear in lstGear)
                    {
                        if (objGear.InternalId != frmPickItem.MyForm.SelectedItem)
                            continue;
                        objGear.Bonded = true;
                        lstStack.Add(objGear);
                        lstGear.Remove(objGear);
                        break;
                    }
                } while (lstGear.Count > 0 && eResult != DialogResult.Cancel);
            }

            // Make sure at least 2 Foci were selected.
            if (lstStack.Count < 2)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_StackedFocusMinimum"), await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Make sure the combined Force of the Foci do not exceed 6.
            if (!CharacterObjectSettings.AllowHigherStackedFoci)
            {
                int intCombined = lstStack.Sum(objGear => objGear.Rating);
                if (intCombined > 6)
                {
                    foreach (Gear objGear in lstStack)
                        objGear.Bonded = false;
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_StackedFocusForce"), await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }
            }

            // Create the Stacked Focus.
            StackedFocus objStack = new StackedFocus(CharacterObject);
            foreach (Gear objGear in lstStack)
                await objStack.Gear.AddAsync(objGear);
            await CharacterObject.StackedFoci.AddAsync(objStack);

            // Remove the Gear from the character and replace it with a Stacked Focus item.
            decimal decCost = 0.0m;
            foreach (Gear objGear in lstStack)
            {
                decCost += objGear.TotalCost;
                await CharacterObject.Gear.RemoveAsync(objGear);
            }

            Gear objStackItem = new Gear(CharacterObject)
            {
                Category = "Stacked Focus",
                Name = "Stacked Focus: " + objStack.CurrentDisplayName,
                Source = "SR5",
                Page = "1",
                Cost = decCost.ToString(GlobalSettings.CultureInfo),
                Avail = "0"
            };

            await CharacterObject.Gear.AddAsync(objStackItem);

            objStack.GearId = objStackItem.InternalId;
        }

        private async void cmdBurnStreetCred_Click(object sender, EventArgs e)
        {
            if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_BurnStreetCred"), await LanguageManager.GetStringAsync("MessageTitle_BurnStreetCred"), MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                return;

            CharacterObject.BurntStreetCred += 2;
        }

        private async void cmdEditImprovement_Click(object sender, EventArgs e)
        {
            await DoEditImprovement();
        }

        private async ValueTask DoEditImprovement()
        {
            // Edit the selected Improvement.
            if (!(await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Improvement objImprovement))
                return;
            using (ThreadSafeForm<CreateImprovement> frmPickImprovement = await ThreadSafeForm<CreateImprovement>.GetAsync(
                       () => new CreateImprovement(CharacterObject, objImprovement.CustomGroup)
                       {
                           EditImprovementObject = objImprovement
                       }))
            {
                if (await frmPickImprovement.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                TreeNode newNode = null;
                if (!string.IsNullOrEmpty(frmPickImprovement.MyForm.NewImprovement?.InternalId))
                    newNode = await treImprovements.DoThreadSafeFuncAsync(x => x.FindNode(frmPickImprovement.MyForm.NewImprovement.InternalId));

                if (newNode != null)
                {
                    await treImprovements.DoThreadSafeAsync(() =>
                    {
                        newNode.Text = frmPickImprovement.MyForm.NewImprovement.CustomName;
                        newNode.ForeColor = frmPickImprovement.MyForm.NewImprovement.PreferredColor;
                        newNode.ToolTipText = frmPickImprovement.MyForm.NewImprovement.Notes;
                    });
                }
                else
                {
                    Utils.BreakIfDebug();
                }

                //TODO: This is currently necessary because the Custom Improvement refresh fires before the improvement is assigned a custom group.
                // Simplest way to fix this would be to make the customgroup a variable in the CreateImprovements method, but that's spooky.
                if (!string.IsNullOrWhiteSpace(frmPickImprovement.MyForm.NewImprovement?.CustomGroup))
                {
                    await RefreshCustomImprovements(treImprovements, lmtControl.LimitTreeView, cmsImprovementLocation, cmsImprovement, lmtControl.LimitContextMenuStrip);
                }
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdDeleteImprovement_Click(object sender, EventArgs e)
        {
            await DoDeleteImprovement();
        }

        private async ValueTask DoDeleteImprovement()
        {
            switch (await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag))
            {
                case Improvement objImprovement:
                    if (CommonFunctions.ConfirmDelete(await LanguageManager.GetStringAsync("Message_DeleteImprovement")))
                        await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Custom,
                                                                         objImprovement.SourceName);
                    break;
                case string strSelectedId:
                    if (strSelectedId == "Node_SelectedImprovements")
                        return;
                    if (!CommonFunctions.ConfirmDelete(
                            await LanguageManager.GetStringAsync("Message_DeleteImprovementGroup")))
                        return;
                    foreach (Improvement imp in CharacterObject.Improvements)
                    {
                        if (imp.CustomGroup == strSelectedId)
                        {
                            imp.CustomGroup = string.Empty;
                        }
                    }
                    // Remove the Group from the character, then remove the selected node.
                    await CharacterObject.ImprovementGroups.RemoveAsync(strSelectedId);
                    break;
            }
        }

        private async void cmdAddArmorBundle_Click(object sender, EventArgs e)
        {
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            // Add a new location to the Armor Tree.
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                       () => new SelectText
                       {
                           Description = strDescription
                       }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                    return;

                Location objLocation = new Location(CharacterObject, CharacterObject.ArmorLocations, frmPickText.MyForm.SelectedValue);
                await CharacterObject.ArmorLocations.AddAsync(objLocation);
            }
        }

        private async void cmdArmorEquipAll_Click(object sender, EventArgs e)
        {
            object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag);
            if (objSelected is Location selectedLocation)
            {
                // Equip all of the Armor in the Armor Bundle.
                foreach (Armor objArmor in selectedLocation.Children.OfType<Armor>())
                {
                    if (objArmor.Location == selectedLocation)
                    {
                        objArmor.Equipped = true;
                    }
                }
            }
            else if (objSelected?.ToString() == "Node_SelectedArmor")
            {
                foreach (Armor objArmor in CharacterObject.Armor.Where(objArmor =>
                    !objArmor.Equipped && objArmor.Location == null))
                {
                    objArmor.Equipped = true;
                }
            }
            else
            {
                return;
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdArmorUnEquipAll_Click(object sender, EventArgs e)
        {
            object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag);
            if (objSelected is Location selectedLocation)
            {
                // Equip all of the Armor in the Armor Bundle.
                foreach (Armor objArmor in selectedLocation.Children.OfType<Armor>())
                {
                    if (objArmor.Location == selectedLocation)
                    {
                        objArmor.Equipped = false;
                    }
                }
            }
            else if (objSelected?.ToString() == "Node_SelectedArmor")
            {
                foreach (Armor objArmor in CharacterObject.Armor.Where(objArmor =>
                    objArmor.Equipped && objArmor.Location == null))
                {
                    objArmor.Equipped = false;
                }
            }
            else
            {
                return;
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdImprovementsEnableAll_Click(object sender, EventArgs e)
        {
            // Enable all of the Improvements in the Improvement Group.
            if (!(await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is string strSelectedId))
                return;
            List<Improvement> lstImprovementsEnabled;
            if (strSelectedId == "Node_SelectedImprovements")
            {
                lstImprovementsEnabled = CharacterObject.Improvements
                                                        .Where(objImprovement =>
                                                                   objImprovement.Custom && !objImprovement.Enabled
                                                                   && string.IsNullOrEmpty(objImprovement.CustomGroup))
                                                        .ToList();
            }
            else
            {
                lstImprovementsEnabled = CharacterObject.Improvements
                                                        .Where(objImprovement =>
                                                                   objImprovement.Custom && !objImprovement.Enabled
                                                                   && objImprovement.CustomGroup == strSelectedId)
                                                        .ToList();
            }
            if (lstImprovementsEnabled.Count == 0)
                return;
            ImprovementManager.EnableImprovements(CharacterObject, lstImprovementsEnabled);
            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdImprovementsDisableAll_Click(object sender, EventArgs e)
        {
            if (!(await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is string strSelectedId))
                return;
            // Disable all of the Improvements in the Improvement Group.
            List<Improvement> lstImprovementsDisabled;
            if (strSelectedId == "Node_SelectedImprovements")
            {
                lstImprovementsDisabled = CharacterObject.Improvements
                                                         .Where(objImprovement =>
                                                                    objImprovement.Custom && objImprovement.Enabled
                                                                    && string.IsNullOrEmpty(objImprovement.CustomGroup))
                                                         .ToList();
            }
            else
            {
                lstImprovementsDisabled = CharacterObject.Improvements
                                                         .Where(objImprovement =>
                                                                    objImprovement.Custom && objImprovement.Enabled
                                                                    && objImprovement.CustomGroup == strSelectedId)
                                                         .ToList();
            }
            if (lstImprovementsDisabled.Count == 0)
                return;
            ImprovementManager.DisableImprovements(CharacterObject, lstImprovementsDisabled);
            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdAddVehicleLocation_Click(object sender, EventArgs e)
        {
            ICollection<Location> destCollection;
            object objSelected = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag);
            // Make sure a Vehicle is selected.
            if (objSelected is Vehicle objVehicle)
            {
                destCollection = objVehicle.Locations;
            }
            else if (objSelected == null || objSelected.ToString() == "Node_SelectedVehicles")
            {
                destCollection = CharacterObject.VehicleLocations;
            }
            else
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectVehicleLocation"), await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            // Add a new location to the Armor Tree.
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                       () => new SelectText
                       {
                           Description = strDescription
                       }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                    return;
                Location objLocation = new Location(CharacterObject, destCollection, frmPickText.MyForm.SelectedValue);
                destCollection.Add(objLocation);
            }
        }

        private async void cmdQuickenSpell_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode);
            if (objSelectedNode == null || objSelectedNode.Level != 1)
                return;

            string strSelectedSpell = objSelectedNode.Text;
            int intKarmaCost;
            string strDescription = string.Format(GlobalSettings.CultureInfo,
                                                  await LanguageManager.GetStringAsync("String_QuickeningKarma"),
                                                  strSelectedSpell);
            using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(
                       () => new SelectNumber(0)
                       {
                           Description = strDescription,
                           Minimum = 1
                       }))
            {
                if (await frmPickNumber.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                intKarmaCost = frmPickNumber.MyForm.SelectedValue.ToInt32();
            }

            // Make sure the character has enough Karma to improve the CharacterAttribute.
            if (intKarmaCost > CharacterObject.Karma)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseQuickeningMetamagic")
                , intKarmaCost.ToString(GlobalSettings.CultureInfo)
                , strSelectedSpell)))
                return;

            // Create the Karma expense.
            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
            objExpense.Create(intKarmaCost * -1, await LanguageManager.GetStringAsync("String_ExpenseQuickenMetamagic") + await LanguageManager.GetStringAsync("String_Space") + strSelectedSpell, ExpenseType.Karma, DateTime.Now);
            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
            CharacterObject.Karma -= intKarmaCost;

            ExpenseUndo objUndo = new ExpenseUndo();
            objUndo.CreateKarma(KarmaExpenseType.QuickeningMetamagic, string.Empty);
            objExpense.Undo = objUndo;
        }

        private void cmdAddSustainedSpell_Click(object sender, EventArgs e)
        {
            AddSustainedSpell();
        }

        private void cmdAddSustainedForm_Click(object sender, EventArgs e)
        {
            AddSustainedComplexForm();
        }

        private void cmdAddSustainedCritterPower_Click(object sender, EventArgs e)
        {
            AddSustainedCritterPower();
        }

        #endregion Button Events

        #region ContextMenu Events

        private void InitiationContextMenu_Opening(object sender, CancelEventArgs e)
        {
            // Enable and disable menu items
            if (!(treMetamagic.SelectedNode?.Tag is InitiationGrade objGrade))
                return;
            int intGrade = objGrade.Grade;
            bool blnHasArt = CharacterObject.Arts.Any(art => art.Grade == intGrade);
            bool blnHasBonus = CharacterObject.Metamagics.Any(bonus => bonus.Grade == intGrade) || CharacterObject.Spells.Any(spell => spell.Grade == intGrade);
            tsMetamagicAddArt.Enabled = !blnHasArt;
            tsMetamagicAddMetamagic.Enabled = !blnHasBonus;
        }

        private async void tsCyberwareAddAsPlugin_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Cyberware window.
            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objCyberware && !string.IsNullOrWhiteSpace(objCyberware.AllowedSubsystems)))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectCyberware"), await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickCyberware(objCyberware, objCyberware.SourceType);
            }
            while (blnAddAgain);
        }

        private async void tsVehicleCyberwareAddAsPlugin_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Cyberware window.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objCyberware && !string.IsNullOrWhiteSpace(objCyberware.AllowedSubsystems)))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectCyberware"), await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickCyberware(objCyberware, objCyberware.SourceType);
            }
            while (blnAddAgain);
        }

        private async void tsWeaponAddAccessory_Click(object sender, EventArgs e)
        {
            // Make sure a parent item is selected, then open the Select Accessory window.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectWeaponAccessory"), await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Accessories cannot be added to Cyberweapons.
            if (objWeapon.Cyberware)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CyberweaponNoAccessory"), await LanguageManager.GetStringAsync("MessageTitle_CyberweaponNoAccessory"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Weapons XML file and locate the selected Weapon.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("weapons.xml");

            XmlNode objXmlWeapon = await objWeapon.GetNodeAsync();
            if (objXmlWeapon == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotFindWeapon"), await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            bool blnAddAgain;

            do
            {
                // Make sure the Weapon allows Accessories to be added to it.
                if (!objWeapon.AllowAccessory)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotModifyWeapon"), await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    break;
                }

                using (ThreadSafeForm<SelectWeaponAccessory> frmPickWeaponAccessory
                       = await ThreadSafeForm<SelectWeaponAccessory>.GetAsync(() => new SelectWeaponAccessory(CharacterObject)
                       {
                           ParentWeapon = objWeapon
                       }))
                {
                    if (await frmPickWeaponAccessory.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        break;
                    blnAddAgain = frmPickWeaponAccessory.MyForm.AddAgain;

                    // Locate the selected piece.
                    objXmlWeapon = objXmlDocument.SelectSingleNode("/chummer/accessories/accessory[id = " + frmPickWeaponAccessory.MyForm.SelectedAccessory.CleanXPath() + ']');

                    WeaponAccessory objAccessory = new WeaponAccessory(CharacterObject);
                    objAccessory.Create(objXmlWeapon, frmPickWeaponAccessory.MyForm.SelectedMount, frmPickWeaponAccessory.MyForm.SelectedRating);
                    objAccessory.Parent = objWeapon;
                    objAccessory.DiscountCost = frmPickWeaponAccessory.MyForm.BlackMarketDiscount;

                    // Check the item's Cost and make sure the character can afford it.
                    decimal decOriginalCost = objWeapon.TotalCost;

                    await objWeapon.WeaponAccessories.AddAsync(objAccessory);

                    if (!frmPickWeaponAccessory.MyForm.FreeCost)
                    {
                        decimal decCost = objWeapon.TotalCost - decOriginalCost;
                        // Apply a markup if applicable.
                        if (frmPickWeaponAccessory.MyForm.Markup != 0)
                        {
                            decCost *= 1 + frmPickWeaponAccessory.MyForm.Markup / 100.0m;
                        }

                        // Multiply the cost if applicable.
                        char chrAvail = objAccessory.TotalAvailTuple().Suffix;
                        switch (chrAvail)
                        {
                            case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                break;

                            case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                break;
                        }

                        if (decCost > CharacterObject.Nuyen)
                        {
                            await objWeapon.WeaponAccessories.RemoveAsync(objAccessory);
                            Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                            continue;
                        }

                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(decCost * -1, await LanguageManager.GetStringAsync("String_ExpensePurchaseWeaponAccessory") + await LanguageManager.GetStringAsync("String_Space") + objAccessory.CurrentDisplayNameShort,
                            ExpenseType.Nuyen, DateTime.Now);
                        CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                        CharacterObject.Nuyen -= decCost;

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateNuyen(NuyenExpenseType.AddWeaponAccessory, objAccessory.InternalId);
                        objExpense.Undo = objUndo;
                    }
                }
            }
            while (blnAddAgain);
        }

        private async ValueTask<bool> PickArmor(Location objLocation = null)
        {
            using (ThreadSafeForm<SelectArmor> frmPickArmor = await ThreadSafeForm<SelectArmor>.GetAsync(() => new SelectArmor(CharacterObject)))
            {
                // Make sure the dialogue window was not canceled.
                if (await frmPickArmor.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return false;

                // Open the Armor XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("armor.xml");

                XmlNode objXmlArmor = objXmlDocument.SelectSingleNode("/chummer/armors/armor[id = " + frmPickArmor.MyForm.SelectedArmor.CleanXPath() + ']');

                Armor objArmor = new Armor(CharacterObject);
                List<Weapon> lstWeapons = new List<Weapon>(1);
                objArmor.Create(objXmlArmor, frmPickArmor.MyForm.Rating, lstWeapons);
                objArmor.DiscountCost = frmPickArmor.MyForm.BlackMarketDiscount;

                if (objArmor.InternalId.IsEmptyGuid())
                    return frmPickArmor.MyForm.AddAgain;

                // Check the item's Cost and make sure the character can afford it.
                if (!frmPickArmor.MyForm.FreeCost)
                {
                    decimal decCost = objArmor.TotalCost;
                    // Apply a markup if applicable.
                    if (frmPickArmor.MyForm.Markup != 0)
                    {
                        decCost *= 1 + frmPickArmor.MyForm.Markup / 100.0m;
                    }

                    // Multiply the cost if applicable.
                    char chrAvail = objArmor.TotalAvailTuple().Suffix;
                    switch (chrAvail)
                    {
                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                            break;

                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                            break;
                    }

                    if (decCost > CharacterObject.Nuyen)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        // Remove the Improvements created by the Armor.
                        await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Armor, objArmor.InternalId);

                        return frmPickArmor.MyForm.AddAgain;
                    }

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(decCost * -1, await LanguageManager.GetStringAsync("String_ExpensePurchaseArmor") + await LanguageManager.GetStringAsync("String_Space") + objArmor.CurrentDisplayNameShort, ExpenseType.Nuyen, DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                    CharacterObject.Nuyen -= decCost;

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateNuyen(NuyenExpenseType.AddArmor, objArmor.InternalId);
                    objExpense.Undo = objUndo;
                }

                // objArmor.Location = objLocation;
                if (objLocation != null)
                    await objLocation.Children.AddAsync(objArmor);
                await CharacterObject.Armor.AddAsync(objArmor);

                foreach (Weapon objWeapon in lstWeapons)
                {
                    await CharacterObject.Weapons.AddAsync(objWeapon);
                }

                return frmPickArmor.MyForm.AddAgain;
            }
        }

        private async void tsArmorLocationAddArmor_Click(object sender, EventArgs e)
        {
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objSelectedLocation))
                return;
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickArmor(objSelectedLocation);
            }
            while (blnAddAgain);
        }

        private async void tsAddArmorMod_Click(object sender, EventArgs e)
        {
            // Make sure a parent item is selected, then open the Select Accessory window.
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Armor objArmor))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectArmor"), await LanguageManager.GetStringAsync("MessageTitle_SelectArmor"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Armor XML file and locate the selected Armor.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("armor.xml");

            XmlNode objXmlArmor = await objArmor.GetNodeAsync();

            string strAllowedCategories = objArmor.Category + ',' + objArmor.Name;
            bool blnExcludeGeneralCategory = false;
            XmlNode xmlAddModCategory = objXmlArmor["forcemodcategory"];
            if (xmlAddModCategory != null)
            {
                strAllowedCategories = xmlAddModCategory.InnerText;
                blnExcludeGeneralCategory = true;
            }
            else
            {
                xmlAddModCategory = objXmlArmor["addmodcategory"];
                if (xmlAddModCategory != null)
                {
                    strAllowedCategories += ',' + xmlAddModCategory.InnerText;
                }
            }

            bool blnAddAgain;
            do
            {
                using (ThreadSafeForm<SelectArmorMod> frmPickArmorMod = await ThreadSafeForm<SelectArmorMod>.GetAsync(
                           () => new SelectArmorMod(CharacterObject, objArmor)
                           {
                               ArmorCost = objArmor.OwnCost,
                               ArmorCapacity
                                   = Convert.ToDecimal(objArmor.CalculatedCapacity(GlobalSettings.InvariantCultureInfo),
                                                       GlobalSettings.InvariantCultureInfo),
                               AllowedCategories = strAllowedCategories,
                               ExcludeGeneralCategory = blnExcludeGeneralCategory,
                               CapacityDisplayStyle = objArmor.CapacityDisplayStyle
                           }))
                {
                    if (await frmPickArmorMod.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        break;
                    blnAddAgain = frmPickArmorMod.MyForm.AddAgain;

                    // Locate the selected piece.
                    objXmlArmor = objXmlDocument.SelectSingleNode("/chummer/mods/mod[id = " + frmPickArmorMod.MyForm.SelectedArmorMod.CleanXPath() + ']');

                    if (objXmlArmor == null)
                        continue;

                    ArmorMod objMod = new ArmorMod(CharacterObject);
                    List<Weapon> lstWeapons = new List<Weapon>(1);
                    int intRating = Convert.ToInt32(objXmlArmor["maxrating"]?.InnerText, GlobalSettings.InvariantCultureInfo) > 1 ? frmPickArmorMod.MyForm.SelectedRating : 0;

                    objMod.Create(objXmlArmor, intRating, lstWeapons);
                    if (objMod.InternalId.IsEmptyGuid())
                        continue;

                    // Check the item's Cost and make sure the character can afford it.
                    decimal decOriginalCost = objArmor.TotalCost;
                    await objArmor.ArmorMods.AddAsync(objMod);

                    // Do not allow the user to add a new piece of Armor if its Capacity has been reached.
                    if (CharacterObjectSettings.EnforceCapacity && objArmor.CapacityRemaining < 0)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CapacityReached"), await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        await objArmor.ArmorMods.RemoveAsync(objMod);
                        continue;
                    }

                    if (!frmPickArmorMod.MyForm.FreeCost)
                    {
                        decimal decCost = objArmor.TotalCost - decOriginalCost;
                        // Apply a markup if applicable.
                        if (frmPickArmorMod.MyForm.Markup != 0)
                        {
                            decCost *= 1 + frmPickArmorMod.MyForm.Markup / 100.0m;
                        }

                        // Multiply the cost if applicable.
                        char chrAvail = objMod.TotalAvailTuple().Suffix;
                        switch (chrAvail)
                        {
                            case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                break;

                            case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                break;
                        }

                        if (decCost > CharacterObject.Nuyen)
                        {
                            await objArmor.ArmorMods.RemoveAsync(objMod);
                            Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                            // Remove the Improvements created by the Armor Mod.
                            await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.ArmorMod, objMod.InternalId);
                            continue;
                        }

                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(decCost * -1, await LanguageManager.GetStringAsync("String_ExpensePurchaseArmorMod") + await LanguageManager.GetStringAsync("String_Space") + objMod.CurrentDisplayNameShort, ExpenseType.Nuyen,
                            DateTime.Now);
                        CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                        CharacterObject.Nuyen -= decCost;

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateNuyen(NuyenExpenseType.AddArmorMod, objMod.InternalId);
                        objExpense.Undo = objUndo;
                    }

                    // Add any Weapons created by the Mod.
                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objWeapon);
                    }
                }
            }
            while (blnAddAgain);
        }

        private async void tsGearAddAsPlugin_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Gear window.
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasChildren<Gear> iParent))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickGear(iParent);
            }
            while (blnAddAgain);
        }

        private async void tsVehicleAddMod_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x =>
            {
                while (x.SelectedNode?.Level > 1)
                    x.SelectedNode = x.SelectedNode.Parent;
                return x.SelectedNode;
            });
            // Make sure a parent items is selected, then open the Select Vehicle Mod window.
            if (!(objSelectedNode?.Tag is Vehicle objVehicle))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectVehicle"), await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Vehicles XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("vehicles.xml");

            bool blnAddAgain;

            do
            {
                using (ThreadSafeForm<SelectVehicleMod> frmPickVehicleMod
                       = await ThreadSafeForm<SelectVehicleMod>.GetAsync(
                           () => new SelectVehicleMod(CharacterObject, objVehicle, objVehicle.Mods)))
                {
                    // Make sure the dialogue window was not canceled.
                    if (await frmPickVehicleMod.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        break;
                    blnAddAgain = frmPickVehicleMod.MyForm.AddAgain;

                    XmlNode objXmlMod = objXmlDocument.SelectSingleNode("/chummer/mods/mod[id = " + frmPickVehicleMod.MyForm.SelectedMod.CleanXPath() + ']');

                    VehicleMod objMod = new VehicleMod(CharacterObject)
                    {
                        DiscountCost = frmPickVehicleMod.MyForm.BlackMarketDiscount
                    };
                    objMod.Create(objXmlMod, frmPickVehicleMod.MyForm.SelectedRating, objVehicle, frmPickVehicleMod.MyForm.Markup);
                    // Make sure that the Armor Rating does not exceed the maximum allowed by the Vehicle.
                    if (objMod.Name.StartsWith("Armor", StringComparison.Ordinal))
                    {
                        if (objMod.Rating > objVehicle.MaxArmor)
                        {
                            objMod.Rating = objVehicle.MaxArmor;
                        }
                    }
                    else
                    {
                        switch (objMod.Category)
                        {
                            case "Handling":
                                {
                                    if (objMod.Rating > objVehicle.MaxHandling)
                                    {
                                        objMod.Rating = objVehicle.MaxHandling;
                                    }

                                    break;
                                }
                            case "Speed":
                                {
                                    if (objMod.Rating > objVehicle.MaxSpeed)
                                    {
                                        objMod.Rating = objVehicle.MaxSpeed;
                                    }

                                    break;
                                }
                            case "Acceleration":
                                {
                                    if (objMod.Rating > objVehicle.MaxAcceleration)
                                    {
                                        objMod.Rating = objVehicle.MaxAcceleration;
                                    }

                                    break;
                                }
                            case "Sensor":
                                {
                                    if (objMod.Rating > objVehicle.MaxSensor)
                                    {
                                        objMod.Rating = objVehicle.MaxSensor;
                                    }

                                    break;
                                }
                            default:
                                {
                                    if (objMod.Name.StartsWith("Pilot Program", StringComparison.Ordinal) && objMod.Rating > objVehicle.MaxPilot)
                                    {
                                        objMod.Rating = objVehicle.MaxPilot;
                                    }

                                    break;
                                }
                        }
                    }

                    // Check the item's Cost and make sure the character can afford it.
                    decimal decOriginalCost = objVehicle.TotalCost;

                    await objVehicle.Mods.AddAsync(objMod);

                    // Do not allow the user to add a new Vehicle Mod if the Vehicle's Capacity has been reached.
                    if (CharacterObjectSettings.EnforceCapacity)
                    {
                        bool blnOverCapacity;
                        if (CharacterObjectSettings.BookEnabled("R5"))
                        {
                            if (objVehicle.IsDrone && CharacterObjectSettings.DroneMods)
                                blnOverCapacity = objVehicle.DroneModSlotsUsed > objVehicle.DroneModSlots;
                            else
                                blnOverCapacity = objVehicle.OverR5Capacity("Weapons");
                        }
                        else
                            blnOverCapacity = objVehicle.Slots < objVehicle.SlotsUsed;

                        if (blnOverCapacity)
                        {
                            Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CapacityReached"), await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                            await objVehicle.Mods.RemoveAsync(objMod);
                            continue;
                        }
                    }

                    if (!frmPickVehicleMod.MyForm.FreeCost)
                    {
                        decimal decCost = objVehicle.TotalCost - decOriginalCost;

                        // Multiply the cost if applicable.
                        char chrAvail = objMod.TotalAvailTuple().Suffix;
                        switch (chrAvail)
                        {
                            case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                break;

                            case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                break;
                        }

                        if (decCost > CharacterObject.Nuyen)
                        {
                            await objVehicle.Mods.RemoveAsync(objMod);
                            Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                                   await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                                   MessageBoxButtons.OK, MessageBoxIcon.Information);
                            continue;
                        }

                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(decCost * -1,
                                          await LanguageManager.GetStringAsync("String_ExpensePurchaseVehicleMod")
                                          + await LanguageManager.GetStringAsync("String_Space")
                                          + objMod.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                          DateTime.Now);
                        CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                        CharacterObject.Nuyen -= decCost;

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateNuyen(NuyenExpenseType.AddVehicleMod, objMod.InternalId);
                        objExpense.Undo = objUndo;
                    }
                }
            }
            while (blnAddAgain);
        }

        private async void tsVehicleAddWeaponWeapon_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasInternalId selectedObject))
                return;
            string strSelectedId = selectedObject.InternalId;
            // Make sure that a Weapon Mount has been selected.
            // Attempt to locate the selected VehicleMod.
            VehicleMod objMod = null;
            WeaponMount objWeaponMount = null;
            Vehicle objVehicle = null;
            if (!string.IsNullOrEmpty(strSelectedId))
            {
                objWeaponMount = CharacterObject.Vehicles.FindVehicleWeaponMount(strSelectedId, out objVehicle);
                if (objWeaponMount == null)
                {
                    objMod = CharacterObject.Vehicles.FindVehicleMod(x => x.InternalId == strSelectedId, out objVehicle, out objWeaponMount);
                    if (objMod?.Name.StartsWith("Mechanical Arm", StringComparison.Ordinal) == false && !objMod.Name.Contains("Drone Arm"))
                    {
                        objMod = null;
                    }
                }
            }

            if (objWeaponMount == null && objMod == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotAddWeapon"),
                    await LanguageManager.GetStringAsync("MessageTitle_CannotAddWeapon"), MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
                return;
            }

            if (objWeaponMount?.IsWeaponsFull == true)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_WeaponMountFull"),
                    await LanguageManager.GetStringAsync("MessageTitle_CannotAddWeapon"), MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
                return;
            }

            bool blnAddAgain;
            do
            {
                blnAddAgain = await AddWeaponToWeaponMount(objWeaponMount, objMod, objVehicle);
            }
            while (blnAddAgain);
        }

        private async ValueTask<bool> AddWeaponToWeaponMount(WeaponMount objWeaponMount, VehicleMod objMod, Vehicle objVehicle)
        {
            using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(
                       () => new SelectWeapon(CharacterObject)
                       {
                           LimitToCategories = objMod == null
                               ? objWeaponMount.AllowedWeaponCategories
                               : objMod.WeaponMountCategories
                       }))
            {
                if (await frmPickWeapon.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return false;

                // Open the Weapons XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("weapons.xml");

                XmlNode objXmlWeapon = objXmlDocument.SelectSingleNode("/chummer/weapons/weapon[id = " + frmPickWeapon.MyForm.SelectedWeapon.CleanXPath() + ']');

                List<Weapon> lstWeapons = new List<Weapon>(1);
                Weapon objWeapon = new Weapon(CharacterObject)
                {
                    ParentVehicle = objVehicle,
                    ParentVehicleMod = objMod,
                    ParentMount = objMod == null ? objWeaponMount : null
                };
                objWeapon.Create(objXmlWeapon, lstWeapons);

                if (!frmPickWeapon.MyForm.FreeCost)
                {
                    decimal decCost = objWeapon.TotalCost;
                    // Apply a markup if applicable.
                    if (frmPickWeapon.MyForm.Markup != 0)
                    {
                        decCost *= 1 + frmPickWeapon.MyForm.Markup / 100.0m;
                    }

                    // Multiply the cost if applicable.
                    char chrAvail = objWeapon.TotalAvailTuple().Suffix;
                    switch (chrAvail)
                    {
                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                            break;

                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                            break;
                    }

                    // Check the item's Cost and make sure the character can afford it.
                    if (decCost > CharacterObject.Nuyen)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);

                        return frmPickWeapon.MyForm.AddAgain;
                    }

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(decCost * -1, await LanguageManager.GetStringAsync("String_ExpensePurchaseVehicleWeapon") + await LanguageManager.GetStringAsync("String_Space") + objWeapon.CurrentDisplayNameShort, ExpenseType.Nuyen,
                        DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                    CharacterObject.Nuyen -= decCost;

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateNuyen(NuyenExpenseType.AddVehicleWeapon, objWeapon.InternalId);
                    objExpense.Undo = objUndo;
                }

                if (objMod != null)
                    await objMod.Weapons.AddAsync(objWeapon);
                else
                    await objWeaponMount.Weapons.AddAsync(objWeapon);

                foreach (Weapon objLoopWeapon in lstWeapons)
                {
                    if (objMod != null)
                        await objMod.Weapons.AddAsync(objLoopWeapon);
                    else
                        await objWeaponMount.Weapons.AddAsync(objLoopWeapon);
                }

                return frmPickWeapon.MyForm.AddAgain && (objMod != null || !objWeaponMount.IsWeaponsFull);
            }
        }

        private async void tsVehicleAddWeaponMount_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Vehicle objVehicle))
                return;
            WeaponMount objNewWeaponMount;
            using (ThreadSafeForm<CreateWeaponMount> frmPickVehicleMod = await ThreadSafeForm<CreateWeaponMount>.GetAsync(
                       () => new CreateWeaponMount(objVehicle, CharacterObject)
                       {
                           AllowDiscounts = true
                       }))
            {
                if (await frmPickVehicleMod.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objNewWeaponMount = frmPickVehicleMod.MyForm.WeaponMount;
            }

            // Calculate cost based on total vehicle cost change to make sure we capture everything
            decimal decCost = -objVehicle.TotalCost;
            await objVehicle.WeaponMounts.AddAsync(objNewWeaponMount);
            decCost += objVehicle.TotalCost;

            // Multiply the cost if applicable.
            char chrAvail = objNewWeaponMount.TotalAvailTuple().Suffix;
            switch (chrAvail)
            {
                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                    break;

                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                    break;
            }

            // Create the Expense Log Entry.
            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
            objExpense.Create(decCost * -1,
                              await LanguageManager.GetStringAsync("String_ExpensePurchaseVehicleWeaponAccessory") + await LanguageManager.GetStringAsync("String_Space") + objNewWeaponMount.CurrentDisplayNameShort, ExpenseType.Nuyen,
                              DateTime.Now);
            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
            CharacterObject.Nuyen -= decCost;

            ExpenseUndo objUndo = new ExpenseUndo();
            objUndo.CreateNuyen(NuyenExpenseType.AddVehicleWeaponMount, objNewWeaponMount.InternalId);
            objExpense.Undo = objUndo;
        }

        private async void tsVehicleAddWeaponAccessory_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_VehicleWeaponAccessories"), await LanguageManager.GetStringAsync("MessageTitle_VehicleWeaponAccessories"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Weapons XML file and locate the selected Weapon.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("weapons.xml");
            XmlNode objXmlWeapon = await objWeapon.GetNodeAsync();
            if (objXmlWeapon == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotFindWeapon"), await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            bool blnAddAgain;

            do
            {
                // Make sure the Weapon allows Accessories to be added to it.
                if (!objWeapon.AllowAccessory)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotModifyWeapon"), await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                using (ThreadSafeForm<SelectWeaponAccessory> frmPickWeaponAccessory
                       = await ThreadSafeForm<SelectWeaponAccessory>.GetAsync(() => new SelectWeaponAccessory(CharacterObject)
                       {
                           ParentWeapon = objWeapon
                       }))
                {
                    if (await frmPickWeaponAccessory.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        break;
                    blnAddAgain = frmPickWeaponAccessory.MyForm.AddAgain;

                    // Locate the selected piece.
                    objXmlWeapon = objXmlDocument.SelectSingleNode("/chummer/accessories/accessory[id = " + frmPickWeaponAccessory.MyForm.SelectedAccessory.CleanXPath() + ']');

                    WeaponAccessory objAccessory = new WeaponAccessory(CharacterObject);
                    objAccessory.Create(objXmlWeapon, frmPickWeaponAccessory.MyForm.SelectedMount, frmPickWeaponAccessory.MyForm.SelectedRating);
                    objAccessory.Parent = objWeapon;

                    // Check the item's Cost and make sure the character can afford it.
                    decimal intOriginalCost = objWeapon.TotalCost;
                    await objWeapon.WeaponAccessories.AddAsync(objAccessory);

                    if (!frmPickWeaponAccessory.MyForm.FreeCost)
                    {
                        decimal decCost = objWeapon.TotalCost - intOriginalCost;
                        // Apply a markup if applicable.
                        if (frmPickWeaponAccessory.MyForm.Markup != 0)
                        {
                            decCost *= 1 + frmPickWeaponAccessory.MyForm.Markup / 100.0m;
                        }

                        // Multiply the cost if applicable.
                        char chrAvail = objAccessory.TotalAvailTuple().Suffix;
                        switch (chrAvail)
                        {
                            case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                break;

                            case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                break;
                        }

                        if (decCost > CharacterObject.Nuyen)
                        {
                            await objWeapon.WeaponAccessories.RemoveAsync(objAccessory);
                            Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                            continue;
                        }

                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(decCost * -1, await LanguageManager.GetStringAsync("String_ExpensePurchaseVehicleWeaponAccessory") + await LanguageManager.GetStringAsync("String_Space") + objAccessory.CurrentDisplayNameShort,
                            ExpenseType.Nuyen, DateTime.Now);
                        CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                        CharacterObject.Nuyen -= decCost;

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateNuyen(NuyenExpenseType.AddVehicleWeaponAccessory, objAccessory.InternalId);
                        objExpense.Undo = objUndo;
                    }
                }
            }
            while (blnAddAgain);
        }

        private async ValueTask<bool> AddUnderbarrelWeapon(Weapon objSelectedWeapon, string strExpenseString)
        {
            using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(() => new SelectWeapon(CharacterObject)
                   {
                       LimitToCategories = "Underbarrel Weapons",
                       ParentWeapon = objSelectedWeapon
                   }))
            {
                frmPickWeapon.MyForm.Mounts.UnionWith(objSelectedWeapon.AccessoryMounts.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries));

                // Make sure the dialogue window was not canceled.
                if (await frmPickWeapon.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return false;

                // Open the Weapons XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("weapons.xml");

                XmlNode objXmlWeapon = objXmlDocument.SelectSingleNode("/chummer/weapons/weapon[id = " + frmPickWeapon.MyForm.SelectedWeapon.CleanXPath() + ']');

                List<Weapon> lstWeapons = new List<Weapon>(1);
                Weapon objWeapon = new Weapon(CharacterObject)
                {
                    ParentVehicle = objSelectedWeapon.ParentVehicle
                };
                objWeapon.Create(objXmlWeapon, lstWeapons);
                objWeapon.DiscountCost = frmPickWeapon.MyForm.BlackMarketDiscount;
                objWeapon.Parent = objSelectedWeapon;
                if (!objSelectedWeapon.AllowAccessory)
                    objWeapon.AllowAccessory = false;

                // Check the item's Cost and make sure the character can afford it.
                if (!frmPickWeapon.MyForm.FreeCost)
                {
                    decimal decCost = objWeapon.TotalCost;
                    // Apply a markup if applicable.
                    if (frmPickWeapon.MyForm.Markup != 0)
                    {
                        decCost *= 1 + frmPickWeapon.MyForm.Markup / 100.0m;
                    }

                    // Multiply the cost if applicable.
                    char chrAvail = objWeapon.TotalAvailTuple().Suffix;
                    switch (chrAvail)
                    {
                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                            break;

                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                            break;
                    }

                    if (decCost > CharacterObject.Nuyen)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return frmPickWeapon.MyForm.AddAgain;
                    }

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(decCost * -1, strExpenseString + await LanguageManager.GetStringAsync("String_Space") + objWeapon.CurrentDisplayNameShort, ExpenseType.Nuyen, DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                    CharacterObject.Nuyen -= decCost;

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateNuyen(NuyenExpenseType.AddVehicleWeapon, objWeapon.InternalId);
                    objExpense.Undo = objUndo;
                }

                await objSelectedWeapon.UnderbarrelWeapons.AddAsync(objWeapon);

                foreach (Weapon objLoopWeapon in lstWeapons)
                {
                    if (!objSelectedWeapon.AllowAccessory)
                        objLoopWeapon.AllowAccessory = false;
                    await objSelectedWeapon.UnderbarrelWeapons.AddAsync(objLoopWeapon);
                }

                return frmPickWeapon.MyForm.AddAgain;
            }
        }

        private async void tsVehicleAddUnderbarrelWeapon_Click(object sender, EventArgs e)
        {
            // Attempt to locate the selected VehicleWeapon.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_VehicleWeaponUnderbarrel"), await LanguageManager.GetStringAsync("MessageTitle_VehicleWeaponUnderbarrel"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            bool blnAddAgain;
            do
            {
                blnAddAgain = await AddUnderbarrelWeapon(objWeapon, await LanguageManager.GetStringAsync("String_ExpensePurchaseVehicleWeapon"));
            }
            while (blnAddAgain);
        }

        private async void tsMartialArtsAddTechnique_Click(object sender, EventArgs e)
        {
            if (await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode != null))
            {
                // Select the Martial Arts node if we're currently on a child.
                await treMartialArts.DoThreadSafeAsync(x =>
                {
                    if (x.SelectedNode.Level > 1)
                        x.SelectedNode = x.SelectedNode.Parent;
                });

                if (!(await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is MartialArt objMartialArt))
                    return;

                bool blnAddAgain = false;
                do
                {
                    using (ThreadSafeForm<SelectMartialArtTechnique> frmPickMartialArtTechnique = await ThreadSafeForm<SelectMartialArtTechnique>.GetAsync(() => new SelectMartialArtTechnique(CharacterObject, objMartialArt)))
                    {
                        if (await frmPickMartialArtTechnique.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            return;

                        // Open the Martial Arts XML file and locate the selected piece.
                        XmlNode xmlTechnique = (await CharacterObject.LoadDataAsync("martialarts.xml")).SelectSingleNode("/chummer/techniques/technique[id = " + frmPickMartialArtTechnique.MyForm.SelectedTechnique.CleanXPath() + ']');

                        if (xmlTechnique == null)
                            continue;
                        // Create the Improvements for the Technique if there are any.
                        MartialArtTechnique objTechnique = new MartialArtTechnique(CharacterObject);
                        objTechnique.Create(xmlTechnique);
                        if (objTechnique.InternalId.IsEmptyGuid())
                            return;

                        blnAddAgain = frmPickMartialArtTechnique.MyForm.AddAgain;

                        int karmaCost = objMartialArt.Techniques.Count > 0 ? CharacterObjectSettings.KarmaTechnique : 0;
                        await objMartialArt.Techniques.AddAsync(objTechnique);

                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(karmaCost * -1,
                            await LanguageManager.GetStringAsync("String_ExpenseLearnTechnique") + await LanguageManager.GetStringAsync("String_Space") + objTechnique.CurrentDisplayName,
                            ExpenseType.Karma, DateTime.Now);
                        CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                        CharacterObject.Karma -= karmaCost;

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateKarma(KarmaExpenseType.AddMartialArtTechnique, objTechnique.InternalId);
                        objExpense.Undo = objUndo;
                    }
                } while (blnAddAgain);
            }
            else
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectMartialArtTechnique"), await LanguageManager.GetStringAsync("MessageTitle_SelectMartialArtTechnique"), MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
        }

        private async void tsVehicleAddGear_Click(object sender, EventArgs e)
        {
            Vehicle objSelectedVehicle;
            Location objLocation = null;
            switch (treVehicles.SelectedNode?.Tag)
            {
                case Vehicle vehicle:
                    objSelectedVehicle = vehicle;
                    break;

                case Location location:
                    objLocation = location;
                    objSelectedVehicle = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode.Parent.Tag) as Vehicle;
                    break;

                default:
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectGearVehicle"), await LanguageManager.GetStringAsync("MessageTitle_SelectGearVehicle"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
            }

            try
            {
                await PurchaseVehicleGear(objSelectedVehicle, objLocation, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleSensorAddAsPlugin_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Gear window.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objSensor))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_ModifyVehicleGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strCategories = string.Empty;
            XPathNodeIterator xmlAddonCategoryList = (await objSensor.GetNodeXPathAsync())?.Select("addoncategory");
            if (xmlAddonCategoryList?.Count > 0)
            {
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                        sbdCategories.Append(objXmlCategory.Value).Append(',');
                    // Remove the trailing comma.
                    --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }
            }

            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(() => new SelectGear(CharacterObject, 0, 1, objSensor, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                 && (!objSensor.Capacity.Contains('[')
                                                                     || objSensor.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        // Open the Gear XML file and locate the selected piece.
                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty, false);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickGear.MyForm.FreeCost)
                        {
                            decimal decCost = objGear.TotalCost;

                            // Multiply the cost if applicable.
                            char chrAvail = (await objGear.TotalAvailTupleAsync()).Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > CharacterObject.Nuyen)
                            {
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                                continue;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                              await LanguageManager.GetStringAsync("String_ExpensePurchaseVehicleGear")
                                              + await LanguageManager.GetStringAsync("String_Space")
                                              + objGear.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                              DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                            CharacterObject.Nuyen -= decCost;

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddVehicleGear, objGear.InternalId,
                                                frmPickGear.MyForm.SelectedQty);
                            objExpense.Undo = objUndo;
                        }

                        await objSensor.Children.AddAsync(objGear);

                        if (lstWeapons.Count > 0)
                        {
                            CharacterObject.Vehicles.FindVehicleGear(objSensor.InternalId, out Vehicle objVehicle,
                                                                     out WeaponAccessory _, out Cyberware _);
                            foreach (Weapon objWeapon in lstWeapons)
                            {
                                await objVehicle.Weapons.AddAsync(objWeapon);
                            }
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void cmsAmmoSingleShot_Click(object sender, EventArgs e)
        {
            await DoSingleShot();
        }

        private async ValueTask DoSingleShot()
        {
            // Locate the selected Weapon.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining < objWeapon.SingleShot)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_OutOfAmmo"),
                                       await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo"), MessageBoxButtons.OK,
                                       MessageBoxIcon.Exclamation);
                return;
            }

            objWeapon.AmmoRemaining -= objWeapon.SingleShot;

            await lblWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo));

            await SetDirty(true);
        }

        private async void cmsAmmoShortBurst_Click(object sender, EventArgs e)
        {
            await DoShortBurst();
        }

        private async ValueTask DoShortBurst()
        {
            // Locate the selected Weapon.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_OutOfAmmo"), await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.ShortBurst)
            {
                objWeapon.AmmoRemaining -= objWeapon.ShortBurst;
            }
            else
            {
                if (objWeapon.AmmoRemaining == objWeapon.SingleShot)
                {
                    if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSingleShot"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                        objWeapon.AmmoRemaining = 0;
                }
                else
                {
                    if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurstShort"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                        objWeapon.AmmoRemaining = 0;
                }
            }

            await lblWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo));

            await SetDirty(true);
        }

        private async void cmsAmmoLongBurst_Click(object sender, EventArgs e)
        {
            await DoLongBurst();
        }

        private async ValueTask DoLongBurst()
        {
            // Locate the selected Weapon.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_OutOfAmmo"), await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.LongBurst)
            {
                objWeapon.AmmoRemaining -= objWeapon.LongBurst;
            }
            else if (objWeapon.AmmoRemaining == objWeapon.SingleShot)
            {
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSingleShot"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                    objWeapon.AmmoRemaining = 0;
            }
            else if (objWeapon.AmmoRemaining > objWeapon.ShortBurst)
            {
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoLongBurstShort"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                    objWeapon.AmmoRemaining = 0;
            }
            else if (objWeapon.AmmoRemaining == objWeapon.ShortBurst)
            {
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurst"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                    objWeapon.AmmoRemaining = 0;
            }
            else if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurstShort"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                objWeapon.AmmoRemaining = 0;

            await lblWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo));

            await SetDirty(true);
        }

        private async void cmsAmmoFullBurst_Click(object sender, EventArgs e)
        {
            // Locate the selected Weapon.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_OutOfAmmo"), await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.FullBurst)
            {
                objWeapon.AmmoRemaining -= objWeapon.FullBurst;
            }
            else
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoFullBurst"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }

            await lblWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo));

            await SetDirty(true);
        }

        private async void cmsAmmoSuppressiveFire_Click(object sender, EventArgs e)
        {
            // Locate the selected Weapon.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_OutOfAmmo"), await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.Suppressive)
            {
                objWeapon.AmmoRemaining -= objWeapon.Suppressive;
            }
            else
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSuppressiveFire"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }

            await lblWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo));

            await SetDirty(true);
        }

        private async void cmsVehicleAmmoSingleShot_Click(object sender, EventArgs e)
        {
            await DoVehicleAmmoSingleShot();
        }

        private async ValueTask DoVehicleAmmoSingleShot()
        {
            // Locate the selected Vehicle Weapon.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining < objWeapon.SingleShot)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_OutOfAmmo"), await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }

            objWeapon.AmmoRemaining -= objWeapon.SingleShot;

            await lblVehicleWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo));

            await SetDirty(true);
        }

        private async void cmsVehicleAmmoShortBurst_Click(object sender, EventArgs e)
        {
            await DoVehicleAmmoShortBurst();
        }

        private async ValueTask DoVehicleAmmoShortBurst()
        {
            // Locate the selected Vehicle Weapon.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_OutOfAmmo"), await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.ShortBurst)
            {
                objWeapon.AmmoRemaining -= objWeapon.ShortBurst;
            }
            else if (objWeapon.AmmoRemaining == objWeapon.SingleShot)
            {
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSingleShot"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                    objWeapon.AmmoRemaining = 0;
            }
            else if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurstShort"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                objWeapon.AmmoRemaining = 0;

            await lblVehicleWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo));

            await SetDirty(true);
        }

        private async void cmsVehicleAmmoLongBurst_Click(object sender, EventArgs e)
        {
            await DoVehicleAmmoLongBurst();
        }

        private async ValueTask DoVehicleAmmoLongBurst()
        {
            // Locate the selected Vehicle Weapon.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_OutOfAmmo"), await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.LongBurst)
            {
                objWeapon.AmmoRemaining -= objWeapon.LongBurst;
            }
            else if (objWeapon.AmmoRemaining == objWeapon.SingleShot)
            {
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSingleShot"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                    objWeapon.AmmoRemaining = 0;
            }
            else if (objWeapon.AmmoRemaining > objWeapon.ShortBurst)
            {
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoLongBurstShort"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                    objWeapon.AmmoRemaining = 0;
            }
            else if (objWeapon.AmmoRemaining == objWeapon.ShortBurst)
            {
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurst"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                    objWeapon.AmmoRemaining = 0;
            }
            else if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoShortBurstShort"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                objWeapon.AmmoRemaining = 0;

            await lblVehicleWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo));

            await SetDirty(true);
        }

        private async void cmsVehicleAmmoFullBurst_Click(object sender, EventArgs e)
        {
            // Locate the selected Vehicle Weapon.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_OutOfAmmo"), await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.FullBurst)
            {
                objWeapon.AmmoRemaining -= objWeapon.FullBurst;
            }
            else
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoFullBurst"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }

            await lblVehicleWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo));

            await SetDirty(true);
        }

        private async void cmsVehicleAmmoSuppressiveFire_Click(object sender, EventArgs e)
        {
            // Locate the selected Vehicle Weapon.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            if (objWeapon.AmmoRemaining == 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_OutOfAmmo"), await LanguageManager.GetStringAsync("MessageTitle_OutOfAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }

            if (objWeapon.AmmoRemaining >= objWeapon.Suppressive)
            {
                objWeapon.AmmoRemaining -= objWeapon.Suppressive;
            }
            else
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughAmmoSuppressiveFire"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughAmmo"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            }

            await lblVehicleWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo));

            await SetDirty(true);
        }

        private async void tsCyberwareSell_Click(object sender, EventArgs e)
        {
            switch (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag))
            {
                case Cyberware objCyberware when objCyberware.Capacity == "[*]" && objCyberware.Parent != null:
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotRemoveCyberware"), await LanguageManager.GetStringAsync("MessageTitle_CannotRemoveCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                    
                case ICanSell vendorTrash:
                    {
                        using (ThreadSafeForm<SellItem> frmSell = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem()))
                        {
                            if (await frmSell.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                                return;
                            vendorTrash.Sell(frmSell.MyForm.SellPercent, GlobalSettings.ConfirmDelete);
                        }

                        break;
                    }
                default:
                    Utils.BreakIfDebug();
                    break;
            }
        }

        private async void tsArmorSell_Click(object sender, EventArgs e)
        {
            if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is ICanSell vendorTrash)
            {
                using (ThreadSafeForm<SellItem> frmSell = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem()))
                {
                    if (await frmSell.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return;
                    vendorTrash.Sell(frmSell.MyForm.SellPercent, GlobalSettings.ConfirmDelete);
                }
            }
            else
            {
                Utils.BreakIfDebug();
            }
        }

        private async void tsWeaponSell_Click(object sender, EventArgs e)
        {
            // Delete the selected Weapon.
            if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is ICanSell vendorTrash)
            {
                using (ThreadSafeForm<SellItem> frmSell = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem()))
                {
                    if (await frmSell.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return;
                    vendorTrash.Sell(frmSell.MyForm.SellPercent, GlobalSettings.ConfirmDelete);
                }
            }
            else
            {
                Utils.BreakIfDebug();
            }
        }

        private async void sellItemToolStripMenuItem_Click(object sender, EventArgs e)
        {
            // Delete the selected Weapon.
            if (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is ICanSell vendorTrash)
            {
                using (ThreadSafeForm<SellItem> frmSell = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem()))
                {
                    if (await frmSell.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return;
                    vendorTrash.Sell(frmSell.MyForm.SellPercent, GlobalSettings.ConfirmDelete);
                }
            }
            else
            {
                Utils.BreakIfDebug();
            }
        }

        private async void tsVehicleSell_Click(object sender, EventArgs e)
        {
            // Delete the selected Weapon.
            if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is ICanSell vendorTrash)
            {
                using (ThreadSafeForm<SellItem> frmSell = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem()))
                {
                    if (await frmSell.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return;
                    vendorTrash.Sell(frmSell.MyForm.SellPercent, GlobalSettings.ConfirmDelete);
                }
            }
            else
            {
                Utils.BreakIfDebug();
            }
        }

        private async void tsAdvancedLifestyle_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                Lifestyle objLifeStyle = new Lifestyle(CharacterObject);
                using (ThreadSafeForm<SelectLifestyleAdvanced> frmPickLifestyle = await ThreadSafeForm<SelectLifestyleAdvanced>.GetAsync(() => new SelectLifestyleAdvanced(CharacterObject, objLifeStyle)))
                {
                    // Make sure the dialogue window was not canceled.
                    if (await frmPickLifestyle.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    {
                        //And if it was, remove Improvements that was already added based on the lifestyle
                        foreach (LifestyleQuality lifestyleQuality in objLifeStyle.LifestyleQualities)
                            await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Quality, lifestyleQuality.InternalId);

                        return;
                    }

                    blnAddAgain = frmPickLifestyle.MyForm.AddAgain;

                    Lifestyle objNewLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;
                    objNewLifestyle.StyleType = LifestyleType.Advanced;

                    await CharacterObject.Lifestyles.AddAsync(objNewLifestyle);
                }
            }
            while (blnAddAgain);
        }

        private async void tsWeaponName_Click(object sender, EventArgs e)
        {
            // Make sure a parent item is selected, then open the Select Accessory window.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectWeaponName"), await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_WeaponName");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objWeapon.CustomName,
                       AllowEmptyString = true
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objWeapon.CustomName = frmPickText.MyForm.SelectedValue;
            }

            await treWeapons.DoThreadSafeAsync(x => x.SelectedNode.Text = objWeapon.CurrentDisplayName);

            await SetDirty(true);
        }

        private async void tsGearName_Click(object sender, EventArgs e)
        {
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objGear))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectGearName"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_GearName");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objGear.GearName,
                       AllowEmptyString = true
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objGear.GearName = frmPickText.MyForm.SelectedValue;
            }

            await treGear.DoThreadSafeAsync(x => x.SelectedNode.Text = objGear.CurrentDisplayName);

            await SetDirty(true);
        }

        private async void tsWeaponAddUnderbarrel_Click(object sender, EventArgs e)
        {
            // Make sure a parent item is selected, then open the Select Accessory window.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objSelectedWeapon))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectWeaponAccessory"), await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            if (objSelectedWeapon.Cyberware)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CyberwareUnderbarrel"), await LanguageManager.GetStringAsync("MessageTitle_WeaponUnderbarrel"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            bool blnAddAgain;
            do
            {
                blnAddAgain = await AddUnderbarrelWeapon(objSelectedWeapon, await LanguageManager.GetStringAsync("String_ExpensePurchaseWeapon"));
            }
            while (blnAddAgain);
        }

        private async void tsUndoKarmaExpense_Click(object sender, EventArgs e)
        {
            ListViewItem objItem = await lstKarma.DoThreadSafeFuncAsync(x => x.SelectedItems.Count > 0 ? lstKarma.SelectedItems[0] : null);

            if (objItem == null)
            {
                return;
            }

            // Find the selected Karma Expense.
            ExpenseLogEntry objExpense = (objItem.SubItems[3] as ListViewItemWithValue.ListViewSubItemWithValue)?.Value as ExpenseLogEntry;

            if (objExpense?.Undo == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_UndoNoHistory"), await LanguageManager.GetStringAsync("MessageTitle_NoUndoHistory"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strUndoId = objExpense.Undo.ObjectId;

            if (objExpense.Undo.KarmaType == KarmaExpenseType.ImproveInitiateGrade)
            {
                // Get the grade of the item we're undoing and make sure it's the highest grade
                int intMaxGrade = 0;
                foreach (InitiationGrade objGrade in CharacterObject.InitiationGrades)
                {
                    intMaxGrade = Math.Max(intMaxGrade, objGrade.Grade);
                }
                foreach (InitiationGrade objGrade in CharacterObject.InitiationGrades)
                {
                    if (objGrade.InternalId != strUndoId)
                        continue;
                    if (objGrade.Grade < intMaxGrade)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_UndoNotHighestGrade"), await LanguageManager.GetStringAsync("MessageTitle_NotHighestGrade"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return;
                    }
                    break;
                }
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_UndoExpense"), await LanguageManager.GetStringAsync("MessageTitle_UndoExpense"), MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                    return;
            }
            else
            {
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_UndoExpense"), await LanguageManager.GetStringAsync("MessageTitle_UndoExpense"), MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                    return;
            }

            switch (objExpense.Undo.KarmaType)
            {
                case KarmaExpenseType.ImproveAttribute:
                    {
                        CharacterObject.GetAttribute(strUndoId).Degrade(1);
                        break;
                    }
                case KarmaExpenseType.AddPowerPoint:
                    {
                        --CharacterObject.MysticAdeptPowerPoints;
                        break;
                    }
                case KarmaExpenseType.AddQuality:
                    {
                        // Locate the Quality that was added.
                        for (int i = CharacterObject.Qualities.Count - 1; i >= 0; --i)
                        {
                            if (i >= CharacterObject.Qualities.Count)
                                continue;
                            Quality objQuality = CharacterObject.Qualities[i];
                            if (objQuality.InternalId == strUndoId)
                                objQuality.DeleteQuality();
                        }
                    }
                    break;

                case KarmaExpenseType.AddSpell:
                    {
                        // Locate the Spell that was added.
                        for (int i = CharacterObject.Spells.Count - 1; i >= 0; --i)
                        {
                            if (i >= CharacterObject.Spells.Count)
                                continue;
                            Spell objSpell = CharacterObject.Spells[i];
                            if (objSpell.InternalId == strUndoId)
                                objSpell.Remove(false); // Remove the Spell from the character.
                        }
                        break;
                    }
                case KarmaExpenseType.SkillSpec:  //I am reasonably sure those 2 are the same. Was written looking at old AddSpecialization code
                case KarmaExpenseType.AddSpecialization:
                {
                    SkillSpecialization objSpec = CharacterObject.SkillsSection.KnowledgeSkills
                                                                 .SelectMany(x => x.Specializations)
                                                                 .FirstOrDefault(
                                                                     x => x.InternalId == strUndoId)
                                                  ?? CharacterObject.SkillsSection.Skills
                                                                    .SelectMany(x => x.Specializations)
                                                                    .FirstOrDefault(
                                                                        x => x.InternalId == strUndoId);
                    if (objSpec != null)
                        await objSpec.Parent.Specializations.RemoveAsync(objSpec);

                    break;
                }
                case KarmaExpenseType.ImproveSkillGroup:
                    {
                        // Locate the Skill Group that was affected.
                        SkillGroup group = CharacterObject.SkillsSection.SkillGroups.FirstOrDefault(g => g.InternalId == strUndoId);

                        if (group != null)
                        {
                            if (group.KarmaUnbroken)
                                --group.Karma;
                            else
                            {
                                Program.ShowMessageBox(this,
                                    await LanguageManager.GetStringAsync("Message_UndoBrokenSkillGroup"),
                                    await LanguageManager.GetStringAsync("MessageTitle_UndoBrokenSkillGroup"),
                                    MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                return;
                            }
                        }

                        break;
                    }
                case KarmaExpenseType.AddSkill:
                    {
                        // Locate the Skill that was affected.
                        Skill objSkill = CharacterObject.SkillsSection.Skills.FirstOrDefault(s => s.InternalId == strUndoId);
                        if (objSkill != null)
                        {
                            if (objSkill.AllowDelete)
                                await CharacterObject.SkillsSection.Skills.RemoveAsync(objSkill);
                            else
                            {
                                objSkill.BasePoints = 0;
                                objSkill.KarmaPoints = 0;
                            }
                        }
                        else
                        {
                            KnowledgeSkill objKnowledgeSkill = CharacterObject.SkillsSection.KnowledgeSkills.FirstOrDefault(s => s.InternalId == strUndoId);
                            if (objKnowledgeSkill != null)
                            {
                                if (objKnowledgeSkill.AllowDelete)
                                    await CharacterObject.SkillsSection.KnowledgeSkills.RemoveAsync(objKnowledgeSkill);
                                else
                                {
                                    objKnowledgeSkill.BasePoints = 0;
                                    objKnowledgeSkill.KarmaPoints = 0;
                                }
                            }
                        }

                        break;
                    }
                case KarmaExpenseType.ImproveSkill:
                    {
                        // Locate the Skill that was affected.
                        Skill objSkill = CharacterObject.SkillsSection.Skills.FirstOrDefault(s => s.InternalId == strUndoId) ??
                                         CharacterObject.SkillsSection.KnowledgeSkills.FirstOrDefault(s => s.InternalId == strUndoId);

                        if (objSkill != null)
                            --objSkill.Karma;

                        break;
                    }
                case KarmaExpenseType.AddMetamagic:
                    {
                        // Locate the Metamagic that was affected.
                        for (int i = CharacterObject.Metamagics.Count - 1; i >= 0; --i)
                        {
                            if (i >= CharacterObject.Metamagics.Count)
                                continue;
                            Metamagic objMetamagic = CharacterObject.Metamagics[i];
                            if (objMetamagic.InternalId == strUndoId)
                                objMetamagic.Remove(false); // Remove the Metamagic from the character.
                        }
                        break;
                    }
                case KarmaExpenseType.ImproveInitiateGrade:
                    {
                        // Locate the Initiate Grade that was affected.
                        for (int i = CharacterObject.InitiationGrades.Count - 1; i >= 0; --i)
                        {
                            if (i >= CharacterObject.InitiationGrades.Count)
                                continue;
                            InitiationGrade objGrade = CharacterObject.InitiationGrades[i];
                            if (objGrade.InternalId == strUndoId)
                                objGrade.Remove(false); // Remove the Grade from the character.
                        }
                        break;
                    }
                case KarmaExpenseType.AddMartialArt:
                    {
                        // Locate the Martial Art that was affected.
                        for (int i = CharacterObject.MartialArts.Count - 1; i >= 0; --i)
                        {
                            if (i >= CharacterObject.MartialArts.Count)
                                continue;
                            MartialArt objMartialArt = CharacterObject.MartialArts[i];
                            if (objMartialArt.InternalId == strUndoId)
                                objMartialArt.Remove(false); // Remove the Martial Art from the character.
                        }
                        break;
                    }
                case KarmaExpenseType.AddMartialArtTechnique:
                    {
                        // Locate the Martial Art Technique that was affected.
                        for (int i = CharacterObject.MartialArts.Count - 1; i >= 0; --i)
                        {
                            if (i >= CharacterObject.MartialArts.Count)
                                continue;
                            MartialArt objMartialArt = CharacterObject.MartialArts[i];
                            for (int j = objMartialArt.Techniques.Count - 1; j >= 0; --j)
                            {
                                if (j >= objMartialArt.Techniques.Count)
                                    continue;
                                MartialArtTechnique objTechnique = objMartialArt.Techniques[i];
                                if (objTechnique.InternalId == strUndoId)
                                    objTechnique.Remove(false); // Remove the Technique from the character.
                            }
                        }
                        break;
                    }

                case KarmaExpenseType.AddComplexForm:
                    {
                        // Locate the Complex Form that was affected.
                        for (int i = CharacterObject.ComplexForms.Count - 1; i >= 0; --i)
                        {
                            if (i >= CharacterObject.ComplexForms.Count)
                                continue;
                            ComplexForm objComplexForm = CharacterObject.ComplexForms[i];
                            if (objComplexForm.InternalId == strUndoId)
                                objComplexForm.Remove(false); // Remove the Complex Form from the character.
                        }
                        break;
                    }
                case KarmaExpenseType.BindFocus:
                    {
                        // Locate the Focus that was bound.
                        for (int i = CharacterObject.Foci.Count - 1; i >= 0; --i)
                        {
                            if (i >= CharacterObject.Foci.Count)
                                continue;
                            Focus objFocus = CharacterObject.Foci[i];
                            if (objFocus.InternalId != strUndoId)
                                continue;
                            await treFoci.DoThreadSafeAsync(x =>
                            {
                                TreeNode objNode = x.FindNode(objFocus.InternalId);
                                if (objNode != null)
                                {
                                    IsRefreshing = true;
                                    try
                                    {
                                        objNode.Checked = false;
                                    }
                                    finally
                                    {
                                        IsRefreshing = false;
                                    }
                                }
                            });
                            await CharacterObject.Foci.RemoveAsync(objFocus);
                        }
                        // Locate the Stacked Focus that was bound.
                        for (int i = CharacterObject.StackedFoci.Count - 1; i >= 0; --i)
                        {
                            if (i >= CharacterObject.StackedFoci.Count)
                                continue;
                            StackedFocus objStack = CharacterObject.StackedFoci[i];
                            if (objStack.InternalId != strUndoId)
                                continue;
                            TreeNode objNode = await treFoci.DoThreadSafeFuncAsync(x => x.FindNode(objStack.InternalId));
                            if (objNode == null)
                                continue;
                            
                            IsRefreshing = true;
                            try
                            {
                                await treFoci.DoThreadSafeAsync(() =>
                                {
                                    objNode.Checked = false;
                                    objStack.Bonded = false;
                                });
                            }
                            finally
                            {
                                IsRefreshing = false;
                            }
                        }
                        break;
                    }
                case KarmaExpenseType.JoinGroup:
                    {
                        // Remove the character from their Group.
                        IsRefreshing = true;
                        try
                        {
                            CharacterObject.GroupMember = false;
                        }
                        finally
                        {
                            IsRefreshing = false;
                        }
                        break;
                    }
                case KarmaExpenseType.LeaveGroup:
                    {
                        // Put the character back in their Group.
                        IsRefreshing = true;
                        try
                        {
                            CharacterObject.GroupMember = true;
                        }
                        finally
                        {
                            IsRefreshing = false;
                        }
                        break;
                    }
                case KarmaExpenseType.RemoveQuality:
                    {
                        // Add the Quality back to the character.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Quality objAddQuality = new Quality(CharacterObject);
                        XmlDocument objXmlQualityDocument = await CharacterObject.LoadDataAsync("qualities.xml");
                        XmlNode objXmlQualityNode = objXmlQualityDocument.SelectSingleNode("/chummer/qualities/quality[id = " + strUndoId.CleanXPath() + ']')
                                                    ?? objXmlQualityDocument.SelectSingleNode("/chummer/qualities/quality[name = " + strUndoId.CleanXPath() + ']');
                        objAddQuality.Create(objXmlQualityNode, QualitySource.Selected, lstWeapons, objExpense.Undo.Extra);

                        await CharacterObject.Qualities.AddAsync(objAddQuality);

                        // Add any created Weapons to the character.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }
                        break;
                    }
                case KarmaExpenseType.ManualAdd:
                case KarmaExpenseType.ManualSubtract:
                case KarmaExpenseType.QuickeningMetamagic:
                    break;

                case KarmaExpenseType.AddCritterPower:
                    {
                        // Locate the Critter Power that was affected.
                        for (int i = CharacterObject.CritterPowers.Count - 1; i >= 0; --i)
                        {
                            if (i >= CharacterObject.CritterPowers.Count)
                                continue;
                            CritterPower objPower = CharacterObject.CritterPowers[i];
                            if (objPower.InternalId == strUndoId)
                                objPower.Remove(false); // Remove the Critter Power from the character.
                        }
                    }
                    break;
            }
            // Refund the Karma amount and remove the Expense Entry.
            CharacterObject.Karma -= objExpense.Amount.ToInt32();
            await CharacterObject.ExpenseEntries.RemoveAsync(objExpense);

            await cboTradition.DoThreadSafeAsync(x =>
            {
                // Select the Magician's Tradition.
                if (CharacterObject.MagicTradition.Type == TraditionType.MAG)
                    x.SelectedValue = CharacterObject.MagicTradition.SourceID;
                else if (x.SelectedIndex == -1 && x.Items.Count > 0)
                    x.SelectedIndex = 0;
            });

            await cboStream.DoThreadSafeAsync(x =>
            {
                // Select the Technomancer's Stream.
                if (CharacterObject.MagicTradition.Type == TraditionType.RES)
                    x.SelectedValue = CharacterObject.MagicTradition.SourceID;
                else if (x.SelectedIndex == -1 && x.Items.Count > 0)
                    x.SelectedIndex = 0;
            });
        }

        private async void tsUndoNuyenExpense_Click(object sender, EventArgs e)
        {
            ListViewItem objItem = await lstNuyen.DoThreadSafeFuncAsync(x => x.SelectedItems.Count > 0 ? lstNuyen.SelectedItems[0] : null);

            if (objItem == null)
            {
                return;
            }

            // Find the selected Nuyen Expense.
            ExpenseLogEntry objExpense = (objItem.SubItems[3] as ListViewItemWithValue.ListViewSubItemWithValue)?.Value as ExpenseLogEntry;

            if (objExpense?.Undo == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_UndoNoHistory"), await LanguageManager.GetStringAsync("MessageTitle_NoUndoHistory"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strUndoId = objExpense.Undo.ObjectId;

            if (objExpense.Undo.KarmaType == KarmaExpenseType.ImproveInitiateGrade)
            {
                // Get the grade of the item we're undoing and make sure it's the highest grade
                int intMaxGrade = 0;
                foreach (InitiationGrade objGrade in CharacterObject.InitiationGrades)
                {
                    intMaxGrade = Math.Max(intMaxGrade, objGrade.Grade);
                }
                foreach (InitiationGrade objGrade in CharacterObject.InitiationGrades)
                {
                    if (objGrade.InternalId != strUndoId)
                        continue;
                    if (objGrade.Grade < intMaxGrade)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_UndoNotHighestGrade"), await LanguageManager.GetStringAsync("MessageTitle_NotHighestGrade"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return;
                    }
                    break;
                }
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_UndoExpense"), await LanguageManager.GetStringAsync("MessageTitle_UndoExpense"), MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                    return;
            }
            else
            {
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_UndoExpense"), await LanguageManager.GetStringAsync("MessageTitle_UndoExpense"), MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                    return;
            }

            if (!string.IsNullOrEmpty(strUndoId))
            {
                switch (objExpense.Undo.NuyenType)
                {
                    case NuyenExpenseType.AddCyberware:
                        {
                            // Locate the Cyberware that was added.
                            Cyberware objCyberware = CharacterObject.Cyberware.DeepFindById(strUndoId) ??
                                                     CharacterObject.Vehicles.FindVehicleCyberware(x => x.InternalId == strUndoId);
                            objCyberware?.DeleteCyberware(blnIncreaseEssenceHole: false);
                        }
                        break;

                    case NuyenExpenseType.AddGear:
                        {
                            // Locate the Gear that was added.
                            //If the gear was already deleted manually we will not be able to locate it here
                            Gear objGear = CharacterObject.Gear.DeepFindById(strUndoId);
                            TreeNode objNode;
                            if (objGear != null)
                            {
                                objNode = await treGear.DoThreadSafeFuncAsync(x => x.FindNode(objGear.InternalId));
                            }
                            else
                            {
                                objGear = CharacterObject.Vehicles.FindVehicleGear(strUndoId);
                                if (objGear != null)
                                    objNode = await treVehicles.DoThreadSafeFuncAsync(x => x.FindNode(objGear.InternalId));
                                else
                                    break;
                            }

                            objGear.Quantity -= objExpense.Undo.Qty;

                            if (objGear.Quantity <= 0)
                            {
                                objGear.DeleteGear();
                            }
                            else if (objNode != null)
                            {
                                await objNode.TreeView.DoThreadSafeAsync(() => objNode.Text = objGear.CurrentDisplayName);
                            }
                        }
                        break;

                    case NuyenExpenseType.AddVehicle:
                        {
                            // Locate the Vehicle that was added.
                            Vehicle objVehicle = CharacterObject.Vehicles.FindById(strUndoId);
                            objVehicle?.DeleteVehicle();
                        }
                        break;

                    case NuyenExpenseType.AddVehicleMod:
                        {
                            // Locate the Vehicle Mod that was added.
                            VehicleMod objVehicleMod = CharacterObject.Vehicles.FindVehicleMod(x => x.InternalId == strUndoId);
                            objVehicleMod?.DeleteVehicleMod();
                        }
                        break;

                    case NuyenExpenseType.AddVehicleGear:
                        {
                            // Locate the Gear that was added.
                            TreeNode objNode = null;
                            Gear objGear = CharacterObject.Vehicles.FindVehicleGear(strUndoId);
                            if (objGear == null)
                            {
                                objGear = CharacterObject.Gear.DeepFindById(strUndoId);
                                if (objGear == null)
                                {
                                    objGear = CharacterObject.Cyberware.FindCyberwareGear(strUndoId);
                                    if (objGear == null)
                                    {
                                        objGear = CharacterObject.Weapons.FindWeaponGear(strUndoId);
                                        if (objGear != null)
                                            objNode = await treWeapons.DoThreadSafeFuncAsync(x => x.FindNode(strUndoId));
                                    }
                                    else
                                        objNode = await treCyberware.DoThreadSafeFuncAsync(x => x.FindNode(strUndoId));
                                }
                                else
                                    objNode = await treGear.DoThreadSafeFuncAsync(x => x.FindNode(strUndoId));
                            }
                            else
                                objNode = await treVehicles.DoThreadSafeFuncAsync(x => x.FindNode(strUndoId));

                            if (objGear != null)
                            {
                                // Deduct the Qty from the Gear.
                                objGear.Quantity -= objExpense.Undo.Qty;

                                // Remove the Gear if its Qty has been reduced to 0.
                                if (objGear.Quantity <= 0)
                                {
                                    objGear.DeleteGear();
                                }
                                else if (objNode != null)
                                {
                                    await objNode.TreeView.DoThreadSafeAsync(() => objNode.Text = objGear.CurrentDisplayName);
                                }
                            }
                        }
                        break;

                    case NuyenExpenseType.AddVehicleWeapon:
                        {
                            // Locate the Weapon that was added.
                            Weapon objWeapon = CharacterObject.Vehicles.FindVehicleWeapon(strUndoId) ??
                                               CharacterObject.Weapons.DeepFindById(strUndoId);
                            objWeapon?.DeleteWeapon();
                        }
                        break;

                    case NuyenExpenseType.AddVehicleWeaponAccessory:
                        {
                            // Locate the Weapon Accessory that was added.
                            WeaponAccessory objWeaponAccessory = CharacterObject.Vehicles.FindVehicleWeaponAccessory(strUndoId) ??
                                                                 CharacterObject.Weapons.FindWeaponAccessory(strUndoId);
                            objWeaponAccessory?.DeleteWeaponAccessory();
                        }
                        break;

                    case NuyenExpenseType.AddVehicleWeaponMount:
                        {
                            WeaponMount objWeaponMount = CharacterObject.Vehicles.FindVehicleWeaponMount(strUndoId);
                            objWeaponMount?.DeleteWeaponMount();
                        }
                        break;

                    case NuyenExpenseType.AddVehicleWeaponMountMod:
                        {
                            VehicleMod objVehicleMod = CharacterObject.Vehicles.FindVehicleWeaponMountMod(strUndoId);
                            objVehicleMod?.DeleteVehicleMod();
                        }
                        break;

                    case NuyenExpenseType.AddArmor:
                        {
                            // Locate the Armor that was added.
                            Armor objArmor = CharacterObject.Armor.FindById(strUndoId);
                            objArmor?.DeleteArmor();
                        }
                        break;

                    case NuyenExpenseType.AddArmorMod:
                        {
                            // Locate the Armor Mod that was added.
                            ArmorMod objArmorMod = CharacterObject.Armor.FindArmorMod(strUndoId);
                            objArmorMod?.DeleteArmorMod();
                        }
                        break;

                    case NuyenExpenseType.AddWeapon:
                        {
                            // Locate the Weapon that was added.
                            Weapon objWeapon = CharacterObject.Weapons.DeepFindById(strUndoId) ??
                                               CharacterObject.Vehicles.FindVehicleWeapon(strUndoId);
                            objWeapon?.DeleteWeapon();
                        }
                        break;

                    case NuyenExpenseType.AddWeaponAccessory:
                        {
                            // Locate the Weapon Accessory that was added.
                            WeaponAccessory objWeaponAccessory = CharacterObject.Weapons.FindWeaponAccessory(strUndoId) ??
                                                                 CharacterObject.Vehicles.FindVehicleWeaponAccessory(strUndoId);
                            objWeaponAccessory?.DeleteWeaponAccessory();
                        }
                        break;

                    case NuyenExpenseType.IncreaseLifestyle:
                        {
                            // Locate the Lifestyle that was increased.
                            Lifestyle objLifestyle = CharacterObject.Lifestyles.FirstOrDefault(x => x.InternalId == strUndoId);
                            if (objLifestyle != null)
                                --objLifestyle.Increments;
                        }
                        break;

                    case NuyenExpenseType.AddArmorGear:
                        {
                            // Locate the Armor Gear that was added.
                            Gear objGear = CharacterObject.Armor.FindArmorGear(strUndoId);
                            if (objGear != null)
                            {
                                // Deduct the Qty from the Gear.
                                objGear.Quantity -= objExpense.Undo.Qty;

                                // Remove the Gear if its Qty has been reduced to 0.
                                if (objGear.Quantity <= 0)
                                {
                                    objGear.DeleteGear();
                                }
                                else
                                {
                                    await treArmor.DoThreadSafeAsync(x =>
                                    {
                                        TreeNode objNode = x.FindNode(strUndoId);
                                        if (objNode != null)
                                            objNode.Text = objGear.CurrentDisplayName;
                                    });
                                }
                            }
                        }
                        break;

                    case NuyenExpenseType.AddVehicleModCyberware:
                        {
                            // Locate the Cyberware that was added.
                            Cyberware objCyberware = CharacterObject.Vehicles.FindVehicleCyberware(x => x.InternalId == strUndoId) ??
                                                     CharacterObject.Cyberware.DeepFindById(strUndoId);
                            objCyberware?.DeleteCyberware(blnIncreaseEssenceHole: false);
                        }
                        break;

                    case NuyenExpenseType.AddCyberwareGear:
                        {
                            // Locate the Gear that was added.
                            Gear objGear = CharacterObject.Cyberware.FindCyberwareGear(strUndoId) ??
                                           CharacterObject.Vehicles.FindVehicleGear(strUndoId) ??
                                           CharacterObject.Gear.DeepFindById(strUndoId);
                            objGear?.DeleteGear();
                        }
                        break;

                    case NuyenExpenseType.AddWeaponGear:
                        {
                            // Locate the Gear that was added.
                            Gear objGear = CharacterObject.Weapons.FindWeaponGear(strUndoId) ??
                                           CharacterObject.Vehicles.FindVehicleGear(strUndoId) ??
                                           CharacterObject.Gear.DeepFindById(strUndoId);
                            objGear?.DeleteGear();
                        }
                        break;

                    case NuyenExpenseType.ManualAdd:
                    case NuyenExpenseType.ManualSubtract:
                        break;
                }
            }

            // Refund the Nuyen amount and remove the Expense Entry.
            CharacterObject.Nuyen -= objExpense.Amount;
            await CharacterObject.ExpenseEntries.RemoveAsync(objExpense);
        }

        private async void tsAddArmorGear_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Gear window.
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Armor objArmor))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectArmor"), await LanguageManager.GetStringAsync("MessageTitle_SelectArmor"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Select the root Gear node then open the Select Gear window.
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickArmorGear(objArmor.InternalId, true);
            }
            while (blnAddAgain);
        }

        private async void tsArmorGearAddAsPlugin_Click(object sender, EventArgs e)
        {
            object objSelectedNodeTag = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag);
            // Make sure a parent items is selected, then open the Select Gear window.
            string strSelectedId;
            switch (objSelectedNodeTag)
            {
                case Gear objGear:
                    strSelectedId = objGear.InternalId;
                    break;

                case ArmorMod objMod:
                    {
                        strSelectedId = objMod.InternalId;
                        if (string.IsNullOrEmpty(objMod.GearCapacity))
                        {
                            Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectArmor"), await LanguageManager.GetStringAsync("MessageTitle_SelectArmor"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                            return;
                        }

                        break;
                    }
                default:
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectArmor"), await LanguageManager.GetStringAsync("MessageTitle_SelectArmor"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
            }

            if (string.IsNullOrEmpty(strSelectedId))
                return;

            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickArmorGear(strSelectedId);
            }
            while (blnAddAgain);
        }

        private async void tsArmorNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsQualityNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMartialArtsNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsSpellNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsComplexFormNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCritterPowersNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsLifestyleNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleName_Click(object sender, EventArgs e)
        {
            // Make sure a parent item is selected.
            if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode == null || x.SelectedNode.Level == 0))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectVehicleName"), await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            await treVehicles.DoThreadSafeAsync(x =>
            {
                while (x.SelectedNode.Level > 1)
                {
                    x.SelectedNode = x.SelectedNode.Parent;
                }
            });

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasCustomName objRename))
                return;

            string strDescription = await LanguageManager.GetStringAsync("String_VehicleName");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objRename.CustomName,
                       AllowEmptyString = true
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objRename.CustomName = frmPickText.MyForm.SelectedValue;
            }

            await treVehicles.DoThreadSafeAsync(x => x.SelectedNode.Text = objRename.CurrentDisplayName);

            await SetDirty(true);
        }

        private async void tsVehicleAddCyberware_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasInternalId strSelectedId))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_VehicleCyberwarePlugin"), await LanguageManager.GetStringAsync("MessageTitle_NoCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            Cyberware objCyberwareParent = null;
            VehicleMod objMod = CharacterObject.Vehicles.FindVehicleMod(x => x.InternalId == strSelectedId.InternalId, out Vehicle objVehicle, out WeaponMount _);
            if (objMod == null)
                objCyberwareParent = CharacterObject.Vehicles.FindVehicleCyberware(x => x.InternalId == strSelectedId.InternalId, out objMod);

            if (objCyberwareParent == null && objMod?.AllowCyberware != true)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_VehicleCyberwarePlugin"), await LanguageManager.GetStringAsync("MessageTitle_NoCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Cyberware XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("cyberware.xml");
            bool blnAddAgain;

            do
            {
                using (ThreadSafeForm<SelectCyberware> frmPickCyberware = await ThreadSafeForm<SelectCyberware>.GetAsync(() => new SelectCyberware(CharacterObject, Improvement.ImprovementSource.Cyberware, objCyberwareParent ?? (object)objMod)))
                {
                    if (objCyberwareParent == null)
                    {
                        //frmPickCyberware.SetGrade = "Standard";
                        frmPickCyberware.MyForm.MaximumCapacity = objMod.CapacityRemaining;
                        frmPickCyberware.MyForm.Subsystems = objMod.Subsystems;
                        using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                        out HashSet<string> setDisallowedMounts))
                        using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                        out HashSet<string> setHasMounts))
                        {
                            foreach (Cyberware objLoopCyberware in objMod.Cyberware.DeepWhere(
                                         x => x.Children, x => string.IsNullOrEmpty(x.PlugsIntoModularMount)))
                            {
                                foreach (string strLoop in objLoopCyberware.BlocksMounts.SplitNoAlloc(
                                             ',', StringSplitOptions.RemoveEmptyEntries))
                                {
                                    if (!setDisallowedMounts.Contains(strLoop + objLoopCyberware.Location))
                                        setDisallowedMounts.Add(strLoop + objLoopCyberware.Location);
                                }

                                string strLoopHasModularMount = objLoopCyberware.HasModularMount;
                                if (!string.IsNullOrEmpty(strLoopHasModularMount)
                                    && !setHasMounts.Contains(strLoopHasModularMount))
                                    setHasMounts.Add(strLoopHasModularMount);
                            }

                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdDisallowedMounts))
                            {
                                foreach (string strLoop in setDisallowedMounts)
                                {
                                    if (!strLoop.EndsWith("Right", StringComparison.Ordinal)
                                        && (!strLoop.EndsWith("Left", StringComparison.Ordinal)
                                            || setDisallowedMounts.Contains(
                                                strLoop.Substring(0, strLoop.Length - 4) + "Right")))
                                        sbdDisallowedMounts.Append(strLoop.TrimEndOnce("Left")).Append(',');
                                }

                                // Remove trailing ","
                                if (sbdDisallowedMounts.Length > 0)
                                    --sbdDisallowedMounts.Length;
                                frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                            }

                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdHasMounts))
                            {
                                foreach (string strLoop in setHasMounts)
                                    sbdHasMounts.Append(strLoop).Append(',');
                                // Remove trailing ","
                                if (sbdHasMounts.Length > 0)
                                    --sbdHasMounts.Length;
                                frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                            }
                        }
                    }
                    else
                    {
                        frmPickCyberware.MyForm.ForcedGrade = objCyberwareParent.Grade;
                        // If the Cyberware has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that consume Capacity).
                        if (!objCyberwareParent.Capacity.Contains('['))
                        {
                            frmPickCyberware.MyForm.MaximumCapacity = objCyberwareParent.CapacityRemaining;

                            // Do not allow the user to add a new piece of Cyberware if its Capacity has been reached.
                            if (CharacterObjectSettings.EnforceCapacity && objCyberwareParent.CapacityRemaining < 0)
                            {
                                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CapacityReached"), await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                                break;
                            }
                        }

                        frmPickCyberware.MyForm.CyberwareParent = objCyberwareParent;
                        frmPickCyberware.MyForm.Subsystems = objCyberwareParent.AllowedSubsystems;

                        using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                        out HashSet<string> setDisallowedMounts))
                        using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                        out HashSet<string> setHasMounts))
                        {
                            foreach (string strLoop in objCyberwareParent.BlocksMounts.SplitNoAlloc(
                                         ',', StringSplitOptions.RemoveEmptyEntries))
                                setDisallowedMounts.Add(strLoop + objCyberwareParent.Location);
                            string strLoopHasModularMount = objCyberwareParent.HasModularMount;
                            if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                setHasMounts.Add(strLoopHasModularMount);
                            foreach (Cyberware objLoopCyberware in objCyberwareParent.Children.DeepWhere(
                                         x => x.Children, x => string.IsNullOrEmpty(x.PlugsIntoModularMount)))
                            {
                                foreach (string strLoop in objLoopCyberware.BlocksMounts.SplitNoAlloc(
                                             ',', StringSplitOptions.RemoveEmptyEntries))
                                {
                                    if (!setDisallowedMounts.Contains(strLoop + objLoopCyberware.Location))
                                        setDisallowedMounts.Add(strLoop + objLoopCyberware.Location);
                                }

                                strLoopHasModularMount = objLoopCyberware.HasModularMount;
                                if (!string.IsNullOrEmpty(strLoopHasModularMount)
                                    && !setHasMounts.Contains(strLoopHasModularMount))
                                    setHasMounts.Add(strLoopHasModularMount);
                            }

                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdDisallowedMounts))
                            {
                                foreach (string strLoop in setDisallowedMounts)
                                {
                                    if (!strLoop.EndsWith("Right", StringComparison.Ordinal)
                                        && (!strLoop.EndsWith("Left", StringComparison.Ordinal)
                                            || setDisallowedMounts.Contains(
                                                strLoop.Substring(0, strLoop.Length - 4) + "Right")))
                                        sbdDisallowedMounts.Append(strLoop.TrimEndOnce("Left")).Append(',');
                                }

                                // Remove trailing ","
                                if (sbdDisallowedMounts.Length > 0)
                                    --sbdDisallowedMounts.Length;
                                frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                            }

                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdHasMounts))
                            {
                                foreach (string strLoop in setHasMounts)
                                    sbdHasMounts.Append(strLoop).Append(',');
                                // Remove trailing ","
                                if (sbdHasMounts.Length > 0)
                                    --sbdHasMounts.Length;
                                frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                            }
                        }
                    }

                    frmPickCyberware.MyForm.LockGrade();
                    frmPickCyberware.MyForm.ParentVehicle = objVehicle ?? objMod.Parent;

                    if (await frmPickCyberware.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        break;
                    blnAddAgain = frmPickCyberware.MyForm.AddAgain;

                    XmlNode objXmlCyberware = objXmlDocument.SelectSingleNode("/chummer/cyberwares/cyberware[id = " + frmPickCyberware.MyForm.SelectedCyberware.CleanXPath() + ']');
                    Cyberware objCyberware = new Cyberware(CharacterObject);
                    if (!objCyberware.Purchase(objXmlCyberware, Improvement.ImprovementSource.Cyberware,
                                               frmPickCyberware.MyForm.SelectedGrade, frmPickCyberware.MyForm.SelectedRating,
                                               objVehicle, objMod.Cyberware, CharacterObject.Vehicles, objMod.Weapons,
                                               frmPickCyberware.MyForm.Markup, frmPickCyberware.MyForm.FreeCost,
                                               frmPickCyberware.MyForm.BlackMarketDiscount, true,
                                               "String_ExpensePurchaseVehicleCyberware", objCyberwareParent))
                        objCyberware.DeleteCyberware();
                }
            }
            while (blnAddAgain);
        }

        private async void tsArmorName_Click(object sender, EventArgs e)
        {
            // Make sure a parent item is selected.
            if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode == null || x.SelectedNode.Level == 0))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectArmorName"), await LanguageManager.GetStringAsync("MessageTitle_SelectArmor"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            await treArmor.DoThreadSafeAsync(x =>
            {
                while (x.SelectedNode.Level > 1)
                {
                    x.SelectedNode = x.SelectedNode.Parent;
                }
            });

            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasCustomName objRename))
                return;

            string strDescription = await LanguageManager.GetStringAsync("String_ArmorName");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objRename.CustomName,
                       AllowEmptyString = true
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objRename.CustomName = frmPickText.MyForm.SelectedValue;
            }

            await treArmor.DoThreadSafeAsync(x => x.SelectedNode.Text = objRename.CurrentDisplayName);

            await SetDirty(true);
        }

        private async void tsLifestyleName_Click(object sender, EventArgs e)
        {
            // Get the information for the currently selected Lifestyle.
            if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasCustomName objCustomName))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectLifestyleName"), await LanguageManager.GetStringAsync("MessageTitle_SelectLifestyle"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_LifestyleName");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objCustomName.CustomName,
                       AllowEmptyString = true
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                if (objCustomName.CustomName == frmPickText.MyForm.SelectedValue)
                    return;
                objCustomName.CustomName = frmPickText.MyForm.SelectedValue;

                await treLifestyles.DoThreadSafeAsync(x => x.SelectedNode.Text = objCustomName.CurrentDisplayName);

                await SetDirty(true);
            }
        }

        private async void tsGearRenameLocation_Click(object sender, EventArgs e)
        {
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objLocation))
                return;
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objLocation.Name
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objLocation.Name = frmPickText.MyForm.SelectedValue;
            }

            await treGear.DoThreadSafeAsync(x => x.SelectedNode.Text = objLocation.DisplayName());

            await SetDirty(true);
        }

        private async void tsWeaponRenameLocation_Click(object sender, EventArgs e)
        {
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objLocation))
                return;
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objLocation.Name
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objLocation.Name = frmPickText.MyForm.SelectedValue;
            }

            await treWeapons.DoThreadSafeAsync(x => x.SelectedNode.Text = objLocation.DisplayName());

            await SetDirty(true);
        }

        private async void tsCreateSpell_Click(object sender, EventArgs e)
        {
            int intSpellKarmaCost = CharacterObject.SpellKarmaCost("Spells");
            // Make sure the character has enough Karma before letting them select a Spell.
            if (CharacterObject.Karma < intSpellKarmaCost)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // The character is still allowed to add Spells, so show the Create Spell window.
            using (ThreadSafeForm<CreateSpell> frmSpell = await ThreadSafeForm<CreateSpell>.GetAsync(() => new CreateSpell(CharacterObject)))
            {
                if (await frmSpell.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                {
                    frmSpell.MyForm.SelectedSpell.Dispose();
                    return;
                }

                Spell objSpell = frmSpell.MyForm.SelectedSpell;
                if (objSpell.Alchemical)
                {
                    intSpellKarmaCost = CharacterObject.SpellKarmaCost("Preparations");
                }
                else if (objSpell.Category == "Rituals")
                {
                    intSpellKarmaCost = CharacterObject.SpellKarmaCost("Rituals");
                }

                if (CharacterObject.Karma < intSpellKarmaCost)
                {
                    objSpell.Dispose();
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend")
                    , objSpell.CurrentDisplayName
                    , intSpellKarmaCost.ToString(GlobalSettings.CultureInfo))))
                {
                    objSpell.Dispose();
                    return;
                }

                await CharacterObject.Spells.AddAsync(objSpell);

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(intSpellKarmaCost * -1, await LanguageManager.GetStringAsync("String_ExpenseLearnSpell") + await LanguageManager.GetStringAsync("String_Space") + objSpell.Name, ExpenseType.Karma, DateTime.Now);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                CharacterObject.Karma -= intSpellKarmaCost;

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.AddSpell, objSpell.InternalId);
                objExpense.Undo = objUndo;
            }
        }

        private async void tsImprovementNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorRenameLocation_Click(object sender, EventArgs e)
        {
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objLocation))
                return;
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objLocation.Name
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objLocation.Name = frmPickText.MyForm.SelectedValue;
            }

            await treArmor.DoThreadSafeAsync(x => x.SelectedNode.Text = objLocation.DisplayName());

            await SetDirty(true);
        }

        private async void tsImprovementRenameLocation_Click(object sender, EventArgs e)
        {
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                string strNewLocation = frmPickText.MyForm.SelectedValue;

                int i = -1;
                foreach (string strLocation in CharacterObject.ImprovementGroups)
                {
                    ++i;
                    if (strLocation != treImprovements.SelectedNode.Text)
                        continue;
                    foreach (Improvement objImprovement in CharacterObject.Improvements)
                    {
                        if (objImprovement.CustomGroup == strLocation)
                            objImprovement.CustomGroup = strNewLocation;
                    }

                    CharacterObject.ImprovementGroups[i] = strNewLocation;
                    break;
                }
            }

            await SetDirty(true);
        }

        private async void tsCyberwareAddGear_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Gear window.
            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objCyberware))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectCyberware"), await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Make sure the Cyberware is allowed to accept Gear.
            if (objCyberware.AllowGear == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CyberwareGear"), await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    string strCategories = string.Empty;
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XmlNode objXmlCategory in objCyberware.AllowGear)
                            sbdCategories.Append(objXmlCategory.InnerText).Append(',');
                        if (sbdCategories.Length > 0)
                        {
                            --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }

                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(() => new SelectGear(CharacterObject, 0, 1, objCyberware, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objCyberware.Capacity) &&
                            objCyberware.Capacity != "0" && (!objCyberware.Capacity.Contains('[') ||
                                                             objCyberware.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        // Open the Gear XML file and locate the selected piece.
                        XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty,
                                       objCyberware.IsModularCurrentlyEquipped);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickGear.MyForm.FreeCost)
                        {
                            decimal decCost = objGear.TotalCost;

                            // Multiply the cost if applicable.
                            char chrAvail = (await objGear.TotalAvailTupleAsync()).Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > CharacterObject.Nuyen)
                            {
                                objGear.DeleteGear();
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                                continue;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                              await LanguageManager.GetStringAsync(
                                                  "String_ExpensePurchaseCyberwareGear")
                                              + await LanguageManager.GetStringAsync("String_Space")
                                              + objGear.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                              DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                            CharacterObject.Nuyen -= decCost;

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddCyberwareGear, objGear.InternalId, 1);
                            objExpense.Undo = objUndo;
                        }

                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }

                        await objCyberware.GearChildren.AddAsync(objGear);
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleCyberwareAddGear_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Gear window.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objCyberware))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectCyberware"), await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Make sure the Cyberware is allowed to accept Gear.
            if (objCyberware.AllowGear == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CyberwareGear"), await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    string strCategories = string.Empty;
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XmlNode objXmlCategory in objCyberware.AllowGear)
                            sbdCategories.Append(objXmlCategory.InnerText).Append(',');
                        if (sbdCategories.Length > 0)
                        {
                            --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }

                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(() => new SelectGear(CharacterObject, 0, 1, objCyberware, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objCyberware.Capacity) &&
                            objCyberware.Capacity != "0" && (!objCyberware.Capacity.Contains('[') ||
                                                             objCyberware.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        // Open the Gear XML file and locate the selected piece.
                        XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty, false);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickGear.MyForm.FreeCost)
                        {
                            decimal decCost = objGear.TotalCost;

                            // Multiply the cost if applicable.
                            char chrAvail = (await objGear.TotalAvailTupleAsync()).Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > CharacterObject.Nuyen)
                            {
                                objGear.DeleteGear();
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                                continue;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                              await LanguageManager.GetStringAsync(
                                                  "String_ExpensePurchaseCyberwareGear")
                                              + await LanguageManager.GetStringAsync("String_Space")
                                              + objGear.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                              DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                            CharacterObject.Nuyen -= decCost;

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddCyberwareGear, objGear.InternalId, 1);
                            objExpense.Undo = objUndo;
                        }

                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }

                        await objCyberware.GearChildren.AddAsync(objGear);
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsCyberwareGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode);
            // Make sure a parent items is selected, then open the Select Gear window.
            if (objSelectedNode == null || objSelectedNode.Level < 2)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Locate the Vehicle Sensor Gear.
            if (!(objSelectedNode.Tag is Gear objSensor))
            // Make sure the Gear was found.
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            CharacterObject.Cyberware.FindCyberwareGear(objSensor.InternalId, out Cyberware objCyberware);

            string strCategories = string.Empty;
            XPathNodeIterator xmlAddonCategoryList = (await objSensor.GetNodeXPathAsync())?.Select("addoncategory");
            if (xmlAddonCategoryList?.Count > 0)
            {
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                        sbdCategories.Append(objXmlCategory.Value).Append(',');
                    // Remove the trailing comma.
                    --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }
            }

            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(() => new SelectGear(CharacterObject, 0, 1, objSensor, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                 && (!objSensor.Capacity.Contains('[')
                                                                     || objSensor.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        // Open the Gear XML file and locate the selected piece.
                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty,
                                       (objSensor.Parent as Gear)?.Equipped
                                       ?? objCyberware?.IsModularCurrentlyEquipped == true);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickGear.MyForm.FreeCost)
                        {
                            decimal decCost = objGear.TotalCost;

                            // Multiply the cost if applicable.
                            char chrAvail = (await objGear.TotalAvailTupleAsync()).Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > CharacterObject.Nuyen)
                            {
                                objGear.DeleteGear();
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                                continue;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                              await LanguageManager.GetStringAsync(
                                                  "String_ExpensePurchaseCyberwareGear")
                                              + await LanguageManager.GetStringAsync("String_Space")
                                              + objGear.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                              DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                            CharacterObject.Nuyen -= decCost;

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddCyberwareGear, objGear.InternalId,
                                                frmPickGear.MyForm.SelectedQty);
                            objExpense.Undo = objUndo;
                        }

                        await objSensor.Children.AddAsync(objGear);

                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleCyberwareGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Gear window.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objSensor))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strCategories = string.Empty;
            XPathNodeIterator xmlAddonCategoryList = (await objSensor.GetNodeXPathAsync())?.Select("addoncategory");
            if (xmlAddonCategoryList?.Count > 0)
            {
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                        sbdCategories.Append(objXmlCategory.Value).Append(',');
                    // Remove the trailing comma.
                    --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }
            }

            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(() => new SelectGear(CharacterObject, 0, 1, objSensor, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                 && (!objSensor.Capacity.Contains('[')
                                                                     || objSensor.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        // Open the Gear XML file and locate the selected piece.
                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty, false);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickGear.MyForm.FreeCost)
                        {
                            decimal decCost = objGear.TotalCost;

                            // Multiply the cost if applicable.
                            char chrAvail = (await objGear.TotalAvailTupleAsync()).Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > CharacterObject.Nuyen)
                            {
                                objGear.DeleteGear();
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                                continue;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                              await LanguageManager.GetStringAsync(
                                                  "String_ExpensePurchaseCyberwareGear")
                                              + await LanguageManager.GetStringAsync("String_Space")
                                              + objGear.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                              DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                            CharacterObject.Nuyen -= decCost;

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddCyberwareGear, objGear.InternalId,
                                                frmPickGear.MyForm.SelectedQty);
                            objExpense.Undo = objUndo;
                        }

                        await objSensor.Children.AddAsync(objGear);

                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsWeaponAccessoryAddGear_Click(object sender, EventArgs e)
        {
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is WeaponAccessory objAccessory))
                return;
            // Make sure the Weapon Accessory is allowed to accept Gear.
            if (objAccessory.AllowGear == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_WeaponGear"), await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    string strCategories = string.Empty;
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XmlNode objXmlCategory in objAccessory.AllowGear)
                            sbdCategories.Append(objXmlCategory.InnerText).Append(',');
                        if (sbdCategories.Length > 0)
                        {
                            --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }

                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(() => new SelectGear(CharacterObject, 0, 1, objAccessory, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        // Open the Gear XML file and locate the selected piece.
                        XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty,
                                       objAccessory.Equipped);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickGear.MyForm.FreeCost)
                        {
                            decimal decCost = objGear.TotalCost;

                            // Multiply the cost if applicable.
                            char chrAvail = (await objGear.TotalAvailTupleAsync()).Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > CharacterObject.Nuyen)
                            {
                                objGear.DeleteGear();
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                                continue;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                              await LanguageManager.GetStringAsync("String_ExpensePurchaseWeaponGear")
                                              + await LanguageManager.GetStringAsync("String_Space")
                                              + objGear.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                              DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                            CharacterObject.Nuyen -= decCost;

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddWeaponGear, objGear.InternalId, 1);
                            objExpense.Undo = objUndo;
                        }

                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }

                        await objAccessory.GearChildren.AddAsync(objGear);
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsWeaponAccessoryGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objSensor))
            // Make sure the Gear was found.
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            CharacterObject.Weapons.FindWeaponGear(objSensor.InternalId, out WeaponAccessory objAccessory);

            // Open the Gear XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
            string strCategories = string.Empty;
            XPathNodeIterator xmlAddonCategoryList = (await objSensor.GetNodeXPathAsync())?.Select("addoncategory");
            if (xmlAddonCategoryList?.Count > 0)
            {
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                        sbdCategories.Append(objXmlCategory.Value).Append(',');
                    // Remove the trailing comma.
                    --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }
            }

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(() => new SelectGear(CharacterObject, 0, 1, objSensor, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                 && (!objSensor.Capacity.Contains('[')
                                                                     || objSensor.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty,
                                       (objSensor.Parent as Gear)?.Equipped ?? objAccessory?.Equipped == true);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickGear.MyForm.FreeCost)
                        {
                            decimal decCost = objGear.TotalCost;

                            // Multiply the cost if applicable.
                            char chrAvail = (await objGear.TotalAvailTupleAsync()).Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > CharacterObject.Nuyen)
                            {
                                objGear.DeleteGear();
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                                continue;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                              await LanguageManager.GetStringAsync("String_ExpensePurchaseWeaponGear")
                                              + await LanguageManager.GetStringAsync("String_Space")
                                              + objGear.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                              DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                            CharacterObject.Nuyen -= decCost;

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddWeaponGear, objGear.InternalId,
                                                frmPickGear.MyForm.SelectedQty);
                            objExpense.Undo = objUndo;
                        }

                        await objSensor.Children.AddAsync(objGear);

                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleRenameLocation_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objLocation))
                return;
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objLocation.Name
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objLocation.Name = frmPickText.MyForm.SelectedValue;
            }

            await treVehicles.DoThreadSafeAsync(x => x.SelectedNode.Text = objLocation.DisplayName());

            await SetDirty(true);
        }

        private async void tsCreateNaturalWeapon_Click(object sender, EventArgs e)
        {
            using (ThreadSafeForm<CreateNaturalWeapon> frmCreateNaturalWeapon = await ThreadSafeForm<CreateNaturalWeapon>.GetAsync(() => new CreateNaturalWeapon(CharacterObject)))
            {
                if (await frmCreateNaturalWeapon.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                Weapon objWeapon = frmCreateNaturalWeapon.MyForm.SelectedWeapon;
                await CharacterObject.Weapons.AddAsync(objWeapon);
            }
        }

        private async void tsVehicleWeaponAccessoryGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            // Locate the Vehicle Sensor Gear.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objSensor))
            // Make sure the Gear was found.
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Gear XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
            string strCategories = string.Empty;
            XPathNodeIterator xmlAddonCategoryList = (await objSensor.GetNodeXPathAsync())?.Select("addoncategory");
            if (xmlAddonCategoryList?.Count > 0)
            {
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                        sbdCategories.Append(objXmlCategory.Value).Append(',');
                    // Remove the trailing comma.
                    --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }
            }

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(() => new SelectGear(CharacterObject, 0, 1, objSensor, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                 && (!objSensor.Capacity.Contains('[')
                                                                     || objSensor.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty, false);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickGear.MyForm.FreeCost)
                        {
                            decimal decCost = objGear.TotalCost;

                            // Multiply the cost if applicable.
                            char chrAvail = (await objGear.TotalAvailTupleAsync()).Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > CharacterObject.Nuyen)
                            {
                                objGear.DeleteGear();
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                                continue;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                              await LanguageManager.GetStringAsync("String_ExpensePurchaseWeaponGear")
                                              + await LanguageManager.GetStringAsync("String_Space")
                                              + objGear.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                              DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                            CharacterObject.Nuyen -= decCost;

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddWeaponGear, objGear.InternalId,
                                                frmPickGear.MyForm.SelectedQty);
                            objExpense.Undo = objUndo;
                        }

                        await objSensor.Children.AddAsync(objGear);
                        CharacterObject.Vehicles.FindVehicleGear(objGear.InternalId, out Vehicle objVehicle, out _,
                                                                 out _);
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            objWeapon.ParentVehicle = objVehicle;
                            await objVehicle.Weapons.AddAsync(objWeapon);
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleWeaponAccessoryAddGear_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is WeaponAccessory objAccessory))
                return;
            // Make sure the Weapon Accessory is allowed to accept Gear.
            if (objAccessory.AllowGear == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_WeaponGear"), await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Gear XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    string strCategories = string.Empty;
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XmlNode objXmlCategory in objAccessory.AllowGear)
                            sbdCategories.Append(objXmlCategory.InnerText).Append(',');
                        if (sbdCategories.Length > 0)
                        {
                            --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }

                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(() => new SelectGear(CharacterObject, 0, 1, objAccessory, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty, false);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";

                        // Check the item's Cost and make sure the character can afford it.
                        if (!frmPickGear.MyForm.FreeCost)
                        {
                            decimal decCost = objGear.TotalCost;

                            // Multiply the cost if applicable.
                            char chrAvail = (await objGear.TotalAvailTupleAsync()).Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            if (decCost > CharacterObject.Nuyen)
                            {
                                objGear.DeleteGear();
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                                continue;
                            }

                            // Create the Expense Log Entry.
                            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                            objExpense.Create(decCost * -1,
                                              await LanguageManager.GetStringAsync("String_ExpensePurchaseWeaponGear")
                                              + await LanguageManager.GetStringAsync("String_Space")
                                              + objGear.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                              DateTime.Now);
                            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                            CharacterObject.Nuyen -= decCost;

                            ExpenseUndo objUndo = new ExpenseUndo();
                            objUndo.CreateNuyen(NuyenExpenseType.AddWeaponGear, objGear.InternalId, 1);
                            objExpense.Undo = objUndo;
                        }

                        await objAccessory.GearChildren.AddAsync(objGear);

                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            objWeapon.Parent = objAccessory.Parent;
                            await objAccessory.Parent.Children.AddAsync(objWeapon);
                        }
                    }
                } while (blnAddAgain);
            }
        }

        #endregion ContextMenu Events

        #region Additional Common Tab Control Events

        private async void treQualities_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedQuality();
        }

        private async Task RefreshSelectedQuality(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            await tlpCommonLeftSide.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                // Locate the selected Quality.
                Quality objQuality = await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag as Quality, token);
                await UpdateQualityLevelValue(objQuality, token);
                if (objQuality == null)
                {
                    await lblQualitySourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblQualityBPLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblQualitySource.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblQualityBP.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                else
                {
                    await lblQualitySourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblQualityBPLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblQualitySource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblQualityBP.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objQuality.SetSourceDetailAsync(lblQualitySource, token);
                    string strText
                        = (objQuality.BP * objQuality.Levels * CharacterObjectSettings.KarmaQuality).ToString(
                              GlobalSettings.CultureInfo) +
                          await LanguageManager.GetStringAsync("String_Space")
                          + await LanguageManager.GetStringAsync("String_Karma");
                    await lblQualityBP.DoThreadSafeAsync(x => x.Text = strText, token);
                }
            }
            finally
            {
                await tlpCommonLeftSide.DoThreadSafeAsync(x => x.ResumeLayout(), token);
            }
        }

        #endregion Additional Common Tab Control Events

        #region Additional Cyberware Tab Control Events

        private async void treCyberware_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedCyberware(GenericToken);
                await RefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Cyberware Tab Control Events

        #region Additional Street Gear Tab Control Events

        private async void treWeapons_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedWeapon(GenericToken);
                await RefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treWeapons_ItemDrag(object sender, ItemDragEventArgs e)
        {
            string strSelectedWeapon = treWeapons.SelectedNode?.Tag.ToString();
            if (string.IsNullOrEmpty(strSelectedWeapon) || treWeapons.SelectedNode.Level != 1)
                return;

            // Do not allow the root element to be moved.
            if (strSelectedWeapon != "Node_SelectedWeapons")
            {
                _intDragLevel = treWeapons.SelectedNode.Level;
                DoDragDrop(e.Item, DragDropEffects.Move);
            }
        }

        private void treWeapons_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private async void treWeapons_DragDrop(object sender, DragEventArgs e)
        {
            try
            {
                await DoTreeDragDrop(sender, e, treWeapons, ItemTreeViewTypes.Weapons, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treWeapons_DragOver(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = ((TreeView)sender).GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (objNode.Level <= _intDragLevel)
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background color for all other Nodes.
            treWeapons.ClearNodeBackground(objNode);
        }

        private async void treArmor_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedArmor(GenericToken);
                await RefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treArmor_ItemDrag(object sender, ItemDragEventArgs e)
        {
            if (treArmor.SelectedNode == null || treArmor.SelectedNode.Level != 1)
                return;

            _intDragLevel = treArmor.SelectedNode.Level;
            DoDragDrop(e.Item, DragDropEffects.Move);
        }

        private void treArmor_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private async void treArmor_DragDrop(object sender, DragEventArgs e)
        {
            try
            {
                await DoTreeDragDrop(sender, e, treArmor, ItemTreeViewTypes.Armor, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treArmor_DragOver(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = ((TreeView)sender).GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (objNode.Level <= _intDragLevel)
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background color for all other Nodes.
            treArmor.ClearNodeBackground(objNode);
        }

        private async void treLifestyles_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedLifestyle(GenericToken);
                await RefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treLifestyles_DoubleClick(object sender, EventArgs e)
        {
            if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Lifestyle objLifestyle))
                return;

            string strGuid = objLifestyle.InternalId;
            int intMonths = objLifestyle.Increments;
            int intPosition = await CharacterObject.Lifestyles.IndexOfAsync(CharacterObject.Lifestyles.FirstOrDefault(p => p.InternalId == objLifestyle.InternalId));
            string strOldLifestyleName = objLifestyle.CurrentDisplayName;
            decimal decOldLifestyleTotalCost = objLifestyle.TotalCost;

            if (objLifestyle.StyleType != LifestyleType.Standard)
            {
                Lifestyle newLifestyle = objLifestyle;
                // Edit Advanced Lifestyle.
                using (ThreadSafeForm<SelectLifestyleAdvanced> frmPickLifestyle = await ThreadSafeForm<SelectLifestyleAdvanced>.GetAsync(() => new SelectLifestyleAdvanced(CharacterObject, newLifestyle)))
                {
                    if (await frmPickLifestyle.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    {
                        if (!ReferenceEquals(objLifestyle, frmPickLifestyle.MyForm.SelectedLifestyle))
                            frmPickLifestyle.MyForm.SelectedLifestyle.Dispose();
                        return;
                    }

                    // Update the selected Lifestyle and refresh the list.
                    objLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;
                }
            }
            else
            {
                // Edit Basic Lifestyle.
                using (ThreadSafeForm<SelectLifestyle> frmPickLifestyle = await ThreadSafeForm<SelectLifestyle>.GetAsync(() => new SelectLifestyle(CharacterObject)))
                {
                    frmPickLifestyle.MyForm.SetLifestyle(objLifestyle);

                    if (await frmPickLifestyle.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    {
                        frmPickLifestyle.MyForm.SelectedLifestyle.Dispose();
                        return;
                    }

                    // Update the selected Lifestyle and refresh the list.
                    objLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;
                }
            }
            objLifestyle.Increments = intMonths;

            decimal decAmount = Math.Max(objLifestyle.TotalCost - decOldLifestyleTotalCost, 0);
            if (decAmount > CharacterObject.Nuyen)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            objLifestyle.SetInternalId(strGuid);
            CharacterObject.Lifestyles[intPosition] = objLifestyle;

            string strSpace = await LanguageManager.GetStringAsync("String_Space");

            // Create the Expense Log Entry.
            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
            objExpense.Create(-decAmount, await LanguageManager.GetStringAsync("String_ExpenseModifiedLifestyle") + await LanguageManager.GetStringAsync("String_Space") + strOldLifestyleName + strSpace + "->" + strSpace + objLifestyle.CurrentDisplayName, ExpenseType.Nuyen, DateTime.Now);
            CharacterObject.ExpenseEntries.AddWithSort(objExpense);

            await RequestCharacterUpdate();

            await SetDirty(true);
        }

        /*
        private void treLifestyles_ItemDrag(object sender, ItemDragEventArgs e)
        {
            if (treLifestyles.SelectedNode == null || treLifestyles.SelectedNode.Level != 1)
            {
                    return;
            }
            _intDragLevel = treLifestyles.SelectedNode.Level;
            DoDragDrop(e.Item, DragDropEffects.Move);
        }

        private void treLifestyles_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private void treLifestyles_DragDrop(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode nodDestination = ((TreeView)sender).GetNodeAt(pt);

            int intNewIndex = 0;
            if (nodDestination != null)
            {
                intNewIndex = nodDestination.Index;
            }
            else if (treLifestyles.Nodes.Count > 0)
            {
                intNewIndex = treLifestyles.Nodes[treLifestyles.Nodes.Count - 1].Nodes.Count;
                nodDestination = treLifestyles.Nodes[treLifestyles.Nodes.Count - 1];
            }

            CommonFunctions.MoveLifestyleNode(CharacterObject, intNewIndex, nodDestination, treLifestyles);

            // Clear the background color for all Nodes.
            treLifestyles.ClearNodeBackground(null);

            await SetDirty(true);
        }
        */

        private void treLifestyles_DragOver(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = ((TreeView)sender).GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (objNode.Level <= _intDragLevel)
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background color for all other Nodes.
            treLifestyles.ClearNodeBackground(objNode);
        }

        private async void treGear_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedGear(GenericToken);
                await RefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkArmorEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag);
            if (objSelected == null)
                return;

            bool blnChecked = await chkArmorEquipped.DoThreadSafeFuncAsync(x => x.Checked);

            // Locate the selected Armor or Armor Mod.
            switch (objSelected)
            {
                case Armor objArmor:
                    objArmor.Equipped = blnChecked;
                    break;

                case ArmorMod objMod:
                    objMod.Equipped = blnChecked;
                    break;

                case Gear objGear:
                    objGear.Equipped = blnChecked;
                    if (blnChecked)
                    {
                        CharacterObject.Armor.FindArmorGear(objGear.InternalId, out Armor objParentArmor, out ArmorMod objParentMod);
                        // Add the Gear's Improvements to the character.
                        if (objParentArmor.Equipped && objParentMod?.Equipped != false)
                        {
                            objGear.ChangeEquippedStatus(true);
                        }
                    }
                    else
                    {
                        objGear.ChangeEquippedStatus(false);
                    }

                    break;

                default:
                    return;
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdFireWeapon_Click(object sender, EventArgs e)
        {
            // "Click" the first menu item available.
            if (await cmsAmmoExpense.DoThreadSafeFuncAsync(() => cmsAmmoSingleShot.Enabled))
                await DoSingleShot();
            else if (await cmsAmmoExpense.DoThreadSafeFuncAsync(() => cmsAmmoShortBurst.Enabled))
                await DoShortBurst();
            else
                await DoLongBurst();
        }

        private async void cmdReloadWeapon_Click(object sender, EventArgs e)
        {
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            await objWeapon.Reload(CharacterObject.Gear, treGear);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdUnloadWeapon_Click(object sender, EventArgs e)
        {
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            await objWeapon.Unload(CharacterObject.Gear, treGear);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkWeaponEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            object objSelected = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag);
            if (objSelected == null)
                return;

            bool blnChecked = await chkWeaponEquipped.DoThreadSafeFuncAsync(x => x.Checked);
            // Determine if this is a Weapon.
            switch (objSelected)
            {
                case Weapon objWeapon:
                    objWeapon.Equipped = blnChecked;
                    break;

                case Gear objGear:
                    // Find the selected Gear.
                    objGear.Equipped = blnChecked;
                    objGear.ChangeEquippedStatus(blnChecked);
                    break;

                case WeaponAccessory objAccessory:
                    objAccessory.Equipped = blnChecked;
                    break;

                default:
                    return;
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkIncludedInWeapon_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            // Locate the selected Weapon Accessory or Modification.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is WeaponAccessory objAccessory))
                return;
            objAccessory.IncludedInWeapon = await chkIncludedInWeapon.DoThreadSafeFuncAsync(x => x.Checked);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private void treGear_ItemDrag(object sender, ItemDragEventArgs e)
        {
            string strSelected = treGear.SelectedNode?.Tag.ToString();
            if (string.IsNullOrEmpty(strSelected) || strSelected == "Node_SelectedGear")
                return;
            if (e.Button == MouseButtons.Left)
            {
                if (treGear.SelectedNode.Level > 1 || treGear.SelectedNode.Level < 0)
                    return;
                DragButton = MouseButtons.Left;
            }
            else
            {
                if (treGear.SelectedNode.Level == 0)
                    return;
                DragButton = MouseButtons.Right;
            }

            _intDragLevel = treGear.SelectedNode.Level;
            DoDragDrop(e.Item, DragDropEffects.Move);
        }

        private void treGear_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private async void treGear_DragDrop(object sender, DragEventArgs e)
        {
            try
            {
                await DoTreeDragDrop(sender, e, treGear, ItemTreeViewTypes.Gear, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treGear_DragOver(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = ((TreeView)sender).GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (DragButton == MouseButtons.Left)
            {
                if (objNode.Level <= _intDragLevel)
                    objNode.BackColor = ColorManager.ControlDarker;
            }
            else
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background color for all other Nodes.
            treGear.ClearNodeBackground(objNode);
        }

        private async void chkGearEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            // Attempt to locate the selected piece of Gear.
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objSelectedGear))
                return;
            bool blnChecked = await chkGearEquipped.DoThreadSafeFuncAsync(x => x.Checked);
            objSelectedGear.Equipped = blnChecked;
            objSelectedGear.ChangeEquippedStatus(blnChecked);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cboWeaponAmmo_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;

            objWeapon.ActiveAmmoSlot = Convert.ToInt32(await cboWeaponAmmo.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString()), GlobalSettings.InvariantCultureInfo);
            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private void chkGearHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (treGear.SelectedNode?.Tag is IHasMatrixAttributes objCommlink)
            {
                objCommlink.SetHomeNode(CharacterObject, chkGearHomeNode.Checked);
            }
        }

        private void chkArmorHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (treArmor.SelectedNode?.Tag is IHasMatrixAttributes objCommlink)
            {
                objCommlink.SetHomeNode(CharacterObject, chkArmorHomeNode.Checked);
            }
        }

        private void chkWeaponHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (treWeapons.SelectedNode?.Tag is IHasMatrixAttributes objCommlink)
            {
                objCommlink.SetHomeNode(CharacterObject, chkWeaponHomeNode.Checked);
            }
        }

        private void chkCyberwareHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (treCyberware.SelectedNode?.Tag is IHasMatrixAttributes objCommlink)
            {
                objCommlink.SetHomeNode(CharacterObject, chkGearHomeNode.Checked);
            }
        }

        private async void cmdWeaponBuyAmmo_Click(object sender, EventArgs e)
        {
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickGear(null, null, null, string.Empty, objWeapon);
            }
            while (blnAddAgain);
        }

        private async void cmdWeaponMoveToVehicle_Click(object sender, EventArgs e)
        {
            // Locate the selected Weapon.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;

            List<Vehicle> lstVehicles = new List<Vehicle>(CharacterObject.Vehicles.Count);
            foreach (Vehicle objCharacterVehicle in CharacterObject.Vehicles)
            {
                if (objCharacterVehicle.WeaponMounts.Count > 0
                    || objCharacterVehicle.Mods.Any(objVehicleMod => objVehicleMod.Name.Contains("Drone Arm")
                                                                     || objVehicleMod.Name.StartsWith("Mechanical Arm", StringComparison.Ordinal)))
                {
                    lstVehicles.Add(objCharacterVehicle);
                }
            }

            // Cannot continue if there are no Vehicles with a Weapon Mount or Mechanical Arm.
            if (lstVehicles.Count == 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotMoveWeapons"), await LanguageManager.GetStringAsync("MessageTitle_CannotMoveWeapons"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            WeaponMount objWeaponMount;
            VehicleMod objMod = null;

            using (ThreadSafeForm<SelectItem> frmPickItem = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem()))
            {
                frmPickItem.MyForm.SetVehiclesMode(lstVehicles);

                if (await frmPickItem.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // Locate the selected Vehicle.
                Vehicle objVehicle = await CharacterObject.Vehicles.FirstOrDefaultAsync(x => x.InternalId == frmPickItem.MyForm.SelectedItem);
                if (objVehicle == null)
                    return;

                // Now display a list of the acceptable mounting points for the Weapon.
                using (new FetchSafelyFromPool<List<ListItem>>(Utils.ListItemListPool, out List<ListItem> lstItems))
                {
                    foreach (WeaponMount objVehicleWeaponMount in objVehicle.WeaponMounts)
                    {
                        //TODO: RAW, some mounts can have multiple weapons attached. Needs support in the Weapon Mount class itself, ideally a 'CanMountThisWeapon' bool or something.
                        if ((objVehicleWeaponMount.AllowedWeaponCategories.Contains(objWeapon.SizeCategory) ||
                             objVehicleWeaponMount.AllowedWeapons.Contains(objWeapon.Name)) &&
                            !objVehicleWeaponMount.IsWeaponsFull)
                            lstItems.Add(new ListItem(objVehicleWeaponMount.InternalId,
                                                      objVehicleWeaponMount.CurrentDisplayName));
                        else
                            foreach (VehicleMod objVehicleMod in objVehicleWeaponMount.Mods)
                            {
                                if ((objVehicleMod.Name.Contains("Drone Arm") ||
                                     objVehicleMod.Name.StartsWith("Mechanical Arm", StringComparison.Ordinal)) &&
                                    objVehicleMod.Weapons.Count == 0)
                                    lstItems.Add(new ListItem(objVehicleMod.InternalId,
                                                              objVehicleMod.CurrentDisplayName));
                            }
                    }

                    foreach (VehicleMod objVehicleMod in objVehicle.Mods)
                    {
                        if ((objVehicleMod.Name.Contains("Drone Arm") ||
                             objVehicleMod.Name.StartsWith("Mechanical Arm", StringComparison.Ordinal))
                            && objVehicleMod.Weapons.Count == 0)
                            lstItems.Add(new ListItem(objVehicleMod.InternalId, objVehicleMod.CurrentDisplayName));
                    }

                    if (lstItems.Count == 0)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NoValidWeaponMount"),
                                                        await LanguageManager.GetStringAsync("MessageTitle_NoValidWeaponMount"),
                                                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }

                    frmPickItem.MyForm.SetGeneralItemsMode(lstItems);

                    if (await frmPickItem.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return;

                    string strId = frmPickItem.MyForm.SelectedItem;
                    // Locate the selected Vehicle Mod.
                    objWeaponMount = await objVehicle.WeaponMounts.FirstOrDefaultAsync(x => x.InternalId == strId);
                    // Locate the selected Vehicle Mod.
                    if (objWeaponMount == null)
                    {
                        objMod = objVehicle.FindVehicleMod(x => x.InternalId == strId, out objWeaponMount);
                        if (objMod == null)
                            return;
                    }
                }
            }

            objWeapon.Location = null;
            // Remove the Weapon from the character and add it to the Vehicle Mod.
            await CharacterObject.Weapons.RemoveAsync(objWeapon);

            // Remove any Improvements from the Character.
            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
            {
                foreach (Gear objGear in objAccessory.GearChildren)
                    objGear.ChangeEquippedStatus(false);
            }
            if (objWeapon.UnderbarrelWeapons.Count > 0)
            {
                foreach (Weapon objUnderbarrelWeapon in objWeapon.UnderbarrelWeapons)
                {
                    foreach (WeaponAccessory objAccessory in objUnderbarrelWeapon.WeaponAccessories)
                    {
                        foreach (Gear objGear in objAccessory.GearChildren)
                            objGear.ChangeEquippedStatus(false);
                    }
                }
            }

            if (objWeaponMount != null)
            {
                objWeapon.ParentMount = objWeaponMount;
                await objWeaponMount.Weapons.AddAsync(objWeapon);
            }
            else
            {
                objWeapon.ParentVehicleMod = objMod;
                await objMod.Weapons.AddAsync(objWeapon);
            }

            List<Gear> lstGearToMove = new List<Gear>();
            foreach (Clip objClip in objWeapon.Clips)
            {
                if (objClip.AmmoGear != null)
                {
                    lstGearToMove.Add(objClip.AmmoGear);
                }
            }
            foreach (Clip objClip in objWeapon.Children.GetAllDescendants(x => x.Children).SelectMany(x => x.Clips))
            {
                if (objClip.AmmoGear != null)
                {
                    lstGearToMove.Add(objClip.AmmoGear);
                }
            }
            foreach (Gear objGear in lstGearToMove)
            {
                switch (objGear.Parent)
                {
                    case IHasGear objHasChildren:
                        await objHasChildren.GearChildren.RemoveAsync(objGear);
                        break;

                    case IHasChildren<Gear> objHasChildren:
                        await objHasChildren.Children.RemoveAsync(objGear);
                        break;

                    default:
                        await CharacterObject.Gear.RemoveAsync(objGear);
                        break;
                }

                if (objWeaponMount != null)
                {
                    await objWeaponMount.Parent.GearChildren.AddAsync(objGear);
                }
                else
                {
                    await objMod.Parent.GearChildren.AddAsync(objGear);
                }
            }
        }

        private async void cmdArmorIncrease_Click(object sender, EventArgs e)
        {
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Armor objArmor))
                return;

            --objArmor.ArmorDamage;

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdArmorDecrease_Click(object sender, EventArgs e)
        {
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Armor objArmor))
                return;

            ++objArmor.ArmorDamage;

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkCommlinks_CheckedChanged(object sender, EventArgs e)
        {
            await FilterCheckboxChanged();
        }

        private async void chkHideLoadedAmmo_CheckedChanged(object sender, EventArgs e)
        {
            await FilterCheckboxChanged();
        }

        private async ValueTask FilterCheckboxChanged()
        {
            try
            {
                bool commlinksOnly = await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, GenericToken);
                bool hideLoadedAmmo = await chkHideLoadedAmmo.DoThreadSafeFuncAsync(x => x.Checked, GenericToken);
                await RefreshGears(treGear, cmsGearLocation, cmsGear, commlinksOnly, hideLoadedAmmo);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void chkGearActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(treGear.SelectedNode?.Tag is IHasMatrixAttributes objSelectedCommlink))
                return;
            objSelectedCommlink.SetActiveCommlink(CharacterObject, chkGearActiveCommlink.Checked);
        }

        private void chkArmorActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(treArmor.SelectedNode?.Tag is IHasMatrixAttributes objSelectedCommlink))
                return;
            objSelectedCommlink.SetActiveCommlink(CharacterObject, chkArmorActiveCommlink.Checked);
        }

        private void chkWeaponActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(treWeapons.SelectedNode?.Tag is IHasMatrixAttributes objSelectedCommlink))
                return;
            objSelectedCommlink.SetActiveCommlink(CharacterObject, chkWeaponActiveCommlink.Checked);
        }

        private void chkCyberwareActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(treCyberware.SelectedNode?.Tag is IHasMatrixAttributes objSelectedCommlink))
                return;
            objSelectedCommlink.SetActiveCommlink(CharacterObject, chkCyberwareActiveCommlink.Checked);
        }

        private void chkVehicleActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(treVehicles.SelectedNode?.Tag is IHasMatrixAttributes objSelectedCommlink))
                return;
            objSelectedCommlink.SetActiveCommlink(CharacterObject, chkCyberwareActiveCommlink.Checked);
        }

        private async void cboGearAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboGearAttack.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboGearAttack, cboGearAttack,
                        cboGearSleaze, cboGearDataProcessing, cboGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboGearSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboGearSleaze.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboGearSleaze, cboGearAttack,
                        cboGearSleaze, cboGearDataProcessing, cboGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboGearDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboGearDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboGearDataProcessing, cboGearAttack,
                        cboGearSleaze, cboGearDataProcessing, cboGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboGearFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboGearFirewall.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboGearFirewall, cboGearAttack,
                        cboGearSleaze, cboGearDataProcessing, cboGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboVehicleAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboVehicleAttack.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboVehicleAttack, cboVehicleAttack,
                        cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboVehicleSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboVehicleSleaze.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboVehicleSleaze, cboVehicleAttack,
                        cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboVehicleFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboVehicleFirewall.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboVehicleFirewall, cboVehicleAttack,
                        cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboVehicleDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboVehicleDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboVehicleDataProcessing, cboVehicleAttack,
                        cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboCyberwareAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboCyberwareAttack.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboCyberwareAttack, cboCyberwareAttack,
                        cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboCyberwareSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboCyberwareSleaze.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboCyberwareSleaze, cboCyberwareAttack,
                        cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboCyberwareDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboCyberwareDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboCyberwareDataProcessing, cboCyberwareAttack,
                        cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboCyberwareFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboCyberwareFirewall.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboCyberwareFirewall, cboCyberwareAttack,
                        cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboArmorAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboArmorAttack.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboArmorAttack, cboArmorAttack, cboArmorSleaze, cboArmorDataProcessing,
                        cboArmorFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboArmorSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboArmorSleaze.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboArmorSleaze, cboArmorAttack, cboArmorSleaze, cboArmorDataProcessing,
                        cboArmorFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboArmorDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboArmorDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboArmorDataProcessing, cboArmorAttack, cboArmorSleaze, cboArmorDataProcessing,
                        cboArmorFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboArmorFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboArmorFirewall.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboArmorFirewall, cboArmorAttack, cboArmorSleaze, cboArmorDataProcessing,
                        cboArmorFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }
        
        private async void cboWeaponGearAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboWeaponGearAttack.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboWeaponGearAttack, cboWeaponGearAttack, cboWeaponGearSleaze,
                        cboWeaponGearDataProcessing, cboWeaponGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboWeaponGearSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboWeaponGearSleaze.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboWeaponGearSleaze, cboWeaponGearAttack, cboWeaponGearSleaze,
                        cboWeaponGearDataProcessing, cboWeaponGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboWeaponGearDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboWeaponGearDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboWeaponGearDataProcessing, cboWeaponGearAttack, cboWeaponGearSleaze,
                        cboWeaponGearDataProcessing, cboWeaponGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboWeaponGearFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboWeaponGearFirewall.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboWeaponGearFirewall, cboWeaponGearAttack, cboWeaponGearSleaze,
                        cboWeaponGearDataProcessing, cboWeaponGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        #endregion Additional Street Gear Tab Control Events

        #region Additional Vehicle Tab Control Events

        private async void treVehicles_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedVehicle(GenericToken);
                await RefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treVehicles_ItemDrag(object sender, ItemDragEventArgs e)
        {
            switch (treVehicles.SelectedNode?.Tag)
            {
                // Determine if this is a piece of Gear or a Vehicle. If not, don't let the user drag it.
                case Gear _:
                    DragButton = e.Button;
                    DraggingGear = true;
                    _intDragLevel = treVehicles.SelectedNode.Level;
                    DoDragDrop(e.Item, DragDropEffects.Move);
                    break;

                case Vehicle _:
                    DragButton = e.Button;
                    DraggingGear = false;
                    _intDragLevel = treVehicles.SelectedNode.Level;
                    DoDragDrop(e.Item, DragDropEffects.Move);
                    break;
            }
        }

        private void treVehicles_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private async void treVehicles_DragDrop(object sender, DragEventArgs e)
        {
            try
            {
                await DoTreeDragDrop(sender, e, treVehicles, ItemTreeViewTypes.Vehicles, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treVehicles_DragOver(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = ((TreeView)sender).GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (DragButton == MouseButtons.Left)
            {
                if (objNode.Level <= _intDragLevel)
                    objNode.BackColor = ColorManager.ControlDarker;
            }
            else
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background color for all other Nodes.
            treVehicles.ClearNodeBackground(objNode);
        }

        private async void cmdFireVehicleWeapon_Click(object sender, EventArgs e)
        {
            // "Click" the first menu item available.
            if (await cmdVehicleAmmoExpense.DoThreadSafeFuncAsync(() => cmsVehicleAmmoSingleShot.Enabled))
                await DoVehicleAmmoSingleShot();
            else if (await cmdVehicleAmmoExpense.DoThreadSafeFuncAsync(() => cmsVehicleAmmoShortBurst.Enabled))
                await DoVehicleAmmoShortBurst();
            else
                await DoVehicleAmmoLongBurst();
        }

        private async void cmdReloadVehicleWeapon_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            await objWeapon.Reload(objWeapon.ParentVehicle.GearChildren, treVehicles);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdUnloadVehicleWeapon_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            await objWeapon.Unload(objWeapon.ParentVehicle.GearChildren, treGear);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkVehicleWeaponAccessoryInstalled_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is ICanEquip objEquippable))
                return;
            objEquippable.Equipped = await chkVehicleWeaponAccessoryInstalled.DoThreadSafeFuncAsync(x => x.Checked);

            await SetDirty(true);
        }

        private async void cboVehicleWeaponAmmo_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            objWeapon.ActiveAmmoSlot = Convert.ToInt32(await cboVehicleWeaponAmmo.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString()), GlobalSettings.InvariantCultureInfo);
            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private void chkVehicleHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !(treVehicles.SelectedNode?.Tag is IHasMatrixAttributes objTarget))
                return;
            objTarget.SetHomeNode(CharacterObject, chkVehicleHomeNode.Checked);
        }

        #endregion Additional Vehicle Tab Control Events

        #region Additional Spells and Spirits Tab Control Events

        private async void treSpells_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedSpell();
        }

        private void treFoci_AfterCheck(object sender, TreeViewEventArgs e)
        {
            if (!e.Node.Checked)
            {
                if (!(e.Node.Tag is IHasInternalId objId)) return;
                Focus objFocus = CharacterObject.Foci.Find(x => x.GearObject.InternalId == objId.InternalId);

                // Mark the Gear as not Bonded and remove any Improvements.
                Gear objGear = objFocus?.GearObject;

                if (objGear != null)
                {
                    objGear.Bonded = false;
                    ImprovementManager.RemoveImprovements(CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId);
                    CharacterObject.Foci.Remove(objFocus);
                }
                else
                {
                    // This is a Stacked Focus.
                    StackedFocus objStack = CharacterObject.StackedFoci.Find(x => x.InternalId == objId.InternalId);

                    if (objStack != null)
                    {
                        objStack.Bonded = false;
                        ImprovementManager.RemoveImprovements(CharacterObject, Improvement.ImprovementSource.StackedFocus, objStack.InternalId);
                    }
                }
            }
        }

        private async void treFoci_BeforeCheck(object sender, TreeViewCancelEventArgs e)
        {
            if (IsRefreshing)
                return;

            TreeView treViewToUse = e.Node.TreeView;

            // If the item is being unchecked, confirm that the user wants to un-bind the Focus.
            if (await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Checked))
            {
                if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_UnbindFocus"), await LanguageManager.GetStringAsync("MessageTitle_UnbindFocus"), MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                    e.Cancel = true;
                return;
            }

            // Set the Focus count to 1 and get its current Rating (Force). This number isn't used in the following loops because it isn't yet checked or unchecked.
            int intFociCount = 1;
            int intFociTotal = 0;

            Gear objSelectedFocus = null;

            switch (await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Tag))
            {
                case Gear objGear:
                    {
                        objSelectedFocus = objGear;
                        intFociTotal = objGear.Rating;
                        break;
                    }
                case StackedFocus objStackedFocus:
                    {
                        intFociTotal = objStackedFocus.TotalForce;
                        break;
                    }
            }

            await treViewToUse.DoThreadSafeAsync(y =>
            {
                // Run through the list of items. Count the number of Foci the character would have bonded including this one, plus the total Force of all checked Foci.
                foreach (TreeNode objNode in y.Nodes)
                {
                    if (objNode.Checked)
                    {
                        string strNodeId = objNode.Tag.ToString();
                        ++intFociCount;
                        intFociTotal += CharacterObject.Gear.FirstOrDefault(x => x.InternalId == strNodeId && x.Bonded)
                                                       ?.Rating ?? 0;
                        intFociTotal += CharacterObject.StackedFoci.Find(x => x.InternalId == strNodeId && x.Bonded)
                                                       ?.TotalForce ?? 0;
                    }
                }
            });

            if (!CharacterObject.IgnoreRules)
            {
                if (intFociTotal > CharacterObject.MAG.TotalValue * 5 ||
                    CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept && intFociTotal > CharacterObject.MAGAdept.TotalValue * 5)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_FocusMaximumForce"), await LanguageManager.GetStringAsync("MessageTitle_FocusMaximum"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    e.Cancel = true;
                    return;
                }

                if (intFociCount > CharacterObject.MAG.TotalValue ||
                    CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept && intFociCount > CharacterObject.MAGAdept.TotalValue)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_FocusMaximumNumber"), await LanguageManager.GetStringAsync("MessageTitle_FocusMaximum"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    e.Cancel = true;
                    return;
                }
            }

            // If we've made it this far, everything is okay, so create a Karma Expense for the newly-bound Focus.

            if (objSelectedFocus != null)
            {
                bool blnOldEquipped = objSelectedFocus.Equipped;
                Focus objFocus = new Focus(CharacterObject)
                {
                    GearObject = objSelectedFocus
                };
                if (objSelectedFocus.Bonus != null || objSelectedFocus.WirelessOn && objSelectedFocus.WirelessBonus != null)
                {
                    if (!string.IsNullOrEmpty(objSelectedFocus.Extra))
                        ImprovementManager.ForcedValue = objSelectedFocus.Extra;
                    if (objSelectedFocus.Bonus != null)
                    {
                        if (!await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objSelectedFocus.InternalId, objSelectedFocus.Bonus, objSelectedFocus.Rating, objSelectedFocus.CurrentDisplayNameShort))
                        {
                            // Clear created improvements
                            objSelectedFocus.ChangeEquippedStatus(false);
                            if (blnOldEquipped)
                                objSelectedFocus.ChangeEquippedStatus(true);
                            e.Cancel = true;
                            return;
                        }
                        objSelectedFocus.Extra = ImprovementManager.SelectedValue;
                    }
                    if (objSelectedFocus.WirelessOn && objSelectedFocus.WirelessBonus != null && !await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objSelectedFocus.InternalId, objSelectedFocus.WirelessBonus, objSelectedFocus.Rating, objSelectedFocus.CurrentDisplayNameShort))
                    {
                        // Clear created improvements
                        objSelectedFocus.ChangeEquippedStatus(false);
                        if (blnOldEquipped)
                            objSelectedFocus.ChangeEquippedStatus(true);
                        e.Cancel = true;
                        return;
                    }
                }

                int intKarmaExpense = objFocus.BindingKarmaCost();
                if (intKarmaExpense > CharacterObject.Karma)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    // Clear created improvements
                    objSelectedFocus.ChangeEquippedStatus(false);
                    if (blnOldEquipped)
                        objSelectedFocus.ChangeEquippedStatus(true);
                    e.Cancel = true;
                    return;
                }

                if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseFocus")
                    , intKarmaExpense.ToString(GlobalSettings.CultureInfo)
                    , objSelectedFocus.CurrentDisplayNameShort)))
                {
                    // Clear created improvements
                    objSelectedFocus.ChangeEquippedStatus(false);
                    if (blnOldEquipped)
                        objSelectedFocus.ChangeEquippedStatus(true);
                    e.Cancel = true;
                    return;
                }

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(intKarmaExpense * -1, await LanguageManager.GetStringAsync("String_ExpenseBound") + await LanguageManager.GetStringAsync("String_Space") + objSelectedFocus.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                CharacterObject.Karma -= intKarmaExpense;

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.BindFocus, objSelectedFocus.InternalId);
                objExpense.Undo = objUndo;

                await CharacterObject.Foci.AddAsync(objFocus);
                objSelectedFocus.Bonded = true;
                if (!blnOldEquipped)
                {
                    objSelectedFocus.ChangeEquippedStatus(false);
                }

                await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Text = objSelectedFocus.CurrentDisplayName);
            }
            else
            {
                // The Focus was not found in Gear, so this is a Stacked Focus.
                if (!(await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Tag) is StackedFocus objStackedFocus))
                {
                    e.Cancel = true;
                    return;
                }

                Gear objStackGear = CharacterObject.Gear.DeepFindById(objStackedFocus.GearId);
                if (objStackGear == null)
                {
                    e.Cancel = true;
                    return;
                }
                bool blnOldEquipped = objStackGear.Equipped;
                foreach (Gear objGear in objStackedFocus.Gear)
                {
                    if (objGear.Bonus != null || objGear.WirelessOn && objGear.WirelessBonus != null)
                    {
                        if (!string.IsNullOrEmpty(objGear.Extra))
                            ImprovementManager.ForcedValue = objGear.Extra;
                        if (objGear.Bonus != null)
                        {
                            if (!await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.StackedFocus, objStackedFocus.InternalId, objGear.Bonus, objGear.Rating, objGear.CurrentDisplayNameShort))
                            {
                                e.Cancel = true;
                                break;
                            }
                            objGear.Extra = ImprovementManager.SelectedValue;
                        }
                        if (objGear.WirelessOn && objGear.WirelessBonus != null && !await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.StackedFocus, objStackedFocus.InternalId, objGear.WirelessBonus, objGear.Rating, objGear.CurrentDisplayNameShort))
                        {
                            e.Cancel = true;
                            break;
                        }
                    }
                }

                if (e.Cancel)
                {
                    // Clear created improvements
                    foreach (Gear objGear in objStackedFocus.Gear)
                        objGear.ChangeEquippedStatus(false);
                    if (blnOldEquipped)
                        foreach (Gear objGear in objStackedFocus.Gear)
                            objGear.ChangeEquippedStatus(true);
                    return;
                }

                int intKarmaExpense = objStackedFocus.BindingCost;
                if (intKarmaExpense > CharacterObject.Karma)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    // Clear created improvements
                    objStackGear.ChangeEquippedStatus(false);
                    if (blnOldEquipped)
                        objStackGear.ChangeEquippedStatus(true);
                    e.Cancel = true;
                    return;
                }

                if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseFocus")
                    , intKarmaExpense.ToString(GlobalSettings.CultureInfo)
                    , await LanguageManager.GetStringAsync("String_StackedFocus") + await LanguageManager.GetStringAsync("String_Space") + objStackedFocus.CurrentDisplayName)))
                {
                    // Clear created improvements
                    objStackGear.ChangeEquippedStatus(false);
                    if (blnOldEquipped)
                        objStackGear.ChangeEquippedStatus(true);
                    e.Cancel = true;
                    return;
                }

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(intKarmaExpense * -1, await LanguageManager.GetStringAsync("String_ExpenseBound") + await LanguageManager.GetStringAsync("String_Space") + await LanguageManager.GetStringAsync("String_StackedFocus") + await LanguageManager.GetStringAsync("String_Space") + objStackedFocus.CurrentDisplayName, ExpenseType.Karma, DateTime.Now);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                CharacterObject.Karma -= intKarmaExpense;

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.BindFocus, objStackedFocus.InternalId);
                objExpense.Undo = objUndo;

                objStackedFocus.Bonded = true;
                await treViewToUse.DoThreadSafeAsync(x => x.SelectedNode.Text = objStackGear.CurrentDisplayName);
            }

            await RequestCharacterUpdate();

            await SetDirty(true);
        }

        private async void cboTradition_SelectedIndexChanged(object sender, EventArgs e)
        {
            //TODO: Why can't IsInitialized be used here? Throws an error when trying to use chummer.helpers.
            if (IsLoading || IsRefreshing || IsDisposed)
                return;

            SkipUpdate = true;
            try
            {
                string strSelectedId
                    = await cboTradition.DoThreadSafeFuncAsync(x => x.SelectedValue?.ToString(), GenericToken);
                if (string.IsNullOrEmpty(strSelectedId))
                    return;

                XmlNode xmlTradition = (await CharacterObject.LoadDataAsync("traditions.xml", token: GenericToken))
                    .SelectSingleNode("/chummer/traditions/tradition[id = " + strSelectedId.CleanXPath()
                                                                            + ']');

                if (xmlTradition == null)
                {
                    await lblTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await txtTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await cboSpiritCombat.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await cboSpiritDetection.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await cboSpiritHealth.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await cboSpiritIllusion.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await cboSpiritManipulation.DoThreadSafeAsync(x => x.Visible = false, GenericToken);

                    if (CharacterObject.MagicTradition.Type == TraditionType.MAG)
                    {
                        CharacterObject.MagicTradition.ResetTradition();
                        await RequestCharacterUpdate();
                        await SetDirty(true);
                    }

                    await cboTradition.DoThreadSafeAsync(
                        x => x.SelectedValue = CharacterObject.MagicTradition.SourceID, GenericToken);
                }
                else if (strSelectedId == Tradition.CustomMagicalTraditionGuid)
                {
                    if (CharacterObject.MagicTradition.Create(xmlTradition))
                    {
                        await lblTraditionName.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                        await txtTraditionName.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                        await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                        await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                        await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                        await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                        await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                        await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                        await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                        await cboSpiritCombat.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken);
                        await cboSpiritDetection.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken);
                        await cboSpiritHealth.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken);
                        await cboSpiritIllusion.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken);
                        await cboSpiritManipulation.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken);

                        await RequestCharacterUpdate();
                        await SetDirty(true);
                    }
                    else
                    {
                        CharacterObject.MagicTradition.ResetTradition();
                        await cboTradition.DoThreadSafeAsync(
                            x => x.SelectedValue = CharacterObject.MagicTradition.SourceID, GenericToken);
                    }
                }
                else if (CharacterObject.MagicTradition.Create(xmlTradition))
                {
                    await lblTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await txtTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                    await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                    await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                    await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                    await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                    await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                    await cboSpiritCombat.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken);
                    await cboSpiritDetection.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken);
                    await cboSpiritHealth.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken);
                    await cboSpiritIllusion.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken);
                    await cboSpiritManipulation.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken);

                    await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = true);
                    await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = true, GenericToken);
                    await CharacterObject.MagicTradition.SetSourceDetailAsync(lblTraditionSource, GenericToken);

                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
                else
                {
                    CharacterObject.MagicTradition.ResetTradition();
                    await cboTradition.DoThreadSafeAsync(
                        x => x.SelectedValue = CharacterObject.MagicTradition.SourceID, GenericToken);
                }

                await cboDrain.DoThreadSafeAsync(x => x.Visible
                                                     = (!CharacterObject.AdeptEnabled
                                                        || CharacterObject.MagicianEnabled) &&
                                                       CharacterObject.MagicTradition.CanChooseDrainAttribute, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
            finally
            {
                SkipUpdate = false;
            }
        }

        #endregion Additional Spells and Spirits Tab Control Events

        #region Additional Sprites and Complex Forms Tab Control Events

        private async void treComplexForms_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedComplexForm();
        }

        private async void cboStream_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing || CharacterObject.MagicTradition.Type != TraditionType.MAG)
                return;
            string strSelectedId = await cboStream.DoThreadSafeFuncAsync(x => x.SelectedValue?.ToString());
            if (string.IsNullOrEmpty(strSelectedId) || strSelectedId == CharacterObject.MagicTradition.SourceIDString)
                return;

            XmlNode xmlNewStreamNode = (await CharacterObject.LoadDataAsync("streams.xml")).SelectSingleNode("/chummer/traditions/tradition[id = " + strSelectedId.CleanXPath() + ']');
            if (xmlNewStreamNode != null && CharacterObject.MagicTradition.Create(xmlNewStreamNode, true))
            {
                await RequestCharacterUpdate();
                await SetDirty(true);
            }
            else
            {
                if (CharacterObject.MagicTradition.Type == TraditionType.RES)
                {
                    CharacterObject.MagicTradition.ResetTradition();
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
                await cboStream.DoThreadSafeAsync(x => x.SelectedValue = CharacterObject.MagicTradition.SourceID);
            }
        }

        #endregion Additional Sprites and Complex Forms Tab Control Events

        #region Additional Initiation Tab Control Events

        private void chkInitiationGroup_EnabledChanged(object sender, EventArgs e)
        {
            if (!chkInitiationGroup.Enabled)
            {
                chkInitiationGroup.Checked = false;
            }
        }

        private void chkInitiationSchooling_EnabledChanged(object sender, EventArgs e)
        {
            if (!chkInitiationSchooling.Enabled)
            {
                chkInitiationSchooling.Checked = false;
            }
        }

        private void treComplexForms_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteComplexForm_Click(sender, e);
            }
        }

        private async void treMetamagic_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedMetamagic();
        }

        private async Task RefreshSelectedMetamagic(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!CharacterObject.InitiationEnabled)
                return;
            IsRefreshing = true;
            try
            {
                string strText;
                switch (await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token))
                {
                    case Metamagic objMetamagic:
                        {
                            strText = await LanguageManager.GetStringAsync(
                                objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic
                                    ? "Button_RemoveMetamagic"
                                    : "Button_RemoveEcho");
                            await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Enabled = objMetamagic.Grade >= 0;
                            }, token);
                            await objMetamagic.SetSourceDetailAsync(lblMetamagicSource, token);
                            break;
                        }
                    case Art objArt:
                        {
                            strText = await LanguageManager.GetStringAsync(
                                objArt.SourceType == Improvement.ImprovementSource.Metamagic
                                    ? "Button_RemoveMetamagic"
                                    : "Button_RemoveEcho");
                            await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Enabled = objArt.Grade >= 0;
                            }, token);
                            await objArt.SetSourceDetailAsync(lblMetamagicSource, token);
                            break;
                        }
                    case Spell objSpell:
                        {
                            strText = await LanguageManager.GetStringAsync("Button_RemoveMetamagic");
                            await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Enabled = objSpell.Grade >= 0;
                            }, token);
                            await objSpell.SetSourceDetailAsync(lblMetamagicSource, token);
                            break;
                        }
                    case ComplexForm objComplexForm:
                        {
                            strText = await LanguageManager.GetStringAsync("Button_RemoveEcho");
                            await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Enabled = objComplexForm.Grade >= 0;
                            }, token);
                            await objComplexForm.SetSourceDetailAsync(lblMetamagicSource, token);
                            break;
                        }
                    case Enhancement objEnhancement:
                        {
                            strText = await LanguageManager.GetStringAsync(
                                objEnhancement.SourceType == Improvement.ImprovementSource.Metamagic
                                    ? "Button_RemoveMetamagic"
                                    : "Button_RemoveEcho");
                            await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Enabled = objEnhancement.Grade >= 0;
                            }, token);
                            await objEnhancement.SetSourceDetailAsync(lblMetamagicSource, token);
                            break;
                        }
                    default:
                        {
                            strText = await LanguageManager.GetStringAsync(
                                CharacterObject.MAGEnabled
                                    ? "Button_RemoveInitiateGrade"
                                    : "Button_RemoveSubmersionGrade");
                            await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Enabled = true;
                            }, token);
                            await SourceString.Blank.SetControlAsync(lblMetamagicSource, token);
                            break;
                        }
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void chkJoinGroup_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || IsLoading || await chkJoinGroup.DoThreadSafeFuncAsync(x => x.Checked) == CharacterObject.GroupMember)
                return;

            // Joining a Network does not cost Karma for Technomancers, so this only applies to Magicians/Adepts.
            if (CharacterObject.MAGEnabled)
            {
                if (await chkJoinGroup.DoThreadSafeFuncAsync(x => x.Checked))
                {
                    int intKarmaExpense = CharacterObjectSettings.KarmaJoinGroup;

                    if (intKarmaExpense > CharacterObject.Karma)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        IsRefreshing = true;
                        try
                        {
                            await chkJoinGroup.DoThreadSafeAsync(x => x.Checked = false);
                        }
                        finally
                        {
                            IsRefreshing = false;
                        }
                        return;
                    }

                    string strMessage;
                    string strExpense;
                    if (CharacterObject.MAGEnabled)
                    {
                        strMessage = await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseJoinGroup");
                        strExpense = await LanguageManager.GetStringAsync("String_ExpenseJoinGroup");
                    }
                    else
                    {
                        strMessage = await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseJoinNetwork");
                        strExpense = await LanguageManager.GetStringAsync("String_ExpenseJoinNetwork");
                    }

                    if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, strMessage, intKarmaExpense.ToString(GlobalSettings.CultureInfo))))
                    {
                        IsRefreshing = true;
                        try
                        {
                            await chkJoinGroup.DoThreadSafeAsync(x => x.Checked = false);
                        }
                        finally
                        {
                            IsRefreshing = false;
                        }
                        return;
                    }

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(intKarmaExpense * -1, strExpense, ExpenseType.Karma, DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                    CharacterObject.Karma -= intKarmaExpense;

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.JoinGroup, string.Empty);
                    objExpense.Undo = objUndo;
                }
                else
                {
                    int intKarmaExpense = CharacterObjectSettings.KarmaLeaveGroup;

                    if (intKarmaExpense > CharacterObject.Karma)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                        IsRefreshing = true;
                        try
                        {
                            await chkJoinGroup.DoThreadSafeAsync(x => x.Checked = true);
                        }
                        finally
                        {
                            IsRefreshing = false;
                        }
                        return;
                    }

                    string strMessage;
                    string strExpense;
                    if (CharacterObject.MAGEnabled)
                    {
                        strMessage = await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseLeaveGroup");
                        strExpense = await LanguageManager.GetStringAsync("String_ExpenseLeaveGroup");
                    }
                    else
                    {
                        strMessage = await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseLeaveNetwork");
                        strExpense = await LanguageManager.GetStringAsync("String_ExpenseLeaveNetwork");
                    }

                    if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, strMessage, intKarmaExpense.ToString(GlobalSettings.CultureInfo))))
                    {
                        IsRefreshing = true;
                        try
                        {
                            await chkJoinGroup.DoThreadSafeAsync(x => x.Checked = true);
                        }
                        finally
                        {
                            IsRefreshing = false;
                        }
                        return;
                    }

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(intKarmaExpense * -1, strExpense, ExpenseType.Karma, DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                    CharacterObject.Karma -= intKarmaExpense;

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.LeaveGroup, string.Empty);
                    objExpense.Undo = objUndo;
                }
            }

            //TODO: If using a databinding for GroupMember, changing Karma here causes chkJoinGroup to revert to false. Unclear why, lazy fix to resolve it for now.
            CharacterObject.GroupMember = chkJoinGroup.Checked;

            if (!await chkJoinGroup.DoThreadSafeFuncAsync(x => x.Enabled))
            {
                await chkInitiationGroup.DoThreadSafeAsync(x => x.Checked = false);
            }
        }

        private void txtNotes_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Control && e.KeyCode == Keys.A)
            {
                e.SuppressKeyPress = true;
                ((TextBox)sender)?.SelectAll();
            }
        }

        #endregion Additional Initiation Tab Control Events

        #region Additional Critter Powers Tab Control Events

        private async void treCritterPowers_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedCritterPower();
        }

        private async Task RefreshSelectedCritterPower(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                // Look for the selected Critter Power.
                if (await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is CritterPower objPower)
                {
                    await cmdDeleteCritterPower.DoThreadSafeAsync(x => x.Enabled = objPower.Grade == 0, token);
                    await lblCritterPowerName.DoThreadSafeAsync(x => x.Text = objPower.CurrentDisplayName, token);
                    string strText = await objPower.DisplayCategoryAsync(GlobalSettings.Language);
                    await lblCritterPowerCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objPower.DisplayTypeAsync(GlobalSettings.Language);
                    await lblCritterPowerType.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objPower.DisplayActionAsync(GlobalSettings.Language);
                    await lblCritterPowerAction.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objPower.DisplayRangeAsync(GlobalSettings.Language);
                    await lblCritterPowerRange.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objPower.DisplayDurationAsync(GlobalSettings.Language);
                    await lblCritterPowerDuration.DoThreadSafeAsync(x => x.Text = strText, token);
                    await chkCritterPowerCount.DoThreadSafeAsync(x => x.Checked = objPower.CountTowardsLimit, token);
                    await objPower.SetSourceDetailAsync(lblCritterPowerSource, token);
                    if (objPower.PowerPoints > 0)
                    {
                        await lblCritterPowerPointCost.DoThreadSafeAsync(x =>
                        {
                            x.Text = objPower.PowerPoints.ToString(GlobalSettings
                                                                       .CultureInfo);
                            x.Visible = true;
                        }, token);
                        await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    }
                    else
                    {
                        await lblCritterPowerPointCost.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    }
                }
                else
                {
                    await cmdDeleteCritterPower.DoThreadSafeAsync(x => x.Enabled = false, token);
                    await lblCritterPowerName.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblCritterPowerCategory.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblCritterPowerType.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblCritterPowerAction.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblCritterPowerRange.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblCritterPowerDuration.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await chkCritterPowerCount.DoThreadSafeAsync(x => x.Checked = false, token);
                    await SourceString.Blank.SetControlAsync(lblCritterPowerSource, token);
                    await lblCritterPowerPointCost.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void chkCritterPowerCount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            // Locate the selected Critter Power.
            if (!(await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is CritterPower objPower))
                return;
            objPower.CountTowardsLimit = await chkCritterPowerCount.DoThreadSafeFuncAsync(x => x.Checked);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        #endregion Additional Critter Powers Tab Control Events

        #region Additional Karma and Nuyen Tab Control Events

        private async void lstKarma_DoubleClick(object sender, EventArgs e)
        {
            ListViewItem objItem = await lstKarma.DoThreadSafeFuncAsync(x => x.SelectedItems.Count > 0 ? lstKarma.SelectedItems[0] : null);
            if (objItem == null)
            {
                return;
            }

            // Find the selected Karma Expense.
            ExpenseLogEntry objExpense = (objItem.SubItems[3] as ListViewItemWithValue.ListViewSubItemWithValue)?.Value as ExpenseLogEntry
                                         ?? new ExpenseLogEntry(CharacterObject);

            // If this is a manual entry, let the player modify the amount.
            int intOldAmount = objExpense.Amount.ToInt32();
            bool blnAllowEdit = objExpense.Undo != null && (objExpense.Undo.KarmaType == KarmaExpenseType.ManualAdd ||
                                                            objExpense.Undo.KarmaType ==
                                                            KarmaExpenseType.ManualSubtract);

            bool blnDoRepopulateList;
            using (ThreadSafeForm<CreateExpense> frmEditExpense = await ThreadSafeForm<CreateExpense>.GetAsync(
                       () => new CreateExpense(CharacterObjectSettings)
                       {
                           Reason = objExpense.Reason,
                           Amount = objExpense.Amount,
                           Refund = objExpense.Refund,
                           SelectedDate = objExpense.Date,
                           ForceCareerVisible = objExpense.ForceCareerVisible
                       }))
            {
                frmEditExpense.MyForm.LockFields(blnAllowEdit);

                if (await frmEditExpense.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // If this is a manual entry, update the character's Karma total.
                int intNewAmount = frmEditExpense.MyForm.Amount.ToInt32();
                if (blnAllowEdit && intOldAmount != intNewAmount)
                {
                    objExpense.Amount = intNewAmount;
                    CharacterObject.Karma += intNewAmount - intOldAmount;
                    blnDoRepopulateList = true;
                }
                else
                    blnDoRepopulateList = intNewAmount != 0 || await chkShowFreeKarma.DoThreadSafeFuncAsync(x => x.Checked);

                // Rename the Expense.
                objExpense.Reason = frmEditExpense.MyForm.Reason;
                objExpense.Date = frmEditExpense.MyForm.SelectedDate;
            }

            if (blnDoRepopulateList)
                await RepopulateKarmaExpenseList();

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void lstNuyen_DoubleClick(object sender, EventArgs e)
        {
            ListViewItem objItem = await lstNuyen.DoThreadSafeFuncAsync(x => x.SelectedItems.Count > 0 ? lstNuyen.SelectedItems[0] : null);
            if (objItem == null)
            {
                return;
            }

            // Find the selected Nuyen Expense.
            ExpenseLogEntry objExpense = (objItem.SubItems[3] as ListViewItemWithValue.ListViewSubItemWithValue)?.Value as ExpenseLogEntry
                                         ?? new ExpenseLogEntry(CharacterObject);

            // If this is a manual entry, let the player modify the amount.
            decimal decOldAmount = objExpense.Amount;
            bool blnAllowEdit = objExpense.Undo != null && (objExpense.Undo.NuyenType == NuyenExpenseType.ManualAdd ||
                                                            objExpense.Undo.NuyenType ==
                                                            NuyenExpenseType.ManualSubtract);

            bool blnDoRepopulateList;
            using (ThreadSafeForm<CreateExpense> frmEditExpense = await ThreadSafeForm<CreateExpense>.GetAsync(
                       () => new CreateExpense(CharacterObjectSettings)
                       {
                           Mode = ExpenseType.Nuyen,
                           Reason = objExpense.Reason,
                           Amount = objExpense.Amount,
                           Refund = objExpense.Refund,
                           SelectedDate = objExpense.Date,
                           ForceCareerVisible = objExpense.ForceCareerVisible
                       }))
            {
                frmEditExpense.MyForm.LockFields(blnAllowEdit);

                if (await frmEditExpense.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // If this is a manual entry, update the character's Karma total.
                decimal decNewAmount = frmEditExpense.MyForm.Amount;
                if (blnAllowEdit && decOldAmount != decNewAmount)
                {
                    objExpense.Amount = decNewAmount;
                    CharacterObject.Nuyen += decNewAmount - decOldAmount;
                    blnDoRepopulateList = true;
                }
                else
                    blnDoRepopulateList = decNewAmount != 0 || await chkShowFreeNuyen.DoThreadSafeFuncAsync(x => x.Checked);

                // Rename the Expense.
                objExpense.Reason = frmEditExpense.MyForm.Reason;
                objExpense.Date = frmEditExpense.MyForm.SelectedDate;
            }

            if (blnDoRepopulateList)
                await RepopulateNuyenExpenseList();

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private void lstKarma_ColumnClick(object sender, ColumnClickEventArgs e)
        {
            if (e.Column == _lvwKarmaColumnSorter.SortColumn)
            {
                _lvwKarmaColumnSorter.Order = _lvwKarmaColumnSorter.Order == SortOrder.Ascending ? SortOrder.Descending : SortOrder.Ascending;
            }
            else
            {
                _lvwKarmaColumnSorter.SortColumn = e.Column;
                _lvwKarmaColumnSorter.Order = SortOrder.Ascending;
            }
            lstKarma.Sort();
        }

        private void lstNuyen_ColumnClick(object sender, ColumnClickEventArgs e)
        {
            if (e.Column == _lvwNuyenColumnSorter.SortColumn)
            {
                _lvwNuyenColumnSorter.Order = _lvwNuyenColumnSorter.Order == SortOrder.Ascending ? SortOrder.Descending : SortOrder.Ascending;
            }
            else
            {
                _lvwNuyenColumnSorter.SortColumn = e.Column;
                _lvwNuyenColumnSorter.Order = SortOrder.Ascending;
            }
            lstNuyen.Sort();
        }

        #endregion Additional Karma and Nuyen Tab Control Events

        #region Additional Improvements Tab Control Events

        private async void treImprovements_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedImprovement();
        }

        private async Task RefreshSelectedImprovement(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                if (await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is Improvement objImprovement)
                {
                    // Get the human-readable name of the Improvement from the Improvements file.
                    XmlNode objNode = (await CharacterObject.LoadDataAsync("improvements.xml", token: token))
                                                     .SelectSingleNode(
                                                         "/chummer/improvements/improvement[id = "
                                                         + objImprovement.CustomId.CleanXPath() + ']');
                    if (objNode != null)
                    {
                        await lblImprovementType.DoThreadSafeAsync(x => x.Text = objNode["translate"]?.InnerText ?? objNode["name"]?.InnerText, token);
                    }
                    token.ThrowIfCancellationRequested();
                    string strSpace = await LanguageManager.GetStringAsync("String_Space");
                    // Build a string that contains the value(s) of the Improvement.
                    string strValue = string.Empty;
                    if (objImprovement.Value != 0)
                        strValue += await LanguageManager.GetStringAsync("Label_CreateImprovementValue") + strSpace
                            + objImprovement.Value.ToString(GlobalSettings.CultureInfo) + ',' + strSpace;
                    if (objImprovement.Minimum != 0)
                        strValue += await LanguageManager.GetStringAsync("Label_CreateImprovementMinimum") + strSpace
                            + objImprovement.Minimum.ToString(GlobalSettings.CultureInfo) + ',' + strSpace;
                    if (objImprovement.Maximum != 0)
                        strValue += await LanguageManager.GetStringAsync("Label_CreateImprovementMaximum") + strSpace
                            + objImprovement.Maximum.ToString(GlobalSettings.CultureInfo) + ',' + strSpace;
                    if (objImprovement.Augmented != 0)
                        strValue += await LanguageManager.GetStringAsync("Label_CreateImprovementAugmented") + strSpace
                            + objImprovement.Augmented.ToString(GlobalSettings.CultureInfo) + ',' + strSpace;
                    token.ThrowIfCancellationRequested();
                    // Remove the trailing comma.
                    if (!string.IsNullOrEmpty(strValue))
                        strValue = strValue.Substring(0, strValue.Length - 1 - strSpace.Length);
                    await cmdImprovementsEnableAll.DoThreadSafeAsync(x => x.Visible = false, token);
                    await cmdImprovementsDisableAll.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblImprovementValue.DoThreadSafeAsync(x => x.Text = strValue, token);
                    await chkImprovementActive.DoThreadSafeAsync(x =>
                    {
                        x.Checked = objImprovement.Enabled;
                        x.Visible = true;
                    }, token);
                }
                else if (await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Level, token) == 0)
                {
                    await cmdImprovementsEnableAll.DoThreadSafeAsync(x => x.Visible = true, token);
                    await cmdImprovementsDisableAll.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblImprovementType.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblImprovementValue.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await chkImprovementActive.DoThreadSafeAsync(x =>
                    {
                        x.Checked = false;
                        x.Visible = false;
                    }, token);
                }
                else
                {
                    await cmdImprovementsEnableAll.DoThreadSafeAsync(x => x.Visible = false, token);
                    await cmdImprovementsDisableAll.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblImprovementType.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblImprovementValue.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await chkImprovementActive.DoThreadSafeAsync(x =>
                    {
                        x.Checked = false;
                        x.Visible = false;
                    }, token);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void treImprovements_DoubleClick(object sender, EventArgs e)
        {
            if (await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Improvement)
            {
                await DoEditImprovement();
            }
            else
            {
                await DoAddImprovement();
            }
        }

        private async void chkImprovementActive_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            if (!(await treImprovements.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Improvement objImprovement))
                return;
            if (await chkImprovementActive.DoThreadSafeFuncAsync(x => x.Checked))
                ImprovementManager.EnableImprovements(CharacterObject, objImprovement);
            else
                ImprovementManager.DisableImprovements(CharacterObject, objImprovement);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private void treImprovements_ItemDrag(object sender, ItemDragEventArgs e)
        {
            // Do not allow the root element to be moved.
            if (treImprovements.SelectedNode == null || treImprovements.SelectedNode.Tag.ToString() == "Node_SelectedImprovements")
                return;
            _intDragLevel = treImprovements.SelectedNode.Level;
            DoDragDrop(e.Item, DragDropEffects.Move);
        }

        private void treImprovements_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private async void treImprovements_DragDrop(object sender, DragEventArgs e)
        {
            try
            {
                await DoTreeDragDrop(sender, e, treImprovements, ItemTreeViewTypes.Improvements, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treImprovements_DragOver(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = ((TreeView)sender).GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (objNode.Level <= _intDragLevel)
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background color for all other Nodes.
            treImprovements.ClearNodeBackground(objNode);
        }

        private async void cmdAddImprovementGroup_Click(object sender, EventArgs e)
        {
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            // Add a new location to the Improvements Tree.
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                string strLocation = frmPickText.MyForm.SelectedValue;

                if (string.IsNullOrEmpty(strLocation))
                    return;

                await CharacterObject.ImprovementGroups.AddAsync(strLocation);
            }

            await SetDirty(true);
        }

        #endregion Additional Improvements Tab Control Events

        #region Tree KeyDown Events

        private async void treQualities_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                await DoDeleteQuality();
            }
        }

        private void treSpells_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteSpell_Click(sender, e);
            }
        }

        private void treCyberware_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteCyberware_Click(sender, e);
            }
        }

        private void treLifestyles_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteLifestyle_Click(sender, e);
            }
        }

        private void treArmor_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteArmor_Click(sender, e);
            }
        }

        private void treWeapons_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteWeapon_Click(sender, e);
            }
        }

        private void treGear_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteGear_Click(sender, e);
            }
        }

        private async void treVehicles_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                await DoDeleteVehicle();
            }
        }

        private void treMartialArts_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteMartialArt_Click(sender, e);
            }
        }

        private void treCritterPowers_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteCritterPower_Click(sender, e);
            }
        }

        private void treMetamagic_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteMetamagic_Click(sender, e);
            }
        }

        private async void treImprovements_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                await DoDeleteImprovement();
            }
        }

        #endregion Tree KeyDown Events

        #region Additional Drug Tab Control Events

        private async void treCustomDrugs_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedDrug();
        }

        #endregion Additional Drug Tab Control Events

        #region Splitter Resize Events

        private void splitKarmaNuyen_Panel1_Resize(object sender, EventArgs e)
        {
            if (lstKarma.Columns.Count >= 2 && lstKarma.Width > 409)
            {
                lstKarma.Columns[2].Width = lstKarma.Width - 195;
            }
        }

        private void splitKarmaNuyen_Panel2_Resize(object sender, EventArgs e)
        {
            if (lstNuyen.Columns.Count >= 2 && lstNuyen.Width > 409)
            {
                lstNuyen.Columns[2].Width = lstNuyen.Width - 195;
            }
        }

        #endregion Splitter Resize Events

        #region Other Control Events

        private async void cmdEdgeSpent_Click(object sender, EventArgs e)
        {
            if (CharacterObject.EdgeUsed >= CharacterObject.EDG.TotalValue)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotSpendEdge"),
                    await LanguageManager.GetStringAsync("MessageTitle_CannotSpendEdge"), MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
                return;
            }

            ++CharacterObject.EdgeUsed;

            await SetDirty(true);
        }

        private async void cmdEdgeGained_Click(object sender, EventArgs e)
        {
            if (CharacterObject.EdgeUsed <= 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotRegainEdge"),
                    await LanguageManager.GetStringAsync("MessageTitle_CannotRegainEdge"), MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
                return;
            }

            --CharacterObject.EdgeUsed;

            await SetDirty(true);
        }

        private async void tabCharacterTabs_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tabStreetGearTabs_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private enum CmdOperation { None, Up, Down }

        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            CmdOperation op = CmdOperation.None;

            // Determine which custom operation we're attempting, if any
            switch (keyData)
            {
                case Keys.Up | Keys.Alt:
                    op = CmdOperation.Up;
                    break;

                case Keys.Down | Keys.Alt:
                    op = CmdOperation.Down;
                    break;
            }

            bool up = op == CmdOperation.Up;
            if (up || op == CmdOperation.Down)
            {
                bool requireParentSortable = false;
                TreeView treActiveView = null;

                if (tabCharacterTabs.SelectedTab == tabStreetGear)
                {
                    // Lifestyle Tab.
                    if (tabStreetGearTabs.SelectedTab == tabLifestyle)
                    {
                        treActiveView = treLifestyles;
                    }
                    // Armor Tab.
                    else if (tabStreetGearTabs.SelectedTab == tabArmor)
                    {
                        treActiveView = treArmor;
                    }
                    // Weapons Tab.
                    else if (tabStreetGearTabs.SelectedTab == tabWeapons)
                    {
                        treActiveView = treWeapons;
                    }
                    // Gear Tab.
                    else if (tabStreetGearTabs.SelectedTab == tabGear)
                    {
                        treActiveView = treGear;
                    }
                    // Drugs Tab.
                    else if (tabStreetGearTabs.SelectedTab == tabDrugs)
                    {
                        treActiveView = treCustomDrugs;
                    }
                }
                // Cyberware Tab.
                else if (tabCharacterTabs.SelectedTab == tabCyberware)
                {
                    // Top-level cyberware is sorted alphabetically, but we can re-arrange any plugins/gear inside them
                    requireParentSortable = true;
                    treActiveView = treCyberware;
                }
                // Vehicles Tab.
                else if (tabCharacterTabs.SelectedTab == tabVehicles)
                {
                    treActiveView = treVehicles;
                }
                // Critter Powers Tab.
                else if (tabCharacterTabs.SelectedTab == tabCritter)
                {
                    treActiveView = treCritterPowers;
                }
                // Improvements Tab.
                else if (tabCharacterTabs.SelectedTab == tabImprovements)
                {
                    treActiveView = treImprovements;
                }

                if (treActiveView != null)
                {
                    TreeNode objSelectedNode = treActiveView.SelectedNode;
                    TreeNode objParentNode = objSelectedNode?.Parent;

                    if (!requireParentSortable || objParentNode?.Tag is ICanSort)
                    {
                        TreeNodeCollection lstNodes = objParentNode?.Nodes ?? treActiveView.Nodes;
                        int intNewIndex = lstNodes.IndexOf(objSelectedNode);
                        intNewIndex = up ? Math.Max(0, intNewIndex - 1) : Math.Min(lstNodes.Count - 1, intNewIndex + 1);

                        Utils.RunWithoutThreadLock(() => MoveTreeNode(objSelectedNode, intNewIndex));
                    }
                }

                // Returning true tells the program to consume the input
                return true;
            }

            // If none of our key combinations are used then use the default logic
            return base.ProcessCmdKey(ref msg, keyData);
        }

        #endregion Other Control Events

        #region Condition Monitors

        private async void chkPhysicalCM_CheckedChanged(object sender, EventArgs e)
        {
            if (sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                await ProcessConditionMonitorCheckedChanged(objBox, i => CharacterObject.PhysicalCMFilled = i);
        }

        private async void chkStunCM_CheckedChanged(object sender, EventArgs e)
        {
            if (sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                await ProcessConditionMonitorCheckedChanged(objBox, i => CharacterObject.StunCMFilled = i);
        }

        /// <summary>
        /// Manages the rendering of condition monitor checkboxes for characters that can have modifiers like overflow and threshold offsets.
        /// </summary>
        /// <param name="pnlConditionMonitorPanel">Container panel for the condition monitor checkboxes.</param>
        /// <param name="intConditionMax">Highest value of the condition monitor type.</param>
        /// <param name="intThreshold">Show an increase in modifiers every <paramref name="intThreshold"/> boxes.</param>
        /// <param name="intThresholdOffset">Initial threshold for penalties from <paramref name="intThreshold"/> should be offset by this much.</param>
        /// <param name="intOverflow">Number of overflow boxes to show (set to 0 if none, like for the stun condition monitor).</param>
        /// <param name="button_Click">Event handler for when a CM box is clicked</param>
        /// <param name="check">Whether or not to check the checkbox when finished processing. Expected to only be called on load.</param>
        /// <param name="value">Tag value of the checkbox to enable when using the check parameter. Expected to be the StunCMFilled or PhysicalCMFilled properties.</param>
        /// <param name="token">Cancellation token to use.</param>
        private async ValueTask ProcessCharacterConditionMonitorBoxDisplays(Control pnlConditionMonitorPanel, int intConditionMax, int intThreshold, int intThresholdOffset, int intOverflow, EventHandler button_Click, bool check = false, int value = 0, CancellationToken token = default)
        {
            await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                if (intConditionMax > 0)
                {
                    await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.Visible = true, token);
                    List<DpiFriendlyCheckBoxDisguisedAsButton> lstCheckBoxes = await pnlConditionMonitorPanel.DoThreadSafeFuncAsync(x => x.Controls
                        .OfType<DpiFriendlyCheckBoxDisguisedAsButton>().ToList(), token);
                    if (lstCheckBoxes.Count < intConditionMax + intOverflow)
                    {
                        int intMax = 0;
                        DpiFriendlyCheckBoxDisguisedAsButton objMaxCheckBox = null;
                        foreach (DpiFriendlyCheckBoxDisguisedAsButton objLoopCheckBox in lstCheckBoxes)
                        {
                            int intLoop = Convert.ToInt32(await objLoopCheckBox.DoThreadSafeFuncAsync(x => x.Tag, token), GlobalSettings.InvariantCultureInfo);
                            if (objMaxCheckBox == null || intMax < intLoop)
                            {
                                intMax = intLoop;
                                objMaxCheckBox = objLoopCheckBox;
                            }
                        }

                        if (objMaxCheckBox != null)
                        {
                            await pnlConditionMonitorPanel.DoThreadSafeAsync(x =>
                            {
                                for (int i = intMax + 1; i <= intConditionMax + intOverflow; i++)
                                {
                                    DpiFriendlyCheckBoxDisguisedAsButton cb
                                        = new DpiFriendlyCheckBoxDisguisedAsButton(components)
                                        {
                                            Tag = i,
                                            Appearance = objMaxCheckBox.Appearance,
                                            AutoSize = objMaxCheckBox.AutoSize,
                                            MinimumSize = objMaxCheckBox.MinimumSize,
                                            Size = objMaxCheckBox.Size,
                                            Padding = objMaxCheckBox.Padding,
                                            Margin = objMaxCheckBox.Margin,
                                            TextAlign = objMaxCheckBox.TextAlign,
                                            Font = objMaxCheckBox.Font,
                                            FlatStyle = objMaxCheckBox.FlatStyle,
                                            UseVisualStyleBackColor = objMaxCheckBox.UseVisualStyleBackColor
                                        };
                                    cb.Click += button_Click;
                                    x.Controls.Add(cb);
                                    lstCheckBoxes.Add(cb);
                                }
                            }, token);
                        }
                    }

                    int intMaxDimension = 0;
                    int intMaxMargin = 0;
                    foreach (DpiFriendlyCheckBoxDisguisedAsButton chkCmBox in lstCheckBoxes)
                    {
                        int intCurrentBoxTag = Convert.ToInt32(await chkCmBox.DoThreadSafeFuncAsync(x => x.Tag, token), GlobalSettings.InvariantCultureInfo);
                        await chkCmBox.DoThreadSafeAsync(x => x.BackColor
                                                             = SystemColors
                                                                 .Control, token); // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                        if (check && intCurrentBoxTag <= value)
                        {
                            await chkCmBox.DoThreadSafeAsync(x => x.Checked = true, token);
                        }

                        if (intCurrentBoxTag <= intConditionMax)
                        {
                            await chkCmBox.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.ImageDpi96 = null;
                                x.ImageDpi192 = null;
                                if (intCurrentBoxTag > intThresholdOffset
                                    && (intCurrentBoxTag - intThresholdOffset) % intThreshold == 0)
                                {
                                    int intModifiers = (intThresholdOffset - intCurrentBoxTag) / intThreshold;
                                    x.Text = intModifiers.ToString(GlobalSettings.CultureInfo);
                                }
                                else
                                    x.Text = " "; // Non-breaking space to help with DPI stuff
                            }, token);
                        }
                        else if (intOverflow != 0 && intCurrentBoxTag <= intConditionMax + intOverflow)
                        {
                            await chkCmBox.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.BackColor
                                    = SystemColors
                                        .ControlDark; // Condition Monitor checkboxes shouldn't get colored based on Dark Mode
                                if (intCurrentBoxTag == intConditionMax + intOverflow)
                                {
                                    x.ImageDpi96 = Properties.Resources.rip;
                                    x.ImageDpi192 = Properties.Resources.rip1;
                                }
                                else
                                {
                                    x.ImageDpi96 = null;
                                    x.ImageDpi192 = null;
                                }
                            }, token);
                        }
                        else
                        {
                            await chkCmBox.DoThreadSafeAsync(x =>
                            {
                                x.Visible = false;
                                x.ImageDpi96 = null;
                                x.ImageDpi192 = null;
                                x.Text = " "; // Non-breaking space to help with DPI stuff
                            }, token);
                        }

                        intMaxDimension = Math.Max(intMaxDimension,
                                                   Math.Max(await chkCmBox.DoThreadSafeFuncAsync(x => x.Width, token),
                                                            await chkCmBox.DoThreadSafeFuncAsync(x => x.Height, token)));
                        Padding objMargin = await chkCmBox.DoThreadSafeFuncAsync(x => x.Margin, token);
                        intMaxMargin = Math.Max(intMaxMargin,
                                                Math.Max(Math.Max(objMargin.Left, objMargin.Right),
                                                         Math.Max(objMargin.Top, objMargin.Bottom)));
                    }

                    Size objSquareSize = new Size(intMaxDimension, intMaxDimension);
                    Padding objSquarePadding = new Padding(intMaxMargin);
                    foreach (DpiFriendlyCheckBoxDisguisedAsButton chkCmBox in lstCheckBoxes)
                    {
                        await chkCmBox.DoThreadSafeAsync(x =>
                        {
                            x.MinimumSize = objSquareSize;
                            x.Margin = objSquarePadding;
                        }, token);
                    }

                    await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.MaximumSize = new Size(
                                                                         (2 * intThreshold + 1) * (intMaxDimension + intMaxMargin) / 2,
                                                                         x.MaximumSize
                                                                          .Height), token); // Width slightly longer to give enough wiggle room to take care of any funny business
                }
                else
                {
                    await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.Visible = false, token);
                }
            }
            finally
            {
                await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.ResumeLayout(), token);
            }
        }

        /// <summary>
        /// Manages the rendering of condition monitor checkboxes for characters that can have modifiers like overflow and threshold offsets.
        /// </summary>
        /// <param name="pnlConditionMonitorPanel">Container panel for the condition monitor checkboxes.</param>
        /// <param name="intConditionMax">Highest value of the condition monitor type.</param>
        /// <param name="intCurrentConditionFilled">Current amount of boxes that should be filled in the condition monitor.</param>
        /// <param name="token">Cancellation token to use.</param>
        private async ValueTask ProcessEquipmentConditionMonitorBoxDisplays(Control pnlConditionMonitorPanel, int intConditionMax, int intCurrentConditionFilled, CancellationToken token = default)
        {
            IsRefreshing = true;
            await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                if (intConditionMax > 0)
                {
                    await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.Visible = true, token);
                    foreach (DpiFriendlyCheckBoxDisguisedAsButton chkCmBox in await pnlConditionMonitorPanel.DoThreadSafeFuncAsync(x => x.Controls
                                 .OfType<DpiFriendlyCheckBoxDisguisedAsButton>(), token))
                    {
                        int intCurrentBoxTag = Convert.ToInt32(await chkCmBox.DoThreadSafeFuncAsync(x => x.Tag, token), GlobalSettings.InvariantCultureInfo);

                        await chkCmBox.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                        if (intCurrentBoxTag <= intConditionMax)
                        {
                            await chkCmBox.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = intCurrentBoxTag <= intCurrentConditionFilled;
                            }, token);
                        }
                        else
                        {
                            await chkCmBox.DoThreadSafeAsync(x =>
                            {
                                x.Visible = false;
                                x.Checked = false;
                            }, token);
                        }
                    }
                }
                else
                {
                    await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.Visible = false, token);
                }
            }
            finally
            {
                await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Changes which boxes are filled and unfilled in a condition monitor when a box in that condition monitor is clicked.
        /// </summary>
        /// <param name="chkSender">Checkbox we're currently changing.</param>
        /// <param name="blnDoUIUpdate">Whether to update all the other boxes in the UI or not. If something like ProcessEquipmentConditionMonitorBoxDisplays would be called later, this can be false.</param>
        /// <param name="funcPropertyToUpdate">Function to run once the condition monitor has been processed, probably a property setter. Uses the amount of filled boxes as its argument.</param>
        /// <param name="token">Cancellation token to use.</param>
        private async ValueTask ProcessConditionMonitorCheckedChanged(DpiFriendlyCheckBoxDisguisedAsButton chkSender, Action<int> funcPropertyToUpdate = null, bool blnDoUIUpdate = true, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (IsRefreshing)
                return;

            if (blnDoUIUpdate)
            {
                Control pnlConditionMonitorPanel = await chkSender.DoThreadSafeFuncAsync(x => x.Parent, token);

                if (pnlConditionMonitorPanel == null)
                    return;

                int intBoxTag = Convert.ToInt32(await chkSender.DoThreadSafeFuncAsync(x => x.Tag, token), GlobalSettings.InvariantCultureInfo);

                int intFillCount = await chkSender.DoThreadSafeFuncAsync(x => x.Checked, token) ? 1 : 0;

                // If this is being checked, make sure everything before it is checked off.
                IsRefreshing = true;
                await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.SuspendLayout(), token);
                try
                {
                    foreach (DpiFriendlyCheckBoxDisguisedAsButton chkCmBox in await pnlConditionMonitorPanel.DoThreadSafeFuncAsync(x => x.Controls
                                 .OfType<DpiFriendlyCheckBoxDisguisedAsButton>(), token))
                    {
                        if (chkCmBox != chkSender)
                        {
                            int intCurrentBoxTag = Convert.ToInt32(await chkCmBox.DoThreadSafeFuncAsync(x => x.Tag, token), GlobalSettings.InvariantCultureInfo);
                            if (intCurrentBoxTag < intBoxTag)
                            {
                                await chkCmBox.DoThreadSafeAsync(x => x.Checked = true, token);
                                ++intFillCount;
                            }
                            else if (intCurrentBoxTag > intBoxTag)
                            {
                                await chkCmBox.DoThreadSafeAsync(x => x.Checked = false, token);
                            }
                        }
                    }
                }
                finally
                {
                    await pnlConditionMonitorPanel.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                    IsRefreshing = false;
                    funcPropertyToUpdate?.Invoke(intFillCount);
                }
            }
            else
            {
                int intFillCount = Convert.ToInt32(await chkSender.DoThreadSafeFuncAsync(x => x.Tag, token), GlobalSettings.InvariantCultureInfo);
                if (!await chkSender.DoThreadSafeFuncAsync(x => x.Checked, token))
                    --intFillCount;
                funcPropertyToUpdate?.Invoke(intFillCount);
            }

            await SetDirty(true);
        }

        private async void chkCyberwareCM_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            if (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objItem && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                await ProcessConditionMonitorCheckedChanged(objBox, i => objItem.MatrixCMFilled = i, false);
        }

        private async void chkGearCM_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            // Locate the selected Gear.
            TreeNode objGearNode = null;
            await treGear.DoThreadSafeAsync(x =>
            {
                objGearNode = x.SelectedNode;
                while (objGearNode?.Level > 1)
                    objGearNode = objGearNode.Parent;
            });

            if (objGearNode?.Tag is Gear objGear && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                await ProcessConditionMonitorCheckedChanged(objBox, i => objGear.MatrixCMFilled = i, false);
        }

        private async void chkArmorMatrixCM_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objItem && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                await ProcessConditionMonitorCheckedChanged(objBox, i => objItem.MatrixCMFilled = i, false);
        }

        private async void chkWeaponCM_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objItem && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                await ProcessConditionMonitorCheckedChanged(objBox, i => objItem.MatrixCMFilled = i, false);
        }

        private async void chkVehicleCM_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            if (panVehicleCM.SelectedIndex == 0)
            {
                // Locate the selected Vehicle.
                TreeNode objVehicleNode = null;
                await treVehicles.DoThreadSafeAsync(x =>
                {
                    objVehicleNode = x.SelectedNode;
                    while (objVehicleNode?.Level > 1)
                        objVehicleNode = objVehicleNode.Parent;
                });

                if (objVehicleNode?.Tag is Vehicle objVehicle && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                    await ProcessConditionMonitorCheckedChanged(objBox, i => objVehicle.PhysicalCMFilled = i);
            }
            else if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objItem && sender is DpiFriendlyCheckBoxDisguisedAsButton objBox)
                await ProcessConditionMonitorCheckedChanged(objBox, i => objItem.MatrixCMFilled = i, false);
        }

        #endregion Condition Monitors

        #region Custom Methods

        /// <summary>
        /// Refresh the currently-selected Drug.
        /// </summary>
        private async Task RefreshSelectedDrug(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpDrugs.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                object objSelectedNodeTag = await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token);
                if (objSelectedNodeTag is Drug objDrug && await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode?.Level != 0, token))
                {
                    await flpDrugs.DoThreadSafeAsync(x => x.Visible = true, token);
                    await btnDeleteCustomDrug.DoThreadSafeAsync(x => x.Enabled = true, token);
                    await lblDrugName.DoThreadSafeAsync(x => x.Text = objDrug.Name, token);
                    await lblDrugAvail.DoThreadSafeAsync(x => x.Text = objDrug.DisplayTotalAvail, token);
                    await lblDrugGrade.DoThreadSafeAsync(x => x.Text = objDrug.Grade.CurrentDisplayName, token);
                    await lblDrugCost.DoThreadSafeAsync(x => x.Text
                                                            = objDrug.Cost.ToString(
                                                                  CharacterObject.Settings.NuyenFormat, GlobalSettings.CultureInfo)
                                                              + LanguageManager.GetString("String_NuyenSymbol"), token);
                    await lblDrugQty.DoThreadSafeAsync(x => x.Text = objDrug.Quantity.ToString(GlobalSettings.CultureInfo), token);
                    await btnIncreaseDrugQty.DoThreadSafeAsync(x => x.Enabled = objDrug.Cost <= CharacterObject.Nuyen, token);
                    await btnDecreaseDrugQty.DoThreadSafeAsync(x => x.Enabled = objDrug.Quantity != 0, token);
                    await lblDrugCategory.DoThreadSafeAsync(x => x.Text = objDrug.Category, token);
                    await lblDrugAddictionRating.DoThreadSafeAsync(x => x.Text = objDrug.AddictionRating.ToString(GlobalSettings.CultureInfo), token);
                    await lblDrugAddictionThreshold.DoThreadSafeAsync(x => x.Text = objDrug.AddictionThreshold.ToString(GlobalSettings.CultureInfo), token);
                    string strText = await objDrug.GetEffectDescriptionAsync();
                    await lblDrugEffect.DoThreadSafeAsync(x => x.Text = strText, token);
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdComponents))
                    {
                        foreach (DrugComponent objComponent in objDrug.Components)
                        {
                            sbdComponents.AppendLine(objComponent.CurrentDisplayName);
                        }
                        await lblDrugComponents.DoThreadSafeAsync(x => x.Text = sbdComponents.ToString(), token);
                    }
                }
                else
                {
                    await flpDrugs.DoThreadSafeAsync(x => x.Visible = false, token);
                    await btnDeleteCustomDrug.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                }
            }
            finally
            {
                await flpDrugs.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        private bool _blnFileUpdateQueued;

        protected override async void LiveUpdateFromCharacterFile(object sender, FileSystemEventArgs e)
        {
            if (_blnFileUpdateQueued)
                return;
            _blnFileUpdateQueued = true;
            try
            {
                while (IsDirty || IsLoading || SkipUpdate || IsCharacterUpdateRequested)
                    await Utils.SafeSleepAsync(GenericToken);

                string strCharacterFile = CharacterObject.FileName;
                if (string.IsNullOrEmpty(strCharacterFile) || !File.Exists(strCharacterFile))
                    return;

                // Character is not dirty and their save file was updated outside of Chummer5 while it is open, so reload them
                using (await CursorWait.NewAsync(this, true))
                {
                    using (await CursorWait.NewAsync(this))
                    using (ThreadSafeForm<LoadingBar> frmLoadingBar
                           = await Program.CreateAndShowProgressBarAsync(Path.GetFileName(CharacterObject.FileName),
                                                                         Character.NumLoadingSections + 1))
                    {
                        SkipUpdate = true;
                        try
                        {
                            await CharacterObject.LoadAsync(frmLoadingBar.MyForm);
                            await frmLoadingBar.MyForm.PerformStepAsync(await LanguageManager.GetStringAsync("String_UI"));
                        }
                        finally
                        {
                            SkipUpdate = false;
                        }
                    }

                    await RequestCharacterUpdate();
                    // Immediately await character update because we know it's necessary
                    try
                    {
                        await UpdateCharacterInfoTask;
                    }
                    catch (OperationCanceledException)
                    {
                        return;
                    }

                    IsDirty = false;

                    if (CharacterObject.InternalIdsNeedingReapplyImprovements.Count > 0 && !Utils.IsUnitTest
                        && Program.ShowMessageBox(
                            this, await LanguageManager.GetStringAsync("Message_ImprovementLoadError"),
                            await LanguageManager.GetStringAsync("MessageTitle_ImprovementLoadError"),
                            MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                    {
                        await DoReapplyImprovements(CharacterObject.InternalIdsNeedingReapplyImprovements, GenericToken);
                        await CharacterObject.InternalIdsNeedingReapplyImprovements.ClearAsync();
                    }
                }
            }
            finally
            {
                _blnFileUpdateQueued = false;
            }
        }

        /// <summary>
        /// Update the Character information.
        /// </summary>
        protected override async Task DoUpdateCharacterInfo(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            while (SkipUpdate)
                await Utils.SafeSleepAsync(token);
            SkipUpdate = true;
            try
            {
                Task tskAutosave = Task.CompletedTask;
                using (await EnterReadLock.EnterAsync(CharacterObject, token))
                {
                    if (AutosaveStopWatch.Elapsed.Minutes >= 5 && IsDirty)
                    {
                        tskAutosave = AutoSaveCharacter(token);
                    }

                    using (await CursorWait.NewAsync(this, true, token))
                    {
                        // TODO: DataBind these wherever possible

                        if (CharacterObject.Metatype == "Free Spirit" && !CharacterObject.IsCritter ||
                            CharacterObject.MetatypeCategory.EndsWith("Spirits", StringComparison.Ordinal))
                        {
                            await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblCritterPowerPoints.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = CharacterObject.CalculateFreeSpiritPowerPoints();
                            }, token);
                        }
                        else if (CharacterObject.IsFreeSprite)
                        {
                            await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblCritterPowerPoints.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = CharacterObject.CalculateFreeSpritePowerPoints();
                            }, token);
                        }
                        else
                        {
                            await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblCritterPowerPoints.DoThreadSafeAsync(x => x.Visible = false, token);
                        }

                        await Task.WhenAll(RefreshSelectedQuality(token), RefreshSelectedCyberware(token),
                                           RefreshSelectedArmor(token),
                                           RefreshSelectedGear(token), RefreshSelectedDrug(token),
                                           RefreshSelectedLifestyle(token),
                                           RefreshSelectedVehicle(token), RefreshSelectedWeapon(token),
                                           RefreshSelectedSpell(token),
                                           RefreshSelectedComplexForm(token), RefreshSelectedCritterPower(token),
                                           RefreshSelectedAIProgram(token), RefreshSelectedMetamagic(token),
                                           RefreshSelectedMartialArt(token), UpdateInitiationCost(token),
                                           RefreshSelectedImprovement(token));
                        await tskAutosave;
                    }
                }
            }
            finally
            {
                SkipUpdate = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed piece of Cyberware.
        /// </summary>
        private async Task RefreshSelectedCyberware(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpCyberware.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                TreeNode objSelectedNode = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, token);
                object objSelectedNodeTag = objSelectedNode?.Tag;
                if (objSelectedNodeTag == null || objSelectedNode.Level == 0)
                {
                    await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbCyberwareMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                    await tabCyberwareCM.DoThreadSafeAsync(x => x.Visible = false, token);
                    // Buttons
                    await cmdDeleteCyberware.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                    return;
                }
                if (objSelectedNodeTag is IHasWirelessBonus objHasWirelessBonus)
                {
                    await chkCyberwareWireless.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Checked = objHasWirelessBonus.WirelessOn;
                    }, token);
                }
                else
                    await chkCyberwareWireless.DoThreadSafeAsync(x => x.Visible = false, token);
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblCyberwareSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblCyberwareSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblCyberwareSource, token);
                }
                else
                {
                    await lblCyberwareSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblCyberwareSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                if (objSelectedNodeTag is IHasRating objHasRating)
                {
                    string strText = string.Format(
                        GlobalSettings.CultureInfo,
                        await LanguageManager.GetStringAsync(
                            "Label_RatingFormat"),
                        await LanguageManager.GetStringAsync(
                            objHasRating.RatingLabel));
                    await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                }
                string strESSFormat = CharacterObjectSettings.EssenceFormat;
                switch (objSelectedNodeTag)
                {
                    case Cyberware objCyberware:
                    {
                        await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbCyberwareMatrix.DoThreadSafeAsync(
                            x => x.Visible = objCyberware.SourceType == Improvement.ImprovementSource.Cyberware, token);
                        await tabCyberwareCM.DoThreadSafeAsync(
                            x => x.Visible = objCyberware.SourceType == Improvement.ImprovementSource.Cyberware, token);
                        // Buttons
                        await cmdDeleteCyberware.DoThreadSafeAsync(
                            x => x.Enabled = string.IsNullOrEmpty(objCyberware.ParentID), token);
                        // gpbCyberwareCommon
                        await lblCyberwareName.DoThreadSafeAsync(x => x.Text = objCyberware.CurrentDisplayNameShort, token);
                        string strText = await objCyberware.DisplayCategoryAsync(GlobalSettings.Language);
                        await lblCyberwareCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        await lblCyberwareGradeLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblCyberwareGrade.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblCyberwareGrade.DoThreadSafeAsync(x => x.Text = objCyberware.Grade.CurrentDisplayName, token);
                        await lblCyberwareEssenceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblCyberwareEssence.DoThreadSafeAsync(x => x.Visible = true, token);
                        if (objCyberware.Parent == null || objCyberware.AddToParentESS)
                        {
                            decimal decCalculatedEss = await objCyberware.CalculatedESSAsync;
                            await lblCyberwareEssence.DoThreadSafeAsync(x => x.Text = objCyberware.Parent == null
                                                                            ? decCalculatedEss.ToString(
                                                                                strESSFormat,
                                                                                GlobalSettings.CultureInfo)
                                                                            : '+' + decCalculatedEss.ToString(
                                                                                strESSFormat,
                                                                                GlobalSettings.CultureInfo), token);
                        }
                        else
                            await lblCyberwareEssence.DoThreadSafeAsync(
                                x => x.Text = 0.0m.ToString(strESSFormat, GlobalSettings.CultureInfo), token);
                        await lblCyberwareAvail.DoThreadSafeAsync(x => x.Text = objCyberware.DisplayTotalAvail, token);
                        await cmdCyberwareChangeMount.DoThreadSafeAsync(
                            x => x.Visible = !string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount), token);
                        await lblCyberwareRating.DoThreadSafeAsync(
                            x => x.Text = objCyberware.Rating.ToString(GlobalSettings.CultureInfo), token);
                        await lblCyberwareCapacity.DoThreadSafeAsync(x => x.Text = objCyberware.DisplayCapacity, token);
                        await lblCyberwareCost.DoThreadSafeAsync(
                            x => x.Text = objCyberware.TotalCost.ToString(
                                CharacterObjectSettings.NuyenFormat, GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        if (objCyberware.Category.Equals("Cyberlimb", StringComparison.Ordinal))
                        {
                            await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblCyberlimbAGI.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblCyberlimbAGI.DoThreadSafeAsync(
                                x => x.Text = objCyberware.GetAttributeTotalValue("AGI")
                                                          .ToString(GlobalSettings.CultureInfo), token);
                            await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblCyberlimbSTR.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblCyberlimbSTR.DoThreadSafeAsync(
                                x => x.Text = objCyberware.GetAttributeTotalValue("STR")
                                                          .ToString(GlobalSettings.CultureInfo), token);
                        }
                        else
                        {
                            await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblCyberlimbAGI.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblCyberlimbSTR.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        // gpbCyberwareMatrix
                        if (await gpbCyberwareMatrix.DoThreadSafeFuncAsync(x => x.Visible, token))
                        {
                            int intDeviceRating = objCyberware.GetTotalMatrixAttribute("Device Rating");
                            await lblCyberDeviceRating.DoThreadSafeAsync(
                                x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                            await objCyberware.RefreshMatrixAttributeComboBoxesAsync(
                                cboCyberwareAttack, cboCyberwareSleaze, cboCyberwareDataProcessing,
                                cboCyberwareFirewall, token);
                            await chkCyberwareActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Visible = objCyberware.IsCommlink;
                                x.Checked = objCyberware.IsActiveCommlink(CharacterObject);
                            }, token);
                            if (CharacterObject.IsAI)
                            {
                                await chkCyberwareHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = objCyberware.IsHomeNode(CharacterObject);
                                    x.Enabled = chkCyberwareActiveCommlink.Visible &&
                                                objCyberware.GetTotalMatrixAttribute("Program Limit")
                                                >= (CharacterObject.DEP.TotalValue > intDeviceRating
                                                    ? 2
                                                    : 1);
                                }, token);
                            }
                            else
                                await chkCyberwareHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                            token.ThrowIfCancellationRequested();
                            await lblCyberwareOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await cboCyberwareOverclocker.DoThreadSafeAsync(x => x.Visible = false, token);
                        }

                        break;
                    }
                    case Gear objGear:
                    {
                        await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbCyberwareMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        await tabCyberwareCM.DoThreadSafeAsync(x => x.Visible = true, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteCyberware.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token);
                        token.ThrowIfCancellationRequested();
                        // gpbCyberwareCommon
                        await lblCyberwareName.DoThreadSafeAsync(x => x.Text = objGear.CurrentDisplayNameShort, token);
                        await lblCyberwareCategory.DoThreadSafeAsync(
                            x => x.Text = objGear.DisplayCategory(GlobalSettings.Language), token);
                        await lblCyberwareGradeLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberwareGrade.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberwareEssenceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberwareEssence.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberwareAvail.DoThreadSafeAsync(x => x.Text = objGear.DisplayTotalAvail, token);
                        token.ThrowIfCancellationRequested();
                        await lblCyberwareRating.DoThreadSafeAsync(
                            x => x.Text = objGear.Rating.ToString(GlobalSettings.CultureInfo), token);
                        await lblCyberwareCapacity.DoThreadSafeAsync(x => x.Text = objGear.DisplayCapacity, token);
                        await lblCyberwareCost.DoThreadSafeAsync(
                            x => x.Text = objGear.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                     GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberlimbAGI.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberlimbSTR.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // gpbCyberwareMatrix
                        int intDeviceRating = objGear.GetTotalMatrixAttribute("Device Rating");
                        await lblCyberDeviceRating.DoThreadSafeAsync(
                            x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objGear.RefreshMatrixAttributeComboBoxesAsync(
                            cboCyberwareAttack, cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall, token);
                        token.ThrowIfCancellationRequested();
                        await chkCyberwareActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objGear.IsCommlink;
                            x.Checked = objGear.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkCyberwareHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objGear.IsHomeNode(CharacterObject);
                                x.Enabled = chkCyberwareActiveCommlink.Visible
                                            && objGear.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating
                                                ? 2
                                                : 1);
                            }, token);
                        }
                        else
                            await chkCyberwareHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        if (CharacterObject.Overclocker && objGear.Category == "Cyberdecks")
                        {
                            using (new FetchSafelyFromPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstOverclocker))
                            {
                                lstOverclocker.Add(
                                    new ListItem("None", await LanguageManager.GetStringAsync("String_None")));
                                lstOverclocker.Add(
                                    new ListItem("Attack", await LanguageManager.GetStringAsync("String_Attack")));
                                lstOverclocker.Add(
                                    new ListItem("Sleaze", await LanguageManager.GetStringAsync("String_Sleaze")));
                                lstOverclocker.Add(new ListItem("Data Processing",
                                                                await LanguageManager.GetStringAsync(
                                                                    "String_DataProcessing")));
                                lstOverclocker.Add(
                                    new ListItem("Firewall", await LanguageManager.GetStringAsync("String_Firewall")));

                                await cboCyberwareOverclocker.PopulateWithListItemsAsync(lstOverclocker, token);
                                await cboCyberwareOverclocker.DoThreadSafeAsync(x =>
                                {
                                    x.SelectedValue = objGear.Overclocked;
                                    if (x.SelectedIndex == -1)
                                        x.SelectedIndex = 0;
                                }, token);
                            }
                            token.ThrowIfCancellationRequested();
                            await cboCyberwareOverclocker.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblCyberwareOverclockerLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        }
                        else
                        {
                            await cboCyberwareOverclocker.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblCyberwareOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        }

                        break;
                    }
                }
                token.ThrowIfCancellationRequested();
                if (await tabCyberwareCM.DoThreadSafeFuncAsync(x => x.Visible, token))
                {
                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasMatrixAttributes objMatrixCM)
                    {
                        await ProcessEquipmentConditionMonitorBoxDisplays(panCyberwareMatrixCM, objMatrixCM.MatrixCM,
                                                                          objMatrixCM.MatrixCMFilled, token);
                    }
                    else
                    {
                        await tabCyberwareCM.DoThreadSafeAsync(x => x.Visible = false, token);
                    }
                    token.ThrowIfCancellationRequested();
                }
                token.ThrowIfCancellationRequested();
            }
            finally
            {
                await flpCyberware.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Weapon.
        /// </summary>
        private async Task RefreshSelectedWeapon(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpWeapons.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                token.ThrowIfCancellationRequested();
                object objSelectedNodeTag = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token);
                if (objSelectedNodeTag == null || await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode.Level, token) <= 0)
                {
                    await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                    token.ThrowIfCancellationRequested();
                    // Buttons
                    await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                    return;
                }
                token.ThrowIfCancellationRequested();
                string strSpace = await LanguageManager.GetStringAsync("String_Space");
                if (objSelectedNodeTag is IHasWirelessBonus objHasWirelessBonus)
                {
                    await chkWeaponWireless.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Checked = objHasWirelessBonus.WirelessOn;
                    }, token);
                }
                else
                    await chkWeaponWireless.DoThreadSafeAsync(x => x.Visible = false, token);
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblWeaponSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblWeaponSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblWeaponSource, token);
                }
                else
                {
                    await lblWeaponSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblWeaponSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasRating objHasRating)
                {
                    string strText = string.Format(
                        GlobalSettings.CultureInfo,
                        await LanguageManager.GetStringAsync(
                            "Label_RatingFormat"),
                        await LanguageManager.GetStringAsync(
                            objHasRating.RatingLabel));
                    await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                }
                token.ThrowIfCancellationRequested();
                switch (objSelectedNodeTag)
                {
                    case Weapon objWeapon:
                    {
                        await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        bool blnDeleteWeaponEnabled = !objWeapon.IncludedInWeapon &&
                                                      !objWeapon.Cyberware &&
                                                      objWeapon.Category != "Gear" &&
                                                      !objWeapon.Category.StartsWith(
                                                          "Quality", StringComparison.Ordinal) &&
                                                      string.IsNullOrEmpty(objWeapon.ParentID);
                        await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = blnDeleteWeaponEnabled, token);
                        token.ThrowIfCancellationRequested();
                        // gpbWeaponsCommon
                        await lblWeaponName.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayName, token);
                        string strText = await objWeapon.DisplayCategoryAsync(GlobalSettings.Language);
                        await lblWeaponCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponCapacity.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponAvail.DoThreadSafeAsync(x => x.Text = objWeapon.DisplayTotalAvail, token);
                        await lblWeaponCost.DoThreadSafeAsync(x => x.Text
                                                                  = objWeapon.TotalCost.ToString(
                                                                      CharacterObjectSettings.NuyenFormat,
                                                                      GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponSlots.DoThreadSafeAsync(x => x.Visible = true, token);
                        if (!string.IsNullOrWhiteSpace(objWeapon.AccessoryMounts))
                        {
                            if (!GlobalSettings.Language.Equals(GlobalSettings.DefaultLanguage,
                                                                StringComparison.OrdinalIgnoreCase))
                            {
                                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdSlotsText))
                                {
                                    foreach (string strMount in objWeapon.AccessoryMounts.SplitNoAlloc(
                                                 '/', StringSplitOptions.RemoveEmptyEntries))
                                        sbdSlotsText
                                            .Append(await LanguageManager.GetStringAsync("String_Mount" + strMount))
                                            .Append('/');
                                    --sbdSlotsText.Length;
                                    await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = sbdSlotsText.ToString(), token);
                                }
                            }
                            else
                                await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = objWeapon.AccessoryMounts, token);
                        }
                        else
                        {
                            string strNone = await LanguageManager.GetStringAsync("String_None");
                            await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = strNone, token);
                        }

                        token.ThrowIfCancellationRequested();
                        await lblWeaponConcealLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponConceal.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objWeapon.DisplayConcealability;
                        }, token);
                        await cmdWeaponMoveToVehicle.DoThreadSafeAsync(x => x.Visible = blnDeleteWeaponEnabled && CharacterObject.Vehicles.Count > 0, token);
                        strText = await LanguageManager.GetStringAsync(
                            objWeapon.Parent == null ? "Checkbox_Equipped" : "Checkbox_Installed");
                        await chkWeaponEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = !objWeapon.IncludedInWeapon;
                            x.Checked = objWeapon.Equipped;
                        }, token);
                        await chkIncludedInWeapon.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objWeapon.Parent != null;
                            x.Enabled = false;
                            x.Checked = objWeapon.IncludedInWeapon;
                        }, token);
                        token.ThrowIfCancellationRequested();
                        // gpbWeaponsWeapon
                        strText = await LanguageManager.GetStringAsync("String_Weapon");
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Text = strText, token);
                        await lblWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponDamage.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponDamage.DoThreadSafeAsync(x => x.Text = objWeapon.DisplayDamage, token);
                        await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponAP.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objWeapon.DisplayTotalAP;
                        }, token);
                        await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponAccuracy.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objWeapon.DisplayAccuracy;
                        }, token);
                        await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await dpcWeaponDicePool.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.DicePool = objWeapon.DicePool;
                            x.CanBeRolled = true;
                        }, token);
                        await dpcWeaponDicePool.SetLabelToolTipAsync(objWeapon.DicePoolTooltip, token);
                        if (objWeapon.RangeType == "Ranged")
                        {
                            await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponRC.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.DisplayTotalRC;
                            }, token);
                            await lblWeaponRC.SetToolTipAsync(objWeapon.RCToolTip, token);
                            await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponAmmo.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.DisplayAmmo;
                            }, token);
                            await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponMode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.DisplayMode;
                            }, token);
                            await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponRangeMain.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayRange, token);
                            await lblWeaponRangeAlternate.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayAlternateRange, token);
                            Dictionary<string, string> dictionaryRanges
                                = objWeapon.GetRangeStrings(GlobalSettings.CultureInfo);
                            await lblWeaponRangeShortLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Short"), token);
                            await lblWeaponRangeMediumLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Medium"), token);
                            await lblWeaponRangeLongLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Long"), token);
                            await lblWeaponRangeExtremeLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Extreme"), token);
                            await lblWeaponRangeShort.DoThreadSafeAsync(x => x.Text = dictionaryRanges["short"], token);
                            await lblWeaponRangeMedium.DoThreadSafeAsync(x => x.Text = dictionaryRanges["medium"], token);
                            await lblWeaponRangeLong.DoThreadSafeAsync(x => x.Text = dictionaryRanges["long"], token);
                            await lblWeaponRangeExtreme.DoThreadSafeAsync(x => x.Text = dictionaryRanges["extreme"], token);
                            await lblWeaponAlternateRangeShort.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternateshort"], token);
                            await lblWeaponAlternateRangeMedium.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternatemedium"], token);
                            await lblWeaponAlternateRangeLong.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternatelong"], token);
                            await lblWeaponAlternateRangeExtreme.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternateextreme"], token);
                        }
                        else
                        {
                            await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponReach.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.TotalReach.ToString(GlobalSettings.CultureInfo);
                            }, token);
                            await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponRC.DoThreadSafeAsync(x => x.Visible = false, token);
                            if (objWeapon.Ammo != "0")
                            {
                                await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblWeaponAmmo.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objWeapon.DisplayAmmo;
                                }, token);
                            }
                            else
                            {
                                await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token);
                            }
                            token.ThrowIfCancellationRequested();
                            await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token);
                            await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        // Enable the fire button if the Weapon is Ranged.
                        if (objWeapon.RangeType == "Ranged" || objWeapon.RangeType == "Melee" && objWeapon.Ammo != "0")
                        {
                            await tlpWeaponsCareer.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo), token);
                            await cmdFireWeapon.DoThreadSafeAsync(x => x.Enabled = objWeapon.AmmoRemaining != 0, token);
                            await cmdUnloadWeapon.DoThreadSafeAsync(x => x.Enabled = objWeapon.RequireAmmo && objWeapon.AmmoLoaded != null && objWeapon.AmmoRemaining != 0, token);
                            token.ThrowIfCancellationRequested();
                            string strSingleShotText
                                = objWeapon.AllowSingleShot || (objWeapon.RangeType == "Melee" && objWeapon.Ammo != "0")
                                    ? string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync(
                                                        "String_SingleShot")
                                                    , objWeapon.SingleShot.ToString(GlobalSettings.CultureInfo),
                                                    objWeapon.SingleShot == 1
                                                        ? await LanguageManager.GetStringAsync(
                                                            "String_Bullet")
                                                        : await LanguageManager.GetStringAsync(
                                                            "String_Bullets"))
                                    : await
                                        LanguageManager.GetStringAsync("String_SingleShotNA");
                            string strShortBurstText
                                = objWeapon.AllowShortBurst
                                    ? string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync(
                                                        "String_ShortBurst")
                                                    , objWeapon.ShortBurst.ToString(GlobalSettings.CultureInfo),
                                                    objWeapon.ShortBurst == 1
                                                        ? await LanguageManager.GetStringAsync(
                                                            "String_Bullet")
                                                        : await LanguageManager.GetStringAsync(
                                                            "String_Bullets"))
                                    : await
                                        LanguageManager.GetStringAsync("String_ShortBurstNA");
                            string strLongBurstText
                                = objWeapon.AllowLongBurst
                                    ? string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync(
                                                        "String_LongBurst")
                                                    , objWeapon.LongBurst.ToString(GlobalSettings.CultureInfo),
                                                    objWeapon.LongBurst == 1
                                                        ? await LanguageManager.GetStringAsync(
                                                            "String_Bullet")
                                                        : await LanguageManager.GetStringAsync(
                                                            "String_Bullets"))
                                    : await
                                        LanguageManager.GetStringAsync("String_LongBurstNA");
                            string strFullBurstText
                                = objWeapon.AllowFullBurst
                                    ? string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync(
                                                        "String_FullBurst")
                                                    , objWeapon.FullBurst.ToString(GlobalSettings.CultureInfo),
                                                    objWeapon.FullBurst == 1
                                                        ? await LanguageManager.GetStringAsync(
                                                            "String_Bullet")
                                                        : await LanguageManager.GetStringAsync(
                                                            "String_Bullets"))
                                    : await
                                        LanguageManager.GetStringAsync("String_FullBurstNA");
                            string strSuppressiveFireText
                                = objWeapon.AllowSuppressive
                                    ? string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync(
                                                        "String_SuppressiveFire")
                                                    , objWeapon.Suppressive.ToString(GlobalSettings.CultureInfo),
                                                    objWeapon.Suppressive == 1
                                                        ? await LanguageManager.GetStringAsync(
                                                            "String_Bullet")
                                                        : await LanguageManager.GetStringAsync(
                                                            "String_Bullets"))
                                    : await
                                        LanguageManager.GetStringAsync("String_SuppressiveFireNA");
                            await cmsAmmoExpense.DoThreadSafeAsync(() =>
                            {
                                cmsAmmoSingleShot.Enabled = objWeapon.AllowSingleShot;
                                cmsAmmoShortBurst.Enabled = objWeapon.AllowShortBurst;
                                cmsAmmoLongBurst.Enabled = objWeapon.AllowLongBurst;
                                cmsAmmoFullBurst.Enabled = objWeapon.AllowFullBurst;
                                cmsAmmoSuppressiveFire.Enabled = objWeapon.AllowSuppressive;

                                // Melee Weapons with Ammo are considered to be Single Shot.
                                if (objWeapon.RangeType == "Melee" && objWeapon.Ammo != "0")
                                    cmsAmmoSingleShot.Enabled = true;

                                cmsAmmoSingleShot.Text = strSingleShotText;
                                cmsAmmoShortBurst.Text = strShortBurstText;
                                cmsAmmoLongBurst.Text = strLongBurstText;
                                cmsAmmoFullBurst.Text = strFullBurstText;
                                cmsAmmoSuppressiveFire.Text = strSuppressiveFireText;
                            }, token);
                            token.ThrowIfCancellationRequested();
                            using (new FetchSafelyFromPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstAmmo))
                            {
                                int intSlot = 0;
                                foreach (Clip objClip in objWeapon.Clips)
                                {
                                    ++intSlot;
                                    token.ThrowIfCancellationRequested();
                                    string strAmmoName;
                                    if (objWeapon.RequireAmmo)
                                    {
                                        Gear objGear = objClip.AmmoGear;
                                        strAmmoName = objGear?.CurrentDisplayNameShort ??
                                                      await LanguageManager.GetStringAsync(objClip.Ammo > 0
                                                          ? "String_ExternalSource"
                                                          : "String_Empty");
                                        if (objWeapon.Clips.Count > 1)
                                            strAmmoName += strSpace + '(' + string.Format(GlobalSettings.CultureInfo
                                                , await LanguageManager.GetStringAsync("String_SlotNumber")
                                                , intSlot.ToString(GlobalSettings.CultureInfo)) + ')';

                                        string strPlugins = string.Empty;
                                        if (objGear?.Children.Count > 0)
                                        {
                                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                       out StringBuilder sbdPlugins))
                                            {
                                                foreach (Gear objChild in objGear.Children)
                                                {
                                                    sbdPlugins.Append(objChild.CurrentDisplayNameShort).Append(',')
                                                              .Append(strSpace);
                                                }

                                                strPlugins = sbdPlugins.ToString();
                                            }
                                        }

                                        // Remove the trailing comma.
                                        if (!string.IsNullOrEmpty(strPlugins))
                                            strPlugins = strPlugins.Substring(
                                                0, strPlugins.Length - 1 - strSpace.Length);

                                        if (!string.IsNullOrEmpty(strPlugins))
                                            strAmmoName += strSpace + '[' + strPlugins + ']';
                                    }
                                    else
                                        strAmmoName = await LanguageManager.GetStringAsync(objClip.Ammo > 0
                                            ? "String_MountInternal"
                                            : "String_Empty");
                                    token.ThrowIfCancellationRequested();
                                    lstAmmo.Add(new ListItem(intSlot.ToString(GlobalSettings.InvariantCultureInfo),
                                                             strAmmoName));
                                }
                                token.ThrowIfCancellationRequested();
                                await cboWeaponAmmo.PopulateWithListItemsAsync(lstAmmo, token);
                                await cboWeaponAmmo.DoThreadSafeAsync(x =>
                                {
                                    x.SelectedValue
                                        = objWeapon.ActiveAmmoSlot.ToString(GlobalSettings.InvariantCultureInfo);
                                    if (x.SelectedIndex == -1)
                                        x.SelectedIndex = 0;
                                    x.Enabled = lstAmmo.Count > 1;
                                }, token);
                            }
                        }
                        else
                        {
                            await tlpWeaponsCareer.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        // gpbWeaponsMatrix
                        int intDeviceRating = objWeapon.GetTotalMatrixAttribute("Device Rating");
                        await lblWeaponDeviceRating.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objWeapon.RefreshMatrixAttributeComboBoxesAsync(
                            cboWeaponGearAttack, cboWeaponGearSleaze, cboWeaponGearDataProcessing,
                            cboWeaponGearFirewall, token);
                        await chkWeaponActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objWeapon.IsCommlink;
                            x.Checked = objWeapon.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkWeaponHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objWeapon.IsHomeNode(CharacterObject);
                                x.Enabled = objWeapon.IsCommlink
                                            && objWeapon.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                            }, token);
                        }
                        else
                            await chkWeaponHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        await cboWeaponOverclocker.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        break;
                    }
                    case WeaponAccessory objSelectedAccessory:
                    {
                        await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        // Buttons
                        await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = !objSelectedAccessory.IncludedInWeapon
                                                                    && string.IsNullOrEmpty(
                                                                        objSelectedAccessory.ParentID), token);
                        // gpbWeaponsCommon
                        await lblWeaponName.DoThreadSafeAsync(x => x.Text = objSelectedAccessory.CurrentDisplayNameShort, token);
                        string strText = await LanguageManager.GetStringAsync("String_WeaponAccessory");
                        await lblWeaponCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        if (objSelectedAccessory.MaxRating > 0)
                        {
                            await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objSelectedAccessory.Rating.ToString(GlobalSettings.CultureInfo);
                            }, token);
                        }
                        else
                        {
                            await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponCapacity.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponAvail.DoThreadSafeAsync(x => x.Text = objSelectedAccessory.DisplayTotalAvail, token);
                        await lblWeaponCost.DoThreadSafeAsync(x => x.Text
                                                                  = objSelectedAccessory.TotalCost.ToString(
                                                                      CharacterObjectSettings.NuyenFormat,
                                                                      GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponSlots.DoThreadSafeAsync(x => x.Visible = true, token);
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdSlotsText))
                        {
                            sbdSlotsText.Append(objSelectedAccessory.Mount);
                            if (sbdSlotsText.Length > 0
                                && !GlobalSettings.Language.Equals(GlobalSettings.DefaultLanguage,
                                                                   StringComparison.OrdinalIgnoreCase))
                            {
                                sbdSlotsText.Clear();
                                foreach (string strMount in objSelectedAccessory.Mount.SplitNoAlloc(
                                             '/', StringSplitOptions.RemoveEmptyEntries))
                                    sbdSlotsText.Append(await LanguageManager.GetStringAsync("String_Mount" + strMount))
                                                .Append('/');
                                --sbdSlotsText.Length;
                            }

                            if (!string.IsNullOrEmpty(objSelectedAccessory.ExtraMount)
                                && objSelectedAccessory.ExtraMount != "None")
                            {
                                bool boolHaveAddedItem = false;
                                foreach (string strCurrentExtraMount in objSelectedAccessory.ExtraMount.SplitNoAlloc(
                                             '/', StringSplitOptions.RemoveEmptyEntries))
                                {
                                    if (!boolHaveAddedItem)
                                    {
                                        sbdSlotsText.Append(strSpace).Append('+').Append(strSpace);
                                        boolHaveAddedItem = true;
                                    }

                                    sbdSlotsText
                                        .Append(await LanguageManager.GetStringAsync(
                                                    "String_Mount" + strCurrentExtraMount))
                                        .Append('/');
                                }

                                // Remove the trailing /
                                if (boolHaveAddedItem)
                                    --sbdSlotsText.Length;
                            }
                            token.ThrowIfCancellationRequested();
                            await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = sbdSlotsText.ToString(), token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblWeaponConcealLabel.DoThreadSafeAsync(x => x.Visible = objSelectedAccessory.TotalConcealability != 0, token);
                        await lblWeaponConceal.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objSelectedAccessory.TotalConcealability != 0;
                            x.Text
                                = objSelectedAccessory.TotalConcealability.ToString(
                                    "+#,0;-#,0;0", GlobalSettings.CultureInfo);
                        }, token);
                        strText = await LanguageManager.GetStringAsync(objSelectedAccessory.Parent == null
                                                                           ? "Checkbox_Equipped"
                                                                           : "Checkbox_Installed");
                        await chkWeaponEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = !objSelectedAccessory.IncludedInWeapon;
                            x.Checked = objSelectedAccessory.Equipped;
                        }, token);
                        await chkIncludedInWeapon.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objSelectedAccessory.Parent != null;
                            x.Enabled = CharacterObjectSettings.AllowEditPartOfBaseWeapon;
                            x.Checked = objSelectedAccessory.IncludedInWeapon;
                        }, token);
                        token.ThrowIfCancellationRequested();
                        // gpbWeaponsWeapon
                        strText = await LanguageManager.GetStringAsync("String_WeaponAccessory");
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Text = strText, token);
                        if (string.IsNullOrEmpty(objSelectedAccessory.Damage))
                        {
                            await lblWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponDamage.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = !string.IsNullOrEmpty(objSelectedAccessory.Damage), token);
                            await lblWeaponDamage.DoThreadSafeAsync(x =>
                            {
                                x.Visible = !string.IsNullOrEmpty(objSelectedAccessory
                                                                      .Damage);
                                x.Text = Convert
                                         .ToInt32(objSelectedAccessory.Damage,
                                                  GlobalSettings.InvariantCultureInfo)
                                         .ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (string.IsNullOrEmpty(objSelectedAccessory.AP))
                        {
                            await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponAP.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponAP.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = Convert
                                         .ToInt32(objSelectedAccessory.AP, GlobalSettings.InvariantCultureInfo)
                                         .ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (objSelectedAccessory.Accuracy == 0)
                        {
                            await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponAccuracy.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponAccuracy.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objSelectedAccessory.Accuracy.ToString(
                                    "+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (objSelectedAccessory.DicePool == 0)
                        {
                            await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await dpcWeaponDicePool.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await dpcWeaponDicePool.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.DicePool = objSelectedAccessory.DicePool;
                                x.CanBeRolled = false;
                            }, token);
                            await dpcWeaponDicePool.SetLabelToolTipAsync(string.Empty, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token);
                        if (string.IsNullOrEmpty(objSelectedAccessory.RC))
                        {
                            await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponRC.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponRC.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = Convert
                                         .ToInt32(objSelectedAccessory.RC, GlobalSettings.InvariantCultureInfo)
                                         .ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (objSelectedAccessory.TotalAmmoBonus != 0
                            || (!string.IsNullOrEmpty(objSelectedAccessory.ModifyAmmoCapacity)
                                && objSelectedAccessory.ModifyAmmoCapacity != "0"))
                        {
                            await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = true, token);
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdAmmoBonus))
                            {
                                int intAmmoBonus = objSelectedAccessory.TotalAmmoBonus;
                                if (intAmmoBonus != 0)
                                    sbdAmmoBonus.Append(
                                        (intAmmoBonus / 100.0m).ToString("+#,0%;-#,0%;0%", GlobalSettings.CultureInfo));
                                if (!string.IsNullOrEmpty(objSelectedAccessory.ModifyAmmoCapacity)
                                    && objSelectedAccessory.ModifyAmmoCapacity != "0")
                                    sbdAmmoBonus.Append(objSelectedAccessory.ModifyAmmoCapacity);
                                await lblWeaponAmmo.DoThreadSafeAsync(x => x.Text = sbdAmmoBonus.ToString(), token);
                            }
                        }
                        else
                        {
                            await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = false, token);
                        await tlpWeaponsCareer.DoThreadSafeAsync(x => x.Visible = false, token);
                        break;
                    }
                    case Gear objGear:
                    {
                        await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token);
                        token.ThrowIfCancellationRequested();
                        // gpbWeaponsCommon
                        await lblWeaponName.DoThreadSafeAsync(x => x.Text = objGear.CurrentDisplayNameShort, token);
                        await lblWeaponCategory.DoThreadSafeAsync(x => x.Text = objGear.DisplayCategory(GlobalSettings.Language), token);
                        int intGearMaxRatingValue = objGear.MaxRatingValue;
                        if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                        {
                            await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objGear.Rating.ToString(GlobalSettings.CultureInfo);
                            }, token);
                        }
                        else
                        {
                            await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponCapacity.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objGear.DisplayCapacity;
                        }, token);
                        await lblWeaponAvail.DoThreadSafeAsync(x => x.Text = objGear.DisplayTotalAvail, token);
                        await lblWeaponCost.DoThreadSafeAsync(x => x.Text
                                                                  = objGear.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                      GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponSlots.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponConcealLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponConceal.DoThreadSafeAsync(x => x.Visible = false, token);
                        string strText = await LanguageManager.GetStringAsync("Checkbox_Equipped");
                        await chkWeaponEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = !objGear.IncludedInParent;
                            x.Checked = objGear.Equipped;
                        }, token);
                        await chkIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // gpbWeaponsMatrix
                        int intDeviceRating = objGear.GetTotalMatrixAttribute("Device Rating");
                        await lblWeaponDeviceRating.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objGear.RefreshMatrixAttributeComboBoxesAsync(
                            cboWeaponGearAttack, cboWeaponGearSleaze, cboWeaponGearDataProcessing,
                            cboWeaponGearFirewall, token);
                        await chkWeaponActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objGear.IsCommlink;
                            x.Checked = objGear.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkWeaponHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objGear.IsHomeNode(CharacterObject);
                                x.Enabled = objGear.IsCommlink
                                            && objGear.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                            }, token);
                        }
                        else
                            await chkWeaponHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        if (CharacterObject.Overclocker && objGear.Category == "Cyberdecks")
                        {
                            using (new FetchSafelyFromPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstOverclocker))
                            {
                                lstOverclocker.Add(
                                    new ListItem("None", await LanguageManager.GetStringAsync("String_None")));
                                lstOverclocker.Add(
                                    new ListItem("Attack", await LanguageManager.GetStringAsync("String_Attack")));
                                lstOverclocker.Add(
                                    new ListItem("Sleaze", await LanguageManager.GetStringAsync("String_Sleaze")));
                                lstOverclocker.Add(new ListItem("Data Processing",
                                                                await LanguageManager.GetStringAsync(
                                                                    "String_DataProcessing")));
                                lstOverclocker.Add(
                                    new ListItem("Firewall", await LanguageManager.GetStringAsync("String_Firewall")));
                                token.ThrowIfCancellationRequested();
                                await cboWeaponOverclocker.PopulateWithListItemsAsync(lstOverclocker, token);
                                await cboWeaponOverclocker.DoThreadSafeAsync(x =>
                                {
                                    x.SelectedValue = objGear.Overclocked;
                                    if (x.SelectedIndex == -1)
                                        x.SelectedIndex = 0;
                                }, token);
                            }
                            token.ThrowIfCancellationRequested();
                            await cboWeaponOverclocker.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponOverclockerLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        }
                        else
                        {
                            await cboWeaponOverclocker.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        }

                        break;
                    }
                    default:
                        await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = false, token);
                        break;
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasMatrixAttributes objMatrixCM)
                {
                    await tabWeaponCM.DoThreadSafeAsync(x => x.Visible = true, token);
                    await ProcessEquipmentConditionMonitorBoxDisplays(panWeaponMatrixCM, objMatrixCM.MatrixCM,
                                                                      objMatrixCM.MatrixCMFilled, token);
                }
                else
                    await tabWeaponCM.DoThreadSafeAsync(x => x.Visible = false, token);
                token.ThrowIfCancellationRequested();
                await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = objSelectedNodeTag is IHasMatrixAttributes ||
                                                                          objSelectedNodeTag is IHasWirelessBonus, token);
                token.ThrowIfCancellationRequested();
            }
            finally
            {
                await flpWeapons.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Armor.
        /// </summary>
        private async Task RefreshSelectedArmor(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpArmor.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                token.ThrowIfCancellationRequested();
                object objSelectedNodeTag = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token);
                if (objSelectedNodeTag == null)
                {
                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token);
                    token.ThrowIfCancellationRequested();
                    // Buttons
                    await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token);
                    return;
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasWirelessBonus objHasWirelessBonus)
                {
                    await chkArmorWireless.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Checked = objHasWirelessBonus.WirelessOn;
                    }, token);
                }
                else
                    await chkArmorWireless.DoThreadSafeAsync(x => x.Visible = false, token);
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblArmorSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblArmorSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblArmorSource, token);
                }
                else
                {
                    await lblArmorSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblArmorSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasRating objHasRating)
                {
                    string strText = string.Format(GlobalSettings.CultureInfo,
                                                   await LanguageManager.GetStringAsync("Label_RatingFormat"),
                                                   await LanguageManager.GetStringAsync(
                                                       objHasRating.RatingLabel));
                    await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is Armor objArmor)
                {
                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token);
                    token.ThrowIfCancellationRequested();
                    // Buttons
                    await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = true, token);
                    token.ThrowIfCancellationRequested();
                    // gpbArmorCommon
                    await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await flpArmorValue.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblArmorValue.DoThreadSafeAsync(x => x.Text = objArmor.DisplayArmorValue, token);
                    await cmdArmorIncrease.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Enabled = objArmor.ArmorDamage < objArmor.TotalArmor &&
                                    objArmor.ArmorDamage < (string.IsNullOrEmpty(objArmor.ArmorOverrideValue)
                                        ? int.MaxValue
                                        : objArmor.TotalOverrideArmor);
                    }, token);
                    await cmdArmorDecrease.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Enabled = objArmor.ArmorDamage > 0;
                    }, token);
                    await lblArmorAvail.DoThreadSafeAsync(x => x.Text = objArmor.DisplayTotalAvail, token);
                    await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = objArmor.DisplayCapacity, token);
                    await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblArmorRating.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblArmorCost.DoThreadSafeAsync(x => x.Text
                                                             = objArmor.TotalCost.ToString(CharacterObjectSettings.NuyenFormat, GlobalSettings.CultureInfo)
                                                               + LanguageManager.GetString("String_NuyenSymbol"), token);
                    await chkArmorEquipped.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Checked = objArmor.Equipped;
                        x.Enabled = true;
                    }, token);
                    await chkIncludedInArmor.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                else
                {
                    token.ThrowIfCancellationRequested();
                    string strSpace = await LanguageManager.GetStringAsync("String_Space");
                    if (objSelectedNodeTag is ArmorMod objArmorMod)
                    {
                        await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = !objArmorMod.IncludedInArmor, token);
                        token.ThrowIfCancellationRequested();
                        // gpbArmorCommon
                        if (objArmorMod.Armor != 0)
                        {
                            await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await flpArmorValue.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblArmorValue.DoThreadSafeAsync(x => x.Text = objArmorMod.Armor.ToString("+0;-0;0", GlobalSettings.CultureInfo), token);
                        }
                        else
                        {
                            await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await flpArmorValue.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await cmdArmorIncrease.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdArmorDecrease.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblArmorAvail.DoThreadSafeAsync(x => x.Text = objArmorMod.DisplayTotalAvail, token);
                        string strCapacity = objArmorMod.Parent.CapacityDisplayStyle == CapacityStyle.Zero
                            ? "[0]"
                            : objArmorMod.CalculatedCapacity;
                        if (!string.IsNullOrEmpty(objArmorMod.GearCapacity))
                            strCapacity = objArmorMod.GearCapacity + '/' + strCapacity + strSpace + '('
                                          + objArmorMod.GearCapacityRemaining.ToString(
                                              "#,0.##", GlobalSettings.CultureInfo) + strSpace
                                          + await LanguageManager.GetStringAsync("String_Remaining") + ')';
                        await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token);
                        if (objArmorMod.MaximumRating > 1)
                        {
                            await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblArmorRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objArmorMod.Rating.ToString(GlobalSettings.CultureInfo);
                            }, token);
                        }
                        else
                        {
                            await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblArmorRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblArmorCost.DoThreadSafeAsync(x => x.Text
                                                                 = objArmorMod.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                     GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await chkArmorEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objArmorMod.Equipped;
                            x.Enabled = true;
                        }, token);
                        await chkIncludedInArmor.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objArmorMod.IncludedInArmor;
                        }, token);
                    }
                    else
                    {
                        switch (objSelectedNodeTag)
                        {
                            case Gear objSelectedGear:
                            {
                                await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                                await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token);
                                token.ThrowIfCancellationRequested();
                                // Buttons
                                await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = !objSelectedGear.IncludedInParent, token);
                                token.ThrowIfCancellationRequested();
                                // gpbArmorCommon
                                await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await flpArmorValue.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblArmorAvail.DoThreadSafeAsync(x => x.Text = objSelectedGear.DisplayTotalAvail, token);
                                CharacterObject.Armor.FindArmorGear(objSelectedGear.InternalId, out objArmor,
                                                                    out objArmorMod);
                                if (objArmorMod != null)
                                    await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = objSelectedGear.CalculatedCapacity, token);
                                else if (objArmor.CapacityDisplayStyle == CapacityStyle.Zero)
                                    await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = '[' + 0.ToString(GlobalSettings.CultureInfo) + ']', token);
                                else
                                    await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = objSelectedGear.CalculatedArmorCapacity, token);
                                int intMaxRatingValue = objSelectedGear.MaxRatingValue;
                                if (intMaxRatingValue > 1 && intMaxRatingValue != int.MaxValue)
                                {
                                    await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                    await lblArmorRating.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = objSelectedGear.Rating.ToString(GlobalSettings.CultureInfo);
                                    }, token);
                                }
                                else
                                {
                                    await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                    await lblArmorRating.DoThreadSafeAsync(x => x.Visible = false, token);
                                }
                                token.ThrowIfCancellationRequested();
                                await lblArmorCost.DoThreadSafeAsync(x => x.Text
                                                                         = objSelectedGear.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                             GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                                await chkArmorEquipped.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = objSelectedGear.Equipped;
                                    x.Enabled = true;
                                }, token);
                                await chkIncludedInArmor.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = objSelectedGear.IncludedInParent;
                                }, token);
                                break;
                            }
                            case Location objLocation:
                            {
                                await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                                await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = true, token);
                                token.ThrowIfCancellationRequested();
                                // Buttons
                                await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = true, token);
                                token.ThrowIfCancellationRequested();
                                // gpbArmorLocation
                                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdArmorEquipped))
                                {
                                    foreach (Armor objLoopArmor in CharacterObject.Armor.Where(
                                                 objLoopArmor =>
                                                     objLoopArmor.Equipped && objLoopArmor.Location == objLocation))
                                    {
                                        sbdArmorEquipped
                                            .Append(objLoopArmor.CurrentDisplayName).Append(strSpace).Append('(')
                                            .Append(objLoopArmor.DisplayArmorValue).AppendLine(')');
                                    }
                                    token.ThrowIfCancellationRequested();
                                    if (sbdArmorEquipped.Length > 0)
                                    {
                                        --sbdArmorEquipped.Length;
                                        await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = sbdArmorEquipped.ToString(), token);
                                    }
                                    else
                                    {
                                        string strNone = await LanguageManager.GetStringAsync("String_None");
                                        await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = strNone, token);
                                    }
                                }

                                break;
                            }
                            default:
                            {
                                if (objSelectedNodeTag.ToString() == "Node_SelectedArmor")
                                {
                                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                                    await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = true, token);
                                    token.ThrowIfCancellationRequested();
                                    // Buttons
                                    await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token);
                                    token.ThrowIfCancellationRequested();
                                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                               out StringBuilder sbdArmorEquipped))
                                    {
                                        foreach (Armor objLoopArmor in CharacterObject.Armor.Where(
                                                     objLoopArmor =>
                                                         objLoopArmor.Equipped && objLoopArmor.Location == null))
                                        {
                                            sbdArmorEquipped.Append(objLoopArmor.CurrentDisplayName).Append(strSpace)
                                                            .Append('(').Append(objLoopArmor.DisplayArmorValue)
                                                            .AppendLine(')');
                                        }
                                        token.ThrowIfCancellationRequested();
                                        if (sbdArmorEquipped.Length > 0)
                                        {
                                            --sbdArmorEquipped.Length;
                                            await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = sbdArmorEquipped.ToString(), token);
                                        }
                                        else
                                        {
                                            string strNone = await LanguageManager.GetStringAsync("String_None");
                                            await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = strNone, token);
                                        }
                                    }
                                }
                                else
                                {
                                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                                    await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token);
                                    token.ThrowIfCancellationRequested();
                                    // Buttons
                                    await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token);
                                }

                                break;
                            }
                        }
                    }
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasMatrixAttributes objHasMatrixAttributes)
                {
                    int intDeviceRating = objHasMatrixAttributes.GetTotalMatrixAttribute("Device Rating");
                    await lblArmorDeviceRating.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                    await objHasMatrixAttributes.RefreshMatrixAttributeComboBoxesAsync(
                        cboArmorAttack, cboArmorSleaze, cboArmorDataProcessing, cboArmorFirewall, token);
                    if (CharacterObject.IsAI)
                    {
                        await chkArmorHomeNode.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objHasMatrixAttributes.IsHomeNode(CharacterObject);
                            x.Enabled = objHasMatrixAttributes.IsCommlink &&
                                        objHasMatrixAttributes.GetTotalMatrixAttribute("Program Limit") >=
                                        (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                        }, token);
                    }
                    else
                        await chkArmorHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                    token.ThrowIfCancellationRequested();
                    await chkArmorActiveCommlink.DoThreadSafeAsync(x =>
                    {
                        x.Checked = objHasMatrixAttributes.IsActiveCommlink(
                            CharacterObject);
                        x.Visible = objHasMatrixAttributes.IsCommlink;
                    }, token);
                    token.ThrowIfCancellationRequested();
                    if (CharacterObject.Overclocker && objHasMatrixAttributes is Gear objGear
                                                    && objGear.Category == "Cyberdecks")
                    {
                        using (new FetchSafelyFromPool<List<ListItem>>(
                                   Utils.ListItemListPool, out List<ListItem> lstOverclocker))
                        {
                            lstOverclocker.Add(
                                new ListItem("None", await LanguageManager.GetStringAsync("String_None")));
                            lstOverclocker.Add(
                                new ListItem("Attack", await LanguageManager.GetStringAsync("String_Attack")));
                            lstOverclocker.Add(
                                new ListItem("Sleaze", await LanguageManager.GetStringAsync("String_Sleaze")));
                            lstOverclocker.Add(new ListItem("Data Processing",
                                                            await LanguageManager.GetStringAsync(
                                                                "String_DataProcessing")));
                            lstOverclocker.Add(
                                new ListItem("Firewall", await LanguageManager.GetStringAsync("String_Firewall")));
                            token.ThrowIfCancellationRequested();
                            await cboArmorOverclocker.PopulateWithListItemsAsync(lstOverclocker, token);
                            await cboArmorOverclocker.DoThreadSafeAsync(x =>
                            {
                                x.SelectedValue = objHasMatrixAttributes.Overclocked;
                                if (x.SelectedIndex == -1)
                                    x.SelectedIndex = 0;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await cboArmorOverclocker.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblArmorOverclockerLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    }
                    else
                    {
                        await cboArmorOverclocker.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblArmorOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    }
                    token.ThrowIfCancellationRequested();
                    await tabArmorCM.DoThreadSafeAsync(x => x.Visible = true, token);
                    await ProcessEquipmentConditionMonitorBoxDisplays(panArmorMatrixCM, objHasMatrixAttributes.MatrixCM,
                                                                      objHasMatrixAttributes.MatrixCMFilled, token);
                    token.ThrowIfCancellationRequested();
                    await lblArmorDeviceRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblArmorDeviceRating.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblArmorAttackLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblArmorSleazeLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblArmorDataProcessingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblArmorFirewallLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await cboArmorAttack.DoThreadSafeAsync(x => x.Visible = true, token);
                    await cboArmorSleaze.DoThreadSafeAsync(x => x.Visible = true, token);
                    await cboArmorDataProcessing.DoThreadSafeAsync(x => x.Visible = true, token);
                    await cboArmorFirewall.DoThreadSafeAsync(x => x.Visible = true, token);
                    await chkArmorWireless.DoThreadSafeAsync(x => x.Visible = objSelectedNodeTag is IHasWirelessBonus, token);
                    await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                }
                else
                {
                    token.ThrowIfCancellationRequested();
                    await tabArmorCM.DoThreadSafeAsync(x => x.Visible = false, token);
                    if (objSelectedNodeTag is IHasWirelessBonus)
                    {
                        await cboArmorOverclocker.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblArmorOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkArmorHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblArmorDeviceRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblArmorDeviceRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblArmorAttackLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblArmorSleazeLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblArmorDataProcessingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblArmorFirewallLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cboArmorAttack.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cboArmorSleaze.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cboArmorDataProcessing.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cboArmorFirewall.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkArmorWireless.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                    }
                    else
                        await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                token.ThrowIfCancellationRequested();
            }
            finally
            {
                await flpArmor.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Gear.
        /// </summary>
        private async Task RefreshSelectedGear(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpGear.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                token.ThrowIfCancellationRequested();
                object objSelectedNodeTag = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token);
                if (objSelectedNodeTag == null || await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode.Level == 0, token))
                {
                    await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                    await tabGearCM.DoThreadSafeAsync(x => x.Visible = false, token);
                    token.ThrowIfCancellationRequested();
                    // Buttons
                    await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                    return;
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasWirelessBonus objHasWirelessBonus)
                {
                    await chkGearWireless.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Checked = objHasWirelessBonus.WirelessOn;
                    }, token);
                }
                else
                    await chkGearWireless.DoThreadSafeAsync(x => x.Visible = false, token);
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblGearSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblGearSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblGearSource, token);
                }
                else
                {
                    await lblGearSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblGearSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasRating objHasRating)
                {
                    string strText = string.Format(
                        GlobalSettings.CultureInfo,
                        await LanguageManager.GetStringAsync(
                            "Label_RatingFormat"),
                        await LanguageManager.GetStringAsync(
                            objHasRating.RatingLabel));
                    await lblGearRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is Gear objGear)
                {
                    await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                    await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                    await tabGearCM.DoThreadSafeAsync(x => x.Visible = true, token);
                    token.ThrowIfCancellationRequested();
                    // Buttons
                    await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token);
                    // gpbGearCommon
                    await lblGearName.DoThreadSafeAsync(x => x.Text = objGear.CurrentDisplayNameShort, token);
                    await lblGearCategory.DoThreadSafeAsync(x => x.Text = objGear.DisplayCategory(GlobalSettings.Language), token);
                    int intGearMaxRatingValue = objGear.MaxRatingValue;
                    if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                    {
                        await lblGearRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblGearRating.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objGear.Rating.ToString(GlobalSettings.CultureInfo);
                        }, token);
                    }
                    else
                    {
                        await lblGearRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblGearRating.DoThreadSafeAsync(x => x.Visible = false, token);
                    }
                    await lblGearQty.DoThreadSafeAsync(x => x.Text = objGear.Quantity.ToString(GlobalSettings.CultureInfo), token);
                    await cmdGearIncreaseQty.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Enabled = !objGear.IncludedInParent;
                    }, token);
                    await cmdGearReduceQty.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Enabled = !objGear.IncludedInParent;
                    }, token);
                    await cmdGearSplitQty.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Enabled = !objGear.IncludedInParent;
                    }, token);
                    await cmdGearMergeQty.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Enabled = !objGear.IncludedInParent;
                    }, token);
                    await cmdGearMoveToVehicle.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Enabled = !objGear.IncludedInParent && objGear.LoadedIntoClip == null && CharacterObject.Vehicles.Count > 0;
                    }, token);
                    await lblGearAvail.DoThreadSafeAsync(x => x.Text = objGear.DisplayTotalAvail, token);
                    try
                    {
                        await lblGearCost.DoThreadSafeAsync(x => x.Text
                                                                = objGear.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                    GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                    }
                    catch (FormatException)
                    {
                        await lblGearCost.DoThreadSafeAsync(x => x.Text = objGear.Cost + LanguageManager.GetString("String_NuyenSymbol"), token);
                    }
                    await lblGearCapacity.DoThreadSafeAsync(x => x.Text = objGear.DisplayCapacity, token);
                    await chkGearEquipped.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Checked = objGear.Equipped;
                    }, token);
                    // If this is a Program, determine if its parent Gear (if any) is a Commlink. If so, show the Equipped checkbox.
                    if (objGear.IsProgram && objGear.Parent is IHasMatrixAttributes objCommlink
                                          && objCommlink.IsCommlink)
                    {
                        string strText = await LanguageManager.GetStringAsync("Checkbox_SoftwareRunning");
                        await chkGearEquipped.DoThreadSafeAsync(x => x.Text = strText, token);
                    }
                    else
                    {
                        string strText = await LanguageManager.GetStringAsync("Checkbox_Equipped");
                        await chkGearEquipped.DoThreadSafeAsync(x => x.Text = strText, token);
                    }
                    // gpbGearMatrix
                    int intDeviceRating = objGear.GetTotalMatrixAttribute("Device Rating");
                    await lblGearDeviceRating.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                    await objGear.RefreshMatrixAttributeComboBoxesAsync(cboGearAttack, cboGearSleaze,
                                                                        cboGearDataProcessing, cboGearFirewall, token);
                    if (CharacterObject.IsAI)
                    {
                        await chkGearHomeNode.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objGear.IsHomeNode(CharacterObject);
                            x.Enabled = objGear.IsCommlink &&
                                        objGear.GetTotalMatrixAttribute("Program Limit") >=
                                        (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                        }, token);
                    }
                    else
                        await chkGearHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                    await chkGearActiveCommlink.DoThreadSafeAsync(x =>
                    {
                        x.Checked = objGear.IsActiveCommlink(CharacterObject);
                        x.Visible = objGear.IsCommlink;
                    }, token);
                    if (CharacterObject.Overclocker && objGear.Category == "Cyberdecks")
                    {
                        using (new FetchSafelyFromPool<List<ListItem>>(
                                   Utils.ListItemListPool, out List<ListItem> lstOverclocker))
                        {
                            lstOverclocker.Add(
                                new ListItem("None", await LanguageManager.GetStringAsync("String_None")));
                            lstOverclocker.Add(
                                new ListItem("Attack", await LanguageManager.GetStringAsync("String_Attack")));
                            lstOverclocker.Add(
                                new ListItem("Sleaze", await LanguageManager.GetStringAsync("String_Sleaze")));
                            lstOverclocker.Add(new ListItem("Data Processing",
                                                            await LanguageManager.GetStringAsync(
                                                                "String_DataProcessing")));
                            lstOverclocker.Add(
                                new ListItem("Firewall", await LanguageManager.GetStringAsync("String_Firewall")));

                            await cboGearOverclocker.PopulateWithListItemsAsync(lstOverclocker, token);
                            await cboGearOverclocker.DoThreadSafeAsync(x =>
                            {
                                x.SelectedValue = objGear.Overclocked;
                                if (x.SelectedIndex == -1)
                                    x.SelectedIndex = 0;
                            }, token);
                        }

                        await cboGearOverclocker.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblGearOverclockerLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    }
                    else
                    {
                        await cboGearOverclocker.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblGearOverclockerLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    }
                    await treGear.DoThreadSafeAsync(x => x.SelectedNode.Text = objGear.CurrentDisplayName, token);
                    await ProcessEquipmentConditionMonitorBoxDisplays(panGearMatrixCM, objGear.MatrixCM,
                                                                      objGear.MatrixCMFilled, token);
                    if (objGear.LoadedIntoClip != null)
                    {
                        await cmdGearIncreaseQty.DoThreadSafeAsync(x => x.Enabled = false);
                        await cmdGearReduceQty.DoThreadSafeAsync(x => x.Enabled = false);
                        await cmdGearMergeQty.DoThreadSafeAsync(x => x.Enabled = false);
                        await cmdGearSplitQty.DoThreadSafeAsync(x => x.Enabled = false);
                        await cmdGearMoveToVehicle.DoThreadSafeAsync(x => x.Enabled = false);
                    }
                }
                else
                {
                    await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                    await tabGearCM.DoThreadSafeAsync(x => x.Visible = false, token);
                    // Buttons
                    await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                }
            }
            finally
            {
                await flpGear.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        protected override string FormMode => LanguageManager.GetString("Title_CareerMode");

        /// <summary>
        /// Open the Select Cyberware window and handle adding to the Tree and Character.
        /// </summary>
        private async ValueTask<bool> PickCyberware(Cyberware objSelectedCyberware, Improvement.ImprovementSource objSource)
        {
            using (ThreadSafeForm<SelectCyberware> frmPickCyberware
                   = await ThreadSafeForm<SelectCyberware>.GetAsync(
                       () => new SelectCyberware(CharacterObject, objSource, objSelectedCyberware)))
            {
                List<Improvement> lstUsedImprovements;
                decimal decMultiplier = 1.0m;
                switch (objSource)
                {
                    // Apply the character's Cyberware Essence cost multiplier if applicable.
                    case Improvement.ImprovementSource.Cyberware:
                        {
                            lstUsedImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.CyberwareEssCost);
                            if (lstUsedImprovements.Count != 0)
                            {
                                foreach (Improvement objImprovement in lstUsedImprovements)
                                {
                                    decMultiplier -= 1 - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterESSMultiplier *= decMultiplier;
                            }

                            lstUsedImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.CyberwareTotalEssMultiplier);
                            if (lstUsedImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstUsedImprovements)
                                {
                                    decMultiplier *= objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                            }

                            lstUsedImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.CyberwareEssCostNonRetroactive);
                            if (lstUsedImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstUsedImprovements)
                                {
                                    decMultiplier -= 1 - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterESSMultiplier *= decMultiplier;
                            }

                            lstUsedImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.CyberwareTotalEssMultiplierNonRetroactive);
                            if (lstUsedImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstUsedImprovements)
                                {
                                    decMultiplier *= objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                            }

                            break;
                        }
                    // Apply the character's Bioware Essence cost multiplier if applicable.
                    case Improvement.ImprovementSource.Bioware:
                        {
                            lstUsedImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.BiowareEssCost);
                            if (lstUsedImprovements.Count != 0)
                            {
                                foreach (Improvement objImprovement in lstUsedImprovements)
                                {
                                    decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterESSMultiplier = decMultiplier;
                            }

                            lstUsedImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.BiowareTotalEssMultiplier);
                            if (lstUsedImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstUsedImprovements)
                                {
                                    decMultiplier *= objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                            }

                            lstUsedImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.BiowareEssCostNonRetroactive);
                            if (lstUsedImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstUsedImprovements)
                                {
                                    decMultiplier -= 1 - objImprovement.Value / 100;
                                }

                                frmPickCyberware.MyForm.CharacterESSMultiplier = decMultiplier;
                            }

                            lstUsedImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.BiowareTotalEssMultiplierNonRetroactive);
                            if (lstUsedImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstUsedImprovements)
                                {
                                    decMultiplier *= objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                            }

                            // Apply the character's Basic Bioware Essence cost multiplier if applicable.
                            lstUsedImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.BasicBiowareEssCost);
                            if (lstUsedImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstUsedImprovements)
                                {
                                    decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.BasicBiowareESSMultiplier = decMultiplier;
                            }

                            // Genetech Cost multiplier.
                            lstUsedImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.GenetechCostMultiplier);
                            if (lstUsedImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstUsedImprovements)
                                {
                                    decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.GenetechCostMultiplier = decMultiplier;
                            }

                            // Apply the character's Genetech Essence cost multiplier if applicable.
                            lstUsedImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.GenetechEssMultiplier);
                            if (lstUsedImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstUsedImprovements)
                                {
                                    decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.GenetechEssMultiplier = decMultiplier;
                            }

                            break;
                        }
                }

                Dictionary<string, int> dicDisallowedMounts = new Dictionary<string, int>(6);
                Dictionary<string, int> dicHasMounts = new Dictionary<string, int>(6);
                if (objSelectedCyberware != null)
                {
                    frmPickCyberware.MyForm.ForcedGrade = objSelectedCyberware.Grade;
                    frmPickCyberware.MyForm.LockGrade();
                    frmPickCyberware.MyForm.Subsystems = objSelectedCyberware.AllowedSubsystems;
                    // If the Cyberware has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that consume Capacity).
                    if (!objSelectedCyberware.Capacity.Contains('['))
                    {
                        frmPickCyberware.MyForm.MaximumCapacity = objSelectedCyberware.CapacityRemaining;

                        // Do not allow the user to add a new piece of Cyberware if its Capacity has been reached.
                        if (CharacterObjectSettings.EnforceCapacity && objSelectedCyberware.CapacityRemaining < 0)
                        {
                            Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CapacityReached"), await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                            return false;
                        }
                    }

                    foreach (string strLoop in objSelectedCyberware.BlocksMounts.SplitNoAlloc(',',
                        StringSplitOptions.RemoveEmptyEntries))
                    {
                        if (!dicDisallowedMounts.ContainsKey(strLoop))
                            dicDisallowedMounts.Add(strLoop, int.MaxValue);
                    }
                    string strLoopHasModularMount = objSelectedCyberware.HasModularMount;
                    if (!string.IsNullOrEmpty(strLoopHasModularMount) && !dicHasMounts.ContainsKey(strLoopHasModularMount))
                        dicHasMounts.Add(strLoopHasModularMount, int.MaxValue);
                    foreach (Cyberware objLoopCyberware in objSelectedCyberware.Children.DeepWhere(x => x.Children, x => string.IsNullOrEmpty(x.PlugsIntoModularMount)))
                    {
                        foreach (string strLoop in objLoopCyberware.BlocksMounts.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries))
                        {
                            string strKey = strLoop;
                            if (objSelectedCyberware.Location != objLoopCyberware.Location)
                                strKey += objLoopCyberware.Location;
                            if (!dicDisallowedMounts.ContainsKey(strKey))
                                dicDisallowedMounts.Add(strKey, int.MaxValue);
                        }
                        strLoopHasModularMount = objSelectedCyberware.Location != objLoopCyberware.Location
                            ? objLoopCyberware.HasModularMount + objLoopCyberware.Location
                            : objLoopCyberware.HasModularMount;
                        if (!string.IsNullOrEmpty(strLoopHasModularMount) && !dicHasMounts.ContainsKey(strLoopHasModularMount))
                            dicHasMounts.Add(strLoopHasModularMount, int.MaxValue);
                    }
                }
                else
                {
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setLoopDisallowedMounts))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setLoopHasModularMount))
                    {
                        foreach (Cyberware objLoopCyberware in CharacterObject.Cyberware)
                        {
                            setLoopDisallowedMounts.Clear();
                            setLoopDisallowedMounts.AddRange(
                                objLoopCyberware.BlocksMounts.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries));
                            setLoopHasModularMount.Clear();
                            if (!string.IsNullOrEmpty(objLoopCyberware.HasModularMount))
                                setLoopHasModularMount.Add(objLoopCyberware.HasModularMount);
                            foreach (Cyberware objInnerLoopCyberware in objLoopCyberware.Children.DeepWhere(
                                         x => x.Children, x => string.IsNullOrEmpty(x.PlugsIntoModularMount)))
                            {
                                foreach (string strLoop in objInnerLoopCyberware.BlocksMounts.SplitNoAlloc(
                                             ',', StringSplitOptions.RemoveEmptyEntries))
                                    setLoopDisallowedMounts.Add(strLoop);
                                if (!string.IsNullOrEmpty(objInnerLoopCyberware.HasModularMount))
                                    setLoopHasModularMount.Add(objInnerLoopCyberware.HasModularMount);
                            }

                            foreach (string strLoop in setLoopDisallowedMounts)
                            {
                                string strKey = strLoop + objLoopCyberware.Location;
                                if (!dicDisallowedMounts.ContainsKey(strKey))
                                    dicDisallowedMounts.Add(strKey, objLoopCyberware.LimbSlotCount);
                                else
                                    dicDisallowedMounts[strKey] += objLoopCyberware.LimbSlotCount;
                            }

                            foreach (string strLoop in setLoopHasModularMount)
                            {
                                string strKey = strLoop + objLoopCyberware.Location;
                                if (!dicHasMounts.ContainsKey(strKey))
                                    dicHasMounts.Add(strKey, objLoopCyberware.LimbSlotCount);
                                else
                                    dicHasMounts[strKey] += objLoopCyberware.LimbSlotCount;
                            }
                        }
                    }
                }

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdDisallowedMounts))
                {
                    foreach (KeyValuePair<string, int> kvpLoop in dicDisallowedMounts)
                    {
                        string strKey = kvpLoop.Key;
                        if (strKey.EndsWith("Right", StringComparison.Ordinal))
                            continue;
                        int intValue = kvpLoop.Value;
                        if (strKey.EndsWith("Left", StringComparison.Ordinal))
                        {
                            strKey = strKey.TrimEndOnce("Left", true);
                            intValue = dicDisallowedMounts.TryGetValue(strKey + "Right", out int intExistingValue)
                                ? 2 * Math.Min(intValue, intExistingValue)
                                : 0;
                            if (dicDisallowedMounts.TryGetValue(strKey, out intExistingValue))
                                intValue += intExistingValue;
                        }

                        if (intValue >= await CharacterObject.LimbCountAsync(Cyberware.MountToLimbType(strKey)))
                            sbdDisallowedMounts.Append(strKey).Append(',');
                    }

                    // Remove trailing ","
                    if (sbdDisallowedMounts.Length > 0)
                        --sbdDisallowedMounts.Length;
                    frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                }

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdHasMounts))
                {
                    foreach (KeyValuePair<string, int> kvpLoop in dicHasMounts)
                    {
                        string strKey = kvpLoop.Key;
                        if (strKey.EndsWith("Right", StringComparison.Ordinal))
                            continue;
                        int intValue = kvpLoop.Value;
                        if (strKey.EndsWith("Left", StringComparison.Ordinal))
                        {
                            strKey = strKey.TrimEndOnce("Left", true);
                            intValue = dicHasMounts.TryGetValue(strKey + "Right", out int intExistingValue)
                                ? 2 * Math.Min(intValue, intExistingValue)
                                : 0;
                            if (dicHasMounts.TryGetValue(strKey, out intExistingValue))
                                intValue += intExistingValue;
                        }

                        if (intValue >= await CharacterObject.LimbCountAsync(Cyberware.MountToLimbType(strKey)))
                            sbdHasMounts.Append(strKey).Append(',');
                    }

                    // Remove trailing ","
                    if (sbdHasMounts.Length > 0)
                        --sbdHasMounts.Length;
                    frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                }

                // Make sure the dialogue window was not canceled.
                if (await frmPickCyberware.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return false;

                // Open the Cyberware XML file and locate the selected piece.
                XmlNode objXmlCyberware = objSource == Improvement.ImprovementSource.Bioware
                    ? (await CharacterObject.LoadDataAsync("bioware.xml")).SelectSingleNode("/chummer/biowares/bioware[id = " + frmPickCyberware.MyForm.SelectedCyberware.CleanXPath() + ']')
                    : (await CharacterObject.LoadDataAsync("cyberware.xml")).SelectSingleNode("/chummer/cyberwares/cyberware[id = " + frmPickCyberware.MyForm.SelectedCyberware.CleanXPath() + ']');

                Cyberware objCyberware = new Cyberware(CharacterObject) { ESSDiscount = frmPickCyberware.MyForm.SelectedESSDiscount, Parent = objSelectedCyberware };
                if (!objCyberware.Purchase(objXmlCyberware, objSource, frmPickCyberware.MyForm.SelectedGrade,
                                           frmPickCyberware.MyForm.SelectedRating, null,
                                           objSelectedCyberware?.Children ?? CharacterObject.Cyberware,
                                           CharacterObject.Vehicles,
                                           CharacterObject.Weapons, frmPickCyberware.MyForm.Markup, frmPickCyberware.MyForm.FreeCost,
                                           frmPickCyberware.MyForm.BlackMarketDiscount, objParent: objSelectedCyberware))
                    objCyberware.DeleteCyberware();

                return frmPickCyberware.MyForm.AddAgain;
            }
        }

        /// <summary>
        /// Select a piece of Gear to be added to the character.
        /// </summary>
        /// <param name="iParent">Parent to which the gear should be added.</param>
        /// <param name="objLocation">Location to which the gear should be added.</param>
        /// <param name="objStackGear">Whether or not the selected item should stack with a matching item on the character.</param>
        /// <param name="strForceItemValue">Force the user to select an item with the passed name.</param>
        /// <param name="objAmmoForWeapon">Gear is being bought as ammo for this weapon.</param>
        private async ValueTask<bool> PickGear(IHasChildren<Gear> iParent, Location objLocation = null, Gear objStackGear = null, string strForceItemValue = "", Weapon objAmmoForWeapon = null)
        {
            bool blnNullParent = false;
            Gear objSelectedGear = null;
            if (iParent is Gear gear)
            {
                objSelectedGear = gear;
            }
            else
            {
                blnNullParent = true;
            }

            // Open the Gear XML file and locate the selected Gear.
            XPathNavigator xmlParent = blnNullParent ? null : await objSelectedGear.GetNodeXPathAsync();

            using (await CursorWait.NewAsync(this))
            {
                string strCategories = string.Empty;

                if (xmlParent != null)
                {
                    XPathNodeIterator xmlAddonCategoryList = xmlParent.Select("addoncategory");
                    if (xmlAddonCategoryList.Count > 0)
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(
                                   Utils.StringBuilderPool, out StringBuilder sbdCategories))
                        {
                            foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                                sbdCategories.Append(objXmlCategory.Value).Append(',');
                            // Remove the trailing comma.
                            --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }
                }

                using (ThreadSafeForm<SelectGear> frmPickGear
                       = await ThreadSafeForm<SelectGear>.GetAsync(() => new SelectGear(CharacterObject,
                                                                       objSelectedGear?.ChildAvailModifier ?? 0,
                                                                       objSelectedGear?.ChildCostMultiplier ?? 1,
                                                                       objSelectedGear, strCategories)
                                                                   {
                                                                       ShowFlechetteAmmoOnly = objAmmoForWeapon?.Damage.EndsWith("(f)", StringComparison.Ordinal)
                                                                           == true
                                                                   }))
                {
                    if (!blnNullParent)
                    {
                        // If the Gear has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that consume Capacity).
                        if (!string.IsNullOrEmpty(objSelectedGear.Capacity) && !objSelectedGear.Capacity.Contains('[')
                            || objSelectedGear.Capacity.Contains("/["))
                        {
                            frmPickGear.MyForm.MaximumCapacity = objSelectedGear.CapacityRemaining;

                            // Do not allow the user to add a new piece of Gear if its Capacity has been reached.
                            if (CharacterObjectSettings.EnforceCapacity && objSelectedGear.CapacityRemaining < 0)
                            {
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_CapacityReached"),
                                    await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                                return false;
                            }

                            if (!string.IsNullOrEmpty(strCategories))
                                frmPickGear.MyForm.ShowNegativeCapacityOnly = true;
                        }

                        // If a Commlink has just been added, see if the character already has one. If not, make it the active Commlink.
                        if (CharacterObject.ActiveCommlink == null && objSelectedGear.IsCommlink)
                        {
                            objSelectedGear.SetActiveCommlink(CharacterObject, true);
                        }
                    }

                    frmPickGear.MyForm.DefaultSearchText = strForceItemValue;
                    frmPickGear.MyForm.ForceItemAmmoForWeaponType = objAmmoForWeapon?.WeaponType ?? string.Empty;

                    // Make sure the dialogue window was not canceled.
                    if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return false;

                    // Open the Cyberware XML file and locate the selected piece.
                    XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
                    XmlNode objXmlGear
                        = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                          + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                    // Create the new piece of Gear.
                    List<Weapon> lstWeapons = new List<Weapon>(1);

                    string strForceValue = objStackGear?.Extra ?? strForceItemValue;
                    if (string.IsNullOrEmpty(strForceValue) && objAmmoForWeapon != null)
                    {
                        //If the amount of an ammunition was increased, force the correct weapon category.
                        strForceValue = objAmmoForWeapon.AmmoCategory;
                    }

                    Gear objGear = new Gear(CharacterObject);
                    objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, strForceValue,
                                   objSelectedGear?.Equipped != false);

                    if (objGear.InternalId.IsEmptyGuid())
                        return frmPickGear.MyForm.AddAgain;

                    objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                    objGear.Parent = blnNullParent ? null : objSelectedGear;

                    //Reduce the Cost for Black Market Pipeline
                    objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                    // Reduce the cost for Do It Yourself components.
                    if (frmPickGear.MyForm.DoItYourself)
                        objGear.Cost = '(' + objGear.Cost + ") * 0.5";

                    decimal decCost;
                    if (objGear.Cost.Contains("Gear Cost"))
                    {
                        string strCost = objGear.Cost.Replace("Gear Cost",
                                                              (objSelectedGear?.CalculatedCost ?? 0).ToString(
                                                                  GlobalSettings.InvariantCultureInfo));
                        (bool blnIsSuccess, object objProcess)
                            = await CommonFunctions.EvaluateInvariantXPathAsync(strCost);
                        decCost = blnIsSuccess
                            ? Convert.ToDecimal(objProcess, GlobalSettings.InvariantCultureInfo)
                            : objGear.TotalCost;
                    }
                    else
                    {
                        decCost = objGear.TotalCost;
                    }

                    Gear objStackWith = null;
                    // See if the character already has the item on them if they chose to stack.
                    if (frmPickGear.MyForm.Stack)
                    {
                        objStackWith = objStackGear
                                       ?? CharacterObject.Gear.FirstOrDefault(x => x.Location == objLocation
                                                                                  && objGear.IsIdenticalToOtherGear(x));
                    }

                    if (objStackWith != null)
                    {
                        if (objStackWith.InternalId.IsEmptyGuid())
                            return frmPickGear.MyForm.AddAgain;
                        // If a match was found, we need to use the cost of a single item in the stack which can include plugins.
                        foreach (Gear objPlugin in objStackWith.Children)
                            decCost += objPlugin.TotalCost * frmPickGear.MyForm.SelectedQty;
                    }

                    // Apply a markup if applicable.
                    if (frmPickGear.MyForm.Markup != 0)
                    {
                        decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                    }

                    // Multiply the cost if applicable.
                    char chrAvail = (await objGear.TotalAvailTupleAsync()).Suffix;
                    switch (chrAvail)
                    {
                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                            break;

                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                            break;
                    }

                    if (!blnNullParent && objStackWith == null)
                    {
                        // Do not allow the user to add a new piece of Cyberware if its Capacity has been reached.
                        if (CharacterObjectSettings.EnforceCapacity &&
                            objSelectedGear.CapacityRemaining - objGear.PluginCapacity < 0)
                        {
                            Program.ShowMessageBox(
                                this, await LanguageManager.GetStringAsync("Message_CapacityReached"),
                                await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"),
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Information);
                            return frmPickGear.MyForm.AddAgain;
                        }

                        // Multiply cost by parent gear's quantity
                        decCost *= objSelectedGear.Quantity;
                    }

                    ExpenseUndo objUndo = new ExpenseUndo();
                    // Check the item's Cost and make sure the character can afford it.
                    if (!frmPickGear.MyForm.FreeCost)
                    {
                        if (decCost > CharacterObject.Nuyen)
                        {
                            Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                                   await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                                   MessageBoxButtons.OK, MessageBoxIcon.Information);
                            // Remove any Improvements created by the Gear.
                            await ImprovementManager.RemoveImprovementsAsync(
                                CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId);
                            return frmPickGear.MyForm.AddAgain;
                        }

                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(decCost * -1,
                                          await LanguageManager.GetStringAsync("String_ExpensePurchaseGear")
                                          + await LanguageManager.GetStringAsync("String_Space")
                                          + objGear.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                          DateTime.Now);
                        CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                        CharacterObject.Nuyen -= decCost;

                        objUndo.CreateNuyen(NuyenExpenseType.AddGear, objGear.InternalId, objGear.Quantity);
                        objExpense.Undo = objUndo;
                    }

                    if (objStackWith != null)
                    {
                        // A match was found, so increase the quantity instead.
                        objStackWith.Quantity += objGear.Quantity;

                        if (!string.IsNullOrEmpty(objUndo.ObjectId))
                            objUndo.ObjectId = objStackWith.InternalId;
                    }
                    // Add the Gear.
                    else
                    {
                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }

                        if (objLocation != null)
                            await objLocation.Children.AddAsync(objGear);
                        if (!blnNullParent)
                        {
                            await objSelectedGear.Children.AddAsync(objGear);
                        }
                        else
                        {
                            await CharacterObject.Gear.AddAsync(objGear);
                        }
                    }

                    return frmPickGear.MyForm.AddAgain;
                }
            }
        }

        /// <summary>
        /// Select a piece of Gear and add it to a piece of Armor.
        /// </summary>
        /// <param name="blnShowArmorCapacityOnly">Whether or not only items that consume capacity should be shown.</param>
        /// <param name="strSelectedId">Id attached to the object to which the gear should be added.</param>
        private async ValueTask<bool> PickArmorGear(string strSelectedId, bool blnShowArmorCapacityOnly = false)
        {
            Gear objSelectedGear = null;
            Armor objSelectedArmor = CharacterObject.Armor.FindById(strSelectedId);
            ArmorMod objSelectedMod = null;

            if (objSelectedArmor == null)
            {
                objSelectedGear = CharacterObject.Armor.FindArmorGear(strSelectedId, out objSelectedArmor, out objSelectedMod);
                if (objSelectedGear == null)
                    objSelectedMod = CharacterObject.Armor.FindArmorMod(strSelectedId);
            }

            // Open the Gear XML file and locate the selected Gear.
            object objParent = objSelectedGear ?? objSelectedMod ?? (object)objSelectedArmor;

            using (await CursorWait.NewAsync(this))
            {
                string strCategories = string.Empty;

                if (!string.IsNullOrEmpty(strSelectedId) && objParent is IHasXmlDataNode objParentWithDataNode)
                {
                    XPathNodeIterator xmlAddonCategoryList
                        = (await objParentWithDataNode.GetNodeXPathAsync())?.Select("addoncategory");
                    if (xmlAddonCategoryList?.Count > 0)
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdCategories))
                        {
                            foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                                sbdCategories.Append(objXmlCategory.Value).Append(',');
                            // Remove the trailing comma.
                            if (sbdCategories.Length > 0)
                                --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }
                }

                using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(
                           () => new SelectGear(CharacterObject, 0, 1, objParent, strCategories)
                           {
                               EnableStack = false,
                               ShowArmorCapacityOnly = blnShowArmorCapacityOnly,
                               CapacityDisplayStyle = objSelectedMod != null
                                   ? CapacityStyle.Standard
                                   : objSelectedArmor.CapacityDisplayStyle
                           }))
                {
                    // If the Gear has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that consume Capacity).
                    if (!string.IsNullOrEmpty(strSelectedId))
                    {
                        if (objSelectedGear != null && (!objSelectedGear.Capacity.Contains('[')
                                                        || objSelectedGear.Capacity.Contains("/[")))
                        {
                            frmPickGear.MyForm.MaximumCapacity = objSelectedGear.CapacityRemaining;

                            // Do not allow the user to add a new piece of Gear if its Capacity has been reached.
                            if (CharacterObjectSettings.EnforceCapacity && objSelectedGear.CapacityRemaining < 0)
                            {
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_CapacityReached"),
                                    await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"),
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Information);
                                return false;
                            }
                        }
                        else if (objSelectedMod != null)
                        {
                            frmPickGear.MyForm.MaximumCapacity = objSelectedMod.GearCapacityRemaining;

                            // Do not allow the user to add a new piece of Gear if its Capacity has been reached.
                            if (CharacterObjectSettings.EnforceCapacity && objSelectedMod.GearCapacityRemaining < 0)
                            {
                                Program.ShowMessageBox(
                                    this, await LanguageManager.GetStringAsync("Message_CapacityReached"),
                                    await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"),
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Information);
                                return false;
                            }
                        }
                    }

                    // Make sure the dialogue window was not canceled.
                    if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return false;

                    // Open the Cyberware XML file and locate the selected piece.
                    XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
                    XmlNode objXmlGear
                        = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                          + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                    // Create the new piece of Gear.
                    List<Weapon> lstWeapons = new List<Weapon>(1);

                    Gear objGear = new Gear(CharacterObject);
                    objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty,
                                   objSelectedGear?.Equipped ?? objSelectedMod?.Equipped ?? objSelectedArmor.Equipped);

                    if (objGear.InternalId.IsEmptyGuid())
                        return frmPickGear.MyForm.AddAgain;

                    objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                    if (objSelectedGear != null)
                        objGear.Parent = objSelectedGear;

                    // Reduce the cost for Do It Yourself components.
                    if (frmPickGear.MyForm.DoItYourself)
                        objGear.Cost = '(' + objGear.Cost + ") * 0.5";

                    // Apply a markup if applicable.
                    decimal decCost = objGear.TotalCost;
                    if (frmPickGear.MyForm.Markup != 0)
                    {
                        decCost *= 1 + frmPickGear.MyForm.Markup / 100.0m;
                    }

                    // Multiply the cost if applicable.
                    char chrAvail = (await objGear.TotalAvailTupleAsync()).Suffix;
                    switch (chrAvail)
                    {
                        case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                            decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                            break;

                        case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                            decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                            break;
                    }

                    Gear objMatchingGear = null;
                    // If this is Ammunition, see if the character already has it on them.
                    if (objGear.Category == "Ammunition" || !string.IsNullOrEmpty(objGear.AmmoForWeaponType))
                    {
                        TaggedObservableCollection<Gear> lstToSearch = string.IsNullOrEmpty(objSelectedGear?.Name)
                            ? objSelectedArmor.GearChildren
                            : objSelectedGear.Children;
                        objMatchingGear = lstToSearch.FirstOrDefault(x => objGear.IsIdenticalToOtherGear(x));
                    }

                    decimal decGearQuantity = 0;
                    if (objMatchingGear != null)
                    {
                        decGearQuantity = objGear.Quantity;
                        // A match was found, so increase the quantity instead.
                        objMatchingGear.Quantity += decGearQuantity;

                        objGear.DeleteGear();
                        if (CharacterObjectSettings.EnforceCapacity && objMatchingGear.CapacityRemaining < 0)
                        {
                            objMatchingGear.Quantity -= decGearQuantity;
                            Program.ShowMessageBox(
                                this, await LanguageManager.GetStringAsync("Message_CapacityReached"),
                                await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"),
                                MessageBoxButtons.OK, MessageBoxIcon.Information);
                            return frmPickGear.MyForm.AddAgain;
                        }
                    }
                    // Add the Gear.
                    else if (!string.IsNullOrEmpty(objSelectedGear?.Name))
                    {
                        await objSelectedGear.Children.AddAsync(objGear);
                        if (CharacterObjectSettings.EnforceCapacity && objSelectedGear.CapacityRemaining < 0)
                        {
                            objGear.DeleteGear();
                            Program.ShowMessageBox(
                                this, await LanguageManager.GetStringAsync("Message_CapacityReached"),
                                await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"),
                                MessageBoxButtons.OK, MessageBoxIcon.Information);
                            return frmPickGear.MyForm.AddAgain;
                        }
                    }
                    else if (!string.IsNullOrEmpty(objSelectedMod?.Name))
                    {
                        await objSelectedMod.GearChildren.AddAsync(objGear);
                        if (CharacterObjectSettings.EnforceCapacity && objSelectedMod.GearCapacityRemaining < 0)
                        {
                            objGear.DeleteGear();
                            Program.ShowMessageBox(
                                this, await LanguageManager.GetStringAsync("Message_CapacityReached"),
                                await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"),
                                MessageBoxButtons.OK, MessageBoxIcon.Information);
                            return frmPickGear.MyForm.AddAgain;
                        }
                    }
                    else
                    {
                        await objSelectedArmor.GearChildren.AddAsync(objGear);
                        if (CharacterObjectSettings.EnforceCapacity && objSelectedArmor.CapacityRemaining < 0)
                        {
                            objGear.DeleteGear();
                            Program.ShowMessageBox(
                                this, await LanguageManager.GetStringAsync("Message_CapacityReached"),
                                await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"),
                                MessageBoxButtons.OK, MessageBoxIcon.Information);
                            return frmPickGear.MyForm.AddAgain;
                        }
                    }

                    // Check the item's Cost and make sure the character can afford it.
                    if (!frmPickGear.MyForm.FreeCost)
                    {
                        if (decCost > CharacterObject.Nuyen)
                        {
                            // Remove the added gear
                            if (objMatchingGear != null)
                                objMatchingGear.Quantity -= decGearQuantity;
                            // Remove any Improvements created by the Gear.
                            else
                                objGear.DeleteGear();
                            Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                                                   await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                                                   MessageBoxButtons.OK, MessageBoxIcon.Information);
                            return frmPickGear.MyForm.AddAgain;
                        }

                        // Create the Expense Log Entry.
                        ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                        objExpense.Create(decCost * -1,
                                          await LanguageManager.GetStringAsync("String_ExpensePurchaseArmorGear")
                                          + await LanguageManager.GetStringAsync("String_Space")
                                          + objGear.CurrentDisplayNameShort, ExpenseType.Nuyen,
                                          DateTime.Now);
                        CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                        CharacterObject.Nuyen -= decCost;

                        ExpenseUndo objUndo = new ExpenseUndo();
                        objUndo.CreateNuyen(NuyenExpenseType.AddArmorGear,
                                            objMatchingGear != null ? objMatchingGear.InternalId : objGear.InternalId,
                                            objGear.Quantity);
                        objExpense.Undo = objUndo;
                    }

                    // Create any Weapons that came with this Gear.
                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objWeapon);
                    }

                    return frmPickGear.MyForm.AddAgain;
                }
            }
        }

        /// <summary>
        /// Refresh the currently-selected Lifestyle.
        /// </summary>
        private async Task RefreshSelectedLifestyle(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpLifestyleDetails.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                token.ThrowIfCancellationRequested();
                object objSelectedNodeTag = await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token);
                if (objSelectedNodeTag == null || await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode.Level == 0, token)
                                               || !(objSelectedNodeTag is Lifestyle objLifestyle))
                {
                    await flpLifestyleDetails.DoThreadSafeAsync(x => x.Visible = false, token);
                    await cmdDeleteLifestyle.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                    return;
                }
                await flpLifestyleDetails.DoThreadSafeAsync(x => x.Visible = true, token);
                await cmdDeleteLifestyle.DoThreadSafeAsync(x => x.Enabled = true, token);
                await lblLifestyleCost.DoThreadSafeAsync(x => x.Text
                                                             = objLifestyle.TotalMonthlyCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                 GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                await lblLifestyleMonths.DoThreadSafeAsync(x => x.Text = objLifestyle.Increments.ToString(GlobalSettings.CultureInfo), token);
                await objLifestyle.SetSourceDetailAsync(lblLifestyleSource, token);
                string strCostLabelString;
                string strIncrementString;
                // Change the Cost/Month label.
                switch (objLifestyle.IncrementType)
                {
                    case LifestyleIncrement.Day:
                        strCostLabelString = await LanguageManager.GetStringAsync("Label_SelectLifestyle_CostPerDay");
                        strIncrementString = await LanguageManager.GetStringAsync("String_Days");
                        break;

                    case LifestyleIncrement.Week:
                        strCostLabelString = await LanguageManager.GetStringAsync("Label_SelectLifestyle_CostPerWeek");
                        strIncrementString = await LanguageManager.GetStringAsync("String_Weeks");
                        break;

                    default:
                        strCostLabelString = await LanguageManager.GetStringAsync("Label_SelectLifestyle_CostPerMonth");
                        strIncrementString = await LanguageManager.GetStringAsync("String_Months");
                        break;
                }
                await lblLifestyleCostLabel.DoThreadSafeAsync(x => x.Text = strCostLabelString, token);
                string strMonthsLabel = strIncrementString + string.Format(
                    GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Label_LifestylePermanent"),
                    objLifestyle.IncrementsRequiredForPermanent.ToString(GlobalSettings.CultureInfo));
                await lblLifestyleMonthsLabel.DoThreadSafeAsync(x => x.Text = strMonthsLabel, token);
                await cmdIncreaseLifestyleMonths.SetToolTipTextAsync(string.Format(GlobalSettings.CultureInfo,
                                                                         await LanguageManager.GetStringAsync(
                                                                             "Tab_IncreaseLifestyleMonths"),
                                                                         strIncrementString));
                await cmdDecreaseLifestyleMonths.SetToolTipTextAsync(string.Format(GlobalSettings.CultureInfo,
                                                                         await LanguageManager.GetStringAsync(
                                                                             "Tab_DecreaseLifestyleMonths"),
                                                                         strIncrementString));
                token.ThrowIfCancellationRequested();
                if (!string.IsNullOrEmpty(objLifestyle.BaseLifestyle))
                {
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdQualities))
                    {
                        sbdQualities.AppendJoin(',' + Environment.NewLine,
                                                objLifestyle.LifestyleQualities.Select(
                                                    r => r.CurrentFormattedDisplayName));
                        foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                     CharacterObject, Improvement.ImprovementType.LifestyleCost))
                        {
                            if (sbdQualities.Length > 0)
                                sbdQualities.AppendLine(',');

                            sbdQualities.Append(await CharacterObject.GetObjectNameAsync(objImprovement, token: token))
                                        .Append(await LanguageManager.GetStringAsync("String_Space")).Append('[')
                                        .Append(
                                            objImprovement.Value.ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo))
                                        .Append("%]");
                        }
                        await lblLifestyleQualities.DoThreadSafeAsync(x => x.Text = sbdQualities.ToString(), token);
                    }
                    await lblBaseLifestyle.DoThreadSafeAsync(x => x.Text = objLifestyle.CurrentDisplayName, token);
                    await lblLifestyleQualitiesLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblLifestyleQualities.DoThreadSafeAsync(x => x.Visible = true, token);
                }
                else
                {
                    string strError = await LanguageManager.GetStringAsync("String_Error");
                    await lblBaseLifestyle.DoThreadSafeAsync(x => x.Text = strError, token);
                    await lblLifestyleQualitiesLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblLifestyleQualities.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                //Controls Visibility and content of the City, District and Borough Labels
                if (!string.IsNullOrEmpty(objLifestyle.City))
                {
                    await lblLifestyleCity.DoThreadSafeAsync(x =>
                    {
                        x.Text = objLifestyle.City;
                        x.Visible = true;
                    }, token);
                    await lblLifestyleCityLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                }
                else
                {
                    await lblLifestyleCity.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblLifestyleCityLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                if (!string.IsNullOrEmpty(objLifestyle.District))
                {
                    await lblLifestyleDistrict.DoThreadSafeAsync(x =>
                    {
                        x.Text = objLifestyle.District;
                        x.Visible = true;
                    }, token);
                    await lblLifestyleDistrictLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                }
                else
                {
                    await lblLifestyleDistrict.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblLifestyleDistrictLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                if (!string.IsNullOrEmpty(objLifestyle.Borough))
                {
                    await lblLifestyleBorough.DoThreadSafeAsync(x =>
                    {
                        x.Text = objLifestyle.Borough;
                        x.Visible = true;
                    }, token);
                    await lblLifestyleBoroughLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                }
                else
                {
                    await lblLifestyleBorough.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblLifestyleBoroughLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                }
            }
            finally
            {
                await flpLifestyleDetails.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the currently-selected Vehicle.
        /// </summary>
        private async Task RefreshSelectedVehicle(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpVehicles.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                token.ThrowIfCancellationRequested();
                object objSelectedNodeTag = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token);
                if (objSelectedNodeTag == null || await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode.Level <= 0, token)
                                               || objSelectedNodeTag.ToString() == "String_WeaponMounts")
                {
                    await panVehicleCM.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                    token.ThrowIfCancellationRequested();
                    // Buttons
                    await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                    return;
                }
                string strSpace = await LanguageManager.GetStringAsync("String_Space");
                if (objSelectedNodeTag is IHasRating objHasRating)
                {
                    string strText = string.Format(
                        GlobalSettings.CultureInfo,
                        await LanguageManager.GetStringAsync(
                            "Label_RatingFormat"),
                        await LanguageManager.GetStringAsync(
                            objHasRating.RatingLabel));
                    await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                }
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblVehicleSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblVehicleSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblVehicleSource, token);
                }
                else
                {
                    await lblVehicleSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblVehicleSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                switch (objSelectedNodeTag)
                {
                    // Locate the selected Vehicle.
                    case Vehicle objVehicle:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = string.IsNullOrEmpty(objVehicle.ParentID), token);
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objVehicle.CurrentDisplayName, token);
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = objVehicle.DisplayCategory(GlobalSettings.Language), token);
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objVehicle.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objVehicle.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        if (CharacterObjectSettings.BookEnabled("R5"))
                        {
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleSlots.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            string strText = objVehicle.Slots.ToString(GlobalSettings.CultureInfo) + strSpace
                                + '('
                                + (objVehicle.Slots - objVehicle.SlotsUsed).ToString(
                                    GlobalSettings.CultureInfo)
                                + strSpace + await LanguageManager.GetStringAsync("String_Remaining")
                                + ')';
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strText;
                            }, token);
                        }
                        await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesVehicle
                        await lblVehicleHandling.DoThreadSafeAsync(x => x.Text = objVehicle.TotalHandling, token);
                        await lblVehicleAccel.DoThreadSafeAsync(x => x.Text = objVehicle.TotalAccel, token);
                        await lblVehicleSpeed.DoThreadSafeAsync(x => x.Text = objVehicle.TotalSpeed, token);
                        await lblVehiclePilot.DoThreadSafeAsync(x => x.Text = objVehicle.Pilot.ToString(GlobalSettings.CultureInfo), token);
                        await lblVehicleBody.DoThreadSafeAsync(x => x.Text = objVehicle.TotalBody.ToString(GlobalSettings.CultureInfo), token);
                        await lblVehicleArmor.DoThreadSafeAsync(x => x.Text = objVehicle.TotalArmor.ToString(GlobalSettings.CultureInfo), token);
                        await lblVehicleSeats.DoThreadSafeAsync(x => x.Text = objVehicle.TotalSeats.ToString(GlobalSettings.CultureInfo), token);
                        await lblVehicleSensor.DoThreadSafeAsync(x => x.Text = objVehicle.CalculatedSensor.ToString(GlobalSettings.CultureInfo), token);
                        if (CharacterObjectSettings.BookEnabled("R5"))
                        {
                            if (objVehicle.IsDrone && CharacterObjectSettings.DroneMods)
                            {
                                await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehiclePowertrain.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleCosmetic.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleElectromagneticLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleElectromagnetic.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleBodymod.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleWeaponsmod.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleProtection.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleDroneModSlots.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text
                                        = objVehicle.DroneModSlotsUsed.ToString(GlobalSettings.CultureInfo) + '/'
                                        + objVehicle.DroneModSlots.ToString(GlobalSettings.CultureInfo);
                                }, token);
                            }
                            else
                            {
                                await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehiclePowertrain.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.PowertrainModSlotsUsed();
                                }, token);
                                await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleCosmetic.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.CosmeticModSlotsUsed();
                                }, token);
                                await lblVehicleElectromagneticLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleElectromagnetic.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.ElectromagneticModSlotsUsed();
                                }, token);
                                await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleBodymod.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.BodyModSlotsUsed();
                                }, token);
                                await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleWeaponsmod.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.WeaponModSlotsUsed();
                                }, token);
                                await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleProtection.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.ProtectionModSlotsUsed();
                                }, token);
                                await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleDroneModSlots.DoThreadSafeAsync(x => x.Visible = false, token);
                            }
                        }
                        else
                        {
                            await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehiclePowertrain.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleCosmetic.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleElectromagneticLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleElectromagnetic.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleBodymod.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponsmod.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleProtection.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleDroneModSlots.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesMatrix
                        int intDeviceRating = objVehicle.GetTotalMatrixAttribute("Device Rating");
                        await lblVehicleDevice.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objVehicle.RefreshMatrixAttributeComboBoxesAsync(
                            cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, token);
                        await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objVehicle.IsCommlink;
                            x.Checked = objVehicle.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objVehicle.IsHomeNode(CharacterObject);
                                x.Enabled = objVehicle.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating
                                                ? 2
                                                : 1);
                            }, token);
                        }
                        else
                            await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        await UpdateSensor(objVehicle, token);
                        break;
                    }
                    case WeaponMount objWeaponMount:
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objWeaponMount.IncludedInVehicle, token);
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesCommon
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = objWeaponMount.DisplayCategory(GlobalSettings.Language), token);
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objWeaponMount.CurrentDisplayName, token);
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objWeaponMount.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objWeaponMount.TotalCost.ToString(
                                                                       CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo), token);
                        await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleSlots.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objWeaponMount.CalculatedSlots.ToString(GlobalSettings.CultureInfo);
                        }, token);
                        await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objWeaponMount.Equipped;
                            x.Enabled = !objWeaponMount.IncludedInVehicle;
                        }, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        break;

                    case VehicleMod objMod:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objMod.IncludedInVehicle, token);
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objMod.CurrentDisplayName, token);
                        string strText = await LanguageManager.GetStringAsync("String_VehicleModification");
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        if (!objMod.MaxRating.Equals("qty", StringComparison.OrdinalIgnoreCase))
                        {
                            if (objMod.MaxRating.Equals("seats", StringComparison.OrdinalIgnoreCase))
                            {
                                objMod.MaxRating = objMod.Parent.TotalSeats.ToString(GlobalSettings.CultureInfo);
                            }
                            else if (objMod.MaxRating.Equals("body", StringComparison.OrdinalIgnoreCase))
                            {
                                objMod.MaxRating = objMod.Parent.TotalBody.ToString(GlobalSettings.CultureInfo);
                            }
                            token.ThrowIfCancellationRequested();
                            if (Convert.ToInt32(objMod.MaxRating, GlobalSettings.InvariantCultureInfo) > 0)
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Text = objMod.Rating.ToString(GlobalSettings
                                                                        .CultureInfo);
                                    x.Visible = true;
                                }, token);
                            }
                            else
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token);
                            }
                        }
                        else
                        {
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleRating.DoThreadSafeAsync(x =>
                            {
                                x.Text = objMod.Rating.ToString(
                                    GlobalSettings.CultureInfo);
                                x.Visible = true;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objMod.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objMod.TotalCost.ToString(CharacterObjectSettings.NuyenFormat, GlobalSettings.CultureInfo)
                                                                     + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleSlots.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objMod.CalculatedSlots.ToString(GlobalSettings.CultureInfo);
                        }, token);
                        await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objMod.Equipped;
                            x.Enabled = !objMod.IncludedInVehicle;
                        }, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        break;
                    }
                    case Weapon objWeapon:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objWeapon.Cyberware
                                                                     && objWeapon.Category != "Gear"
                                                                     && !objWeapon.IncludedInWeapon
                                                                     && string.IsNullOrEmpty(objWeapon.ParentID)
                                                                     && !objWeapon.Category.StartsWith(
                                                                         "Quality", StringComparison.Ordinal), token);
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayName, token);
                        string strText = await objWeapon.DisplayCategoryAsync(GlobalSettings.Language);
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objWeapon.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objWeapon.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleSlots.DoThreadSafeAsync(x => x.Visible = true, token);
                        if (!string.IsNullOrWhiteSpace(objWeapon.AccessoryMounts))
                        {
                            if (!GlobalSettings.Language.Equals(GlobalSettings.DefaultLanguage,
                                                                StringComparison.OrdinalIgnoreCase))
                            {
                                using (new FetchSafelyFromPool<StringBuilder>(
                                           Utils.StringBuilderPool, out StringBuilder sbdSlotsText))
                                {
                                    foreach (string strMount in objWeapon.AccessoryMounts.SplitNoAlloc(
                                                 '/', StringSplitOptions.RemoveEmptyEntries))
                                        sbdSlotsText
                                            .Append(await LanguageManager.GetStringAsync("String_Mount" + strMount))
                                            .Append('/');
                                    --sbdSlotsText.Length;
                                    token.ThrowIfCancellationRequested();
                                    await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = sbdSlotsText.ToString(), token);
                                }
                            }
                            else
                                await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = objWeapon.AccessoryMounts, token);
                        }
                        else
                        {
                            string strNone = await LanguageManager.GetStringAsync("String_None");
                            await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = strNone, token);
                        }
                        await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = !objWeapon.IncludedInWeapon, token);
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objWeapon.Equipped;
                            x.Enabled = objWeapon.ParentID != objWeapon.Parent?.InternalId
                                        && objWeapon.ParentID
                                        != objWeapon.ParentVehicle.InternalId;
                        }, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objWeapon.IncludedInWeapon;
                        }, token);
                        // gpbVehiclesWeapon
                        await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleWeaponDamage.DoThreadSafeAsync(x =>
                        {
                            x.Text = objWeapon.DisplayDamage;
                            x.Visible = true;
                        }, token);
                        await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleWeaponAP.DoThreadSafeAsync(x =>
                        {
                            x.Text = objWeapon.DisplayTotalAP;
                            x.Visible = true;
                        }, token);
                        await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x =>
                        {
                            x.Text = objWeapon.DisplayAccuracy;
                            x.Visible = true;
                        }, token);
                        await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await dpcVehicleWeaponDicePool.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.DicePool = objWeapon.DicePool;
                            x.CanBeRolled = true;
                        }, token);
                        await dpcVehicleWeaponDicePool.SetLabelToolTipAsync(objWeapon.DicePoolTooltip, token);
                        if (objWeapon.RangeType == "Ranged")
                        {
                            await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponAmmo.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.DisplayAmmo;
                            }, token);
                            await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponMode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.DisplayMode;
                            }, token);
                            await tlpVehiclesWeaponRanges.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponRangeMain.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayRange, token);
                            await lblVehicleWeaponRangeAlternate.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayAlternateRange, token);
                            Dictionary<string, string> dictionaryRanges
                                = objWeapon.GetRangeStrings(GlobalSettings.CultureInfo);
                            await lblVehicleWeaponRangeShortLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Short"), token);
                            await lblVehicleWeaponRangeMediumLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Medium"), token);
                            await lblVehicleWeaponRangeLongLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Long"), token);
                            await lblVehicleWeaponRangeExtremeLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Extreme"), token);
                            await lblVehicleWeaponRangeShort.DoThreadSafeAsync(x => x.Text = dictionaryRanges["short"], token);
                            await lblVehicleWeaponRangeMedium.DoThreadSafeAsync(x => x.Text = dictionaryRanges["medium"], token);
                            await lblVehicleWeaponRangeLong.DoThreadSafeAsync(x => x.Text = dictionaryRanges["long"], token);
                            await lblVehicleWeaponRangeExtreme.DoThreadSafeAsync(x => x.Text = dictionaryRanges["extreme"], token);
                            await lblVehicleWeaponAlternateRangeShort.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternateshort"], token);
                            await lblVehicleWeaponAlternateRangeMedium.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternatemedium"], token);
                            await lblVehicleWeaponAlternateRangeLong.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternatelong"], token);
                            await lblVehicleWeaponAlternateRangeExtreme.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternateextreme"], token);
                        }
                        else
                        {
                            if (objWeapon.Ammo != "0")
                            {
                                await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objWeapon.DisplayAmmo;
                                }, token);
                            }
                            else
                            {
                                await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token);
                            }
                            await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token);
                            await tlpVehiclesWeaponRanges.DoThreadSafeAsync(x => x.Visible = false, token);
                        }

                        if (objWeapon.RangeType == "Ranged" || objWeapon.RangeType == "Melee" && objWeapon.Ammo != "0")
                        {
                            await tlpVehiclesWeaponCareer.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponAmmoRemaining.DoThreadSafeAsync(x => x.Text
                                = objWeapon.AmmoRemaining.ToString(GlobalSettings.CultureInfo), token);
                            await cmdFireVehicleWeapon.DoThreadSafeAsync(x => x.Enabled = objWeapon.AmmoRemaining != 0, token);
                            await cmdUnloadVehicleWeapon.DoThreadSafeAsync(x => x.Enabled = objWeapon.RequireAmmo && objWeapon.AmmoLoaded != null && objWeapon.AmmoRemaining != 0, token);
                            await cboVehicleWeaponFiringMode.DoThreadSafeAsync(x => x.SelectedValue = objWeapon.FireMode, token);
                            string strSingleShotText
                                = objWeapon.AllowSingleShot || (objWeapon.RangeType == "Melee" && objWeapon.Ammo != "0")
                                    ? string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync(
                                                        "String_SingleShot")
                                                    , objWeapon.SingleShot.ToString(GlobalSettings.CultureInfo),
                                                    objWeapon.SingleShot == 1
                                                        ? await LanguageManager.GetStringAsync(
                                                            "String_Bullet")
                                                        : await LanguageManager.GetStringAsync(
                                                            "String_Bullets"))
                                    : await
                                        LanguageManager.GetStringAsync("String_SingleShotNA");
                            string strShortBurstText
                                = objWeapon.AllowShortBurst
                                    ? string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync(
                                                        "String_ShortBurst")
                                                    , objWeapon.ShortBurst.ToString(GlobalSettings.CultureInfo),
                                                    objWeapon.ShortBurst == 1
                                                        ? await LanguageManager.GetStringAsync(
                                                            "String_Bullet")
                                                        : await LanguageManager.GetStringAsync(
                                                            "String_Bullets"))
                                    : await
                                        LanguageManager.GetStringAsync("String_ShortBurstNA");
                            string strLongBurstText
                                = objWeapon.AllowLongBurst
                                    ? string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync(
                                                        "String_LongBurst")
                                                    , objWeapon.LongBurst.ToString(GlobalSettings.CultureInfo),
                                                    objWeapon.LongBurst == 1
                                                        ? await LanguageManager.GetStringAsync(
                                                            "String_Bullet")
                                                        : await LanguageManager.GetStringAsync(
                                                            "String_Bullets"))
                                    : await
                                        LanguageManager.GetStringAsync("String_LongBurstNA");
                            string strFullBurstText
                                = objWeapon.AllowFullBurst
                                    ? string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync(
                                                        "String_FullBurst")
                                                    , objWeapon.FullBurst.ToString(GlobalSettings.CultureInfo),
                                                    objWeapon.FullBurst == 1
                                                        ? await LanguageManager.GetStringAsync(
                                                            "String_Bullet")
                                                        : await LanguageManager.GetStringAsync(
                                                            "String_Bullets"))
                                    : await
                                        LanguageManager.GetStringAsync("String_FullBurstNA");
                            string strSuppressiveFireText
                                = objWeapon.AllowSuppressive
                                    ? string.Format(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync(
                                                        "String_SuppressiveFire")
                                                    , objWeapon.Suppressive.ToString(GlobalSettings.CultureInfo),
                                                    objWeapon.Suppressive == 1
                                                        ? await LanguageManager.GetStringAsync(
                                                            "String_Bullet")
                                                        : await LanguageManager.GetStringAsync(
                                                            "String_Bullets"))
                                    : await
                                        LanguageManager.GetStringAsync("String_SuppressiveFireNA");
                            await cmdVehicleAmmoExpense.DoThreadSafeAsync(() =>
                            {
                                cmsVehicleAmmoSingleShot.Enabled = objWeapon.AllowSingleShot;
                                cmsVehicleAmmoShortBurst.Enabled = objWeapon.AllowShortBurst;
                                cmsVehicleAmmoLongBurst.Enabled = objWeapon.AllowLongBurst;
                                cmsVehicleAmmoFullBurst.Enabled = objWeapon.AllowFullBurst;
                                cmsVehicleAmmoSuppressiveFire.Enabled = objWeapon.AllowSuppressive;

                                // Melee Weapons with Ammo are considered to be Single Shot.
                                if (objWeapon.RangeType == "Melee" && objWeapon.Ammo != "0")
                                    cmsVehicleAmmoSingleShot.Enabled = true;

                                cmsVehicleAmmoSingleShot.Text = strSingleShotText;
                                cmsVehicleAmmoShortBurst.Text = strShortBurstText;
                                cmsVehicleAmmoLongBurst.Text = strLongBurstText;
                                cmsVehicleAmmoFullBurst.Text = strFullBurstText;
                                cmsVehicleAmmoSuppressiveFire.Text = strSuppressiveFireText;
                            }, token);
                            using (new FetchSafelyFromPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstAmmo))
                            {
                                int intSlot = 0;
                                foreach (Clip objClip in objWeapon.Clips)
                                {
                                    ++intSlot;
                                    token.ThrowIfCancellationRequested();
                                    string strAmmoName;
                                    if (objWeapon.RequireAmmo)
                                    {
                                        Gear objGear = objClip.AmmoGear;
                                        strAmmoName = objGear?.CurrentDisplayNameShort ??
                                                        await LanguageManager.GetStringAsync(objClip.Ammo > 0
                                                            ? "String_ExternalSource"
                                                            : "String_Empty");
                                        if (objWeapon.Clips.Count > 1)
                                            strAmmoName += strSpace + '(' + string.Format(GlobalSettings.CultureInfo
                                                , await LanguageManager.GetStringAsync("String_SlotNumber")
                                                , intSlot.ToString(GlobalSettings.CultureInfo)) + ')';

                                        string strPlugins = string.Empty;
                                        if (objGear?.Children.Count > 0)
                                        {
                                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                        out StringBuilder sbdPlugins))
                                            {
                                                foreach (Gear objChild in objGear.Children)
                                                {
                                                    sbdPlugins.Append(objChild.CurrentDisplayNameShort).Append(',')
                                                                .Append(strSpace);
                                                }

                                                strPlugins = sbdPlugins.ToString();
                                            }
                                        }

                                        // Remove the trailing comma.
                                        if (!string.IsNullOrEmpty(strPlugins))
                                            strPlugins = strPlugins.Substring(
                                                0, strPlugins.Length - 1 - strSpace.Length);

                                        if (!string.IsNullOrEmpty(strPlugins))
                                            strAmmoName += strSpace + '[' + strPlugins + ']';
                                    }
                                    else
                                        strAmmoName = await LanguageManager.GetStringAsync(objClip.Ammo > 0
                                            ? "String_MountInternal"
                                            : "String_Empty");
                                    token.ThrowIfCancellationRequested();
                                    lstAmmo.Add(new ListItem(intSlot.ToString(GlobalSettings.InvariantCultureInfo),
                                                                strAmmoName));
                                    }
                                token.ThrowIfCancellationRequested();
                                await cboVehicleWeaponAmmo.PopulateWithListItemsAsync(lstAmmo, token);
                                await cboVehicleWeaponAmmo.DoThreadSafeAsync(x =>
                                {
                                    x.SelectedValue
                                        = objWeapon.ActiveAmmoSlot.ToString(GlobalSettings.InvariantCultureInfo);
                                    if (x.SelectedIndex == -1)
                                        x.SelectedIndex = 0;
                                    x.Enabled = lstAmmo.Count > 1;
                                }, token);
                            }
                        }
                        else
                        {
                            await tlpVehiclesWeaponCareer.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesMatrix
                        int intDeviceRating = objWeapon.GetTotalMatrixAttribute("Device Rating");
                        await lblVehicleDevice.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objWeapon.RefreshMatrixAttributeComboBoxesAsync(
                            cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, token);
                        await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objWeapon.IsCommlink;
                            x.Checked = objWeapon.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objWeapon.IsHomeNode(CharacterObject);
                                x.Enabled = objWeapon.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                            }, token);
                        }
                        else
                            await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);

                        break;
                    }
                    case WeaponAccessory objAccessory:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objAccessory.IncludedInWeapon, token);
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objAccessory.CurrentDisplayNameShort, token);
                        string strText = await LanguageManager.GetStringAsync("String_VehicleWeaponAccessory");
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        if (objAccessory.MaxRating > 0)
                        {
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objAccessory.Rating.ToString(GlobalSettings.CultureInfo);
                            }, token);
                        }
                        else
                        {
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objAccessory.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objAccessory.TotalCost.ToString(
                                                                       CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdMount))
                        {
                            foreach (string strCurrentMount in objAccessory.Mount.SplitNoAlloc(
                                         '/', StringSplitOptions.RemoveEmptyEntries))
                                sbdMount.Append(await LanguageManager.GetStringAsync("String_Mount" + strCurrentMount))
                                        .Append('/');
                            // Remove the trailing /
                            if (sbdMount.Length > 0)
                                --sbdMount.Length;
                            if (!string.IsNullOrEmpty(objAccessory.ExtraMount) && objAccessory.ExtraMount != "None")
                            {
                                bool boolHaveAddedItem = false;
                                foreach (string strCurrentExtraMount in objAccessory.ExtraMount.SplitNoAlloc(
                                             '/', StringSplitOptions.RemoveEmptyEntries))
                                {
                                    if (!boolHaveAddedItem)
                                    {
                                        sbdMount.Append(strSpace).Append('+').Append(strSpace);
                                        boolHaveAddedItem = true;
                                    }
                                    token.ThrowIfCancellationRequested();
                                    sbdMount.Append(await LanguageManager.GetStringAsync(
                                                        "String_Mount" + strCurrentExtraMount))
                                            .Append('/');
                                }

                                // Remove the trailing /
                                if (boolHaveAddedItem)
                                    --sbdMount.Length;
                            }
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = sbdMount.ToString();
                            }, token);
                        }
                        await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Enabled = true;
                            x.Checked = objAccessory.Equipped;
                        }, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objAccessory.IncludedInWeapon;
                        }, token);
                        token.ThrowIfCancellationRequested();
                        // gpbWeaponsWeapon
                        strText = await LanguageManager.GetStringAsync("String_WeaponAccessory");
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Text = strText, token);
                        if (string.IsNullOrEmpty(objAccessory.Damage))
                        {
                            await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponDamage.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = !string.IsNullOrEmpty(objAccessory.Damage), token);
                            await lblVehicleWeaponDamage.DoThreadSafeAsync(x =>
                            {
                                x.Visible = !string.IsNullOrEmpty(objAccessory
                                                                      .Damage);
                                x.Text = Convert
                                         .ToInt32(objAccessory.Damage,
                                                  GlobalSettings.InvariantCultureInfo)
                                         .ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        if (string.IsNullOrEmpty(objAccessory.AP))
                        {
                            await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponAP.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponAP.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = Convert
                                         .ToInt32(objAccessory.AP, GlobalSettings.InvariantCultureInfo)
                                         .ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        if (objAccessory.Accuracy == 0)
                        {
                            await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text
                                    = objAccessory.Accuracy.ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        if (objAccessory.DicePool == 0)
                        {
                            await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await dpcVehicleWeaponDicePool.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await dpcVehicleWeaponDicePool.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.DicePool = objAccessory.DicePool;
                                x.CanBeRolled = false;
                            }, token);
                            await dpcVehicleWeaponDicePool.SetLabelToolTipAsync(string.Empty, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (objAccessory.TotalAmmoBonus != 0
                            || (!string.IsNullOrEmpty(objAccessory.ModifyAmmoCapacity)
                                && objAccessory.ModifyAmmoCapacity != "0"))
                        {
                            await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = true, token);
                            using (new FetchSafelyFromPool<StringBuilder>(
                                       Utils.StringBuilderPool, out StringBuilder sbdAmmoBonus))
                            {
                                int intAmmoBonus = objAccessory.TotalAmmoBonus;
                                if (intAmmoBonus != 0)
                                    sbdAmmoBonus.Append(
                                        (intAmmoBonus / 100.0m).ToString("+#,0%;-#,0%;0%", GlobalSettings.CultureInfo));
                                if (!string.IsNullOrEmpty(objAccessory.ModifyAmmoCapacity)
                                    && objAccessory.ModifyAmmoCapacity != "0")
                                    sbdAmmoBonus.Append(objAccessory.ModifyAmmoCapacity);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Text = sbdAmmoBonus.ToString(), token);
                            }
                        }
                        else
                        {
                            await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token);
                        await tlpVehiclesWeaponRanges.DoThreadSafeAsync(x => x.Visible = false, token);
                        await tlpVehiclesWeaponCareer.DoThreadSafeAsync(x => x.Visible = false, token);
                        break;
                    }
                    case Cyberware objCyberware:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = string.IsNullOrEmpty(objCyberware.ParentID), token);
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objCyberware.CurrentDisplayNameShort, token);
                        string strText = await objCyberware.DisplayCategoryAsync(GlobalSettings.Language);
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        if (objCyberware.MaxRating == 0)
                        {
                            await lblVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblVehicleRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objCyberware.Rating.ToString(GlobalSettings.CultureInfo);
                            }, token);
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objCyberware.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objCyberware.TotalCost.ToString(
                                                                       CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible
                                                                                   = !string.IsNullOrEmpty(
                                                                                       objCyberware.PlugsIntoModularMount), token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesMatrix
                        int intDeviceRating = objCyberware.GetTotalMatrixAttribute("Device Rating");
                        await lblVehicleDevice.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objCyberware.RefreshMatrixAttributeComboBoxesAsync(
                            cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, token);
                        token.ThrowIfCancellationRequested();
                        await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objCyberware.IsCommlink;
                            x.Checked = objCyberware.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objCyberware.IsHomeNode(CharacterObject);
                                x.Enabled = objCyberware.IsCommlink
                                            && objCyberware.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                            }, token);
                        }
                        else
                            await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);

                        break;
                    }
                    case Gear objGear:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token);
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objGear.CurrentDisplayNameShort, token);
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = objGear.DisplayCategory(GlobalSettings.Language), token);
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleRating.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objGear.Rating.ToString(GlobalSettings.CultureInfo);
                        }, token);
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleGearQty.DoThreadSafeAsync(x => x.Visible = true, token);
                        string strQuantity = objGear.DisplayQuantity(GlobalSettings.CultureInfo);
                        if (string.IsNullOrEmpty(strQuantity))
                            strQuantity = 1.ToString(GlobalSettings.CultureInfo);
                        await lblVehicleGearQty.DoThreadSafeAsync(x => x.Text = strQuantity, token);
                        await cmdVehicleGearReduceQty.DoThreadSafeAsync(x => x.Visible = !objGear.IncludedInParent, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objGear.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objGear.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        string strText = objGear.CalculatedCapacity
                                         + strSpace + '('
                                         + objGear.CapacityRemaining.ToString(
                                             "#,0.##", GlobalSettings.CultureInfo)
                                         + strSpace
                                         + await LanguageManager.GetStringAsync("String_Remaining") + ')';
                        await lblVehicleSlots.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = strText;
                        }, token);
                        await cmdVehicleMoveToInventory.DoThreadSafeAsync(x => x.Visible = !objGear.IncludedInParent && objGear.LoadedIntoClip == null, token);
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        // gpbVehiclesMatrix
                        int intDeviceRating = objGear.GetTotalMatrixAttribute("Device Rating");
                        await lblVehicleDevice.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objGear.RefreshMatrixAttributeComboBoxesAsync(
                            cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, token);
                        await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objGear.IsCommlink;
                            x.Checked = objGear.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objGear.IsHomeNode(CharacterObject);
                                x.Enabled = objGear.IsCommlink
                                            && objGear.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                            }, token);
                        }
                        else
                            await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);

                        break;
                    }
                    default:
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = false, token);
                        break;
                }
                await panVehicleCM.DoThreadSafeAsync(x => x.Visible = objSelectedNodeTag is IHasPhysicalConditionMonitor ||
                                                                      objSelectedNodeTag is IHasMatrixAttributes, token);
                await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = objSelectedNodeTag is IHasMatrixAttributes ||
                                                                           objSelectedNodeTag is IHasWirelessBonus, token);
                if (await panVehicleCM.DoThreadSafeFuncAsync(x => x.Visible, token))
                {
                    if (objSelectedNodeTag is IHasPhysicalConditionMonitor objCM)
                    {
                        await ProcessEquipmentConditionMonitorBoxDisplays(
                            panVehiclePhysicalCM, objCM.PhysicalCM, objCM.PhysicalCMFilled, token);
                    }

                    if (objSelectedNodeTag is IHasMatrixAttributes objMatrixCM)
                    {
                        await ProcessEquipmentConditionMonitorBoxDisplays(
                            panVehicleMatrixCM, objMatrixCM.MatrixCM, objMatrixCM.MatrixCMFilled, token);
                    }
                }
            }
            finally
            {
                await flpVehicles.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        private async void ExpenseEntriesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            await DoExpenseEntriesCollectionChanged(e);
        }

        private async ValueTask DoExpenseEntriesCollectionChanged(NotifyCollectionChangedEventArgs e)
        {
            bool blnDoRepopulateKarmaExpenseList = false;
            bool blnDoRepopulateNuyenExpenseList = false;
            if (e == null || e.Action == NotifyCollectionChangedAction.Reset)
            {
                blnDoRepopulateKarmaExpenseList = true;
                blnDoRepopulateNuyenExpenseList = true;
            }
            else
            {
                switch (e.Action)
                {
                    // TODO: Find a way to add, remove, or replace a single item at a time instead of needing to redraw the entire list
                    case NotifyCollectionChangedAction.Add:
                        foreach (ExpenseLogEntry objEntry in e.NewItems)
                        {
                            switch (objEntry.Type)
                            {
                                case ExpenseType.Karma:
                                    blnDoRepopulateKarmaExpenseList = blnDoRepopulateKarmaExpenseList || objEntry.Amount != 0 || await chkShowFreeKarma.DoThreadSafeFuncAsync(x => x.Checked);
                                    break;

                                case ExpenseType.Nuyen:
                                    blnDoRepopulateNuyenExpenseList = blnDoRepopulateNuyenExpenseList || objEntry.Amount != 0 || await chkShowFreeNuyen.DoThreadSafeFuncAsync(x => x.Checked);
                                    break;
                            }
                            if (blnDoRepopulateKarmaExpenseList && blnDoRepopulateNuyenExpenseList)
                                break;
                        }
                        break;

                    case NotifyCollectionChangedAction.Remove:
                        foreach (ExpenseLogEntry objEntry in e.OldItems)
                        {
                            switch (objEntry.Type)
                            {
                                case ExpenseType.Karma:
                                    blnDoRepopulateKarmaExpenseList = blnDoRepopulateKarmaExpenseList || objEntry.Amount != 0 || await chkShowFreeKarma.DoThreadSafeFuncAsync(x => x.Checked);
                                    break;

                                case ExpenseType.Nuyen:
                                    blnDoRepopulateNuyenExpenseList = blnDoRepopulateNuyenExpenseList || objEntry.Amount != 0 || await chkShowFreeNuyen.DoThreadSafeFuncAsync(x => x.Checked);
                                    break;
                            }
                            if (blnDoRepopulateKarmaExpenseList && blnDoRepopulateNuyenExpenseList)
                                break;
                        }
                        break;

                    case NotifyCollectionChangedAction.Replace:
                        foreach (ExpenseLogEntry objEntry in e.OldItems)
                        {
                            switch (objEntry.Type)
                            {
                                case ExpenseType.Karma:
                                    blnDoRepopulateKarmaExpenseList = blnDoRepopulateKarmaExpenseList || objEntry.Amount != 0 || await chkShowFreeKarma.DoThreadSafeFuncAsync(x => x.Checked);
                                    break;

                                case ExpenseType.Nuyen:
                                    blnDoRepopulateNuyenExpenseList = blnDoRepopulateNuyenExpenseList || objEntry.Amount != 0 || await chkShowFreeNuyen.DoThreadSafeFuncAsync(x => x.Checked);
                                    break;
                            }
                            if (blnDoRepopulateKarmaExpenseList && blnDoRepopulateNuyenExpenseList)
                                break;
                        }

                        if (!blnDoRepopulateKarmaExpenseList || !blnDoRepopulateNuyenExpenseList)
                        {
                            foreach (ExpenseLogEntry objEntry in e.NewItems)
                            {
                                switch (objEntry.Type)
                                {
                                    case ExpenseType.Karma:
                                        blnDoRepopulateKarmaExpenseList = blnDoRepopulateKarmaExpenseList || objEntry.Amount != 0 || await chkShowFreeKarma.DoThreadSafeFuncAsync(x => x.Checked);
                                        break;

                                    case ExpenseType.Nuyen:
                                        blnDoRepopulateNuyenExpenseList = blnDoRepopulateNuyenExpenseList || objEntry.Amount != 0 || await chkShowFreeNuyen.DoThreadSafeFuncAsync(x => x.Checked);
                                        break;
                                }
                                if (blnDoRepopulateKarmaExpenseList && blnDoRepopulateNuyenExpenseList)
                                    break;
                            }
                        }
                        break;

                    case NotifyCollectionChangedAction.Move:
                        return;
                }
            }
            if (blnDoRepopulateKarmaExpenseList)
                await RepopulateKarmaExpenseList();
            if (blnDoRepopulateNuyenExpenseList)
                await RepopulateNuyenExpenseList();
        }

        private async void chkShowFreeKarma_CheckedChanged(object sender, EventArgs e)
        {
            if (await CharacterObject.ExpenseEntries.AnyAsync(x => x.Type == ExpenseType.Karma && x.Amount == 0))
            {
                await RepopulateKarmaExpenseList();
            }
        }

        private async ValueTask RepopulateKarmaExpenseList()
        {
            using (await CursorWait.NewAsync(this))
            {
                await lstKarma.DoThreadSafeAsync(x =>
                {
                    x.Items.Clear();
                    x.ContextMenuStrip = null;
                });
                await chtKarma.DoThreadSafeAsync(x => x.SuspendLayout());
                try
                {
                    chtKarma.ExpenseValues.Clear();
                    decimal decKarmaValue = 0;
                    bool blnShowFreeKarma = await chkShowFreeKarma.DoThreadSafeFuncAsync(x => x.Checked);
                    //Find the last karma/nuyen entry as well in case a chart only contains one point
                    DateTime KarmaLast = DateTime.MinValue;
                    foreach (ExpenseLogEntry objExpense in CharacterObject.ExpenseEntries)
                    {
                        if (objExpense.Type != ExpenseType.Karma || (objExpense.Amount == 0 && !blnShowFreeKarma))
                            continue;
                        ListViewItemWithValue.ListViewSubItemWithValue objAmountItem =
                            new ListViewItemWithValue.ListViewSubItemWithValue
                            {
                                Value = objExpense.Amount,
                                Text = objExpense.Amount.ToString("#,0.##", GlobalSettings.CultureInfo)
                            };
                        ListViewItemWithValue.ListViewSubItemWithValue objReasonItem =
                            new ListViewItemWithValue.ListViewSubItemWithValue
                            {
                                Value = objExpense.Reason,
                                Text = await objExpense.DisplayReasonAsync(GlobalSettings.Language)
                            };
                        ListViewItemWithValue.ListViewSubItemWithValue objInternalIdItem =
                            new ListViewItemWithValue.ListViewSubItemWithValue
                            {
                                Value = objExpense,
                                Text = objExpense.InternalId
                            };

                        ListViewItemWithValue objItem = new ListViewItemWithValue(objExpense.Date,
                                objExpense.Date.ToString(GlobalSettings.CustomDateTimeFormats
                                                             ? GlobalSettings.CustomDateFormat
                                                               + ' ' + GlobalSettings.CustomTimeFormat
                                                             : GlobalSettings.CultureInfo.DateTimeFormat.ShortDatePattern
                                                               + ' ' + GlobalSettings.CultureInfo.DateTimeFormat.ShortTimePattern,
                                                         GlobalSettings.CultureInfo)
                        );
                        objItem.SubItems.Add(objAmountItem);
                        objItem.SubItems.Add(objReasonItem);
                        objItem.SubItems.Add(objInternalIdItem);

                        await lstKarma.DoThreadSafeAsync(x =>
                        {
                            x.Items.Add(objItem);
                            if (objExpense.Undo != null)
                                x.ContextMenuStrip = cmsUndoKarmaExpense;
                        });
                        if (objExpense.Amount == 0)
                            continue;
                        if (objExpense.Date > KarmaLast)
                            KarmaLast = objExpense.Date;
                        decKarmaValue += objExpense.Amount;
                        chtKarma.ExpenseValues.Add(new DateTimePoint(objExpense.Date, decimal.ToDouble(decKarmaValue)));
                    }

                    if (KarmaLast == DateTime.MinValue)
                        KarmaLast = File.Exists(CharacterObject.FileName)
                            ? File.GetCreationTime(CharacterObject.FileName)
                            : new DateTime(DateTime.Now.Ticks - 1000);
                    if (chtKarma.ExpenseValues.Count < 2)
                    {
                        if (chtKarma.ExpenseValues.Count < 1)
                            chtKarma.ExpenseValues.Add(new DateTimePoint(KarmaLast, decimal.ToDouble(decKarmaValue)));
                        chtKarma.ExpenseValues.Add(new DateTimePoint(DateTime.Now, decimal.ToDouble(decKarmaValue)));
                    }

                    await chtKarma.NormalizeYAxis();
                }
                finally
                {
                    await chtKarma.DoThreadSafeAsync(x => x.ResumeLayout());
                }
            }
        }

        private async void chkShowFreeNuyen_CheckedChanged(object sender, EventArgs e)
        {
            if (await CharacterObject.ExpenseEntries.AnyAsync(x => x.Type == ExpenseType.Nuyen && x.Amount == 0))
            {
                await RepopulateNuyenExpenseList();
            }
        }

        private async ValueTask RepopulateNuyenExpenseList()
        {
            using (await CursorWait.NewAsync(this))
            {
                await lstNuyen.DoThreadSafeAsync(x =>
                {
                    x.Items.Clear();
                    x.ContextMenuStrip = null;
                });
                await chtNuyen.DoThreadSafeAsync(x => x.SuspendLayout());
                try
                {
                    chtNuyen.ExpenseValues.Clear();
                    decimal decNuyenValue = 0;
                    bool blnShowFreeNuyen = await chkShowFreeNuyen.DoThreadSafeFuncAsync(x => x.Checked);
                    //Find the last karma/nuyen entry as well in case a chart only contains one point
                    DateTime NuyenLast = DateTime.MinValue;
                    foreach (ExpenseLogEntry objExpense in CharacterObject.ExpenseEntries)
                    {
                        if (objExpense.Type != ExpenseType.Nuyen || (objExpense.Amount == 0 && !blnShowFreeNuyen))
                            continue;
                        ListViewItemWithValue.ListViewSubItemWithValue objAmountItem =
                            new ListViewItemWithValue.ListViewSubItemWithValue
                            {
                                Value = objExpense.Amount,
                                Text = objExpense.Amount.ToString("#,0.##", GlobalSettings.CultureInfo)
                            };
                        ListViewItemWithValue.ListViewSubItemWithValue objReasonItem =
                            new ListViewItemWithValue.ListViewSubItemWithValue
                            {
                                Value = objExpense.Reason,
                                Text = await objExpense.DisplayReasonAsync(GlobalSettings.Language)
                            };
                        ListViewItemWithValue.ListViewSubItemWithValue objInternalIdItem =
                            new ListViewItemWithValue.ListViewSubItemWithValue
                            {
                                Value = objExpense,
                                Text = objExpense.InternalId
                            };

                        ListViewItemWithValue objItem = new ListViewItemWithValue(objExpense.Date,
                                objExpense.Date.ToString(GlobalSettings.CustomDateTimeFormats
                                                             ? GlobalSettings.CustomDateFormat
                                                               + ' ' + GlobalSettings.CustomTimeFormat
                                                             : GlobalSettings.CultureInfo.DateTimeFormat
                                                                             .ShortDatePattern
                                                               + ' ' + GlobalSettings.CultureInfo.DateTimeFormat
                                                                   .ShortTimePattern,
                                                         GlobalSettings.CultureInfo)
                        );
                        objItem.SubItems.Add(objAmountItem);
                        objItem.SubItems.Add(objReasonItem);
                        objItem.SubItems.Add(objInternalIdItem);

                        await lstNuyen.DoThreadSafeAsync(x =>
                        {
                            x.Items.Add(objItem);
                            if (objExpense.Undo != null)
                                x.ContextMenuStrip = cmsUndoNuyenExpense;
                        });
                        if (objExpense.Amount == 0)
                            continue;
                        if (objExpense.Date > NuyenLast)
                            NuyenLast = objExpense.Date;
                        decNuyenValue += objExpense.Amount;
                        chtNuyen.ExpenseValues.Add(new DateTimePoint(objExpense.Date, decimal.ToDouble(decNuyenValue)));
                    }

                    if (NuyenLast == DateTime.MinValue)
                        NuyenLast = File.Exists(CharacterObject.FileName)
                            ? File.GetCreationTime(CharacterObject.FileName)
                            : new DateTime(DateTime.Now.Ticks - 1000);
                    if (chtNuyen.ExpenseValues.Count < 2)
                    {
                        if (chtNuyen.ExpenseValues.Count < 1)
                            chtNuyen.ExpenseValues.Add(new DateTimePoint(NuyenLast, decimal.ToDouble(decNuyenValue)));
                        chtNuyen.ExpenseValues.Add(new DateTimePoint(DateTime.Now, decimal.ToDouble(decNuyenValue)));
                    }

                    await chtNuyen.NormalizeYAxis();
                }
                finally
                {
                    await chtNuyen.DoThreadSafeAsync(x => x.ResumeLayout());
                }
            }
        }

        private async void UpdateInitiationCostEvent(object sender, EventArgs e)
        {
            await UpdateInitiationCost();
        }

        /// <summary>
        /// Update the karma cost tooltip for Initiation/Submersion.
        /// </summary>
        private async Task UpdateInitiationCost(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            decimal decMultiplier = 1.0m;
            int intAmount;
            string strInitTip;
            if (CharacterObject.MAGEnabled)
            {
                if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaMAGInitiationGroupPercent;
                if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaMAGInitiationOrdealPercent;
                if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaMAGInitiationSchoolingPercent;
                intAmount = ((CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.InitiateGrade + 1) * CharacterObjectSettings.KarmaInitiation) * decMultiplier).StandardRound();
                token.ThrowIfCancellationRequested();
                strInitTip = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_ImproveInitiateGrade")
                    , (CharacterObject.InitiateGrade + 1).ToString(GlobalSettings.CultureInfo)
                    , intAmount.ToString(GlobalSettings.CultureInfo));
            }
            else
            {
                if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaRESInitiationGroupPercent;
                if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaRESInitiationOrdealPercent;
                if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaRESInitiationSchoolingPercent;
                intAmount = ((CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.SubmersionGrade + 1) * CharacterObjectSettings.KarmaInitiation) * decMultiplier).StandardRound();
                token.ThrowIfCancellationRequested();
                strInitTip = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_ImproveSubmersionGrade")
                    , (CharacterObject.SubmersionGrade + 1).ToString(GlobalSettings.CultureInfo)
                    , intAmount.ToString(GlobalSettings.CultureInfo));
            }
            await cmdAddMetamagic.SetToolTipAsync(strInitTip, token);
        }

        /// <summary>
        /// Set the ToolTips from the Language file.
        /// </summary>
        private async ValueTask SetTooltips()
        {
            // Armor Tab.
            await chkArmorEquipped.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_ArmorEquipped"));
            // ToolTipFactory.SetToolTip(cmdArmorIncrease, LanguageManager.GetString("Tip_ArmorDegradationAPlus"));
            // ToolTipFactory.SetToolTip(cmdArmorDecrease, LanguageManager.GetString("Tip_ArmorDegradationAMinus"));
            // Weapon Tab.
            await cmdWeaponBuyAmmo.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_BuyAmmo"));
            await cmdWeaponMoveToVehicle.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_TransferToVehicle"));
            // Gear Tab.
            await cmdGearIncreaseQty.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_IncreaseGearQty"));
            await cmdGearReduceQty.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_DecreaseGearQty"));
            await cmdGearSplitQty.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_SplitGearQty"));
            await cmdGearMergeQty.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_MergeGearQty"));
            await cmdGearMoveToVehicle.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_TransferToVehicle"));
            await chkGearActiveCommlink.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_ActiveCommlink"));
            await chkCyberwareActiveCommlink.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_ActiveCommlink"));
            // Vehicles Tab.
            await chkVehicleWeaponAccessoryInstalled.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_WeaponInstalled"));
            await cmdVehicleGearReduceQty.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_DecreaseGearQty"));
            await cmdVehicleMoveToInventory.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_TransferToInventory"));
            await chkVehicleActiveCommlink.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_ActiveCommlink"));
            // Other Info Tab.
            await lblCMPhysicalLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherCMPhysical"));
            await lblCMStunLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherCMStun"));
            await lblINILabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherInitiative"));
            await lblMatrixINILabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherMatrixInitiative"));
            await lblAstralINILabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherAstralInitiative"));
            await lblArmorLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherArmor"));
            await lblESS.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherEssence"));
            await lblRemainingNuyenLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherNuyen"));
            await lblCareerKarmaLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherCareerKarma"));
            await lblMovementLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherMovement"));
            await lblSwimLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherSwim"));
            await lblFlyLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherFly"));
            await lblLiftCarryLimitsLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherLiftAndCarryLimits"));
            await lblComposureLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherComposure"));
            await lblSurpriseLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherSurprise"));
            await lblJudgeIntentionsLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherJudgeIntentions"));
            await lblLiftCarryLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherLiftAndCarry"));
            await lblMemoryLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherMemory"));
            // Condition Monitor Tab.
            await lblCMPenaltyLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_CMPenalty"));
            await lblCMArmorLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherArmor"));
            await lblCMDamageResistancePoolLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_CMDamageResistance"));
            await cmdEdgeGained.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_CMRegainEdge"));
            await cmdEdgeSpent.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_CMSpendEdge"));
            // Common Info Tab.
            await lblStreetCred.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_StreetCred"));
            await lblNotoriety.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_Notoriety"));
            if (CharacterObjectSettings.UseCalculatedPublicAwareness)
                await lblPublicAware.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_PublicAwareness"));
            await cmdBurnStreetCred.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_BurnStreetCred"));
        }

        /// <summary>
        /// Refresh the information for the currently selected Spell
        /// </summary>
        private async Task RefreshSelectedSpell(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await gpbMagicianSpell.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                object objSelectedNodeTag = await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token);
                if (objSelectedNodeTag is Spell objSpell && await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode?.Level > 0, token))
                {
                    await gpbMagicianSpell.DoThreadSafeAsync(x => x.Visible = true, token);
                    await cmdDeleteSpell.DoThreadSafeAsync(x => x.Enabled = objSpell.Grade == 0, token);
                    string strText = await objSpell.DisplayDescriptorsAsync(GlobalSettings.Language);
                    if (string.IsNullOrEmpty(strText))
                        strText = await LanguageManager.GetStringAsync("String_None");
                    await lblSpellDescriptors.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayCategoryAsync(GlobalSettings.Language);
                    await lblSpellCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayTypeAsync(GlobalSettings.Language);
                    await lblSpellType.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayRangeAsync(GlobalSettings.Language);
                    await lblSpellRange.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayDamageAsync(GlobalSettings.Language);
                    await lblSpellDamage.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayDurationAsync(GlobalSettings.Language);
                    await lblSpellDuration.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayDvAsync(GlobalSettings.Language);
                    await lblSpellDV.DoThreadSafeAsync(x => x.Text = strText, token);
                    await lblSpellDV.SetToolTipAsync(objSpell.DvTooltip, token);
                    await objSpell.SetSourceDetailAsync(lblSpellSource, token);
                    // Determine the size of the Spellcasting Dice Pool.
                    await dpcSpellDicePool.DoThreadSafeAsync(x => x.DicePool = objSpell.DicePool, token);
                    await dpcSpellDicePool.SetLabelToolTipAsync(objSpell.DicePoolTooltip, token);
                }
                else
                {
                    await gpbMagicianSpell.DoThreadSafeAsync(x => x.Visible = false, token);
                    await cmdDeleteSpell.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                }
            }
            finally
            {
                await gpbMagicianSpell.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Recheck all mods to see if Sensor has changed.
        /// </summary>
        private async ValueTask UpdateSensor(Vehicle objVehicle, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            foreach (Gear objGear in objVehicle.GearChildren)
            {
                if (objGear.Category != "Sensors" || objGear.Name != "Sensor Array" || !objGear.IncludedInParent)
                    continue;
                token.ThrowIfCancellationRequested();
                // Update the name of the item in the TreeView.
                TreeNode objNode = treVehicles.FindNode(objGear.InternalId);
                if (objNode != null)
                {
                    await treVehicles.DoThreadSafeAsync(() => objNode.Text = objGear.CurrentDisplayName, token);
                }
            }
        }

        /// <summary>
        /// Copy the Improvements from a piece of Armor on one character to another.
        /// </summary>
        /// <param name="objSource">Source character.</param>
        /// <param name="objDestination">Destination character.</param>
        /// <param name="objArmor">Armor to copy.</param>
        private static void CopyArmorImprovements(Character objSource, Character objDestination, Armor objArmor)
        {
            foreach (Improvement objImprovement in objSource.Improvements)
            {
                if (objImprovement.SourceName == objArmor.InternalId)
                {
                    objDestination.Improvements.Add(objImprovement);
                }
            }
            // Look through any Armor Mods and add the Improvements as well.
            foreach (ArmorMod objMod in objArmor.ArmorMods)
            {
                foreach (Improvement objImprovement in objSource.Improvements)
                {
                    if (objImprovement.SourceName == objMod.InternalId)
                    {
                        objDestination.Improvements.Add(objImprovement);
                    }
                }
                // Look through any children and add their Improvements as well.
                foreach (Gear objChild in objMod.GearChildren)
                    CopyGearImprovements(objSource, objDestination, objChild);
            }
            // Look through any children and add their Improvements as well.
            foreach (Gear objChild in objArmor.GearChildren)
                CopyGearImprovements(objSource, objDestination, objChild);
        }

        /// <summary>
        /// Copy the Improvements from a piece of Gear on one character to another.
        /// </summary>
        /// <param name="objSource">Source character.</param>
        /// <param name="objDestination">Destination character.</param>
        /// <param name="objGear">Gear to copy.</param>
        private static void CopyGearImprovements(Character objSource, Character objDestination, Gear objGear)
        {
            foreach (Improvement objImprovement in objSource.Improvements)
            {
                if (objImprovement.SourceName == objGear.InternalId)
                {
                    objDestination.Improvements.Add(objImprovement);
                }
            }
            // Look through any children and add their Improvements as well.
            foreach (Gear objChild in objGear.Children)
                CopyGearImprovements(objSource, objDestination, objChild);
        }

        /// <summary>
        /// Copy the Improvements from a piece of Cyberware on one character to another.
        /// </summary>
        /// <param name="objSource">Source character.</param>
        /// <param name="objDestination">Destination character.</param>
        /// <param name="objCyberware">Cyberware to copy.</param>
        private static void CopyCyberwareImprovements(Character objSource, Character objDestination, Cyberware objCyberware)
        {
            foreach (Improvement objImprovement in objSource.Improvements)
            {
                if (objImprovement.SourceName == objCyberware.InternalId)
                {
                    objDestination.Improvements.Add(objImprovement);
                }
            }
            // Look through any children and add their Improvements as well.
            foreach (Cyberware objChild in objCyberware.Children)
                CopyCyberwareImprovements(objSource, objDestination, objChild);
        }

        /// <summary>
        /// Enable/Disable the Paste Menu and ToolStrip items as appropriate.
        /// </summary>
        private async ValueTask RefreshPasteStatus(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            bool blnCopyEnabled = false;

            if (await tabCharacterTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token) == tabStreetGear)
            {
                // Lifestyle Tab.
                if (await tabStreetGearTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token) == tabLifestyle)
                {
                    blnCopyEnabled = await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Lifestyle, token);
                }
                // Armor Tab.
                else if (await tabStreetGearTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token) == tabArmor)
                {
                    blnCopyEnabled
                        = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Armor || x.SelectedNode?.Tag is Gear, token);
                }

                // Weapons Tab.
                if (await tabStreetGearTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token) == tabWeapons)
                {
                    blnCopyEnabled = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Weapon ||
                                                                           x.SelectedNode?.Tag is Gear, token);
                }
                // Gear Tab.
                else if (await tabStreetGearTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token) == tabGear)
                {
                    blnCopyEnabled = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Gear, token);
                }
            }
            // Cyberware Tab.
            else if (await tabCharacterTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token) == tabCyberware)
            {
                blnCopyEnabled = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Cyberware ||
                                                                         x.SelectedNode?.Tag is Gear, token);
            }
            // Vehicles Tab.
            else if (await tabCharacterTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token) == tabVehicles)
            {
                blnCopyEnabled = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag is Vehicle ||
                                                                        x.SelectedNode?.Tag is Gear ||
                                                                        x.SelectedNode?.Tag is Weapon, token);
            }

            await mnuCreateMenu.DoThreadSafeAsync(() => mnuEditCopy.Enabled = blnCopyEnabled, token);
            await tsMain.DoThreadSafeAsync(() => tsbCopy.Enabled = blnCopyEnabled, token);
        }

        /// <summary>
        /// Refresh the information for the currently selected Complex Form.
        /// </summary>
        private async Task RefreshSelectedComplexForm(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                object objSelectedNodeTag = await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token);
                if (objSelectedNodeTag is ComplexForm objComplexForm && await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode?.Level > 0, token))
                {
                    await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.Visible = true, token);
                    await cmdDeleteComplexForm.DoThreadSafeAsync(x => x.Enabled = objComplexForm.Grade == 0, token);
                    string strText = await objComplexForm.DisplayTargetAsync(GlobalSettings.Language);
                    await lblTarget.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objComplexForm.DisplayDurationAsync(GlobalSettings.Language);
                    await lblDuration.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objComplexForm.DisplayFvAsync(GlobalSettings.Language);
                    await lblFV.DoThreadSafeAsync(x => x.Text = strText, token);
                    await lblFV.SetToolTipAsync(objComplexForm.FvTooltip, token);
                    await objComplexForm.SetSourceDetailAsync(lblSpellSource, token);
                    // Determine the size of the Threading Dice Pool.
                    await dpcComplexFormDicePool.DoThreadSafeAsync(x => x.DicePool = objComplexForm.DicePool, token);
                    await dpcComplexFormDicePool.SetLabelToolTipAsync(objComplexForm.DicePoolTooltip, token);
                }
                else
                {
                    await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.Visible = false, token);
                    await cmdDeleteComplexForm.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                }
            }
            finally
            {
                await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Create Cyberware from a Cyberware Suite.
        /// </summary>
        /// <param name="xmlSuiteNode">XmlNode for the cyberware suite to add.</param>
        /// <param name="xmlCyberwareNode">XmlNode for the Cyberware to add.</param>
        /// <param name="objGrade">CyberwareGrade to add the item as.</param>
        /// <param name="intRating">Rating of the Cyberware.</param>
        /// <param name="eSource">Source representing whether the suite is cyberware or bioware.</param>
        private Cyberware CreateSuiteCyberware(XmlNode xmlSuiteNode, XmlNode xmlCyberwareNode, Grade objGrade, int intRating, Improvement.ImprovementSource eSource)
        {
            // Create the Cyberware object.
            List<Weapon> lstWeapons = new List<Weapon>(1);
            List<Vehicle> lstVehicles = new List<Vehicle>(1);
            Cyberware objCyberware = new Cyberware(CharacterObject);
            string strForced = xmlSuiteNode.SelectSingleNode("name/@select")?.InnerText ?? string.Empty;

            objCyberware.Create(xmlCyberwareNode, objGrade, eSource, intRating, lstWeapons, lstVehicles, true, true, strForced);
            objCyberware.Suite = true;

            foreach (Weapon objWeapon in lstWeapons)
            {
                CharacterObject.Weapons.Add(objWeapon);
            }

            foreach (Vehicle objVehicle in lstVehicles)
            {
                CharacterObject.Vehicles.Add(objVehicle);
            }

            string strType = eSource == Improvement.ImprovementSource.Cyberware ? "cyberware" : "bioware";
            string strXPathPrefix = strType + "s/" + strType;
            using (XmlNodeList xmlChildrenList = xmlSuiteNode.SelectNodes(strXPathPrefix))
            {
                if (xmlChildrenList?.Count > 0)
                {
                    XmlDocument objXmlDocument = CharacterObject.LoadData(strType + ".xml");
                    foreach (XmlNode objXmlChild in xmlChildrenList)
                    {
                        string strChildName = objXmlChild["name"]?.InnerText;
                        if (string.IsNullOrEmpty(strChildName))
                            continue;
                        XmlNode objXmlChildCyberware = objXmlDocument.SelectSingleNode("/chummer/" + strXPathPrefix + "[name = " + strChildName.CleanXPath() + ']');
                        int intChildRating = Convert.ToInt32(objXmlChild["rating"]?.InnerText, GlobalSettings.InvariantCultureInfo);

                        objCyberware.Children.Add(CreateSuiteCyberware(objXmlChild, objXmlChildCyberware, objGrade, intChildRating, eSource));
                    }
                }
            }

            return objCyberware;
        }

        private async ValueTask AddCyberwareSuite(Improvement.ImprovementSource objSource)
        {
            using (ThreadSafeForm<SelectCyberwareSuite> frmPickCyberwareSuite = await ThreadSafeForm<SelectCyberwareSuite>.GetAsync(() => new SelectCyberwareSuite(CharacterObject, objSource)))
            {
                if (await frmPickCyberwareSuite.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                decimal decCost = frmPickCyberwareSuite.MyForm.TotalCost;
                if (decCost > CharacterObject.Nuyen)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                string strType = objSource == Improvement.ImprovementSource.Cyberware ? "cyberware" : "bioware";
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync(strType + ".xml");

                XmlNode xmlSuite = frmPickCyberwareSuite.MyForm.SelectedSuite.IsGuid()
                    ? objXmlDocument.SelectSingleNode("/chummer/suites/suite[id = " + frmPickCyberwareSuite.MyForm.SelectedSuite.CleanXPath() + ']')
                    : objXmlDocument.SelectSingleNode("/chummer/suites/suite[name = " + frmPickCyberwareSuite.MyForm.SelectedSuite.CleanXPath() + ']');
                if (xmlSuite == null)
                    return;

                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(decCost * -1, await LanguageManager.GetStringAsync("String_ExpensePurchaseCyberwareSuite") + await LanguageManager.GetStringAsync("String_Space") + xmlSuite["name"]?.InnerText, ExpenseType.Nuyen, DateTime.Now);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                CharacterObject.Nuyen -= decCost;

                Grade objGrade = Grade.ConvertToCyberwareGrade(xmlSuite["grade"]?.InnerText, objSource, CharacterObject);

                // Run through each of the items in the Suite and add them to the character.
                using (XmlNodeList xmlItemList = xmlSuite.SelectNodes(strType + "s/" + strType))
                {
                    if (xmlItemList?.Count > 0)
                    {
                        foreach (XmlNode xmlItem in xmlItemList)
                        {
                            string strItemName = xmlItem["name"]?.InnerText;
                            if (string.IsNullOrEmpty(strItemName))
                                continue;
                            XmlNode objXmlCyberware = objXmlDocument.SelectSingleNode("/chummer/" + strType + "s/" + strType + "[name = " + strItemName.CleanXPath() + ']');
                            int intRating = Convert.ToInt32(xmlItem["rating"]?.InnerText, GlobalSettings.InvariantCultureInfo);

                            Cyberware objCyberware = CreateSuiteCyberware(xmlItem, objXmlCyberware, objGrade, intRating, objSource);
                            await CharacterObject.Cyberware.AddAsync(objCyberware);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Adds a sustained spell
        /// </summary>
        private void AddSustainedSpell()
        {
            //Could be merged with AddSustainedComplex form and create an more or less universal method to add ISustainables from tre viewers. Not worth the trouble and probably not better at the moment.
            if (treSpells.SelectedNode?.Level > 0 && treSpells.SelectedNode.Tag is Spell objSpell)
            {
                SustainedObject objSustained = new SustainedObject(CharacterObject);
                objSustained.Create(objSpell);
                CharacterObject.SustainedCollection.Add(objSustained);
            }
        }

        /// <summary>
        /// Adds a sustained complex form
        /// </summary>
        private void AddSustainedComplexForm()
        {
            if (treComplexForms.SelectedNode?.Level > 0 && treComplexForms.SelectedNode.Tag is ComplexForm objComplexForm)
            {
                SustainedObject objSustained = new SustainedObject(CharacterObject);
                objSustained.Create(objComplexForm);
                CharacterObject.SustainedCollection.Add(objSustained);
            }
        }

        /// <summary>
        /// Add a sustained critter power
        /// </summary>
        private void AddSustainedCritterPower()
        {
            if (treCritterPowers.SelectedNode?.Level > 0 && treCritterPowers.SelectedNode.Tag is CritterPower objCritterPower)
            {
                SustainedObject objSustained = new SustainedObject(CharacterObject);
                objSustained.Create(objCritterPower);
                CharacterObject.SustainedCollection.Add(objSustained);
            }
        }

        #endregion Custom Methods

        private void cmdIncreasePowerPoints_Click(object sender, EventArgs e)
        {
            // Make sure the character has enough Karma to improve the CharacterAttribute.
            int intKarmaCost = CharacterObject.Settings.KarmaMysticAdeptPowerPoint;
            if (intKarmaCost > CharacterObject.Karma)
            {
                Program.ShowMessageBox(this, LanguageManager.GetString("Message_NotEnoughKarma"), LanguageManager.GetString("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            if (CharacterObject.MysticAdeptPowerPoints + 1 > CharacterObject.MAG.TotalValue)
            {
                Program.ShowMessageBox(this, LanguageManager.GetString("Message_NotEnoughMagic"), LanguageManager.GetString("MessageTitle_NotEnoughMagic"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, LanguageManager.GetString("Message_ConfirmKarmaExpenseSpend")
                , LanguageManager.GetString("String_PowerPoint")
                , intKarmaCost.ToString(GlobalSettings.CultureInfo))))
                return;

            // Create the Karma expense.
            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
            objExpense.Create(intKarmaCost * -1, LanguageManager.GetString("String_PowerPoint"), ExpenseType.Karma, DateTime.Now);
            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
            CharacterObject.Karma -= intKarmaCost;

            ExpenseUndo objUndo = new ExpenseUndo();
            objUndo.CreateKarma(KarmaExpenseType.AddPowerPoint, string.Empty);
            objExpense.Undo = objUndo;

            ++CharacterObject.MysticAdeptPowerPoints;
        }

        private async void tsMetamagicAddMetamagic_Click(object sender, EventArgs e)
        {
            // Character can only have a number of Metamagics/Echoes equal to their Initiate Grade. Additional ones cost Karma.

            if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is InitiationGrade objGrade))
                return;

            // Evaluate each object
            bool blnPayWithKarma = CharacterObject.Metamagics.Any(objMetamagic => objMetamagic.Grade == objGrade.Grade) ||
                                   CharacterObject.Spells.Any(objSpell => objSpell.Grade == objGrade.Grade);

            // Additional Metamagics beyond the standard 1 per Grade cost additional Karma, so ask if the user wants to spend the additional Karma.
            if (blnPayWithKarma && CharacterObject.Karma < CharacterObjectSettings.KarmaMetamagic)
            {
                // Make sure the Karma expense would not put them over the limit.
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            if (CharacterObject.MAGEnabled && blnPayWithKarma)
            {
                if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend")
                    , await LanguageManager.GetStringAsync("String_Metamagic")
                    , CharacterObjectSettings.KarmaMetamagic.ToString(GlobalSettings.CultureInfo))))
                    return;
            }
            else if (blnPayWithKarma && !CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend")
                , await LanguageManager.GetStringAsync("String_Echo")
                , CharacterObjectSettings.KarmaMetamagic.ToString(GlobalSettings.CultureInfo))))
                return;

            using (ThreadSafeForm<SelectMetamagic> frmPickMetamagic = await ThreadSafeForm<SelectMetamagic>.GetAsync(() => new SelectMetamagic(CharacterObject, objGrade)))
            {
                // Make sure a value was selected.
                if (await frmPickMetamagic.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                Metamagic objNewMetamagic = new Metamagic(CharacterObject);

                XmlNode objXmlMetamagic;
                Improvement.ImprovementSource objSource;
                if (CharacterObject.RESEnabled)
                {
                    objXmlMetamagic = (await CharacterObject.LoadDataAsync("echoes.xml")).SelectSingleNode("/chummer/echoes/echo[id = " + frmPickMetamagic.MyForm.SelectedMetamagic.CleanXPath() + ']');
                    objSource = Improvement.ImprovementSource.Echo;
                }
                else
                {
                    objXmlMetamagic = (await CharacterObject.LoadDataAsync("metamagic.xml")).SelectSingleNode("/chummer/metamagics/metamagic[id = " + frmPickMetamagic.MyForm.SelectedMetamagic.CleanXPath() + ']');
                    objSource = Improvement.ImprovementSource.Metamagic;
                }

                objNewMetamagic.Create(objXmlMetamagic, objSource);
                objNewMetamagic.Grade = objGrade.Grade;
                if (objNewMetamagic.InternalId.IsEmptyGuid())
                    return;

                await CharacterObject.Metamagics.AddAsync(objNewMetamagic);

                if (blnPayWithKarma)
                {
                    string strType = await LanguageManager.GetStringAsync(objNewMetamagic.SourceType == Improvement.ImprovementSource.Echo ? "String_Echo" : "String_Metamagic");
                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(CharacterObjectSettings.KarmaMetamagic * -1, strType + await LanguageManager.GetStringAsync("String_Space") + objNewMetamagic.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.AddMetamagic, objNewMetamagic.InternalId);
                    objExpense.Undo = objUndo;

                    // Adjust the character's Karma total.
                    CharacterObject.Karma -= CharacterObjectSettings.KarmaMetamagic;
                }
            }
        }

        private async void tsMetamagicAddArt_Click(object sender, EventArgs e)
        {
            if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is InitiationGrade objGrade))
                return;

            int intGrade = objGrade.Grade;

            /*
            // Character can only have a number of Metamagics/Echoes equal to their Initiate Grade. Additional ones cost Karma.
            bool blnPayWithKarma = false;
            if (blnPayWithKarma && CharacterObject.Karma < CharacterObjectSettings.KarmaMetamagic)
            {
                // Make sure the Karma expense would not put them over the limit.
                Program.ShowMessageBox(this, LanguageManager.GetString("Message_NotEnoughKarma"), LanguageManager.GetString("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }
            */

            using (ThreadSafeForm<SelectArt> frmPickArt
                   = await ThreadSafeForm<SelectArt>.GetAsync(() => new SelectArt(CharacterObject, SelectArt.Mode.Art)))
            {
                // Make sure a value was selected.
                if (await frmPickArt.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                XmlNode objXmlArt = (await CharacterObject.LoadDataAsync("metamagic.xml")).SelectSingleNode("/chummer/arts/art[id = " + frmPickArt.MyForm.SelectedItem.CleanXPath() + ']');

                Art objArt = new Art(CharacterObject);
                objArt.Create(objXmlArt, Improvement.ImprovementSource.Metamagic);
                objArt.Grade = intGrade;
                if (objArt.InternalId.IsEmptyGuid())
                    return;

                await CharacterObject.Arts.AddAsync(objArt);

                /*
                if (blnPayWithKarma)
                {
                    string strType = LanguageManager.GetString("String_Art");
                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create(CharacterObjectSettings.KarmaMetamagic * -1, strType + LanguageManager.GetString("String_Space") + objArt.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(KarmaExpenseType.AddMetamagic, objArt.InternalId);
                    objExpense.Undo = objUndo;

                    // Adjust the character's Karma total.
                    CharacterObject.Karma -= CharacterObjectSettings.KarmaMetamagic;
                }
                */
            }
        }

        private async void tsMetamagicAddEnchantment_Click(object sender, EventArgs e)
        {
            if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is InitiationGrade objGrade))
                return;

            int intGrade = objGrade.Grade;

            // Character can only have a number of Metamagics/Echoes equal to their Initiate Grade. Additional ones cost Karma.
            bool blnPayWithKarma = false;

            // Evaluate each object
            foreach (Metamagic objMetamagic in CharacterObject.Metamagics)
            {
                if (objMetamagic.Grade == intGrade)
                    blnPayWithKarma = true;
            }

            foreach (Spell objSpell in CharacterObject.Spells)
            {
                if (objSpell.Grade == intGrade)
                    blnPayWithKarma = true;
            }

            int intSpellKarmaCost = CharacterObject.SpellKarmaCost("Enchantments");

            if (blnPayWithKarma)
            {
                if (CharacterObject.Karma < intSpellKarmaCost)
                {
                    // Make sure the Karma expense would not put them over the limit.
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK,
                        MessageBoxIcon.Information);
                    return;
                }

                if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo,
                    await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend")
                    , await LanguageManager.GetStringAsync("String_Enchantment")
                    , intSpellKarmaCost.ToString(GlobalSettings.CultureInfo))))
                    return;
            }

            XmlNode objXmlArt;
            using (ThreadSafeForm<SelectArt> frmPickArt
                   = await ThreadSafeForm<SelectArt>.GetAsync(
                       () => new SelectArt(CharacterObject, SelectArt.Mode.Enchantment)))
            {
                // Make sure a value was selected.
                if (await frmPickArt.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objXmlArt = (await CharacterObject.LoadDataAsync("spells.xml")).SelectSingleNode("/chummer/spells/spell[id = " + frmPickArt.MyForm.SelectedItem.CleanXPath() + ']');
            }

            Spell objNewSpell = new Spell(CharacterObject);
            objNewSpell.Create(objXmlArt, string.Empty, false, false, false, Improvement.ImprovementSource.Initiation);
            objNewSpell.Grade = intGrade;
            if (objNewSpell.InternalId.IsEmptyGuid())
            {
                objNewSpell.Dispose();
                return;
            }

            await CharacterObject.Spells.AddAsync(objNewSpell);

            if (blnPayWithKarma)
            {
                string strType = await LanguageManager.GetStringAsync("String_Enhancement");
                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(-intSpellKarmaCost, strType + await LanguageManager.GetStringAsync("String_Space") + objNewSpell.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.AddSpell, objNewSpell.InternalId);
                objExpense.Undo = objUndo;

                // Adjust the character's Karma total.
                CharacterObject.Karma -= intSpellKarmaCost;
            }
        }

        private async void tsMetamagicAddRitual_Click(object sender, EventArgs e)
        {
            if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is InitiationGrade objGrade))
                return;

            int intGrade = objGrade.Grade;

            // Character can only have a number of Metamagics/Echoes equal to their Initiate Grade. Additional ones cost Karma.
            // Evaluate each object
            bool blnPayWithKarma = CharacterObject.Metamagics.Any(objMetamagic => objMetamagic.Grade == intGrade)
                || CharacterObject.Spells.Any(objSpell => objSpell.Grade == intGrade);

            int intSpellKarmaCost = CharacterObject.SpellKarmaCost("Rituals");
            if (blnPayWithKarma)
            {
                if (CharacterObject.Karma < intSpellKarmaCost)
                {
                    // Make sure the Karma expense would not put them over the limit.
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"),
                        await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK,
                        MessageBoxIcon.Information);
                    return;
                }

                if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo,
                    await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend")
                    , await LanguageManager.GetStringAsync("String_Ritual")
                    , intSpellKarmaCost.ToString(GlobalSettings.CultureInfo))))
                    return;
            }

            XmlNode objXmlArt;
            using (ThreadSafeForm<SelectArt> frmPickArt
                   = await ThreadSafeForm<SelectArt>.GetAsync(
                       () => new SelectArt(CharacterObject, SelectArt.Mode.Ritual)))
            {
                // Make sure a value was selected.
                if (await frmPickArt.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objXmlArt = (await CharacterObject.LoadDataAsync("spells.xml")).SelectSingleNode("/chummer/spells/spell[id = " + frmPickArt.MyForm.SelectedItem.CleanXPath() + ']');
            }

            Spell objNewSpell = new Spell(CharacterObject);
            objNewSpell.Create(objXmlArt, string.Empty, false, false, false, Improvement.ImprovementSource.Initiation);
            objNewSpell.Grade = intGrade;
            if (objNewSpell.InternalId.IsEmptyGuid())
            {
                objNewSpell.Dispose();
                return;
            }

            await CharacterObject.Spells.AddAsync(objNewSpell);

            if (blnPayWithKarma)
            {
                string strType = await LanguageManager.GetStringAsync("String_Ritual");
                // Create the Expense Log Entry.
                ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                objExpense.Create(-intSpellKarmaCost, strType + await LanguageManager.GetStringAsync("String_Space") + objNewSpell.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
                CharacterObject.ExpenseEntries.AddWithSort(objExpense);

                ExpenseUndo objUndo = new ExpenseUndo();
                objUndo.CreateKarma(KarmaExpenseType.AddSpell, objNewSpell.InternalId);
                objExpense.Undo = objUndo;

                // Adjust the character's Karma total.
                CharacterObject.Karma -= intSpellKarmaCost;
            }
        }

        private async void tsInitiationNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicAddEnhancement_Click(object sender, EventArgs e)
        {
            if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is InitiationGrade objGrade))
                return;

            int intGrade = objGrade.Grade;

            if (CharacterObject.Karma < CharacterObjectSettings.KarmaEnhancement)
            {
                // Make sure the Karma expense would not put them over the limit.
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend")
                , await LanguageManager.GetStringAsync("String_Enhancement")
                , CharacterObjectSettings.KarmaEnhancement.ToString(GlobalSettings.CultureInfo))))
                return;

            XmlNode objXmlArt;
            using (ThreadSafeForm<SelectArt> frmPickArt
                   = await ThreadSafeForm<SelectArt>.GetAsync(
                       () => new SelectArt(CharacterObject, SelectArt.Mode.Enhancement)))
            {
                // Make sure a value was selected.
                if (await frmPickArt.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objXmlArt = (await CharacterObject.LoadDataAsync("powers.xml")).SelectSingleNode("/chummer/enhancements/enhancement[id = " + frmPickArt.MyForm.SelectedItem.CleanXPath() + ']');
            }

            if (objXmlArt == null)
                return;

            Enhancement objEnhancement = new Enhancement(CharacterObject);
            objEnhancement.Create(objXmlArt, Improvement.ImprovementSource.Initiation);
            objEnhancement.Grade = intGrade;
            if (objEnhancement.InternalId.IsEmptyGuid())
                return;

            // Find the associated Power
            string strPower = objXmlArt["power"]?.InnerText;
            bool blnPowerFound = false;
            foreach (Power objPower in CharacterObject.Powers)
            {
                if (objPower.Name == strPower)
                {
                    await objPower.Enhancements.AddAsync(objEnhancement);
                    blnPowerFound = true;
                    break;
                }
            }

            if (!blnPowerFound)
            {
                // Add it to the character instead
                await CharacterObject.Enhancements.AddAsync(objEnhancement);
            }

            string strType = await LanguageManager.GetStringAsync("String_Enhancement");
            // Create the Expense Log Entry.
            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
            objExpense.Create(CharacterObjectSettings.KarmaEnhancement * -1, strType + await LanguageManager.GetStringAsync("String_Space") + objEnhancement.CurrentDisplayNameShort, ExpenseType.Karma, DateTime.Now);
            CharacterObject.ExpenseEntries.AddWithSort(objExpense);

            ExpenseUndo objUndo = new ExpenseUndo();
            objUndo.CreateKarma(KarmaExpenseType.AddSpell, objEnhancement.InternalId);
            objExpense.Undo = objUndo;

            // Adjust the character's Karma total.
            CharacterObject.Karma -= CharacterObjectSettings.KarmaEnhancement;
        }

        private void panContacts_Click(object sender, EventArgs e)
        {
            panContacts.Focus();
        }

        private void panEnemies_Click(object sender, EventArgs e)
        {
            panEnemies.Focus();
        }

        private async void cboGearOverclocker_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing || !CharacterObject.Overclocker)
                return;
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objCommlink))
                return;
            string strOldOverClocked = objCommlink.Overclocked;
            objCommlink.Overclocked = await cboGearOverclocker.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString());
            await objCommlink.RefreshMatrixAttributeComboBoxesAsync(cboGearAttack, cboGearSleaze, cboGearDataProcessing, cboGearFirewall);
            if (objCommlink.IsActiveCommlink(CharacterObject) || objCommlink.IsHomeNode(CharacterObject))
            {
                if (strOldOverClocked == "Data Processing" || objCommlink.Overclocked == "Data Processing")
                {
                    if (objCommlink.IsActiveCommlink(CharacterObject))
                    {
                        if (objCommlink.IsHomeNode(CharacterObject))
                            CharacterObject.OnMultiplePropertyChanged(nameof(Character.MatrixInitiativeValue),
                                                                      nameof(Character.MatrixInitiativeColdValue),
                                                                      nameof(Character.MatrixInitiativeHotValue));
                        else
                            CharacterObject.OnMultiplePropertyChanged(nameof(Character.MatrixInitiativeColdValue),
                                                                      nameof(Character.MatrixInitiativeHotValue));
                    }
                    else
                        CharacterObject.OnPropertyChanged(nameof(Character.MatrixInitiativeValue));
                }
                await RequestCharacterUpdate();
                await SetDirty(true);
            }
        }

        private async void cboArmorOverclocker_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing || !CharacterObject.Overclocker)
                return;
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objCommlink))
                return;
            string strOldOverClocked = objCommlink.Overclocked;
            objCommlink.Overclocked = await cboArmorOverclocker.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString());
            await objCommlink.RefreshMatrixAttributeComboBoxesAsync(cboArmorAttack, cboArmorSleaze, cboArmorDataProcessing, cboArmorFirewall);
            if (objCommlink.IsActiveCommlink(CharacterObject) || objCommlink.IsHomeNode(CharacterObject))
            {
                if (strOldOverClocked == "Data Processing" || objCommlink.Overclocked == "Data Processing")
                {
                    if (objCommlink.IsActiveCommlink(CharacterObject))
                    {
                        if (objCommlink.IsHomeNode(CharacterObject))
                            CharacterObject.OnMultiplePropertyChanged(nameof(Character.MatrixInitiativeValue),
                                                                      nameof(Character.MatrixInitiativeColdValue),
                                                                      nameof(Character.MatrixInitiativeHotValue));
                        else
                            CharacterObject.OnMultiplePropertyChanged(nameof(Character.MatrixInitiativeColdValue),
                                                                      nameof(Character.MatrixInitiativeHotValue));
                    }
                    else
                        CharacterObject.OnPropertyChanged(nameof(Character.MatrixInitiativeValue));
                }
                await RequestCharacterUpdate();
                await SetDirty(true);
            }
        }

        private async void cboWeaponOverclocker_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing || !CharacterObject.Overclocker)
                return;
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objCommlink))
                return;
            string strOldOverClocked = objCommlink.Overclocked;
            objCommlink.Overclocked = await cboWeaponOverclocker.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString());
            await objCommlink.RefreshMatrixAttributeComboBoxesAsync(cboWeaponGearAttack, cboWeaponGearSleaze, cboWeaponGearDataProcessing, cboWeaponGearFirewall);
            if (objCommlink.IsActiveCommlink(CharacterObject) || objCommlink.IsHomeNode(CharacterObject))
            {
                if (strOldOverClocked == "Data Processing" || objCommlink.Overclocked == "Data Processing")
                {
                    if (objCommlink.IsActiveCommlink(CharacterObject))
                    {
                        if (objCommlink.IsHomeNode(CharacterObject))
                            CharacterObject.OnMultiplePropertyChanged(nameof(Character.MatrixInitiativeValue),
                                                                      nameof(Character.MatrixInitiativeColdValue),
                                                                      nameof(Character.MatrixInitiativeHotValue));
                        else
                            CharacterObject.OnMultiplePropertyChanged(nameof(Character.MatrixInitiativeColdValue),
                                                                      nameof(Character.MatrixInitiativeHotValue));
                    }
                    else
                        CharacterObject.OnPropertyChanged(nameof(Character.MatrixInitiativeValue));
                }
                await RequestCharacterUpdate();
                await SetDirty(true);
            }
        }

        private async void cboCyberwareOverclocker_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing || !CharacterObject.Overclocker)
                return;
            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objCommlink))
                return;
            string strOldOverClocked = objCommlink.Overclocked;
            objCommlink.Overclocked = await cboCyberwareOverclocker.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString());
            await objCommlink.RefreshMatrixAttributeComboBoxesAsync(cboCyberwareAttack, cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall);
            if (objCommlink.IsActiveCommlink(CharacterObject) || objCommlink.IsHomeNode(CharacterObject))
            {
                if (strOldOverClocked == "Data Processing" || objCommlink.Overclocked == "Data Processing")
                {
                    if (objCommlink.IsActiveCommlink(CharacterObject))
                    {
                        if (objCommlink.IsHomeNode(CharacterObject))
                            CharacterObject.OnMultiplePropertyChanged(nameof(Character.MatrixInitiativeValue),
                                                                      nameof(Character.MatrixInitiativeColdValue),
                                                                      nameof(Character.MatrixInitiativeHotValue));
                        else
                            CharacterObject.OnMultiplePropertyChanged(nameof(Character.MatrixInitiativeColdValue),
                                                                      nameof(Character.MatrixInitiativeHotValue));
                    }
                    else
                        CharacterObject.OnPropertyChanged(nameof(Character.MatrixInitiativeValue));
                }
                await RequestCharacterUpdate();
                await SetDirty(true);
            }
        }

        private async void cmdAddAIProgram_Click(object sender, EventArgs e)
        {
            int intNewAIProgramCost = CharacterObject.AIProgramKarmaCost;
            int intNewAIAdvancedProgramCost = CharacterObject.AIAdvancedProgramKarmaCost;
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("programs.xml");

            bool blnAddAgain;
            do
            {
                // Make sure the character has enough Karma before letting them select a Spell.
                if (CharacterObject.Karma < intNewAIProgramCost && CharacterObject.Karma < intNewAIAdvancedProgramCost)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughKarma"), await LanguageManager.GetStringAsync("MessageTitle_NotEnoughKarma"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    break;
                }
                // Let the user select a Program.
                using (ThreadSafeForm<SelectAIProgram> frmPickProgram = await ThreadSafeForm<SelectAIProgram>.GetAsync(() => new SelectAIProgram(CharacterObject, CharacterObject.Karma >= intNewAIAdvancedProgramCost)))
                {
                    // Make sure the dialogue window was not canceled.
                    if (await frmPickProgram.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        break;

                    blnAddAgain = frmPickProgram.MyForm.AddAgain;

                    XmlNode objXmlProgram = objXmlDocument.SelectSingleNode("/chummer/programs/program[id = " + frmPickProgram.MyForm.SelectedProgram.CleanXPath() + ']');
                    if (objXmlProgram == null)
                        continue;

                    // Check for SelectText.
                    string strExtra = string.Empty;
                    XmlNode xmlSelectText = objXmlProgram.SelectSingleNode("bonus/selecttext");
                    if (xmlSelectText != null)
                    {
                        string strDescription = string.Format(GlobalSettings.CultureInfo,
                                                              await LanguageManager.GetStringAsync(
                                                                  "String_Improvement_SelectText")
                                                              , objXmlProgram["translate"]?.InnerText ?? objXmlProgram["name"]?.InnerText ?? await LanguageManager.GetStringAsync("String_Unknown"));
                        using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                               {
                                   Description = strDescription
                               }))
                        {
                            if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                                continue;
                            strExtra = frmPickText.MyForm.SelectedValue;
                        }
                    }

                    AIProgram objProgram = new AIProgram(CharacterObject);
                    objProgram.Create(objXmlProgram, strExtra);
                    if (objProgram.InternalId.IsEmptyGuid())
                        continue;

                    bool boolIsAdvancedProgram = objProgram.IsAdvancedProgram;
                    if (!CommonFunctions.ConfirmKarmaExpense(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ConfirmKarmaExpenseSpend")
                        , objProgram.CurrentDisplayNameShort
                        , (boolIsAdvancedProgram ? intNewAIAdvancedProgramCost : intNewAIProgramCost).ToString(GlobalSettings.CultureInfo))))
                        continue;

                    await CharacterObject.AIPrograms.AddAsync(objProgram);

                    // Create the Expense Log Entry.
                    ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
                    objExpense.Create((boolIsAdvancedProgram ? intNewAIAdvancedProgramCost : intNewAIProgramCost) * -1, await LanguageManager.GetStringAsync("String_ExpenseLearnProgram") + await LanguageManager.GetStringAsync("String_Space") + objProgram.Name,
                        ExpenseType.Karma, DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objExpense);
                    CharacterObject.Karma -= boolIsAdvancedProgram ? intNewAIAdvancedProgramCost : intNewAIProgramCost;

                    ExpenseUndo objUndo = new ExpenseUndo();
                    objUndo.CreateKarma(boolIsAdvancedProgram ? KarmaExpenseType.AddAIAdvancedProgram : KarmaExpenseType.AddAIProgram, objProgram.InternalId);
                    objExpense.Undo = objUndo;
                }
            }
            while (blnAddAgain);
        }

        private void cmdDeleteAIProgram_Click(object sender, EventArgs e)
        {
            // Delete the selected AI Program.
            if (!(treAIPrograms.SelectedNode?.Tag is ICanRemove selectedObject))
                return;
            selectedObject.Remove();
        }

        private async void treAIPrograms_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedAIProgram(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedAIProgram(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                // Locate the Program that is selected in the tree.
                if (await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is AIProgram objProgram)
                {
                    string strText = await objProgram.DisplayRequiresProgramAsync(GlobalSettings.Language);
                    await lblAIProgramsRequires.DoThreadSafeAsync(x => x.Text = strText, token);
                    await objProgram.SetSourceDetailAsync(lblAIProgramsSource, token);
                }
                else
                {
                    await lblAIProgramsRequires.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await SourceString.Blank.SetControlAsync(lblAIProgramsSource, token);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private void treAIPrograms_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteAIProgram_Click(sender, e);
            }
        }

        private async void tsAIProgramNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboPrimaryArm_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing || CharacterObject.Ambidextrous)
                return;
            CharacterObject.PrimaryArm = await cboPrimaryArm.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString());

            await SetDirty(true);
        }

        private async void picMugshot_SizeChanged(object sender, EventArgs e)
        {
            try
            {
                await ProcessMugshot(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async ValueTask ProcessMugshot(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (await this.DoThreadSafeFuncAsync(x => x.IsNullOrDisposed(), token))
                return;
            await picMugshot.DoThreadSafeAsync(x =>
            {
                try
                {
                    x.SizeMode = x.Image != null && x.Height >= x.Image.Height
                                                 && x.Width >= x.Image.Width
                        ? PictureBoxSizeMode.CenterImage
                        : PictureBoxSizeMode.Zoom;
                }
                catch (ArgumentException) // No other way to catch when the Image is not null, but is disposed
                {
                    x.SizeMode = PictureBoxSizeMode.Zoom;
                }
            }, token);
        }

        private async void cmdCyberwareChangeMount_Click(object sender, EventArgs e)
        {
            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objModularCyberware))
                return;
            string strSelectedParentID;
            using (new FetchSafelyFromPool<List<ListItem>>(
                       Utils.ListItemListPool, out List<ListItem> lstModularMounts))
            {
                lstModularMounts.AddRange(CharacterObject.ConstructModularCyberlimbList(objModularCyberware));
                //Mounted cyberware should always be allowed to be dismounted.
                //Unmounted cyberware requires that a valid mount be present.
                if (!objModularCyberware.IsModularCurrentlyEquipped
                    && lstModularMounts.All(
                        x => !string.Equals(x.Value.ToString(), "None", StringComparison.OrdinalIgnoreCase)))
                {
                    Program.ShowMessageBox(this,
                                                    await LanguageManager.GetStringAsync("Message_NoValidModularMount"),
                                                    await LanguageManager.GetStringAsync("MessageTitle_NoValidModularMount"),
                                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                string strDescription = await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware");
                using (ThreadSafeForm<SelectItem> frmPickMount = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem
                       {
                           Description = strDescription
                       }))
                {
                    frmPickMount.MyForm.SetGeneralItemsMode(lstModularMounts);

                    // Make sure the dialogue window was not canceled.
                    if (await frmPickMount.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    {
                        return;
                    }

                    strSelectedParentID = frmPickMount.MyForm.SelectedItem;
                }
            }

            Cyberware objOldParent = objModularCyberware.Parent;
            if (objOldParent != null)
                objModularCyberware.ChangeModularEquip(false);
            if (strSelectedParentID == "None")
            {
                if (objOldParent != null)
                {
                    await objOldParent.Children.RemoveAsync(objModularCyberware);

                    await CharacterObject.Cyberware.AddAsync(objModularCyberware);
                }
            }
            else
            {
                Cyberware objNewParent = CharacterObject.Cyberware.DeepFindById(strSelectedParentID);
                if (objNewParent != null)
                {
                    if (objOldParent != null)
                        await objOldParent.Children.RemoveAsync(objModularCyberware);
                    else
                        await CharacterObject.Cyberware.RemoveAsync(objModularCyberware);

                    await objNewParent.Children.AddAsync(objModularCyberware);

                    objModularCyberware.ChangeModularEquip(true);
                }
                else
                {
                    VehicleMod objNewVehicleModParent = CharacterObject.Vehicles.FindVehicleMod(x => x.InternalId == strSelectedParentID);
                    if (objNewVehicleModParent == null)
                        objNewParent = CharacterObject.Vehicles.FindVehicleCyberware(x => x.InternalId == strSelectedParentID, out objNewVehicleModParent);
                    if (objNewVehicleModParent != null || objNewParent != null)
                    {
                        if (objOldParent != null)
                            await objOldParent.Children.RemoveAsync(objModularCyberware);
                        else
                            await CharacterObject.Cyberware.RemoveAsync(objModularCyberware);

                        if (objNewParent != null)
                            await objNewParent.Children.AddAsync(objModularCyberware);
                        else
                            await objNewVehicleModParent.Cyberware.AddAsync(objModularCyberware);
                    }
                    else if (objOldParent != null)
                    {
                        await objOldParent.Children.RemoveAsync(objModularCyberware);

                        await CharacterObject.Cyberware.AddAsync(objModularCyberware);
                    }
                }
            }
        }

        private async void cmdVehicleCyberwareChangeMount_Click(object sender, EventArgs e)
        {
            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objModularCyberware))
                return;
            string strSelectedParentID;
            using (new FetchSafelyFromPool<List<ListItem>>(
                       Utils.ListItemListPool, out List<ListItem> lstModularMounts))
            {
                lstModularMounts.AddRange(CharacterObject.ConstructModularCyberlimbList(objModularCyberware));
                //Mounted cyberware should always be allowed to be dismounted.
                //Unmounted cyberware requires that a valid mount be present.
                if (!objModularCyberware.IsModularCurrentlyEquipped
                    && lstModularMounts.All(
                        x => !string.Equals(x.Value.ToString(), "None", StringComparison.OrdinalIgnoreCase)))
                {
                    Program.ShowMessageBox(this,
                                           await LanguageManager.GetStringAsync("Message_NoValidModularMount"),
                                           await LanguageManager.GetStringAsync("MessageTitle_NoValidModularMount"),
                                           MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                string strDescription = await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware");
                using (ThreadSafeForm<SelectItem> frmPickMount = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem
                       {
                           Description = strDescription
                       }))
                {
                    frmPickMount.MyForm.SetGeneralItemsMode(lstModularMounts);

                    // Make sure the dialogue window was not canceled.
                    if (await frmPickMount.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    {
                        return;
                    }

                    strSelectedParentID = frmPickMount.MyForm.SelectedItem;
                }
            }
            CharacterObject.Vehicles.FindVehicleCyberware(x => x.InternalId == objModularCyberware.InternalId, out VehicleMod objOldParentVehicleMod);

            Cyberware objOldParent = objModularCyberware.Parent;
            if (objOldParent != null)
                objModularCyberware.ChangeModularEquip(false);
            if (strSelectedParentID == "None")
            {
                if (objOldParent != null)
                    await objOldParent.Children.RemoveAsync(objModularCyberware);
                else
                    await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware);

                await CharacterObject.Cyberware.AddAsync(objModularCyberware);
            }
            else
            {
                Cyberware objNewParent = CharacterObject.Cyberware.DeepFindById(strSelectedParentID);
                if (objNewParent != null)
                {
                    if (objOldParent != null)
                        await objOldParent.Children.RemoveAsync(objModularCyberware);
                    else
                        await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware);

                    await objNewParent.Children.AddAsync(objModularCyberware);

                    objModularCyberware.ChangeModularEquip(true);
                }
                else
                {
                    VehicleMod objNewVehicleModParent = CharacterObject.Vehicles.FindVehicleMod(x => x.InternalId == strSelectedParentID);
                    if (objNewVehicleModParent == null)
                        objNewParent = CharacterObject.Vehicles.FindVehicleCyberware(x => x.InternalId == strSelectedParentID, out objNewVehicleModParent);
                    if (objNewVehicleModParent != null || objNewParent != null)
                    {
                        if (objOldParent != null)
                            await objOldParent.Children.RemoveAsync(objModularCyberware);
                        else
                            await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware);

                        if (objNewParent != null)
                            await objNewParent.Children.AddAsync(objModularCyberware);
                        else
                            await objNewVehicleModParent.Cyberware.AddAsync(objModularCyberware);
                    }
                    else
                    {
                        if (objOldParent != null)
                            await objOldParent.Children.RemoveAsync(objModularCyberware);
                        else
                            await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware);

                        await CharacterObject.Cyberware.AddAsync(objModularCyberware);
                    }
                }
            }
        }

        private async void cboAttributeCategory_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken);
                try
                {
                    CharacterObject.AttributeSection.AttributeCategory
                        = AttributeSection.ConvertAttributeCategory(
                            await cboAttributeCategory.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString(), GenericToken));
                }
                finally
                {
                    await objCursorWait.DisposeAsync();
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void cmdContactsExpansionToggle_Click(object sender, EventArgs e)
        {
            if (panContacts.Controls.Count > 0)
            {
                panContacts.SuspendLayout();
                bool toggle = ((ContactControl)panContacts.Controls[0]).Expanded;

                foreach (ContactControl c in panContacts.Controls)
                {
                    c.Expanded = !toggle;
                }

                panContacts.ResumeLayout();
            }
        }

        private void cmdSwapContactOrder_Click(object sender, EventArgs e)
        {
            panContacts.FlowDirection = panContacts.FlowDirection == FlowDirection.LeftToRight
                ? FlowDirection.TopDown
                : FlowDirection.LeftToRight;
        }

        private async void tsGearLocationAddGear_Click(object sender, EventArgs e)
        {
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objLocation))
                return;
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickGear(null, objLocation);
            }
            while (blnAddAgain);
        }

        private async void tsVehicleLocationAddVehicle_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await AddVehicle(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) as Location);
            }
            while (blnAddAgain);
        }

        private async void tsWeaponLocationAddWeapon_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickWeapon(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) as Location);
            }
            while (blnAddAgain);
        }

        private void tsVehicleLocationAddWeapon_Click(object sender, EventArgs e)
        {
            //TODO: Where should weapons attached to locations of vehicles go?
            //PickWeapon(treVehicles.SelectedNode);
        }

        private async void cboVehicleWeaponFiringMode_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            objWeapon.FireMode = await cboVehicleWeaponFiringMode.DoThreadSafeFuncAsync(x => x.SelectedIndex >= 0
                ? (Weapon.FiringMode) x.SelectedValue
                : Weapon.FiringMode.DogBrain);
            await RefreshSelectedVehicle();

            await SetDirty(true);
        }

        private async void OpenSourceFromLabel(object sender, EventArgs e)
        {
            await CommonFunctions.OpenPdfFromControl(sender);
        }

        private async void btnCreateCustomDrug_Click(object sender, EventArgs e)
        {
            using (ThreadSafeForm<CreateCustomDrug> form = await ThreadSafeForm<CreateCustomDrug>.GetAsync(() => new CreateCustomDrug(CharacterObject)))
            {
                if (await form.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                Drug objCustomDrug = form.MyForm.CustomDrug;
                objCustomDrug.Quantity = 0;
                await CharacterObject.Drugs.AddAsync(objCustomDrug);
                objCustomDrug.GenerateImprovement();
            }
        }

        private async void btnIncreaseDrugQty_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode);
            if (!(objSelectedNode?.Tag is Drug selectedDrug))
                return;

            decimal decCost = selectedDrug.Cost;
            /* Apply a markup if applicable.
            if (frmPickArmor.Markup != 0)
            {
                decCost *= 1 + (frmPickArmor.Markup / 100.0m);
            }*/

            // Multiply the cost if applicable.
            char chrAvail = selectedDrug.TotalAvailTuple().Suffix;
            switch (chrAvail)
            {
                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                    break;

                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                    break;
            }

            // Check the item's Cost and make sure the character can afford it.
            if (decCost > CharacterObject.Nuyen)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NotEnoughNuyen"),
                    await LanguageManager.GetStringAsync("MessageTitle_NotEnoughNuyen"),
                    MessageBoxButtons.OK, MessageBoxIcon.Information);
            }

            if (!CharacterObject.Improvements.Any(imp =>
                imp.ImproveSource == Improvement.ImprovementSource.Drug && imp.SourceName == selectedDrug.InternalId))
            {
                selectedDrug.GenerateImprovement();
            }

            // Create the Expense Log Entry.
            ExpenseLogEntry objExpense = new ExpenseLogEntry(CharacterObject);
            objExpense.Create(decCost * -1,
                await LanguageManager.GetStringAsync("String_ExpensePurchaseDrug") +
                await LanguageManager.GetStringAsync("String_Space") +
                selectedDrug.CurrentDisplayNameShort, ExpenseType.Nuyen, DateTime.Now);
            CharacterObject.ExpenseEntries.AddWithSort(objExpense);
            CharacterObject.Nuyen -= decCost;
            selectedDrug.Quantity++;
            await treCustomDrugs.DoThreadSafeAsync(() => objSelectedNode.Text = selectedDrug.CurrentDisplayName);
            ExpenseUndo objUndo = new ExpenseUndo();
            objUndo.CreateNuyen(NuyenExpenseType.AddGear, selectedDrug.InternalId);
            objExpense.Undo = objUndo;

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void btnDecreaseDrugQty_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode);
            if (!(objSelectedNode?.Tag is Drug objDrug))
                return;

            string strDescription = await LanguageManager.GetStringAsync("String_ReduceGear");
            using (ThreadSafeForm<SelectNumber> frmPickNumber = await ThreadSafeForm<SelectNumber>.GetAsync(() => new SelectNumber
                   {
                       Minimum = 0,
                       Maximum = objDrug.Quantity,
                       Description = strDescription
                   }))
            {
                if (await frmPickNumber.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                decimal decSelectedValue = frmPickNumber.MyForm.SelectedValue;

                if (!CommonFunctions.ConfirmDelete(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ReduceQty"), decSelectedValue.ToString(GlobalSettings.CultureInfo))))
                    return;

                objDrug.Quantity -= decSelectedValue;
                await treCustomDrugs.DoThreadSafeAsync(() => objSelectedNode.Text = objDrug.CurrentDisplayName);
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        #region Wireless Toggles

        private void chkGearWireless_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (treGear.SelectedNode.Tag is IHasWirelessBonus obj)
            {
                obj.WirelessOn = chkGearWireless.Checked;
            }
        }

        private void chkCyberwareWireless_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (treCyberware.SelectedNode?.Tag is IHasWirelessBonus obj)
            {
                obj.WirelessOn = chkCyberwareWireless.Checked;
            }
        }

        private void chkWeaponWireless_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (treWeapons.SelectedNode?.Tag is IHasWirelessBonus obj)
            {
                obj.WirelessOn = chkWeaponWireless.Checked;
            }
        }

        private void chkArmorWireless_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (treArmor.SelectedNode?.Tag is IHasWirelessBonus obj)
            {
                obj.WirelessOn = chkArmorWireless.Checked;
            }
        }

        #endregion Wireless Toggles

        private void pnlAttributes_Layout(object sender, LayoutEventArgs e)
        {
            pnlAttributes.SuspendLayout();
            foreach (Control objAttributeControl in pnlAttributes.Controls)
            {
                if (pnlAttributes.ClientSize.Width < objAttributeControl.MinimumSize.Height)
                    objAttributeControl.MinimumSize = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MinimumSize.Height);
                if (pnlAttributes.ClientSize.Width != objAttributeControl.MaximumSize.Height)
                    objAttributeControl.MaximumSize = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MaximumSize.Height);
                if (pnlAttributes.ClientSize.Width > objAttributeControl.MinimumSize.Height)
                    objAttributeControl.MinimumSize = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MinimumSize.Height);
            }
            pnlAttributes.ResumeLayout();
        }

        private async void tsCyberwareUpgrade_Click(object sender, EventArgs e)
        {
            if (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objCyberware)
            {
                if (objCyberware.Capacity == "[*]" && objCyberware.Parent != null)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotRemoveCyberware"), await LanguageManager.GetStringAsync("MessageTitle_CannotRemoveCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                using (ThreadSafeForm<SellItem> frmSell = await ThreadSafeForm<SellItem>.GetAsync(() => new SellItem()))
                {
                    if (await frmSell.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return;

                    using (ThreadSafeForm<SelectCyberware> frmCyberware = await ThreadSafeForm<SelectCyberware>.GetAsync(() => new SelectCyberware(CharacterObject, objCyberware.SourceType)
                           {
                               DefaultSearchText = objCyberware.CurrentDisplayNameShort,
                               Upgrading = true
                           }))
                    {
                        if (await frmCyberware.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            return;

                        objCyberware.Upgrade(frmCyberware.MyForm.SelectedGrade, frmCyberware.MyForm.SelectedRating, frmSell.MyForm.SellPercent, frmCyberware.MyForm.FreeCost);
                    }
                }

                //TODO: Bind displayname to selectednode text properly.
                await treCyberware.DoThreadSafeAsync(x =>
                {
                    if (x.SelectedNode.Tag != objCyberware)
                    {
                        x.FindNodeByTag(objCyberware).Text = objCyberware.CurrentDisplayName;
                    }
                    else
                    {
                        x.SelectedNode.Text = objCyberware.CurrentDisplayName;
                    }
                });
            }
            else
            {
                Utils.BreakIfDebug();
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        // Data binding doesn't work for some reason, so handle visibility toggles through events

        private void chkShowKarmaChart_CheckedChanged(object sender, EventArgs e)
        {
            chtKarma.Visible = chkShowKarmaChart.Checked;
        }

        private void chkShowNuyenChart_CheckedChanged(object sender, EventArgs e)
        {
            chtNuyen.Visible = chkShowNuyenChart.Checked;
        }

        private async void mnuSpecialChangeOptions_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken);
                try
                {
                    using (ThreadSafeForm<SelectBuildMethod> frmPickBP
                           = await ThreadSafeForm<SelectBuildMethod>.GetAsync(
                               () => new SelectBuildMethod(CharacterObject, true), GenericToken))
                    {
                        await frmPickBP.ShowDialogSafeAsync(this, GenericToken);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync();
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }
    }
}
