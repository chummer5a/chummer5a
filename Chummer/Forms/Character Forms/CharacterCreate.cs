/*  This file is part of Chummer5a.
 *
 *  Chummer5a is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Chummer5a is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Chummer5a.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  You can obtain the full source code for Chummer5a at
 *  https://github.com/chummer5a/chummer5a
 */

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Xml;
using System.Xml.XPath;
using Chummer.Backend.Attributes;
using Chummer.Backend.Equipment;
using Chummer.Backend.Skills;
using Chummer.Backend.Uniques;
using Microsoft.ApplicationInsights;
using NLog;

namespace Chummer
{
    [DesignerCategory("Form")]
    public partial class CharacterCreate : CharacterShared
    {
        private static readonly TelemetryClient TelemetryClient = new TelemetryClient();
        private static Logger Log { get; } = LogManager.GetCurrentClassLogger();
        
        private bool _blnReapplyImprovements;
        private bool _blnFreestyle;
        public bool IsReopenQueued { get; private set; }
        private int _intDragLevel;
        private StoryBuilder _objStoryBuilder;

        public TabControl TabCharacterTabs => tabCharacterTabs;

        #region Form Events

        [Obsolete("This constructor is for use by form designers only.", true)]
        public CharacterCreate()
        {
            InitializeComponent();
        }

        public CharacterCreate(Character objCharacter) : base(objCharacter)
        {
            InitializeComponent();

            GlobalSettings.ClipboardChanged += RefreshPasteStatus;
            tabStreetGearTabs.MouseWheel += ShiftTabsOnMouseScroll;
            tabPeople.MouseWheel += ShiftTabsOnMouseScroll;
            tabInfo.MouseWheel += ShiftTabsOnMouseScroll;
            tabCharacterTabs.MouseWheel += ShiftTabsOnMouseScroll;

            // Add EventHandlers for the various events MAG, RES, Qualities, etc.
            CharacterObject.PropertyChanged += OnCharacterPropertyChanged;
            CharacterObject.SettingsPropertyChanged += OnCharacterSettingsPropertyChanged;
            tabSkillsUc.MakeDirtyWithCharacterUpdate += MakeDirtyWithCharacterUpdate;
            lmtControl.MakeDirtyWithCharacterUpdate += MakeDirtyWithCharacterUpdate;
            lmtControl.MakeDirty += MakeDirty;

            this.UpdateLightDarkMode();
            this.TranslateWinForm();
            ContextMenuStrip[] lstCMSToTranslate = {
                cmsAdvancedLifestyle,
                cmsAdvancedProgram,
                cmsArmor,
                cmsArmorGear,
                cmsArmorLocation,
                cmsArmorMod,
                cmsBioware,
                cmsComplexForm,
                cmsCritterPowers,
                cmsCyberware,
                cmsCyberwareGear,
                cmsVehicleCyberware,
                cmsVehicleCyberwareGear,
                cmsGear,
                cmsGearAllowRename,
                cmsGearButton,
                cmsGearLocation,
                cmsGearPlugin,
                cmsInitiationNotes,
                cmsLifestyle,
                cmsLifestyleNotes,
                cmsMartialArts,
                cmsMetamagic,
                cmsQuality,
                cmsSpell,
                cmsSpellButton,
                cmsTechnique,
                cmsVehicle,
                cmsVehicleGear,
                cmsVehicleLocation,
                cmsVehicleWeapon,
                cmsVehicleWeaponAccessory,
                cmsVehicleWeaponAccessoryGear,
                cmsWeapon,
                cmsWeaponAccessory,
                cmsWeaponAccessoryGear,
                cmsWeaponLocation,
                cmsWeaponMount
            };

            // Update the text in the Menus so they can be merged with frmMain properly.
            foreach (ToolStripMenuItem tssItem in mnuCreateMenu.Items.OfType<ToolStripMenuItem>())
            {
                tssItem.UpdateLightDarkMode();
                tssItem.TranslateToolStripItemsRecursively();
            }
            foreach (ContextMenuStrip objCMS in lstCMSToTranslate)
            {
                if (objCMS != null)
                {
                    foreach (ToolStripMenuItem tssItem in objCMS.Items.OfType<ToolStripMenuItem>())
                    {
                        tssItem.UpdateLightDarkMode();
                        tssItem.TranslateToolStripItemsRecursively();
                    }
                }
            }
        }

        private void TreeView_MouseDown(object sender, MouseEventArgs e)
        {
            // Generic event for all TreeViews to allow right-clicking to select a TreeNode so the proper ContextMenu is shown.
            //if (e.Button == System.Windows.Forms.MouseButtons.Right)
            //{
            TreeView objTree = (TreeView)sender;
            objTree.SelectedNode = objTree.HitTest(e.X, e.Y).Node;
            //}
            if (ModifierKeys != Keys.Control)
                return;
            if (objTree.SelectedNode?.IsExpanded == false)
            {
                foreach (TreeNode objNode in objTree.SelectedNode.Nodes)
                {
                    objNode.ExpandAll();
                }
            }
            else if (objTree.SelectedNode?.Nodes != null)
            {
                foreach (TreeNode objNode in objTree.SelectedNode.Nodes)
                {
                    objNode.Collapse();
                }
            }
        }

        private async void CharacterCreate_Load(object sender, EventArgs e)
        {
            try
            {
                using (await CursorWait.NewAsync(this))
                {
                    using (CustomActivity op_load_frm_create = await Timekeeper.StartSyncronAsync(
                               "load_frm_create", null, CustomActivity.OperationType.RequestOperation,
                               CharacterObject?.FileName))
                    {
                        try
                        {
                            try
                            {
                                if (CharacterObject == null)
                                {
                                    // Stupid hack to get the MDI icon to show up properly.
                                    await this.DoThreadSafeFuncAsync(x => x.Icon = x.Icon.Clone() as Icon, GenericToken);
                                    return;
                                }

                                if (!CharacterObject.IsCritter
                                    && !CharacterObject.EffectiveBuildMethodIsLifeModule
                                    && CharacterObjectSettings.BuildKarma == 0)
                                {
                                    _blnFreestyle = true;
                                    await tsMain.DoThreadSafeAsync(() =>
                                    {
                                        tslKarmaRemaining.Visible = false;
                                        tslKarmaRemainingLabel.Visible = false;
                                    }, GenericToken);
                                }

                                using (_ = await Timekeeper.StartSyncronAsync(
                                           "load_frm_create_BuildMethod", op_load_frm_create))
                                {
                                    // Initialize elements if we're using Priority to build.
                                    if (CharacterObject.EffectiveBuildMethodUsesPriorityTables)
                                    {
                                        await mnuCreateMenu.DoThreadSafeAsync(() =>
                                        {
                                            mnuSpecialChangeMetatype.Tag = "Menu_SpecialChangePriorities";
                                            mnuSpecialChangeMetatype.TranslateToolStripItemsRecursively();
                                        }, GenericToken);
                                    }
                                }

                                using (_ = await Timekeeper.StartSyncronAsync(
                                           "load_frm_create_databinding", op_load_frm_create))
                                {
                                    lblNuyenTotal.DoOneWayDataBinding("Text", CharacterObject,
                                                                      nameof(Character.DisplayTotalStartingNuyen));
                                    lblStolenNuyen.DoOneWayDataBinding("Text", CharacterObject,
                                                                       nameof(Character.DisplayStolenNuyen));
                                    lblAttributesBase.DoOneWayDataBinding("Visible", CharacterObject,
                                                                          nameof(Character
                                                                              .EffectiveBuildMethodUsesPriorityTables));

                                    txtGroupName.DoDataBinding("Text", CharacterObject, nameof(Character.GroupName));
                                    txtGroupNotes.DoDataBinding("Text", CharacterObject, nameof(Character.GroupNotes));

                                    txtCharacterName.DoDataBinding("Text", CharacterObject, nameof(Character.Name));
                                    txtGender.DoDataBinding("Text", CharacterObject, nameof(Character.Gender));
                                    txtAge.DoDataBinding("Text", CharacterObject, nameof(Character.Age));
                                    txtEyes.DoDataBinding("Text", CharacterObject, nameof(Character.Eyes));
                                    txtHeight.DoDataBinding("Text", CharacterObject, nameof(Character.Height));
                                    txtWeight.DoDataBinding("Text", CharacterObject, nameof(Character.Weight));
                                    txtSkin.DoDataBinding("Text", CharacterObject, nameof(Character.Skin));
                                    txtHair.DoDataBinding("Text", CharacterObject, nameof(Character.Hair));
                                    rtfDescription.DoDataBinding("Rtf", CharacterObject, nameof(Character.Description));
                                    rtfBackground.DoDataBinding("Rtf", CharacterObject, nameof(Character.Background));
                                    rtfConcept.DoDataBinding("Rtf", CharacterObject, nameof(Character.Concept));
                                    rtfNotes.DoDataBinding("Rtf", CharacterObject, nameof(Character.Notes));
                                    txtAlias.DoDataBinding("Text", CharacterObject, nameof(Character.Alias));
                                    txtPlayerName.DoDataBinding("Text", CharacterObject, nameof(Character.PlayerName));

                                    lblPositiveQualitiesBP.DoOneWayDataBinding("Text", CharacterObject,
                                                                               nameof(Character
                                                                                   .DisplayPositiveQualityKarma));
                                    lblNegativeQualitiesBP.DoOneWayDataBinding("Text", CharacterObject,
                                                                               nameof(Character
                                                                                   .DisplayNegativeQualityKarma));
                                    lblMetagenicQualities.DoOneWayDataBinding("Text", CharacterObject,
                                                                              nameof(Character
                                                                                  .DisplayMetagenicQualityKarma));
                                    lblMetagenicQualities.DoOneWayDataBinding("Visible", CharacterObject,
                                                                              nameof(Character.IsChangeling));
                                    lblMetagenicQualitiesLabel.DoOneWayDataBinding(
                                        "Visible", CharacterObject, nameof(Character.IsChangeling));
                                    lblEnemiesBP.DoOneWayDataBinding("Text", CharacterObject,
                                                                     nameof(Character.DisplayEnemyKarma));

                                    string strKarma = await LanguageManager.GetStringAsync("Label_Karma");
                                    string strKarmaRemaining
                                        = await LanguageManager.GetStringAsync("Label_KarmaRemaining");
                                    string strBPSummaryKarma
                                        = await LanguageManager.GetStringAsync("Tab_BPSummary_Karma");
                                    await tsMain.DoThreadSafeAsync(() =>
                                    {
                                        tslKarmaLabel.Text = strKarma;
                                        tslKarmaRemainingLabel.Text = strKarmaRemaining;
                                    }, GenericToken);
                                    await tabBPSummary.DoThreadSafeAsync(x => x.Text = strBPSummaryKarma, GenericToken);
                                    await lblQualityBPLabel.DoThreadSafeAsync(x => x.Text = strKarma, GenericToken);

                                    lblMetatype.DoOneWayDataBinding("Text", CharacterObject,
                                                                    nameof(Character.FormattedMetatype));

                                    // Set the visibility of the Bioware Suites menu options.
                                    await mnuCreateMenu.DoThreadSafeAsync(() =>
                                    {
                                        mnuSpecialAddBiowareSuite.Visible = CharacterObjectSettings.AllowBiowareSuites;
                                        mnuSpecialCreateBiowareSuite.Visible
                                            = CharacterObjectSettings.AllowBiowareSuites;
                                    }, GenericToken);

                                    chkJoinGroup.DoDataBinding("Checked", CharacterObject,
                                                               nameof(Character.GroupMember));
                                    chkInitiationGroup.DoOneWayDataBinding("Enabled", CharacterObject,
                                                                           nameof(Character.GroupMember));

                                    chkCyberwareBlackMarketDiscount.DoOneWayDataBinding(
                                        "Visible", CharacterObject, nameof(Character.BlackMarketDiscount));
                                    chkGearBlackMarketDiscount.DoOneWayDataBinding(
                                        "Visible", CharacterObject, nameof(Character.BlackMarketDiscount));
                                    chkWeaponBlackMarketDiscount.DoOneWayDataBinding(
                                        "Visible", CharacterObject, nameof(Character.BlackMarketDiscount));
                                    chkArmorBlackMarketDiscount.DoOneWayDataBinding(
                                        "Visible", CharacterObject, nameof(Character.BlackMarketDiscount));
                                    chkVehicleBlackMarketDiscount.DoOneWayDataBinding(
                                        "Visible", CharacterObject, nameof(Character.BlackMarketDiscount));

                                    // If the character has a mugshot, decode it and put it in the PictureBox.
                                    if (CharacterObject.Mugshots.Count > 0)
                                    {
                                        await nudMugshotIndex.DoThreadSafeAsync(x =>
                                        {
                                            x.Minimum = 1;
                                            x.Maximum = CharacterObject.Mugshots.Count;
                                            x.Value = Math.Max(CharacterObject.MainMugshotIndex, 0) + 1;
                                        }, GenericToken);
                                    }
                                    else
                                    {
                                        await nudMugshotIndex.DoThreadSafeAsync(x =>
                                        {
                                            x.Minimum = 0;
                                            x.Maximum = 0;
                                            x.Value = 0;
                                        }, GenericToken);
                                    }

                                    string strNumMugshots = await LanguageManager.GetStringAsync("String_Of") +
                                                            CharacterObject.Mugshots.Count.ToString(
                                                                GlobalSettings.CultureInfo);
                                    await lblNumMugshots.DoThreadSafeAsync(x => x.Text = strNumMugshots, GenericToken);
                                }

                                if (!CharacterObjectSettings.BookEnabled("RF"))
                                {
                                    await cmdAddLifestyle.DoThreadSafeAsync(x => x.SplitMenuStrip = null, GenericToken);
                                }

                                if (!CharacterObjectSettings.BookEnabled("FA"))
                                {
                                    await lblWildReputation.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                    await lblWildReputationTotal.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                    if (!CharacterObjectSettings.BookEnabled("SG"))
                                    {
                                        await lblAstralReputation.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                        await lblAstralReputationTotal.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                    }
                                }

                                if (!CharacterObjectSettings.EnableEnemyTracking)
                                {
                                    await tabPeople.DoThreadSafeAsync(x => x.TabPages.Remove(tabEnemies), GenericToken);
                                }

                                await splitMagician.DoThreadSafeAsync(x => x.SplitterDistance
                                                                          = Math.Max(x.SplitterDistance,
                                                                              ((x.Height - x.SplitterWidth) * 2 + 2)
                                                                              / 3), GenericToken);
                                await splitTechnomancer.DoThreadSafeAsync(
                                    x => x.SplitterDistance
                                        = Math.Max(x.SplitterDistance, ((x.Height - x.SplitterWidth) * 2 + 2) / 3), GenericToken);

                                using (_ = await Timekeeper.StartSyncronAsync(
                                           "load_frm_create_refresh", op_load_frm_create))
                                {
                                    cmdAddMetamagic.DoOneWayDataBinding("Enabled", CharacterObject,
                                                                        nameof(Character.AddInitiationsAllowed));

                                    cmdLifeModule.DoOneWayDataBinding("Visible", CharacterObject,
                                                                      nameof(Character
                                                                                 .EffectiveBuildMethodIsLifeModule));
                                    btnCreateBackstory.DoOneWayDataBinding("Visible", CharacterObject,
                                                                           nameof(Character
                                                                               .EnableAutomaticStoryButton));

                                    if (!CharacterObjectSettings.BookEnabled("RF"))
                                    {
                                        await cmdAddLifestyle.DoThreadSafeAsync(x => x.SplitMenuStrip = null, GenericToken);
                                    }

                                    if (!CharacterObjectSettings.BookEnabled("FA"))
                                    {
                                        await lblWildReputation.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                        await lblWildReputationTotal.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                        if (!CharacterObjectSettings.BookEnabled("SG"))
                                        {
                                            await lblAstralReputation.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                            await lblAstralReputationTotal.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                        }
                                    }

                                    if (!CharacterObjectSettings.EnableEnemyTracking)
                                    {
                                        await tabPeople.DoThreadSafeAsync(x => x.TabPages.Remove(tabEnemies), GenericToken);
                                        await lblEnemiesBP.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                        await lblBuildEnemies.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                    }

                                    await RefreshQualities(treQualities, cmsQuality);
                                    await RefreshSpirits(panSpirits, panSprites);
                                    await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes);
                                    await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm,
                                                        cmsInitiationNotes);
                                    await RefreshPowerCollectionListChanged(treMetamagic, cmsMetamagic, cmsInitiationNotes);
                                    await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes);
                                    await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram);
                                    await RefreshCritterPowers(treCritterPowers, cmsCritterPowers);
                                    await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique);
                                    await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle);
                                    await RefreshContacts(panContacts, panEnemies, panPets);

                                    await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod, cmsArmorGear);
                                    await RefreshGears(treGear, cmsGearLocation, cmsGear, await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, GenericToken));
                                    await RefreshFociFromGear(treFoci, null);
                                    await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear);
                                    await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon, cmsWeaponAccessory,
                                                   cmsWeaponAccessoryGear);
                                    await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle, cmsVehicleWeapon,
                                                    cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear,
                                                    cmsVehicleGear,
                                                    cmsWeaponMount,
                                                    cmsVehicleCyberware, cmsVehicleCyberwareGear);
                                    await RefreshDrugs(treCustomDrugs);
                                }

                                using (_ = await Timekeeper.StartSyncronAsync(
                                           "load_frm_create_sortAndCallback", op_load_frm_create))
                                {
                                    await treWeapons.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treArmor.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treGear.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treLifestyles.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treCustomDrugs.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treCyberware.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treVehicles.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                                    await treCritterPowers.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);

                                    // Set up events that would change various lists
                                    CharacterObject.Spells.CollectionChanged += SpellCollectionChanged;
                                    CharacterObject.ComplexForms.CollectionChanged += ComplexFormCollectionChanged;
                                    CharacterObject.Arts.CollectionChanged += ArtCollectionChanged;
                                    CharacterObject.Enhancements.CollectionChanged += EnhancementCollectionChanged;
                                    CharacterObject.Metamagics.CollectionChanged += MetamagicCollectionChanged;
                                    CharacterObject.InitiationGrades.CollectionChanged
                                        += InitiationGradeCollectionChanged;
                                    CharacterObject.Powers.ListChanged += PowersListChanged;
                                    CharacterObject.Powers.BeforeRemove += PowersBeforeRemove;
                                    CharacterObject.AIPrograms.CollectionChanged += AIProgramCollectionChanged;
                                    CharacterObject.CritterPowers.CollectionChanged += CritterPowerCollectionChanged;
                                    CharacterObject.Qualities.CollectionChanged += QualityCollectionChanged;
                                    CharacterObject.MartialArts.CollectionChanged += MartialArtCollectionChanged;
                                    CharacterObject.Lifestyles.CollectionChanged += LifestyleCollectionChanged;
                                    CharacterObject.Contacts.CollectionChanged += ContactCollectionChanged;
                                    CharacterObject.Spirits.CollectionChanged += SpiritCollectionChanged;
                                    CharacterObject.Armor.CollectionChanged += ArmorCollectionChanged;
                                    CharacterObject.ArmorLocations.CollectionChanged += ArmorLocationCollectionChanged;
                                    CharacterObject.Weapons.CollectionChanged += WeaponCollectionChanged;
                                    CharacterObject.WeaponLocations.CollectionChanged
                                        += WeaponLocationCollectionChanged;
                                    CharacterObject.Gear.CollectionChanged += GearCollectionChanged;
                                    CharacterObject.GearLocations.CollectionChanged += GearLocationCollectionChanged;
                                    CharacterObject.Drugs.CollectionChanged += DrugCollectionChanged;
                                    CharacterObject.Cyberware.CollectionChanged += CyberwareCollectionChanged;
                                    CharacterObject.Vehicles.CollectionChanged += VehicleCollectionChanged;
                                    CharacterObject.VehicleLocations.CollectionChanged
                                        += VehicleLocationCollectionChanged;

                                    SetupCommonCollectionDatabindings(true);
                                }

                                using (_ = await Timekeeper.StartSyncronAsync(
                                           "load_frm_create_tradition", op_load_frm_create))
                                {
                                    // Populate the Magician Traditions list.
                                    XPathNavigator xmlTraditionsBaseChummerNode =
                                        await (await CharacterObject.LoadDataXPathAsync("traditions.xml"))
                                            .SelectSingleNodeAndCacheExpressionAsync("/chummer");
                                    using (new FetchSafelyFromPool<List<ListItem>>(Utils.ListItemListPool,
                                               out List<ListItem> lstTraditions))
                                    {
                                        if (xmlTraditionsBaseChummerNode != null)
                                        {
                                            foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                         "traditions/tradition[" + CharacterObjectSettings.BookXPath()
                                                         + ']'))
                                            {
                                                string strName
                                                    = (await xmlTradition.SelectSingleNodeAndCacheExpressionAsync(
                                                        "name"))
                                                    ?.Value;
                                                if (!string.IsNullOrEmpty(strName))
                                                    lstTraditions.Add(new ListItem(
                                                                          (await xmlTradition
                                                                              .SelectSingleNodeAndCacheExpressionAsync(
                                                                                  "id"))
                                                                          ?.Value ?? strName,
                                                                          (await xmlTradition
                                                                              .SelectSingleNodeAndCacheExpressionAsync(
                                                                                  "translate"))
                                                                          ?.Value ?? strName));
                                            }
                                        }

                                        if (lstTraditions.Count > 1)
                                        {
                                            lstTraditions.Sort(CompareListItems.CompareNames);
                                            lstTraditions.Insert(0,
                                                                 new ListItem(
                                                                     "None",
                                                                     await LanguageManager
                                                                         .GetStringAsync("String_None")));
                                            await cboTradition.PopulateWithListItemsAsync(lstTraditions, GenericToken);
                                        }
                                        else
                                        {
                                            await this.DoThreadSafeAsync(() =>
                                            {
                                                cboTradition.Visible = false;
                                                lblTraditionLabel.Visible = false;
                                            }, GenericToken);
                                        }
                                    }

                                    // Populate the Magician Custom Drain Options list.
                                    using (new FetchSafelyFromPool<List<ListItem>>(Utils.ListItemListPool,
                                               out List<ListItem> lstDrainAttributes))
                                    {
                                        if (xmlTraditionsBaseChummerNode != null)
                                        {
                                            foreach (XPathNavigator xmlDrain in xmlTraditionsBaseChummerNode.Select(
                                                         "drainattributes/drainattribute"))
                                            {
                                                string strName
                                                    = (await xmlDrain.SelectSingleNodeAndCacheExpressionAsync("name"))
                                                    ?.Value;
                                                if (!string.IsNullOrEmpty(strName)
                                                    && lstDrainAttributes.All(x => x.Value.ToString() != strName))
                                                {
                                                    string strTranslatedName = (await xmlDrain
                                                        .SelectSingleNodeAndCacheExpressionAsync(
                                                            "translate"))?.Value ?? strName;
                                                    lstDrainAttributes.Add(new ListItem(strName, strTranslatedName));
                                                }
                                            }
                                        }

                                        lstDrainAttributes.Sort(CompareListItems.CompareNames);
                                        lstDrainAttributes.Insert(0, ListItem.Blank);
                                        await cboDrain.PopulateWithListItemsAsync(lstDrainAttributes, GenericToken);
                                        cboDrain.DoDataBinding("SelectedValue", CharacterObject.MagicTradition,
                                                               nameof(Tradition.DrainExpression));
                                    }

                                    lblDrainAttributes.DoOneWayDataBinding("Text", CharacterObject.MagicTradition,
                                                                           nameof(Tradition.DisplayDrainExpression));
                                    lblDrainAttributesValue.DoOneWayDataBinding("Text", CharacterObject.MagicTradition,
                                        nameof(Tradition.DrainValue));
                                    lblDrainAttributesValue.DoOneWayDataBinding(
                                        "ToolTipText", CharacterObject.MagicTradition,
                                        nameof(Tradition.DrainValueToolTip));
                                    await CharacterObject.MagicTradition.SetSourceDetailAsync(lblTraditionSource, GenericToken);

                                    lblFadingAttributes.DoOneWayDataBinding("Text", CharacterObject.MagicTradition,
                                                                            nameof(Tradition.DisplayDrainExpression));
                                    lblFadingAttributesValue.DoOneWayDataBinding("Text", CharacterObject.MagicTradition,
                                        nameof(Tradition.DrainValue));
                                    lblFadingAttributesValue.DoOneWayDataBinding(
                                        "ToolTipText", CharacterObject.MagicTradition,
                                        nameof(Tradition.DrainValueToolTip));

                                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                               out HashSet<string> limit))
                                    {
                                        foreach (Improvement improvement in await ImprovementManager
                                                     .GetCachedImprovementListForValueOfAsync(
                                                         CharacterObject,
                                                         Improvement.ImprovementType.LimitSpiritCategory))
                                        {
                                            limit.Add(improvement.ImprovedName);
                                        }

                                        /* Populate drugs. //TODO: fix
                                        foreach (Drug objDrug in CharacterObj.Drugs)
                                        {
                                            treCustomDrugs.Add(objDrug);
                                        }
                                        */

                                        // Populate the Magician Custom Spirits lists - Combat.
                                        using (new FetchSafelyFromPool<List<ListItem>>(Utils.ListItemListPool,
                                                   out List<ListItem> lstSpirit))
                                        {
                                            lstSpirit.Add(ListItem.Blank);
                                            if (xmlTraditionsBaseChummerNode != null)
                                            {
                                                foreach (XPathNavigator xmlSpirit in await xmlTraditionsBaseChummerNode
                                                             .SelectAndCacheExpressionAsync("spirits/spirit"))
                                                {
                                                    string strSpiritName
                                                        = (await xmlSpirit.SelectSingleNodeAndCacheExpressionAsync(
                                                            "name"))
                                                        ?.Value;
                                                    if (!string.IsNullOrEmpty(strSpiritName)
                                                        && (limit.Count == 0 || limit.Contains(strSpiritName)))
                                                    {
                                                        lstSpirit.Add(new ListItem(strSpiritName,
                                                                          (await xmlSpirit
                                                                              .SelectSingleNodeAndCacheExpressionAsync(
                                                                                  "translate"))?.Value
                                                                          ?? strSpiritName));
                                                    }
                                                }
                                            }

                                            lstSpirit.Sort(CompareListItems.CompareNames);

                                            await cboSpiritCombat.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                            cboSpiritCombat.DoDataBinding(
                                                "SelectedValue", CharacterObject.MagicTradition,
                                                nameof(Tradition.SpiritCombat));
                                            await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible
                                                = CharacterObject.MagicTradition.Type == TraditionType.MAG, GenericToken);
                                            await cboSpiritCombat.DoThreadSafeAsync(x =>
                                            {
                                                x.Visible
                                                    = CharacterObject.MagicTradition.Type == TraditionType.MAG;
                                                x.Enabled = CharacterObject.MagicTradition.IsCustomTradition;
                                            }, GenericToken);

                                            await cboSpiritDetection.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                            cboSpiritDetection.DoDataBinding(
                                                "SelectedValue", CharacterObject.MagicTradition,
                                                nameof(Tradition.SpiritDetection));
                                            await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible
                                                = CharacterObject.MagicTradition.Type == TraditionType.MAG, GenericToken);
                                            await cboSpiritDetection.DoThreadSafeAsync(x =>
                                            {
                                                x.Visible
                                                    = CharacterObject.MagicTradition.Type == TraditionType.MAG;
                                                x.Enabled
                                                    = CharacterObject.MagicTradition.IsCustomTradition;
                                            }, GenericToken);

                                            await cboSpiritHealth.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                            cboSpiritHealth.DoDataBinding(
                                                "SelectedValue", CharacterObject.MagicTradition,
                                                nameof(Tradition.SpiritHealth));
                                            await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible
                                                = CharacterObject.MagicTradition.Type == TraditionType.MAG, GenericToken);
                                            await cboSpiritDetection.DoThreadSafeAsync(x =>
                                            {
                                                x.Visible
                                                    = CharacterObject.MagicTradition.Type == TraditionType.MAG;
                                                x.Enabled
                                                    = CharacterObject.MagicTradition.IsCustomTradition;
                                            }, GenericToken);

                                            await cboSpiritIllusion.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                            cboSpiritIllusion.DoDataBinding(
                                                "SelectedValue", CharacterObject.MagicTradition,
                                                nameof(Tradition.SpiritIllusion));
                                            await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible
                                                = CharacterObject.MagicTradition.Type == TraditionType.MAG, GenericToken);
                                            await cboSpiritIllusion.DoThreadSafeAsync(x =>
                                            {
                                                x.Visible
                                                    = CharacterObject.MagicTradition.Type == TraditionType.MAG;
                                                x.Enabled
                                                    = CharacterObject.MagicTradition.IsCustomTradition;
                                            }, GenericToken);

                                            await cboSpiritManipulation.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                            cboSpiritManipulation.DoDataBinding(
                                                "SelectedValue", CharacterObject.MagicTradition,
                                                nameof(Tradition.SpiritManipulation));
                                            await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible
                                                = CharacterObject.MagicTradition.Type == TraditionType.MAG, GenericToken);
                                            await cboSpiritManipulation.DoThreadSafeAsync(x =>
                                            {
                                                x.Visible
                                                    = CharacterObject.MagicTradition.Type == TraditionType.MAG;
                                                x.Enabled
                                                    = CharacterObject.MagicTradition.IsCustomTradition;
                                            }, GenericToken);
                                        }
                                    }

                                    // Populate the Technomancer Streams list.
                                    xmlTraditionsBaseChummerNode =
                                        await (await CharacterObject.LoadDataXPathAsync("streams.xml"))
                                            .SelectSingleNodeAndCacheExpressionAsync("/chummer");
                                    using (new FetchSafelyFromPool<List<ListItem>>(Utils.ListItemListPool,
                                               out List<ListItem> lstStreams))
                                    {
                                        if (xmlTraditionsBaseChummerNode != null)
                                        {
                                            foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                         "traditions/tradition[" + CharacterObjectSettings.BookXPath()
                                                         + ']'))
                                            {
                                                string strName
                                                    = (await xmlTradition.SelectSingleNodeAndCacheExpressionAsync(
                                                        "name"))
                                                    ?.Value;
                                                if (!string.IsNullOrEmpty(strName))
                                                    lstStreams.Add(new ListItem(
                                                                       (await xmlTradition
                                                                           .SelectSingleNodeAndCacheExpressionAsync(
                                                                               "id"))
                                                                       ?.Value
                                                                       ?? strName,
                                                                       (await xmlTradition
                                                                           .SelectSingleNodeAndCacheExpressionAsync(
                                                                               "translate"))
                                                                       ?.Value ?? strName));
                                            }
                                        }

                                        if (lstStreams.Count > 1)
                                        {
                                            lstStreams.Sort(CompareListItems.CompareNames);
                                            lstStreams.Insert(0,
                                                              new ListItem(
                                                                  "None",
                                                                  await LanguageManager.GetStringAsync("String_None")));
                                            await cboStream.PopulateWithListItemsAsync(lstStreams, GenericToken);
                                        }
                                        else
                                        {
                                            await cboStream.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                            await lblStreamLabel.DoThreadSafeAsync(x => x.Visible = false, GenericToken);
                                        }
                                    }

                                    nudMysticAdeptMAGMagician.DoOneWayDataBinding("Maximum", CharacterObject.MAG,
                                        nameof(CharacterAttrib.TotalValue));
                                    nudMysticAdeptMAGMagician.DoDataBinding("Value", CharacterObject,
                                                                            nameof(Character.MysticAdeptPowerPoints));

                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        if (CharacterObject.MagicTradition.Type == TraditionType.MAG)
                                            cboTradition.SelectedValue = CharacterObject.MagicTradition.SourceIDString;
                                        else if (cboTradition.SelectedIndex == -1 && cboTradition.Items.Count > 0)
                                            cboTradition.SelectedIndex = 0;
                                        if (CharacterObject.MagicTradition.Type == TraditionType.RES)
                                            cboStream.SelectedValue = CharacterObject.MagicTradition.SourceIDString;
                                        else if (cboStream.SelectedIndex == -1 && cboStream.Items.Count > 0)
                                            cboStream.SelectedIndex = 0;
                                    }, GenericToken);
                                    txtTraditionName.DoDataBinding("Text", CharacterObject.MagicTradition,
                                                                   nameof(Tradition.Name));
                                }

                                using (CustomActivity op_load_frm_create_longloads
                                       = await Timekeeper.StartSyncronAsync("load_frm_create_longloads",
                                                                            op_load_frm_create))
                                {
                                    using (_ = await Timekeeper.StartSyncronAsync(
                                               "load_frm_create_tabSkillsUc.RealLoad()",
                                               op_load_frm_create_longloads))
                                    {
                                        await tabSkillsUc.RealLoad();
                                    }

                                    using (_ = await Timekeeper.StartSyncronAsync(
                                               "load_frm_create_tabPowerUc.RealLoad()",
                                               op_load_frm_create_longloads))
                                    {
                                        await tabPowerUc.RealLoad();
                                    }

                                    using (_ = await Timekeeper.StartSyncronAsync(
                                               "load_frm_create_Run through all appropriate property changers",
                                               op_load_frm_create_longloads))
                                    {
                                        // Run through all appropriate property changers
                                        foreach (PropertyInfo objProperty in typeof(Character).GetProperties())
                                            await DoOnCharacterPropertyChanged(
                                                new PropertyChangedEventArgs(objProperty.Name));
                                    }
                                }

                                using (_ = await Timekeeper.StartSyncronAsync(
                                           "load_frm_create_databinding2", op_load_frm_create))
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        treGear.ItemDrag += treGear_ItemDrag;
                                        treGear.DragEnter += treGear_DragEnter;
                                        treGear.DragDrop += treGear_DragDrop;
                                        /*
                                        treLifestyles.ItemDrag += treLifestyles_ItemDrag;
                                        treLifestyles.DragEnter += treLifestyles_DragEnter;
                                        treLifestyles.DragDrop += treLifestyles_DragDrop;
                                        */
                                        treArmor.ItemDrag += treArmor_ItemDrag;
                                        treArmor.DragEnter += treArmor_DragEnter;
                                        treArmor.DragDrop += treArmor_DragDrop;
                                        treWeapons.ItemDrag += treWeapons_ItemDrag;
                                        treWeapons.DragEnter += treWeapons_DragEnter;
                                        treWeapons.DragDrop += treWeapons_DragDrop;
                                        treVehicles.ItemDrag += treVehicles_ItemDrag;
                                        treVehicles.DragEnter += treVehicles_DragEnter;
                                        treVehicles.DragDrop += treVehicles_DragDrop;
                                    }, GenericToken);

                                    // Merge the ToolStrips.
                                    ToolStripManager.RevertMerge("toolStrip");
                                    ToolStripManager.Merge(tsMain, "toolStrip");

                                    nudNuyen.DoDataBinding("Value", CharacterObject, nameof(Character.NuyenBP));
                                    nudNuyen.DoOneWayDataBinding("Maximum", CharacterObject,
                                                                 nameof(Character.TotalNuyenMaximumBP));

                                    lblCMPhysical.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                      nameof(Character.PhysicalCMToolTip));
                                    lblCMPhysical.DoOneWayDataBinding("Text", CharacterObject,
                                                                      nameof(Character.PhysicalCM));
                                    lblCMPhysicalLabel.DoOneWayDataBinding("Text", CharacterObject,
                                                                           nameof(Character.PhysicalCMLabelText));
                                    await lblCMStun.DoThreadSafeAsync(x => x.Visible = true); // Needed to make sure data bindings go through
                                    lblCMStun.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                  nameof(Character.StunCMToolTip));
                                    lblCMStun.DoOneWayDataBinding("Text", CharacterObject, nameof(Character.StunCM));
                                    lblCMStun.DoOneWayDataBinding("Visible", CharacterObject,
                                                                  nameof(Character.StunCMVisible));
                                    lblCMStunLabel.DoOneWayDataBinding("Text", CharacterObject,
                                                                       nameof(Character.StunCMLabelText));

                                    lblESSMax.DoOneWayDataBinding("Text", CharacterObject,
                                                                  nameof(Character.DisplayEssence));
                                    lblCyberwareESS.DoOneWayDataBinding("Text", CharacterObject,
                                                                        nameof(Character.DisplayCyberwareEssence));
                                    lblBiowareESS.DoOneWayDataBinding("Text", CharacterObject,
                                                                      nameof(Character.DisplayBiowareEssence));
                                    lblEssenceHoleESS.DoOneWayDataBinding("Text", CharacterObject,
                                                                          nameof(Character.DisplayEssenceHole));

                                    lblPrototypeTranshumanESS.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplayPrototypeTranshumanEssenceUsed));

                                    lblArmor.DoOneWayDataBinding("Text", CharacterObject,
                                                                 nameof(Character.TotalArmorRating));
                                    lblArmor.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                 nameof(Character.TotalArmorRatingToolTip));

                                    lblDodge.DoOneWayDataBinding("Text", CharacterObject,
                                                                 nameof(Character.DisplayDodge));
                                    lblDodge.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                 nameof(Character.DodgeToolTip));

                                    lblSpellDefenseIndirectDodge.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseIndirectDodge));
                                    lblSpellDefenseIndirectDodge.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseIndirectDodgeToolTip));
                                    lblSpellDefenseIndirectSoak.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseIndirectSoak));
                                    lblSpellDefenseIndirectSoak.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseIndirectSoakToolTip));
                                    lblSpellDefenseDirectSoakMana.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseDirectSoakMana));
                                    lblSpellDefenseDirectSoakMana.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseDirectSoakManaToolTip));
                                    lblSpellDefenseDirectSoakPhysical.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character.DisplaySpellDefenseDirectSoakPhysical));
                                    lblSpellDefenseDirectSoakPhysical.DoOneWayDataBinding(
                                        "ToolTipText", CharacterObject,
                                        nameof(Character.SpellDefenseDirectSoakPhysicalToolTip));

                                    lblSpellDefenseDetection.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseDetection));
                                    lblSpellDefenseDetection.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseDetectionToolTip));
                                    lblSpellDefenseDecAttBOD.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseBOD));
                                    lblSpellDefenseDecAttBOD.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseBODToolTip));
                                    lblSpellDefenseDecAttAGI.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseAGI));
                                    lblSpellDefenseDecAttAGI.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseAGIToolTip));
                                    lblSpellDefenseDecAttREA.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseREA));
                                    lblSpellDefenseDecAttREA.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseREAToolTip));
                                    lblSpellDefenseDecAttSTR.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseSTR));
                                    lblSpellDefenseDecAttSTR.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseSTRToolTip));
                                    lblSpellDefenseDecAttCHA.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseCHA));
                                    lblSpellDefenseDecAttCHA.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseCHAToolTip));
                                    lblSpellDefenseDecAttINT.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseINT));
                                    lblSpellDefenseDecAttINT.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseINTToolTip));
                                    lblSpellDefenseDecAttLOG.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseLOG));
                                    lblSpellDefenseDecAttLOG.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseLOGToolTip));
                                    lblSpellDefenseDecAttWIL.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(
                                            Character
                                                .DisplaySpellDefenseDecreaseWIL));
                                    lblSpellDefenseDecAttWIL.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(
                                            Character
                                                .SpellDefenseDecreaseWILToolTip));

                                    lblSpellDefenseIllusionMana.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseIllusionMana));
                                    lblSpellDefenseIllusionMana.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseIllusionManaToolTip));
                                    lblSpellDefenseIllusionPhysical.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character.DisplaySpellDefenseIllusionPhysical));
                                    lblSpellDefenseIllusionPhysical.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character.SpellDefenseIllusionPhysicalToolTip));
                                    lblSpellDefenseManipMental.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseManipulationMental));
                                    lblSpellDefenseManipMental.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseManipulationMentalToolTip));
                                    lblSpellDefenseManipPhysical.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .DisplaySpellDefenseManipulationPhysical));
                                    lblSpellDefenseManipPhysical.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character
                                                   .SpellDefenseManipulationPhysicalToolTip));
                                    nudCounterspellingDice.DoDataBinding("Value", CharacterObject,
                                                                         nameof(Character.CurrentCounterspellingDice));

                                    nudLiftCarryHits.DoDataBinding("Value", CharacterObject,
                                                                   nameof(Character.CurrentLiftCarryHits));

                                    lblMovement.DoOneWayDataBinding("Text", CharacterObject,
                                                                    nameof(Character.DisplayMovement));
                                    lblSwim.DoOneWayDataBinding("Text", CharacterObject, nameof(Character.DisplaySwim));
                                    lblFly.DoOneWayDataBinding("Text", CharacterObject, nameof(Character.DisplayFly));

                                    lblRemainingNuyen.DoOneWayDataBinding("Text", CharacterObject,
                                                                          nameof(Character.DisplayNuyen));

                                    lblStreetCredTotal.DoOneWayDataBinding("Text", CharacterObject,
                                                                           nameof(Character.TotalStreetCred));
                                    lblStreetCredTotal.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                           nameof(Character.StreetCredTooltip));
                                    lblNotorietyTotal.DoOneWayDataBinding("Text", CharacterObject,
                                                                          nameof(Character.TotalNotoriety));
                                    lblNotorietyTotal.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                          nameof(Character.NotorietyTooltip));
                                    lblPublicAwareTotal.DoOneWayDataBinding("Text", CharacterObject,
                                                                            nameof(Character.TotalPublicAwareness));
                                    lblPublicAwareTotal.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                            nameof(Character.PublicAwarenessTooltip));
                                    lblAstralReputationTotal.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character.TotalAstralReputation));
                                    lblAstralReputationTotal.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                        nameof(Character.AstralReputationTooltip));
                                    lblWildReputationTotal.DoOneWayDataBinding("Text", CharacterObject,
                                                                               nameof(Character.TotalWildReputation));
                                    lblWildReputationTotal.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                               nameof(Character.WildReputationTooltip));

                                    lblMentorSpirit.DoOneWayDataBinding("Text", CharacterObject,
                                                                        nameof(Character.FirstMentorSpiritDisplayName));
                                    lblMentorSpiritInformation.DoOneWayDataBinding("Text", CharacterObject,
                                        nameof(Character
                                                   .FirstMentorSpiritDisplayInformation));
                                    lblParagon.DoOneWayDataBinding("Text", CharacterObject,
                                                                   nameof(Character.FirstMentorSpiritDisplayName));
                                    lblParagonInformation.DoOneWayDataBinding("Text", CharacterObject,
                                                                              nameof(Character
                                                                                  .FirstMentorSpiritDisplayInformation));

                                    lblComposure.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                     nameof(Character.ComposureToolTip));
                                    lblComposure.DoOneWayDataBinding("Text", CharacterObject,
                                                                     nameof(Character.Composure));
                                    lblSurprise.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                    nameof(Character.SurpriseToolTip));
                                    lblSurprise.DoOneWayDataBinding("Text", CharacterObject,
                                                                    nameof(Character.Surprise));
                                    lblJudgeIntentions.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                           nameof(Character.JudgeIntentionsToolTip));
                                    lblJudgeIntentions.DoOneWayDataBinding("Text", CharacterObject,
                                                                           nameof(Character.JudgeIntentions));
                                    lblLiftCarry.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                     nameof(Character.LiftAndCarryToolTip));
                                    lblLiftCarry.DoOneWayDataBinding("Text", CharacterObject,
                                                                     nameof(Character.LiftAndCarry));
                                    lblMemory.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                  nameof(Character.MemoryToolTip));
                                    lblMemory.DoOneWayDataBinding("Text", CharacterObject, nameof(Character.Memory));

                                    lblLiftCarryLimits.DoOneWayDataBinding("Text", CharacterObject,
                                                                           nameof(Character.LiftAndCarryLimits));

                                    lblINI.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                               nameof(Character.InitiativeToolTip));
                                    lblINI.DoOneWayDataBinding("Text", CharacterObject, nameof(Character.Initiative));
                                    lblAstralINI.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                     nameof(Character.AstralInitiativeToolTip));
                                    lblAstralINI.DoOneWayDataBinding("Text", CharacterObject,
                                                                     nameof(Character.AstralInitiative));
                                    lblMatrixINI.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                     nameof(Character.MatrixInitiativeToolTip));
                                    lblMatrixINI.DoOneWayDataBinding("Text", CharacterObject,
                                                                     nameof(Character.MatrixInitiative));
                                    lblMatrixINICold.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                         nameof(Character.MatrixInitiativeColdToolTip));
                                    lblMatrixINICold.DoOneWayDataBinding("Text", CharacterObject,
                                                                         nameof(Character.MatrixInitiativeCold));
                                    lblMatrixINIHot.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                        nameof(Character.MatrixInitiativeHotToolTip));
                                    lblMatrixINIHot.DoOneWayDataBinding("Text", CharacterObject,
                                                                        nameof(Character.MatrixInitiativeHot));
                                    lblRiggingINI.DoOneWayDataBinding("ToolTipText", CharacterObject,
                                                                      nameof(Character.InitiativeToolTip));
                                    lblRiggingINI.DoOneWayDataBinding("Text", CharacterObject,
                                                                      nameof(Character.Initiative));
                                }

                                using (_ = await Timekeeper.StartSyncronAsync(
                                           "load_frm_create_vehicle", op_load_frm_create))
                                {
                                    // Populate vehicle weapon fire mode list.
                                    using (new FetchSafelyFromPool<List<ListItem>>(Utils.ListItemListPool,
                                               out List<ListItem> lstFireModes))
                                    {
                                        foreach (Weapon.FiringMode mode in Enum.GetValues(typeof(Weapon.FiringMode)))
                                        {
                                            if (mode == Weapon.FiringMode.NumFiringModes)
                                                continue;
                                            lstFireModes.Add(new ListItem(mode,
                                                                          await LanguageManager
                                                                              .GetStringAsync("Enum_" + mode)));
                                        }

                                        await cboVehicleWeaponFiringMode.PopulateWithListItemsAsync(lstFireModes, GenericToken);
                                    }
                                }
                            }
                            finally
                            {
                                IsLoading = false;
                            }

                            using (_ = await Timekeeper.StartSyncronAsync("load_frm_create_finish", op_load_frm_create))
                            {
                                await SetTooltips(GenericToken);
                                await RefreshAttributes(pnlAttributes, null, lblAttributes, lblKarma.PreferredWidth,
                                                        await lblAttributesAug.DoThreadSafeFuncAsync(
                                                            x => x.PreferredWidth, GenericToken),
                                                        await lblAttributesMetatype.DoThreadSafeFuncAsync(
                                                            x => x.PreferredWidth, GenericToken));

                                CharacterObject.AttributeSection.Attributes.CollectionChanged
                                    += AttributeCollectionChanged;

                                await RequestCharacterUpdate();
                                // Directly awaiting here so that we can properly unset the dirty flag after the update
                                try
                                {
                                    await UpdateCharacterInfoTask;
                                }
                                catch (OperationCanceledException)
                                {
                                    return;
                                }

                                // Clear the Dirty flag which gets set when creating a new Character.
                                if (!CharacterObject.LoadAsDirty)
                                    IsDirty = false;
                                await DoRefreshPasteStatus(GenericToken);
                                await ProcessMugshot(GenericToken);

                                // Stupid hack to get the MDI icon to show up properly.
                                await this.DoThreadSafeFuncAsync(x => x.Icon = x.Icon.Clone() as Icon, GenericToken);

                                Program.PluginLoader.CallPlugins(this, op_load_frm_create);
                            }

                            if (CharacterObject.InternalIdsNeedingReapplyImprovements.Count > 0
                                && !Utils.IsUnitTest
                                && Program.ShowMessageBox(this,
                                                          await LanguageManager.GetStringAsync(
                                                              "Message_ImprovementLoadError"),
                                                          await LanguageManager.GetStringAsync(
                                                              "MessageTitle_ImprovementLoadError"),
                                                          MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation)
                                == DialogResult.Yes)
                            {
                                await DoReapplyImprovements(CharacterObject.InternalIdsNeedingReapplyImprovements, GenericToken);
                                await CharacterObject.InternalIdsNeedingReapplyImprovements.ClearAsync();
                            }

                            op_load_frm_create.SetSuccess(true);
                        }
                        catch (OperationCanceledException)
                        {
                            //swallow this
                            op_load_frm_create?.SetSuccess(false);
                        }
                        catch (Exception ex)
                        {
                            if (op_load_frm_create != null)
                            {
                                op_load_frm_create.SetSuccess(false);
                                TelemetryClient.TrackException(ex);
                            }

                            Log.Error(ex);
                            throw;
                        }
                    }
                }
            }
            finally
            {
                IsFinishedInitializing = true;
            }
        }

        private async void CharacterCreate_FormClosing(object sender, FormClosingEventArgs e)
        {
            using (await CursorWait.NewAsync(this))
            {
                IsLoading = true;
                try
                {
                    // If there are unsaved changes to the character, as the user if they would like to save their changes.
                    if (IsDirty && !Utils.IsUnitTest)
                    {
                        string strCharacterName = CharacterObject.CharacterName;
                        DialogResult objResult = Program.ShowMessageBox(
                            this,
                            string.Format(GlobalSettings.CultureInfo,
                                          await LanguageManager.GetStringAsync("Message_UnsavedChanges"),
                                          strCharacterName),
                            await LanguageManager.GetStringAsync("MessageTitle_UnsavedChanges"),
                            MessageBoxButtons.YesNoCancel, MessageBoxIcon.Question);
                        switch (objResult)
                        {
                            case DialogResult.Yes:
                            {
                                // Attempt to save the Character. If the user cancels the Save As dialogue that may open, cancel the closing event so that changes are not lost.
                                bool blnResult = await SaveCharacter();
                                if (!blnResult)
                                    e.Cancel = true;
                                break;
                            }
                            case DialogResult.Cancel:
                                e.Cancel = true;
                                break;
                        }
                    }

                    // Reset the ToolStrip so the Save button is removed for the currently closing window.
                    if (e.Cancel)
                        return;

                    GenericCancellationTokenSource?.Cancel(false);

                    if (Program.MainForm.ActiveMdiChild == this)
                        ToolStripManager.RevertMerge("toolStrip");

                    // Unsubscribe from events.
                    GlobalSettings.ClipboardChanged -= RefreshPasteStatus;
                    CharacterObject.AttributeSection.Attributes.CollectionChanged -= AttributeCollectionChanged;
                    CharacterObject.Spells.CollectionChanged -= SpellCollectionChanged;
                    CharacterObject.ComplexForms.CollectionChanged -= ComplexFormCollectionChanged;
                    CharacterObject.Arts.CollectionChanged -= ArtCollectionChanged;
                    CharacterObject.Enhancements.CollectionChanged -= EnhancementCollectionChanged;
                    CharacterObject.Metamagics.CollectionChanged -= MetamagicCollectionChanged;
                    CharacterObject.InitiationGrades.CollectionChanged -= InitiationGradeCollectionChanged;
                    CharacterObject.Powers.ListChanged -= PowersListChanged;
                    CharacterObject.Powers.BeforeRemove -= PowersBeforeRemove;
                    CharacterObject.AIPrograms.CollectionChanged -= AIProgramCollectionChanged;
                    CharacterObject.CritterPowers.CollectionChanged -= CritterPowerCollectionChanged;
                    CharacterObject.Qualities.CollectionChanged -= QualityCollectionChanged;
                    CharacterObject.MartialArts.CollectionChanged -= MartialArtCollectionChanged;
                    CharacterObject.Lifestyles.CollectionChanged -= LifestyleCollectionChanged;
                    CharacterObject.Contacts.CollectionChanged -= ContactCollectionChanged;
                    CharacterObject.Spirits.CollectionChanged -= SpiritCollectionChanged;
                    CharacterObject.Armor.CollectionChanged -= ArmorCollectionChanged;
                    CharacterObject.ArmorLocations.CollectionChanged -= ArmorLocationCollectionChanged;
                    CharacterObject.Weapons.CollectionChanged -= WeaponCollectionChanged;
                    CharacterObject.Drugs.CollectionChanged -= DrugCollectionChanged;
                    CharacterObject.WeaponLocations.CollectionChanged -= WeaponLocationCollectionChanged;
                    CharacterObject.Gear.CollectionChanged -= GearCollectionChanged;
                    CharacterObject.GearLocations.CollectionChanged -= GearLocationCollectionChanged;
                    CharacterObject.Cyberware.CollectionChanged -= CyberwareCollectionChanged;
                    CharacterObject.Vehicles.CollectionChanged -= VehicleCollectionChanged;
                    CharacterObject.VehicleLocations.CollectionChanged -= VehicleLocationCollectionChanged;
                    CharacterObject.PropertyChanged -= OnCharacterPropertyChanged;
                    CharacterObject.SettingsPropertyChanged -= OnCharacterSettingsPropertyChanged;

                    SetupCommonCollectionDatabindings(false);

                    treGear.ItemDrag -= treGear_ItemDrag;
                    treGear.DragEnter -= treGear_DragEnter;
                    treGear.DragDrop -= treGear_DragDrop;

                    /*
                    treLifestyles.ItemDrag -= treLifestyles_ItemDrag;
                    treLifestyles.DragEnter -= treLifestyles_DragEnter;
                    treLifestyles.DragDrop -= treLifestyles_DragDrop;
                    */

                    treArmor.ItemDrag -= treArmor_ItemDrag;
                    treArmor.DragEnter -= treArmor_DragEnter;
                    treArmor.DragDrop -= treArmor_DragDrop;

                    treWeapons.ItemDrag -= treWeapons_ItemDrag;
                    treWeapons.DragEnter -= treWeapons_DragEnter;
                    treWeapons.DragDrop -= treWeapons_DragDrop;

                    treVehicles.ItemDrag -= treVehicles_ItemDrag;
                    treVehicles.DragEnter -= treVehicles_DragEnter;
                    treVehicles.DragDrop -= treVehicles_DragDrop;

                    foreach (ContactControl objContactControl in panContacts.Controls.OfType<ContactControl>())
                    {
                        objContactControl.ContactDetailChanged -= MakeDirtyWithCharacterUpdate;
                        objContactControl.DeleteContact -= DeleteContact;
                        objContactControl.MouseDown -= DragContactControl;
                    }

                    foreach (ContactControl objContactControl in panEnemies.Controls.OfType<ContactControl>())
                    {
                        objContactControl.ContactDetailChanged -= MakeDirtyWithCharacterUpdate;
                        objContactControl.DeleteContact -= DeleteEnemy;
                        objContactControl.MouseDown -= DragContactControl;
                    }

                    foreach (PetControl objPetControl in panPets.Controls.OfType<PetControl>())
                    {
                        objPetControl.DeleteContact -= DeletePet;
                        objPetControl.ContactDetailChanged -= MakeDirtyWithCharacterUpdate;
                    }

                    foreach (SpiritControl objSpiritControl in panSpirits.Controls.OfType<SpiritControl>())
                    {
                        objSpiritControl.ContactDetailChanged -= MakeDirtyWithCharacterUpdate;
                        objSpiritControl.DeleteSpirit -= DeleteSpirit;
                    }

                    foreach (SpiritControl objSpiritControl in panSprites.Controls.OfType<SpiritControl>())
                    {
                        objSpiritControl.ContactDetailChanged -= MakeDirtyWithCharacterUpdate;
                        objSpiritControl.DeleteSpirit -= DeleteSpirit;
                    }

                    try
                    {
                        await UpdateCharacterInfoTask;
                    }
                    catch (OperationCanceledException)
                    {
                        // Swallow this
                    }
                }
                finally
                {
                    IsLoading = false;
                }
            }
        }

        private void CharacterCreate_Activated(object sender, EventArgs e)
        {
            // Merge the ToolStrips.
            ToolStripManager.RevertMerge("toolStrip");
            ToolStripManager.Merge(tsMain, "toolStrip");
        }

        private async void ReopenCharacter(object sender, FormClosedEventArgs e)
        {
            await Program.OpenCharacter(CharacterObject);
            await this.DoThreadSafeAsync(x => x.FormClosed -= ReopenCharacter);
        }

        #endregion Form Events

        #region Character Events

        private async void OnCharacterPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            await DoOnCharacterPropertyChanged(e);
        }

        private async ValueTask DoOnCharacterPropertyChanged(PropertyChangedEventArgs e)
        {
            if (_blnReapplyImprovements)
                return;

            await SetDirty(true);

            try
            {
                switch (e.PropertyName)
                {
                    case nameof(Character.CharacterName):
                        await UpdateWindowTitleAsync(false, GenericToken);
                        break;

                    case nameof(Character.DisplayNuyen):
                        await StatusStrip.DoThreadSafeAsync(() => tslNuyenRemaining.Text = CharacterObject.DisplayNuyen,
                                                            GenericToken);
                        break;

                    case nameof(Character.StolenNuyen):
                        bool show = await ImprovementManager.ValueOfAsync(
                            CharacterObject, Improvement.ImprovementType.Nuyen, strImprovedName: "Stolen") != 0;

                        await lblStolenNuyen.DoThreadSafeAsync(x => x.Visible = show, GenericToken);
                        await lblStolenNuyenLabel.DoThreadSafeAsync(x => x.Visible = show, GenericToken);
                        break;

                    case nameof(Character.DisplayEssence):
                        await StatusStrip.DoThreadSafeAsync(() => tslEssence.Text = CharacterObject.DisplayEssence,
                                                            GenericToken);
                        break;

                    case nameof(Character.DisplayTotalCarriedWeight):
                        await StatusStrip.DoThreadSafeAsync(
                            () => tslCarriedWeight.Text = CharacterObject.DisplayTotalCarriedWeight, GenericToken);
                        break;

                    case nameof(Character.Encumbrance):
                        Color objControlTextColor = await ColorManager.ControlTextAsync;
                        await StatusStrip.DoThreadSafeAsync(() => tslCarriedWeight.ForeColor
                                                                = CharacterObject.Encumbrance > 0
                                                                    ? ColorManager.ErrorColor
                                                                    : objControlTextColor, GenericToken);
                        break;

                    case nameof(Character.NuyenBP):
                    case nameof(Character.MetatypeBP):
                    case nameof(Character.ContactPoints):
                    case nameof(Character.FreeSpells):
                    case nameof(Character.CFPLimit):
                    case nameof(Character.AIAdvancedProgramLimit):
                    case nameof(Character.SpellKarmaCost):
                    case nameof(Character.ComplexFormKarmaCost):
                    case nameof(Character.AIProgramKarmaCost):
                    case nameof(Character.AIAdvancedProgramKarmaCost):
                    case nameof(Character.MysticAdeptPowerPoints):
                    case nameof(Character.MagicTradition):
                    case nameof(Character.GroupMember):
                    case nameof(Character.HomeNode):
                    case nameof(Character.ActiveCommlink):
                        await RequestCharacterUpdate();
                        break;

                    case nameof(Character.Source):
                    case nameof(Character.Page):
                        await CharacterObject.SetSourceDetailAsync(lblMetatypeSource, GenericToken);
                        break;

                    case nameof(Character.MAGEnabled):
                    {
                        if (CharacterObject.MAGEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabInitiation))
                                    x.TabPages.Insert(3, tabInitiation);
                            }, GenericToken);

                            await UpdateInitiationCost(GenericToken);

                            await LanguageManager.GetStringAsync("Tab_Initiation")
                                                 .ContinueWith(
                                                     y => tabInitiation.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("Button_AddMetamagic")
                                                 .ContinueWith(
                                                     y => cmsMetamagic.DoThreadSafeAsync(
                                                         () => tsMetamagicAddMetamagic.Text = y.Result, GenericToken),
                                                     GenericToken)
                                                 .Unwrap();
                            await LanguageManager.GetStringAsync("Button_AddInitiateGrade")
                                                 .ContinueWith(
                                                     y => cmdAddMetamagic.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("Button_RemoveInitiateGrade")
                                                 .ContinueWith(
                                                     y => cmdDeleteMetamagic.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("String_InitiationType")
                                                 .ContinueWith(
                                                     y => gpbInitiationType.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("String_InitiationGroup")
                                                 .ContinueWith(
                                                     y => gpbInitiationGroup.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            string strText1 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_InitiationOrdeal"),
                                                    CharacterObjectSettings.KarmaMAGInitiationOrdealPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationOrdeal.DoThreadSafeAsync(x => x.Text = strText1, GenericToken);
                            string strText2 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_InitiationGroup"),
                                                    CharacterObjectSettings.KarmaMAGInitiationGroupPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationGroup.DoThreadSafeAsync(x => x.Text = strText2, GenericToken);
                            string strText3 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_InitiationSchooling"),
                                                    CharacterObjectSettings.KarmaMAGInitiationSchoolingPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationSchooling.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText3;
                                x.Enabled = true;
                            }, GenericToken);
                            await cmsMetamagic.DoThreadSafeAsync(() =>
                            {
                                tsMetamagicAddArt.Visible = true;
                                tsMetamagicAddEnchantment.Visible = true;
                                tsMetamagicAddEnhancement.Visible = true;
                                tsMetamagicAddRitual.Visible = true;
                            }, GenericToken);
                            string strInitTip = string.Format(GlobalSettings.CultureInfo,
                                                              await LanguageManager.GetStringAsync(
                                                                  "Tip_ImproveInitiateGrade")
                                                              , CharacterObject.InitiateGrade + 1
                                                              , CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.InitiateGrade + 1) * CharacterObjectSettings.KarmaInitiation);
                            await cmdAddMetamagic.SetToolTipAsync(strInitTip, GenericToken);
                            await LanguageManager.GetStringAsync("Checkbox_JoinedGroup")
                                                 .ContinueWith(
                                                     y => chkJoinGroup.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();

                            if (!await CharacterObject.AttributeSection.Attributes.ContainsAsync(CharacterObject.MAG))
                            {
                                await CharacterObject.AttributeSection.Attributes.AddAsync(CharacterObject.MAG);
                            }

                            if (CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept)
                            {
                                CharacterAttrib objMAGAdept =
                                    CharacterObject.AttributeSection.GetAttributeByName("MAGAdept");
                                if (!await CharacterObject.AttributeSection.Attributes.ContainsAsync(objMAGAdept))
                                {
                                    await CharacterObject.AttributeSection.Attributes.AddAsync(objMAGAdept);
                                }
                            }
                        }
                        else
                        {
                            if (!CharacterObject.RESEnabled)
                                await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation), GenericToken);

                            if (CharacterObject.AttributeSection.Attributes != null)
                            {
                                await CharacterObject.AttributeSection.Attributes.RemoveAsync(CharacterObject.MAG);
                                await CharacterObject.AttributeSection.Attributes.RemoveAsync(CharacterObject.MAGAdept);
                            }
                        }

                        await gpbGearBondedFoci.DoThreadSafeAsync(x => x.Visible = CharacterObject.MAGEnabled, GenericToken);
                        await lblAstralINI.DoThreadSafeAsync(x => x.Visible = CharacterObject.MAGEnabled, GenericToken);

                        await RequestCharacterUpdate();
                    }
                        break;

                    case nameof(Character.RESEnabled):
                    {
                        // Change to the status of RES being enabled.
                        if (CharacterObject.RESEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabInitiation))
                                    x.TabPages.Insert(3, tabInitiation);
                            }, GenericToken);

                            /*
                            int intEssenceLoss = 0;
                            if (!CharacterObjectSettings.ESSLossReducesMaximumOnly)
                                intEssenceLoss = _objCharacter.EssencePenalty;
                            // If the character options permit submersion in create mode, show the Initiation page.
                            */

                            await UpdateInitiationCost(GenericToken);

                            await LanguageManager.GetStringAsync("Tab_Submersion")
                                                 .ContinueWith(
                                                     y => tabInitiation.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("Button_AddEcho")
                                                 .ContinueWith(
                                                     y => cmsMetamagic.DoThreadSafeAsync(
                                                         () => tsMetamagicAddMetamagic.Text = y.Result, GenericToken),
                                                     GenericToken)
                                                 .Unwrap();
                            await LanguageManager.GetStringAsync("Button_AddSubmersionGrade")
                                                 .ContinueWith(
                                                     y => cmdAddMetamagic.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("Button_RemoveSubmersionGrade")
                                                 .ContinueWith(
                                                     y => cmdDeleteMetamagic.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("String_SubmersionType")
                                                 .ContinueWith(
                                                     y => gpbInitiationType.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            await LanguageManager.GetStringAsync("String_SubmersionNetwork")
                                                 .ContinueWith(
                                                     y => gpbInitiationGroup.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();
                            string strText1 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_SubmersionTask"),
                                                    CharacterObjectSettings.KarmaRESInitiationOrdealPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationOrdeal.DoThreadSafeAsync(x => x.Text = strText1, GenericToken);
                            string strText2 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_NetworkSubmersion"),
                                                    CharacterObjectSettings.KarmaRESInitiationGroupPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationGroup.DoThreadSafeAsync(x => x.Text = strText2, GenericToken);
                            string strText3 = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync(
                                                        "Checkbox_InitiationSchooling"),
                                                    CharacterObjectSettings.KarmaRESInitiationSchoolingPercent.ToString(
                                                        "P", GlobalSettings.CultureInfo));
                            await chkInitiationSchooling.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText3;
                                x.Enabled = CharacterObjectSettings.AllowTechnomancerSchooling;
                            }, GenericToken);
                            await cmsMetamagic.DoThreadSafeAsync(() =>
                            {
                                tsMetamagicAddArt.Visible = false;
                                tsMetamagicAddEnchantment.Visible = false;
                                tsMetamagicAddEnhancement.Visible = false;
                                tsMetamagicAddRitual.Visible = false;
                            }, GenericToken);
                            string strInitTip = string.Format(GlobalSettings.CultureInfo,
                                                              await LanguageManager.GetStringAsync(
                                                                  "Tip_ImproveSubmersionGrade")
                                                              , CharacterObject.SubmersionGrade + 1
                                                              , CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.SubmersionGrade + 1) * CharacterObjectSettings.KarmaInitiation);
                            await cmdAddMetamagic.SetToolTipAsync(strInitTip, GenericToken);
                            await LanguageManager.GetStringAsync("Checkbox_JoinedNetwork")
                                                 .ContinueWith(
                                                     y => chkJoinGroup.DoThreadSafeAsync(
                                                         x => x.Text = y.Result, GenericToken), GenericToken).Unwrap();

                            if (CharacterObject.AttributeSection.Attributes != null && !await CharacterObject.AttributeSection.Attributes.ContainsAsync(
                                    CharacterObject.RES))
                            {
                                await CharacterObject.AttributeSection.Attributes.AddAsync(CharacterObject.RES);
                            }
                        }
                        else
                        {
                            if (!CharacterObject.MAGEnabled)
                                await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation), GenericToken);
                            if (CharacterObject.AttributeSection.Attributes != null)
                            {
                                await CharacterObject.AttributeSection.Attributes.RemoveAsync(CharacterObject.RES);
                            }
                        }

                        await RequestCharacterUpdate();
                    }
                        break;

                    case nameof(Character.DEPEnabled):
                    {
                        if (CharacterObject.DEPEnabled)
                        {
                            if (!(await CharacterObject.AttributeSection.Attributes.ContainsAsync(CharacterObject.DEP)))
                            {
                                await CharacterObject.AttributeSection.Attributes.AddAsync(CharacterObject.DEP);
                            }
                        }
                        else if (await CharacterObject.AttributeSection.Attributes.ContainsAsync(CharacterObject.DEP))
                        {
                            await CharacterObject.AttributeSection.Attributes.RemoveAsync(CharacterObject.DEP);
                        }
                    }
                        break;

                    case nameof(Character.Ambidextrous):
                    {
                        using (new FetchSafelyFromPool<List<ListItem>>(Utils.ListItemListPool,
                                                                       out List<ListItem> lstPrimaryArm))
                        {
                            if (CharacterObject.Ambidextrous)
                            {
                                lstPrimaryArm.Add(new ListItem("Ambidextrous",
                                                               await LanguageManager.GetStringAsync(
                                                                   "String_Ambidextrous")));
                                await cboPrimaryArm.DoThreadSafeAsync(x => x.Enabled = false, GenericToken);
                            }
                            else
                            {
                                //Create the dropdown for the character's primary arm.
                                lstPrimaryArm.Add(new ListItem(
                                                      "Left",
                                                      await LanguageManager.GetStringAsync(
                                                          "String_Improvement_SideLeft")));
                                lstPrimaryArm.Add(new ListItem(
                                                      "Right",
                                                      await LanguageManager.GetStringAsync(
                                                          "String_Improvement_SideRight")));
                                lstPrimaryArm.Sort(CompareListItems.CompareNames);
                                await cboPrimaryArm.DoThreadSafeAsync(x => x.Enabled = true, GenericToken);
                            }

                            string strPrimaryArm = CharacterObject.PrimaryArm;

                            await cboPrimaryArm.PopulateWithListItemsAsync(lstPrimaryArm, GenericToken);
                            await cboPrimaryArm.DoThreadSafeAsync(x =>
                            {
                                x.SelectedValue = strPrimaryArm;
                                if (x.SelectedIndex == -1)
                                    x.SelectedIndex = 0;
                            }, GenericToken);
                        }
                    }
                        break;

                    case nameof(Character.MagicianEnabled):
                    {
                        // Change to the status of Magician being enabled.
                        if (CharacterObject.MagicianEnabled || CharacterObject.AdeptEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabMagician))
                                    x.TabPages.Insert(3, tabMagician);
                            });
                            await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, GenericToken);
                            if (CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept
                                && CharacterObject.AttributeSection.Attributes != null)
                            {
                                CharacterAttrib objMAGAdept =
                                    CharacterObject.AttributeSection.GetAttributeByName("MAGAdept");
                                if (!await CharacterObject.AttributeSection.Attributes.ContainsAsync(objMAGAdept))
                                {
                                    await CharacterObject.AttributeSection.Attributes.AddAsync(objMAGAdept);
                                }
                            }
                        }
                        else
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabMagician));
                            await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = false, GenericToken);
                            if (CharacterObjectSettings.MysAdeptSecondMAGAttribute
                                && CharacterObject.AttributeSection.Attributes != null)
                            {
                                CharacterAttrib objMAGAdept =
                                    CharacterObject.AttributeSection.GetAttributeByName("MAGAdept");
                                if (await CharacterObject.AttributeSection.Attributes.ContainsAsync(objMAGAdept))
                                {
                                    await CharacterObject.AttributeSection.Attributes.RemoveAsync(objMAGAdept);
                                }
                            }
                        }

                        await cmdAddSpirit.DoThreadSafeAsync(x => x.Visible = CharacterObject.MagicianEnabled,
                                                             GenericToken);
                        await panSpirits.DoThreadSafeAsync(x => x.Visible = CharacterObject.MagicianEnabled,
                                                           GenericToken);
                    }
                        break;

                    case nameof(Character.AdeptEnabled):
                    {
                        // Change to the status of Adept being enabled.
                        if (CharacterObject.AdeptEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabMagician))
                                    x.TabPages.Insert(3, tabMagician);
                            });
                            await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, GenericToken);
                            if (CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept
                                && CharacterObject.AttributeSection.Attributes != null)
                            {
                                CharacterAttrib objMAGAdept =
                                    CharacterObject.AttributeSection.GetAttributeByName("MAGAdept");
                                if (!await CharacterObject.AttributeSection.Attributes.ContainsAsync(objMAGAdept))
                                {
                                    await CharacterObject.AttributeSection.Attributes.AddAsync(objMAGAdept);
                                }
                            }

                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabAdept))
                                    x.TabPages.Insert(3, tabAdept);
                            });
                        }
                        else
                        {
                            if (!CharacterObject.MagicianEnabled)
                            {
                                await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabMagician));
                                await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = false, GenericToken);
                                if (CharacterObjectSettings.MysAdeptSecondMAGAttribute
                                    && CharacterObject.AttributeSection.Attributes != null)
                                {
                                    CharacterAttrib objMAGAdept =
                                        CharacterObject.AttributeSection.GetAttributeByName("MAGAdept");
                                    if (await CharacterObject.AttributeSection.Attributes.ContainsAsync(objMAGAdept))
                                    {
                                        await CharacterObject.AttributeSection.Attributes.RemoveAsync(objMAGAdept);
                                    }
                                }
                            }
                            else
                                await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, GenericToken);

                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabAdept));
                        }
                    }
                        break;

                    case nameof(Character.TechnomancerEnabled):
                    {
                        // Change to the status of Technomancer being enabled.
                        if (CharacterObject.TechnomancerEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabTechnomancer))
                                    x.TabPages.Insert(3, tabTechnomancer);
                            });
                        }
                        else
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabTechnomancer));
                        }
                    }
                        break;

                    case nameof(Character.AdvancedProgramsEnabled):
                    {
                        // Change to the status of Advanced Programs being enabled.
                        if (CharacterObject.AdvancedProgramsEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabAdvancedPrograms))
                                    x.TabPages.Insert(3, tabAdvancedPrograms);
                            });
                        }
                        else
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabAdvancedPrograms));
                        }
                    }
                        break;

                    case nameof(Character.CritterEnabled):
                    {
                        // Change the status of Critter being enabled.
                        if (CharacterObject.CritterEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabCritter))
                                    x.TabPages.Insert(3, tabCritter);
                            });
                        }
                        else
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabCritter));
                        }
                    }
                        break;

                    case nameof(Character.AddBiowareEnabled):
                    {
                        if (!CharacterObject.AddBiowareEnabled)
                        {
                            bool blnDoRefresh = false;
                            foreach (Cyberware objCyberware in CharacterObject.Cyberware.DeepWhere(
                                                                                  x => x.Children, x =>
                                                                                      x.SourceType
                                                                                      == Improvement.ImprovementSource
                                                                                          .Bioware
                                                                                      && x.SourceID != Cyberware
                                                                                          .EssenceHoleGUID
                                                                                      && x.SourceID != Cyberware
                                                                                          .EssenceAntiHoleGUID
                                                                                      && x.IsModularCurrentlyEquipped)
                                                                              .ToList())
                            {
                                if (!string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount))
                                {
                                    if (objCyberware.CanRemoveThroughImprovements)
                                    {
                                        if (objCyberware.Parent != null)
                                            await objCyberware.Parent.Children.RemoveAsync(objCyberware);
                                        await CharacterObject.Cyberware.AddAsync(objCyberware);
                                        objCyberware.ChangeModularEquip(false);
                                    }

                                    continue;
                                }

                                if (!objCyberware.CanRemoveThroughImprovements)
                                    continue;
                                objCyberware.DeleteCyberware();
                                blnDoRefresh = true;
                            }

                            if (blnDoRefresh)
                            {
                                await RequestCharacterUpdate();
                            }
                        }
                    }
                        break;

                    case nameof(Character.AddCyberwareEnabled):
                    {
                        if (!CharacterObject.AddCyberwareEnabled)
                        {
                            bool blnDoRefresh = false;
                            foreach (Cyberware objCyberware in CharacterObject.Cyberware.DeepWhere(
                                                                                  x => x.Children, x =>
                                                                                      x.SourceType
                                                                                      == Improvement.ImprovementSource
                                                                                          .Cyberware
                                                                                      && x.SourceID != Cyberware
                                                                                          .EssenceHoleGUID
                                                                                      && x.SourceID != Cyberware
                                                                                          .EssenceAntiHoleGUID
                                                                                      && x.IsModularCurrentlyEquipped)
                                                                              .ToList())
                            {
                                if (!string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount))
                                {
                                    if (objCyberware.CanRemoveThroughImprovements)
                                    {
                                        objCyberware.ChangeModularEquip(false);
                                        if (objCyberware.Parent != null)
                                            await objCyberware.Parent.Children.RemoveAsync(objCyberware);
                                        await CharacterObject.Cyberware.AddAsync(objCyberware);
                                    }

                                    continue;
                                }

                                if (!objCyberware.CanRemoveThroughImprovements)
                                    continue;
                                objCyberware.DeleteCyberware();
                                blnDoRefresh = true;
                            }

                            if (blnDoRefresh)
                            {
                                await RequestCharacterUpdate();
                            }
                        }
                    }
                        break;

                    case nameof(Character.ExCon):
                    {
                        if (CharacterObject.ExCon)
                        {
                            bool blnDoRefresh = false;
                            foreach (Cyberware objCyberware in CharacterObject.Cyberware.DeepWhere(
                                                                                  x => x.Children, x =>
                                                                                      x.SourceID != Cyberware
                                                                                          .EssenceHoleGUID
                                                                                      && x.SourceID != Cyberware
                                                                                          .EssenceAntiHoleGUID
                                                                                      && x.IsModularCurrentlyEquipped)
                                                                              .ToList())
                            {
                                char chrAvail = objCyberware.TotalAvailTuple(false).Suffix;
                                if (chrAvail != 'R' && chrAvail != 'F')
                                    continue;
                                if (!string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount))
                                {
                                    if (objCyberware.CanRemoveThroughImprovements)
                                    {
                                        if (objCyberware.Parent != null)
                                            await objCyberware.Parent.Children.RemoveAsync(objCyberware);
                                        await CharacterObject.Cyberware.AddAsync(objCyberware);
                                        objCyberware.ChangeModularEquip(false);
                                    }

                                    continue;
                                }

                                if (!objCyberware.CanRemoveThroughImprovements)
                                    continue;
                                objCyberware.DeleteCyberware();
                                blnDoRefresh = true;
                            }

                            if (blnDoRefresh)
                            {
                                await RequestCharacterUpdate();
                            }
                        }
                    }
                        break;

                    case nameof(Character.InitiationEnabled):
                    {
                        // Change the status of the Initiation tab being show.
                        if (CharacterObject.InitiationEnabled)
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x =>
                            {
                                if (!x.TabPages.Contains(tabInitiation))
                                    x.TabPages.Insert(3, tabInitiation);
                            });
                        }
                        else
                        {
                            await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation));
                        }

                        await gpbInitiationType.DoThreadSafeAsync(x => x.Visible = CharacterObject.InitiationEnabled,
                                                                  GenericToken);
                        await gpbInitiationGroup.DoThreadSafeAsync(x => x.Visible = CharacterObject.InitiationEnabled,
                                                                   GenericToken);
                    }
                        break;

                    case nameof(Character.FirstMentorSpiritDisplayName):
                    {
                        MentorSpirit objMentor = await CharacterObject.MentorSpirits.FirstOrDefaultAsync();
                        if (objMentor != null)
                        {
                            await objMentor.SetSourceDetailAsync(lblMentorSpiritSource, GenericToken);
                            await objMentor.SetSourceDetailAsync(lblParagonSource, GenericToken);
                        }

                        break;
                    }
                    case nameof(Character.HasMentorSpirit):
                    {
                        await gpbMagicianMentorSpirit.DoThreadSafeAsync(
                            x => x.Visible = CharacterObject.HasMentorSpirit, GenericToken);
                        await gpbTechnomancerParagon.DoThreadSafeAsync(x => x.Visible = CharacterObject.HasMentorSpirit,
                                                                       GenericToken);
                        break;
                    }
                    case nameof(Character.UseMysticAdeptPPs):
                    {
                        await lblMysticAdeptAssignment.DoThreadSafeAsync(
                            x => x.Visible = CharacterObject.UseMysticAdeptPPs, GenericToken);
                        await nudMysticAdeptMAGMagician.DoThreadSafeAsync(
                            x => x.Visible = CharacterObject.UseMysticAdeptPPs, GenericToken);
                        break;
                    }
                    case nameof(Character.IsPrototypeTranshuman):
                    {
                        await RequestCharacterUpdate();
                        await lblPrototypeTranshumanESS.DoThreadSafeAsync(
                            x => x.Visible = CharacterObject.IsPrototypeTranshuman);
                        await lblPrototypeTranshumanESSLabel.DoThreadSafeAsync(
                            x => x.Visible = CharacterObject.IsPrototypeTranshuman);
                        break;
                    }
                    case nameof(Character.MetatypeCategory):
                    {
                        await RequestCharacterUpdate();
                        await mnuCreateMenu.DoThreadSafeAsync(
                            () => mnuSpecialCyberzombie.Visible = CharacterObject.MetatypeCategory != "Cyberzombie",
                            GenericToken);
                        break;
                    }
                    case nameof(Character.IsSprite):
                    {
                        await RequestCharacterUpdate();
                        await mnuCreateMenu.DoThreadSafeAsync(
                            () => mnuSpecialConvertToFreeSprite.Visible = CharacterObject.IsSprite, GenericToken);
                        break;
                    }
                    case nameof(Character.BlackMarketDiscount):
                    {
                        await Task.WhenAll(RefreshSelectedCyberware(GenericToken),
                                           RefreshSelectedArmor(GenericToken),
                                           RefreshSelectedGear(GenericToken),
                                           RefreshSelectedVehicle(GenericToken),
                                           RefreshSelectedWeapon(GenericToken));
                        break;
                    }
                    case nameof(Character.Settings):
                    {
                        if (!IsLoading)
                        {
                            foreach (PropertyInfo objProperty in typeof(CharacterSettings).GetProperties())
                                await DoOnCharacterSettingsPropertyChanged(
                                    new PropertyChangedEventArgs(objProperty.Name));
                        }

                        break;
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void OnCharacterSettingsPropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            await DoOnCharacterSettingsPropertyChanged(e);
        }

        private async ValueTask DoOnCharacterSettingsPropertyChanged(PropertyChangedEventArgs e)
        {
            try
            {
                switch (e.PropertyName)
                {
                    case nameof(CharacterSettings.Books):
                    {
                        if (IsLoading)
                            break;
                        using (await CursorWait.NewAsync(this))
                        {
                            await this.DoThreadSafeAsync(x => x.SuspendLayout(), GenericToken);
                            try
                            {
                                await cmdAddLifestyle.DoThreadSafeAsync(x => x.SplitMenuStrip =
                                                                            CharacterObjectSettings.BookEnabled("RF")
                                                                                ? cmsAdvancedLifestyle
                                                                                : null, GenericToken);

                                if (!CharacterObjectSettings.BookEnabled("FA"))
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        lblWildReputation.Visible = false;
                                        lblWildReputationTotal.Visible = false;
                                        if (!CharacterObjectSettings.BookEnabled("SG"))
                                        {
                                            lblAstralReputation.Visible = false;
                                            lblAstralReputationTotal.Visible = false;
                                        }
                                        else
                                        {
                                            lblAstralReputation.Visible = true;
                                            lblAstralReputationTotal.Visible = true;
                                        }
                                    }, GenericToken);
                                }
                                else
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        lblWildReputation.Visible = true;
                                        lblWildReputationTotal.Visible = true;
                                        lblAstralReputation.Visible = true;
                                        lblAstralReputationTotal.Visible = true;
                                    }, GenericToken);
                                }

                                // Refresh all trees because enabled sources can change the nodes that are visible
                                await RefreshQualities(treQualities, cmsQuality);
                                await RefreshSpirits(panSpirits, panSprites);
                                await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes);
                                await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm, cmsInitiationNotes);
                                await RefreshPowerCollectionListChanged(treMetamagic, cmsMetamagic, cmsInitiationNotes);
                                await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes);
                                await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram);
                                await RefreshCritterPowers(treCritterPowers, cmsCritterPowers);
                                await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique);
                                await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle);
                                await RefreshContacts(panContacts, panEnemies, panPets);

                                await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod, cmsArmorGear);
                                await RefreshGears(treGear, cmsGearLocation, cmsGear, await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, GenericToken));
                                await RefreshFociFromGear(treFoci, null);
                                await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear);
                                await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon, cmsWeaponAccessory,
                                               cmsWeaponAccessoryGear);
                                await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle, cmsVehicleWeapon,
                                                cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear,
                                                cmsVehicleGear,
                                                cmsWeaponMount,
                                                cmsVehicleCyberware, cmsVehicleCyberwareGear);
                                await RefreshDrugs(treCustomDrugs);
                                await this.DoThreadSafeAsync(() =>
                                {
                                    treWeapons.SortCustomOrder();
                                    treArmor.SortCustomOrder();
                                    treGear.SortCustomOrder();
                                    treLifestyles.SortCustomOrder();
                                    treCustomDrugs.SortCustomOrder();
                                    treCyberware.SortCustomOrder();
                                    treVehicles.SortCustomOrder();
                                    treCritterPowers.SortCustomOrder();
                                }, GenericToken);

                                XPathNavigator xmlTraditionsBaseChummerNode =
                                    await (await CharacterObject.LoadDataXPathAsync("traditions.xml"))
                                        .SelectSingleNodeAndCacheExpressionAsync("/chummer");
                                using (new FetchSafelyFromPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstTraditions))
                                {
                                    if (xmlTraditionsBaseChummerNode != null)
                                    {
                                        foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                     "traditions/tradition[" + CharacterObjectSettings.BookXPath()
                                                                             + ']'))
                                        {
                                            string strName
                                                = (await xmlTradition.SelectSingleNodeAndCacheExpressionAsync("name"))
                                                ?.Value;
                                            if (!string.IsNullOrEmpty(strName))
                                                lstTraditions.Add(new ListItem(
                                                                      (await xmlTradition
                                                                          .SelectSingleNodeAndCacheExpressionAsync(
                                                                              "id"))
                                                                      ?.Value ?? strName,
                                                                      (await xmlTradition
                                                                          .SelectSingleNodeAndCacheExpressionAsync(
                                                                              "translate"))
                                                                      ?.Value ?? strName));
                                        }
                                    }

                                    if (lstTraditions.Count > 1)
                                    {
                                        lstTraditions.Sort(CompareListItems.CompareNames);
                                        lstTraditions.Insert(
                                            0,
                                            new ListItem("None", await LanguageManager.GetStringAsync("String_None")));
                                        if (!lstTraditions.SequenceEqual(
                                                await cboTradition.DoThreadSafeFuncAsync(
                                                    x => x.Items.Cast<ListItem>(), GenericToken)))
                                        {
                                            await cboTradition.PopulateWithListItemsAsync(lstTraditions, GenericToken);
                                            await cboTradition.DoThreadSafeAsync(x =>
                                            {
                                                if (CharacterObject.MagicTradition.Type == TraditionType.MAG)
                                                    x.SelectedValue
                                                        = CharacterObject.MagicTradition.SourceID.ToString();
                                                else if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                    x.SelectedIndex = 0;
                                            }, GenericToken);
                                        }
                                    }
                                    else
                                    {
                                        await this.DoThreadSafeAsync(() =>
                                        {
                                            cboTradition.Visible = false;
                                            lblTraditionLabel.Visible = false;
                                        }, GenericToken);
                                    }
                                }

                                using (new FetchSafelyFromPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstDrainAttributes))
                                {
                                    if (xmlTraditionsBaseChummerNode != null)
                                    {
                                        foreach (XPathNavigator xmlDrain in await xmlTraditionsBaseChummerNode
                                                     .SelectAndCacheExpressionAsync(
                                                         "drainattributes/drainattribute"))
                                        {
                                            string strName
                                                = (await xmlDrain.SelectSingleNodeAndCacheExpressionAsync("name"))
                                                ?.Value;
                                            if (!string.IsNullOrEmpty(strName)
                                                && lstDrainAttributes.All(x => x.Value.ToString() != strName))
                                            {
                                                string strTranslatedName = (await xmlDrain
                                                    .SelectSingleNodeAndCacheExpressionAsync(
                                                        "translate"))?.Value ?? strName;
                                                lstDrainAttributes.Add(new ListItem(strName, strTranslatedName));
                                            }
                                        }
                                    }

                                    lstDrainAttributes.Sort(CompareListItems.CompareNames);
                                    lstDrainAttributes.Insert(0, ListItem.Blank);
                                    await cboDrain.PopulateWithListItemsAsync(lstDrainAttributes, GenericToken);
                                }

                                using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                           out HashSet<string> limit))
                                {
                                    foreach (Improvement improvement in await ImprovementManager
                                                 .GetCachedImprovementListForValueOfAsync(
                                                     CharacterObject, Improvement.ImprovementType.LimitSpiritCategory))
                                    {
                                        limit.Add(improvement.ImprovedName);
                                    }

                                    using (new FetchSafelyFromPool<List<ListItem>>(
                                               Utils.ListItemListPool, out List<ListItem> lstSpirit))
                                    {
                                        lstSpirit.Add(ListItem.Blank);
                                        if (xmlTraditionsBaseChummerNode != null)
                                        {
                                            foreach (XPathNavigator xmlSpirit in await xmlTraditionsBaseChummerNode
                                                         .SelectAndCacheExpressionAsync("spirits/spirit"))
                                            {
                                                string strSpiritName
                                                    = (await xmlSpirit.SelectSingleNodeAndCacheExpressionAsync("name"))
                                                    ?.Value;
                                                if (!string.IsNullOrEmpty(strSpiritName)
                                                    && (limit.Count == 0 || limit.Contains(strSpiritName)))
                                                {
                                                    lstSpirit.Add(new ListItem(strSpiritName,
                                                                               (await xmlSpirit
                                                                                   .SelectSingleNodeAndCacheExpressionAsync(
                                                                                       "translate"))?.Value
                                                                               ?? strSpiritName));
                                                }
                                            }
                                        }

                                        lstSpirit.Sort(CompareListItems.CompareNames);
                                        await cboSpiritCombat.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                        await cboSpiritDetection.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                        await cboSpiritHealth.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                        await cboSpiritIllusion.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                        await cboSpiritManipulation.PopulateWithListItemsAsync(lstSpirit, GenericToken);
                                    }
                                }

                                // Populate the Technomancer Streams list.
                                xmlTraditionsBaseChummerNode =
                                    await (await CharacterObject.LoadDataXPathAsync("streams.xml"))
                                        .SelectSingleNodeAndCacheExpressionAsync("/chummer");
                                using (new FetchSafelyFromPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstStreams))
                                {
                                    if (xmlTraditionsBaseChummerNode != null)
                                    {
                                        foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                     "traditions/tradition[" + CharacterObjectSettings.BookXPath()
                                                                             + ']'))
                                        {
                                            string strName
                                                = (await xmlTradition.SelectSingleNodeAndCacheExpressionAsync("name"))
                                                ?.Value;
                                            if (!string.IsNullOrEmpty(strName))
                                                lstStreams.Add(new ListItem(
                                                                   (await xmlTradition
                                                                       .SelectSingleNodeAndCacheExpressionAsync("id"))
                                                                   ?.Value ?? strName,
                                                                   (await xmlTradition
                                                                       .SelectSingleNodeAndCacheExpressionAsync(
                                                                           "translate"))
                                                                   ?.Value ?? strName));
                                        }
                                    }

                                    if (lstStreams.Count > 1)
                                    {
                                        lstStreams.Sort(CompareListItems.CompareNames);
                                        lstStreams.Insert(
                                            0,
                                            new ListItem("None", await LanguageManager.GetStringAsync("String_None")));
                                        if (!lstStreams.SequenceEqual(await cboStream.DoThreadSafeFuncAsync(x => x.Items.Cast<ListItem>(), GenericToken)))
                                        {
                                            await cboStream.PopulateWithListItemsAsync(lstStreams, GenericToken);
                                            await cboStream.DoThreadSafeAsync(x =>
                                            {
                                                if (CharacterObject.MagicTradition.Type == TraditionType.RES)
                                                    x.SelectedValue
                                                        = CharacterObject.MagicTradition.SourceID.ToString();
                                                else if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                    x.SelectedIndex = 0;
                                            }, GenericToken);
                                        }
                                    }
                                    else
                                    {
                                        await this.DoThreadSafeAsync(() =>
                                        {
                                            cboStream.Visible = false;
                                            lblStreamLabel.Visible = false;
                                        }, GenericToken);
                                    }
                                }
                            }
                            finally
                            {
                                await this.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken);
                            }
                        }

                        break;
                    }
                    case nameof(CharacterSettings.AllowFreeGrids):
                    {
                        if (!CharacterObjectSettings.BookEnabled("HT"))
                        {
                            using (await CursorWait.NewAsync(this))
                            {
                                await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle);
                                await treLifestyles.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken);
                            }
                        }

                        break;
                    }
                    case nameof(CharacterSettings.EnableEnemyTracking):
                    {
                        using (await CursorWait.NewAsync(this))
                        {
                            await this.DoThreadSafeAsync(x =>
                                      {
                                          x.SuspendLayout();
                                          try
                                          {
                                              if (!CharacterObjectSettings.EnableEnemyTracking)
                                              {
                                                  tabPeople.TabPages.Remove(tabEnemies);
                                                  lblEnemiesBP.Visible = false;
                                                  lblBuildEnemies.Visible = false;
                                              }
                                              else
                                              {
                                                  lblEnemiesBP.Visible = true;
                                                  lblBuildEnemies.Visible = true;
                                                  if (!tabPeople.TabPages.Contains(tabEnemies))
                                                      tabPeople.TabPages.Insert(
                                                          tabPeople.TabPages.IndexOf(tabContacts) + 1,
                                                          tabEnemies);
                                              }
                                          }
                                          finally
                                          {
                                              x.ResumeLayout();
                                          }
                                      }, GenericToken)
                                      .ContinueWith(y => RefreshContacts(panContacts, panEnemies, panPets),
                                                    GenericToken)
                                      .Unwrap();
                        }

                        break;
                    }
                }
            }
            finally
            {
                await RequestCharacterUpdate();
            }
        }

        #endregion Character Events

        #region Menu Events

        private async void mnuFileSave_Click(object sender, EventArgs e)
        {
            try
            {
                await SaveCharacter(token: GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuFileSaveAs_Click(object sender, EventArgs e)
        {
            try
            {
                await SaveCharacterAs(token: GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuFileSaveAsCreated_Click(object sender, EventArgs e)
        {
            try
            {
                await SaveCharacterAs(true, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuFilePrint_Click(object sender, EventArgs e)
        {
            try
            {
                await DoPrint(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void mnuFileClose_Click(object sender, EventArgs e)
        {
            Close();
        }

        private async void mnuSpecialAddPACKSKit_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await AddPACKSKit();
            }
            while (blnAddAgain);
        }

        private async void mnuSpecialCreatePACKSKit_Click(object sender, EventArgs e)
        {
            await CreatePACKSKit();
        }

        private async void mnuSpecialChangeMetatype_Click(object sender, EventArgs e)
        {
            await ChangeMetatype();
        }

        private async void mnuSpecialChangeOptions_Click(object sender, EventArgs e)
        {
            try
            {
                using (await CursorWait.NewAsync(this, token: GenericToken))
                using (ThreadSafeForm<SelectBuildMethod> frmPickBP = await ThreadSafeForm<SelectBuildMethod>.GetAsync(() => new SelectBuildMethod(CharacterObject, true), GenericToken))
                {
                    await frmPickBP.ShowDialogSafeAsync(this, GenericToken);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialCyberzombie_Click(object sender, EventArgs e)
        {
            await CharacterObject.ConvertCyberzombie();
        }

        private async void mnuSpecialAddCyberwareSuite_Click(object sender, EventArgs e)
        {
            await AddCyberwareSuite(Improvement.ImprovementSource.Cyberware);
        }

        private async void mnuSpecialAddBiowareSuite_Click(object sender, EventArgs e)
        {
            await AddCyberwareSuite(Improvement.ImprovementSource.Bioware);
        }

        private async void mnuSpecialCreateCyberwareSuite_Click(object sender, EventArgs e)
        {
            await CreateCyberwareSuite(Improvement.ImprovementSource.Cyberware);
        }

        private async void mnuSpecialCreateBiowareSuite_Click(object sender, EventArgs e)
        {
            await CreateCyberwareSuite(Improvement.ImprovementSource.Bioware);
        }

        private async void mnuSpecialReapplyImprovements_Click(object sender, EventArgs e)
        {
            // This only re-applies the Improvements for everything the character has. If a match is not found in the data files, the current Improvement information is left as-is.
            // Verify that the user wants to go through with it.
            if (Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ConfirmReapplyImprovements"), await LanguageManager.GetStringAsync("MessageTitle_ConfirmReapplyImprovements"), MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.No)
                return;

            await DoReapplyImprovements();
        }

        private async ValueTask DoReapplyImprovements(ICollection<string> lstInternalIdFilter = null, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            using (await CursorWait.NewAsync(this, token: token))
            {
                IAsyncDisposable objLocker
                    = await CharacterObject.LockObject.EnterWriteLockAsync(token);
                try
                {
                    token.ThrowIfCancellationRequested();
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdOutdatedItems))
                    {
                        // Record the status of any flags that normally trigger character events.
                        bool blnMAGEnabled = CharacterObject.MAGEnabled;
                        bool blnRESEnabled = CharacterObject.RESEnabled;
                        bool blnDEPEnabled = CharacterObject.DEPEnabled;

                        _blnReapplyImprovements = true;

                        // Wipe all improvements that we will reapply, this is mainly to eliminate orphaned improvements caused by certain bugs and also for a performance increase
                        if (lstInternalIdFilter == null)
                            await ImprovementManager.RemoveImprovementsAsync(
                                CharacterObject, CharacterObject.Improvements.Where(
                                    x =>
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .AIProgram ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .Armor ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .ArmorMod ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .Bioware ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .ComplexForm ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .CritterPower ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .Cyberware ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .Echo ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .Gear ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .MartialArt ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .MartialArtTechnique ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .Metamagic ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .Power ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .Quality ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .Spell ||
                                        x.ImproveSource == Improvement
                                                           .ImprovementSource
                                                           .StackedFocus).ToList(),
                                _blnReapplyImprovements);
                        else
                            await ImprovementManager.RemoveImprovementsAsync(
                                CharacterObject, CharacterObject.Improvements.Where(
                                    x => lstInternalIdFilter.Contains(x.SourceName) &&
                                         (x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .AIProgram ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .Armor ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .ArmorMod ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .Bioware ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .ComplexForm ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .CritterPower ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .Cyberware ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .Echo ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .Gear ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .MartialArt ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .MartialArtTechnique ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .Metamagic ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .Power ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .Quality ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .Spell ||
                                          x.ImproveSource == Improvement
                                                             .ImprovementSource
                                                             .StackedFocus)).ToList(),
                                _blnReapplyImprovements);

                        // Refresh Qualities.
                        // We cannot use foreach because qualities can add more qualities
                        for (int j = 0; j < CharacterObject.Qualities.Count; j++)
                        {
                            Quality objQuality = CharacterObject.Qualities[j];
                            if (objQuality.OriginSource == QualitySource.Improvement
                                || objQuality.OriginSource == QualitySource.MetatypeRemovedAtChargen)
                                continue;
                            // We're only re-apply improvements a list of items, not all of them
                            if (lstInternalIdFilter?.Contains(objQuality.InternalId) == false)
                                continue;

                            XmlNode objNode = await objQuality.GetNodeAsync();
                            if (objNode != null)
                            {
                                string strSelected = objQuality.Extra;

                                objQuality.Bonus = objNode["bonus"];
                                if (objQuality.Bonus != null)
                                {
                                    ImprovementManager.ForcedValue = strSelected;
                                    await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                        Improvement.ImprovementSource.Quality,
                                        objQuality.InternalId, objQuality.Bonus, 1,
                                        objQuality.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objQuality.Extra = ImprovementManager.SelectedValue;
                                        await treQualities.DoThreadSafeAsync(x =>
                                        {
                                            TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                            if (objTreeNode != null)
                                                objTreeNode.Text = objQuality.CurrentDisplayName;
                                        }, token);
                                    }
                                }

                                objQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                if (objQuality.FirstLevelBonus?.HasChildNodes == true)
                                {
                                    bool blnDoFirstLevel = true;
                                    for (int k = 0; k < CharacterObject.Qualities.Count; ++k)
                                    {
                                        Quality objCheckQuality = CharacterObject.Qualities[k];
                                        if (j != k
                                            && objCheckQuality.SourceIDString == objQuality.SourceIDString
                                            && objCheckQuality.Extra == objQuality.Extra
                                            && objCheckQuality.SourceName == objQuality.SourceName
                                            && (k < j
                                                || objCheckQuality.OriginSource == QualitySource.Improvement
                                                || lstInternalIdFilter?.Contains(objCheckQuality.InternalId) == false))
                                        {
                                            blnDoFirstLevel = false;
                                            break;
                                        }
                                    }

                                    if (blnDoFirstLevel)
                                    {
                                        ImprovementManager.ForcedValue = strSelected;
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.Quality,
                                            objQuality.InternalId,
                                            objQuality.FirstLevelBonus, 1,
                                            objQuality.CurrentDisplayNameShort);
                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                        {
                                            objQuality.Extra = ImprovementManager.SelectedValue;
                                            await treQualities.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                                if (objTreeNode != null)
                                                    objTreeNode.Text = objQuality.CurrentDisplayName;
                                            }, token);
                                        }
                                    }
                                }

                                objQuality.NaturalWeaponsNode = objNode["naturalweapons"];
                                if (objQuality.NaturalWeaponsNode != null)
                                {
                                    ImprovementManager.ForcedValue = strSelected;
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, Improvement.ImprovementSource.Quality, objQuality.InternalId,
                                        objQuality.NaturalWeaponsNode, 1, objQuality.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objQuality.Extra = ImprovementManager.SelectedValue;
                                        await treQualities.DoThreadSafeAsync(x =>
                                        {
                                            TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                            if (objTreeNode != null)
                                                objTreeNode.Text = objQuality.CurrentDisplayName;
                                        }, token);
                                    }
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objQuality.CurrentDisplayName);
                            }
                        }

                        // Refresh Martial Art Techniques.
                        foreach (MartialArt objMartialArt in CharacterObject.MartialArts)
                        {
                            XmlNode objMartialArtNode = await objMartialArt.GetNodeAsync();
                            if (objMartialArtNode != null)
                            {
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objMartialArt.InternalId) != false
                                    && objMartialArtNode["bonus"] != null)
                                {
                                    await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                        Improvement.ImprovementSource.MartialArt,
                                        objMartialArt.InternalId,
                                        objMartialArtNode["bonus"], 1,
                                        objMartialArt.CurrentDisplayNameShort);
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objMartialArt.CurrentDisplayName);
                            }

                            foreach (MartialArtTechnique objTechnique in objMartialArt.Techniques.Where(
                                         x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                            {
                                XmlNode objNode = await objTechnique.GetNodeAsync();
                                if (objNode != null)
                                {
                                    if (objNode["bonus"] != null)
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.MartialArtTechnique,
                                            objTechnique.InternalId, objNode["bonus"], 1,
                                            objTechnique.CurrentDisplayName);
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(objMartialArt.CurrentDisplayName);
                                }
                            }
                        }

                        // Refresh Spells.
                        foreach (Spell objSpell in CharacterObject.Spells.Where(
                                     x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                        {
                            XmlNode objNode = await objSpell.GetNodeAsync();
                            if (objNode != null)
                            {
                                if (objNode["bonus"] != null)
                                {
                                    ImprovementManager.ForcedValue = objSpell.Extra;
                                    await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                        Improvement.ImprovementSource.Spell,
                                        objSpell.InternalId, objNode["bonus"], 1,
                                        objSpell.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objSpell.Extra = ImprovementManager.SelectedValue;
                                        await treSpells.DoThreadSafeAsync(x =>
                                        {
                                            TreeNode objSpellNode = x.FindNode(objSpell.InternalId);
                                            if (objSpellNode != null)
                                                objSpellNode.Text = objSpell.CurrentDisplayName;
                                        }, token);
                                    }
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objSpell.CurrentDisplayName);
                            }
                        }

                        // Refresh Adept Powers.
                        foreach (Power objPower in CharacterObject.Powers.Where(
                                     x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                        {
                            XmlNode objNode = await objPower.GetNodeAsync();
                            if (objNode != null)
                            {
                                objPower.Bonus = objNode["bonus"];
                                if (objPower.Bonus != null)
                                {
                                    ImprovementManager.ForcedValue = objPower.Extra;
                                    await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                        Improvement.ImprovementSource.Power,
                                        objPower.InternalId, objPower.Bonus,
                                        objPower.TotalRating,
                                        objPower.CurrentDisplayNameShort);
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objPower.CurrentDisplayName);
                            }
                        }

                        // Refresh Complex Forms.
                        foreach (ComplexForm objComplexForm in CharacterObject.ComplexForms.Where(
                                     x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                        {
                            XmlNode objNode = await objComplexForm.GetNodeAsync();
                            if (objNode != null)
                            {
                                if (objNode["bonus"] != null)
                                {
                                    ImprovementManager.ForcedValue = objComplexForm.Extra;
                                    await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                        Improvement.ImprovementSource.ComplexForm,
                                        objComplexForm.InternalId, objNode["bonus"],
                                        1,
                                        objComplexForm.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objComplexForm.Extra = ImprovementManager.SelectedValue;
                                        TreeNode objCFNode = treComplexForms.FindNode(objComplexForm.InternalId);
                                        if (objCFNode != null)
                                            objCFNode.Text = objComplexForm.CurrentDisplayName;
                                    }
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objComplexForm.CurrentDisplayName);
                            }
                        }

                        // Refresh AI Programs and Advanced Programs
                        foreach (AIProgram objProgram in CharacterObject.AIPrograms.Where(
                                     x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                        {
                            XmlNode objNode = await objProgram.GetNodeAsync();
                            if (objNode != null)
                            {
                                if (objNode["bonus"] != null)
                                {
                                    ImprovementManager.ForcedValue = objProgram.Extra;
                                    await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                        Improvement.ImprovementSource.AIProgram,
                                        objProgram.InternalId, objNode["bonus"], 1,
                                        objProgram.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objProgram.Extra = ImprovementManager.SelectedValue;
                                        await treAIPrograms.DoThreadSafeAsync(x =>
                                        {
                                            TreeNode objProgramNode = x.FindNode(objProgram.InternalId);
                                            if (objProgramNode != null)
                                                objProgramNode.Text = objProgram.CurrentDisplayNameShort;
                                        }, token);
                                    }
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objProgram.CurrentDisplayNameShort);
                            }
                        }

                        // Refresh Critter Powers.
                        foreach (CritterPower objPower in CharacterObject.CritterPowers.Where(
                                     x => lstInternalIdFilter?.Contains(x.InternalId) != false))
                        {
                            XmlNode objNode = await objPower.GetNodeAsync();
                            if (objNode != null)
                            {
                                objPower.Bonus = objNode["bonus"];
                                if (objPower.Bonus != null)
                                {
                                    string strSelected = objPower.Extra;
                                    if (!int.TryParse(strSelected, out int intRating))
                                    {
                                        intRating = 1;
                                        ImprovementManager.ForcedValue = strSelected;
                                    }

                                    await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                        Improvement.ImprovementSource.CritterPower,
                                        objPower.InternalId, objPower.Bonus,
                                        intRating,
                                        objPower.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                    {
                                        objPower.Extra = ImprovementManager.SelectedValue;
                                        await treCritterPowers.DoThreadSafeAsync(x =>
                                        {
                                            TreeNode objPowerNode = x.FindNode(objPower.InternalId);
                                            if (objPowerNode != null)
                                                objPowerNode.Text = objPower.CurrentDisplayName;
                                        }, token);
                                    }
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objPower.CurrentDisplayName);
                            }
                        }

                        // Refresh Metamagics and Echoes.
                        // We cannot use foreach because metamagics/echoes can add more metamagics/echoes
                        // ReSharper disable once ForCanBeConvertedToForeach
                        for (int j = 0; j < CharacterObject.Metamagics.Count; j++)
                        {
                            Metamagic objMetamagic = CharacterObject.Metamagics[j];
                            if (objMetamagic.Grade < 0)
                                continue;
                            // We're only re-apply improvements a list of items, not all of them
                            if (lstInternalIdFilter?.Contains(objMetamagic.InternalId) == false)
                                continue;
                            XmlNode objNode = await objMetamagic.GetNodeAsync();
                            if (objNode != null)
                            {
                                objMetamagic.Bonus = objNode["bonus"];
                                if (objMetamagic.Bonus != null)
                                {
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, objMetamagic.SourceType,
                                        objMetamagic.InternalId, objMetamagic.Bonus,
                                        1,
                                        objMetamagic.CurrentDisplayNameShort);
                                }
                            }
                            else
                            {
                                sbdOutdatedItems.AppendLine(objMetamagic.CurrentDisplayName);
                            }
                        }

                        // Refresh Cyberware and Bioware.
                        Dictionary<Cyberware, int> dicPairableCyberwares
                            = new Dictionary<Cyberware, int>(CharacterObject.Cyberware.Count);
                        foreach (Cyberware objCyberware in CharacterObject.Cyberware.GetAllDescendants(x => x.Children))
                        {
                            // We're only re-apply improvements a list of items, not all of them
                            if (lstInternalIdFilter?.Contains(objCyberware.InternalId) != false)
                            {
                                XmlNode objNode = await objCyberware.GetNodeAsync();
                                if (objNode != null)
                                {
                                    objCyberware.Bonus = objNode["bonus"];
                                    objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                    objCyberware.PairBonus = objNode["pairbonus"];
                                    if (!string.IsNullOrEmpty(objCyberware.Forced) && objCyberware.Forced != "Right"
                                        && objCyberware.Forced != "Left")
                                        ImprovementManager.ForcedValue = objCyberware.Forced;
                                    if (objCyberware.Bonus != null)
                                    {
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, objCyberware.SourceType, objCyberware.InternalId,
                                            objCyberware.Bonus, objCyberware.Rating,
                                            objCyberware.CurrentDisplayNameShort);
                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                            objCyberware.Extra = ImprovementManager.SelectedValue;
                                    }

                                    if (!objCyberware.IsModularCurrentlyEquipped)
                                        objCyberware.ChangeModularEquip(false);
                                    else
                                    {
                                        objCyberware.RefreshWirelessBonuses();
                                        if (objCyberware.PairBonus != null)
                                        {
                                            Cyberware objMatchingCyberware
                                                = dicPairableCyberwares.Keys.FirstOrDefault(
                                                    x => objCyberware.IncludePair.Contains(x.Name)
                                                         && x.Extra == objCyberware.Extra);
                                            if (objMatchingCyberware != null)
                                                ++dicPairableCyberwares[objMatchingCyberware];
                                            else
                                                dicPairableCyberwares.Add(objCyberware, 1);
                                        }
                                    }

                                    TreeNode objWareNode = objCyberware.SourceID == Cyberware.EssenceHoleGUID
                                                           || objCyberware.SourceID == Cyberware.EssenceAntiHoleGUID
                                        ? await treCyberware.DoThreadSafeFuncAsync(x => x.FindNode(objCyberware.SourceIDString), token)
                                        : await treCyberware.DoThreadSafeFuncAsync(x => x.FindNode(objCyberware.InternalId), token);
                                    if (objWareNode != null)
                                        await treCyberware.DoThreadSafeAsync(() => objWareNode.Text = objCyberware.CurrentDisplayName, token);
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(objCyberware.CurrentDisplayName);
                                }
                            }

                            foreach (Gear objGear in objCyberware.GearChildren)
                            {
                                await objGear.ReaddImprovements(treCyberware, sbdOutdatedItems, lstInternalIdFilter);
                            }
                        }

                        // Separate Pass for PairBonuses
                        foreach (KeyValuePair<Cyberware, int> objItem in dicPairableCyberwares)
                        {
                            Cyberware objCyberware = objItem.Key;
                            int intCyberwaresCount = objItem.Value;
                            List<Cyberware> lstPairableCyberwares = CharacterObject.Cyberware
                                .DeepWhere(x => x.Children,
                                           x => objCyberware.IncludePair
                                                            .Contains(x.Name)
                                                && x.Extra == objCyberware.Extra
                                                && x.IsModularCurrentlyEquipped)
                                .ToList();
                            // Need to use slightly different logic if this cyberware has a location (Left or Right) and only pairs with itself because Lefts can only be paired with Rights and Rights only with Lefts
                            if (!string.IsNullOrEmpty(objCyberware.Location)
                                && objCyberware.IncludePair.All(x => x == objCyberware.Name))
                            {
                                int intMatchLocationCount = 0;
                                int intNotMatchLocationCount = 0;
                                foreach (Cyberware objPairableCyberware in lstPairableCyberwares)
                                {
                                    if (objPairableCyberware.Location != objCyberware.Location)
                                        ++intNotMatchLocationCount;
                                    else
                                        ++intMatchLocationCount;
                                }

                                // Set the count to the total number of cyberwares in matching pairs, which would mean 2x the number of whichever location contains the fewest members (since every single one of theirs would have a pair)
                                intCyberwaresCount = Math.Min(intNotMatchLocationCount, intMatchLocationCount) * 2;
                            }

                            if (intCyberwaresCount <= 0)
                                continue;
                            foreach (Cyberware objLoopCyberware in lstPairableCyberwares)
                            {
                                if ((intCyberwaresCount & 1) == 0)
                                {
                                    if (!string.IsNullOrEmpty(objCyberware.Forced) && objCyberware.Forced != "Right"
                                        && objCyberware.Forced != "Left")
                                        ImprovementManager.ForcedValue = objCyberware.Forced;
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, objLoopCyberware.SourceType,
                                        objLoopCyberware.InternalId + "Pair",
                                        objLoopCyberware.PairBonus,
                                        objLoopCyberware.Rating,
                                        objLoopCyberware.CurrentDisplayNameShort);
                                    if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue)
                                        && string.IsNullOrEmpty(objCyberware.Extra))
                                        objCyberware.Extra = ImprovementManager.SelectedValue;
                                    TreeNode objNode = objLoopCyberware.SourceID == Cyberware.EssenceHoleGUID
                                                       || objCyberware.SourceID == Cyberware.EssenceAntiHoleGUID
                                        ? await treCyberware.DoThreadSafeFuncAsync(x => x.FindNode(objCyberware.SourceIDString), token)
                                        : await treCyberware.DoThreadSafeFuncAsync(x => x.FindNode(objLoopCyberware.InternalId), token);
                                    if (objNode != null)
                                        await treCyberware.DoThreadSafeAsync(() => objNode.Text = objLoopCyberware.CurrentDisplayName, token);
                                }

                                --intCyberwaresCount;
                                if (intCyberwaresCount <= 0)
                                    break;
                            }
                        }

                        // Refresh Armors.
                        foreach (Armor objArmor in CharacterObject.Armor)
                        {
                            // We're only re-apply improvements a list of items, not all of them
                            if (lstInternalIdFilter?.Contains(objArmor.InternalId) != false)
                            {
                                XmlNode objNode = await objArmor.GetNodeAsync();
                                if (objNode != null)
                                {
                                    objArmor.Bonus = objNode["bonus"];
                                    if (objArmor.Bonus != null && objArmor.Equipped)
                                    {
                                        ImprovementManager.ForcedValue = objArmor.Extra;
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.Armor, objArmor.InternalId,
                                            objArmor.Bonus, objArmor.Rating,
                                            objArmor.CurrentDisplayNameShort);
                                        if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                        {
                                            objArmor.Extra = ImprovementManager.SelectedValue;
                                            await treArmor.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objArmorNode = x.FindNode(objArmor.InternalId);
                                                if (objArmorNode != null)
                                                    objArmorNode.Text = objArmor.CurrentDisplayName;
                                            }, token);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(objArmor.CurrentDisplayName);
                                }
                            }

                            foreach (ArmorMod objMod in objArmor.ArmorMods)
                            {
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objMod.InternalId) != false)
                                {
                                    XmlNode objChild = await objMod.GetNodeAsync();

                                    if (objChild != null)
                                    {
                                        objMod.Bonus = objChild["bonus"];
                                        if (objMod.Bonus != null && objMod.Equipped)
                                        {
                                            ImprovementManager.ForcedValue = objMod.Extra;
                                            await ImprovementManager.CreateImprovementsAsync(
                                                CharacterObject, Improvement.ImprovementSource.ArmorMod,
                                                objMod.InternalId,
                                                objMod.Bonus, objMod.Rating,
                                                objMod.CurrentDisplayNameShort);
                                            if (!string.IsNullOrEmpty(ImprovementManager.SelectedValue))
                                            {
                                                objMod.Extra = ImprovementManager.SelectedValue;
                                                await treArmor.DoThreadSafeAsync(x =>
                                                {
                                                    TreeNode objPluginNode = x.FindNode(objMod.InternalId);
                                                    if (objPluginNode != null)
                                                        objPluginNode.Text = objMod.CurrentDisplayName;
                                                }, token);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        sbdOutdatedItems.AppendLine(objMod.CurrentDisplayName);
                                    }
                                }

                                foreach (Gear objGear in objMod.GearChildren)
                                {
                                    await objGear.ReaddImprovements(treArmor, sbdOutdatedItems, lstInternalIdFilter);
                                }
                            }

                            foreach (Gear objGear in objArmor.GearChildren)
                            {
                                await objGear.ReaddImprovements(treArmor, sbdOutdatedItems, lstInternalIdFilter);
                            }

                            objArmor.RefreshWirelessBonuses();
                        }

                        // Refresh Gear.
                        foreach (Gear objGear in CharacterObject.Gear)
                        {
                            await objGear.ReaddImprovements(treGear, sbdOutdatedItems, lstInternalIdFilter);
                            objGear.RefreshWirelessBonuses();
                        }

                        // Refresh Weapons Gear
                        foreach (Weapon objWeapon in CharacterObject.Weapons)
                        {
                            foreach (WeaponAccessory objAccessory in objWeapon.WeaponAccessories)
                            {
                                foreach (Gear objGear in objAccessory.GearChildren)
                                {
                                    await objGear.ReaddImprovements(treWeapons, sbdOutdatedItems, lstInternalIdFilter);
                                }
                            }

                            objWeapon.RefreshWirelessBonuses();
                        }

                        _blnReapplyImprovements = false;

                        // If the status of any Character Event flags has changed, manually trigger those events.
                        if (blnMAGEnabled != CharacterObject.MAGEnabled)
                            await DoOnCharacterPropertyChanged(
                                new PropertyChangedEventArgs(nameof(Character.MAGEnabled)));
                        if (blnRESEnabled != CharacterObject.RESEnabled)
                            await DoOnCharacterPropertyChanged(
                                new PropertyChangedEventArgs(nameof(Character.RESEnabled)));
                        if (blnDEPEnabled != CharacterObject.DEPEnabled)
                            await DoOnCharacterPropertyChanged(
                                new PropertyChangedEventArgs(nameof(Character.DEPEnabled)));

                        await RequestCharacterUpdate();
                        // Immediately await character update because it re-applies essence loss improvements
                        try
                        {
                            await UpdateCharacterInfoTask;
                        }
                        catch (OperationCanceledException)
                        {
                            return;
                        }

                        if (sbdOutdatedItems.Length > 0 && !Utils.IsUnitTest)
                        {
                            Program.ShowMessageBox(
                                this, await LanguageManager.GetStringAsync(
                                          "Message_ReapplyImprovementsFoundOutdatedItems_Top") +
                                      sbdOutdatedItems +
                                      await LanguageManager.GetStringAsync(
                                          "Message_ReapplyImprovementsFoundOutdatedItems_Bottom"),
                                await LanguageManager.GetStringAsync("MessageTitle_ConfirmReapplyImprovements"),
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync();
                }
            }

            await SetDirty(true);
        }

        private void mnuEditCopy_Click(object sender, EventArgs e)
        {
            object selectedObject = null;
            if (tabCharacterTabs.SelectedTab == tabStreetGear)
            {
                // Lifestyle Tab.
                if (tabStreetGearTabs.SelectedTab == tabLifestyle)
                {
                    selectedObject = treLifestyles.SelectedNode?.Tag;
                }
                // Armor Tab.
                else if (tabStreetGearTabs.SelectedTab == tabArmor)
                {
                    selectedObject = treArmor.SelectedNode?.Tag;
                }
                // Weapons Tab.
                else if (tabStreetGearTabs.SelectedTab == tabWeapons)
                {
                    selectedObject = treWeapons.SelectedNode?.Tag;
                }
                // Gear Tab.
                else if (tabStreetGearTabs.SelectedTab == tabGear)
                {
                    selectedObject = treGear.SelectedNode?.Tag;
                }
            }
            // Cyberware Tab.
            else if (tabCharacterTabs.SelectedTab == tabCyberware)
            {
                selectedObject = treCyberware.SelectedNode?.Tag;
            }
            // Vehicles Tab.
            else if (tabCharacterTabs.SelectedTab == tabVehicles)
            {
                selectedObject = treVehicles.SelectedNode?.Tag;
            }
            CopyObject(selectedObject);
        }

        private void mnuEditPaste_Click(object sender, EventArgs e)
        {
            object objSelectedObject = null;
            if (tabCharacterTabs?.SelectedTab == tabStreetGear)
            {
                objSelectedObject = treGear.SelectedNode?.Tag;
            }
            else if (tabCharacterTabs?.SelectedTab == tabArmor)
            {
                objSelectedObject = treArmor.SelectedNode?.Tag;
            }
            else if (tabCharacterTabs?.SelectedTab == tabVehicles)
            {
                objSelectedObject = treVehicles.SelectedNode?.Tag;
            }
            else if (tabCharacterTabs?.SelectedTab == tabWeapons)
            {
                objSelectedObject = treWeapons.SelectedNode?.Tag;
            }
            else if (tabCharacterTabs?.SelectedTab == tabCyberware)
            {
                objSelectedObject = treCyberware.SelectedNode?.Tag;
            }
            else if (tabCharacterTabs?.SelectedTab == tabLifestyle)
            {
                // Intentionally blank, lifestyles are always clones.
            }
            else
            {
                Utils.BreakIfDebug();
                return;
            }

            switch (GlobalSettings.ClipboardContentType)
            {
                case ClipboardContentType.Armor:
                    {
                        // Paste Armor.
                        XmlNode objXmlNode = GlobalSettings.Clipboard.SelectSingleNode("/character/armor");
                        if (objXmlNode != null)
                        {
                            Armor objArmor = new Armor(CharacterObject);
                            objArmor.Load(objXmlNode, true);
                            CharacterObject.Armor.Add(objArmor);

                            AddChildVehicles(objArmor.InternalId);
                            AddChildWeapons(objArmor.InternalId);
                        }

                        break;
                    }
                case ClipboardContentType.ArmorMod:
                    {
                        if (!(objSelectedObject is Armor selectedArmor && selectedArmor.AllowPasteXml)) break;
                        // Paste Armor.
                        XmlNode objXmlNode = GlobalSettings.Clipboard.SelectSingleNode("/character/armormod");
                        if (objXmlNode != null)
                        {
                            ArmorMod objArmorMod = new ArmorMod(CharacterObject);
                            objArmorMod.Load(objXmlNode, true);
                            selectedArmor.ArmorMods.Add(objArmorMod);

                            AddChildVehicles(objArmorMod.InternalId);
                            AddChildWeapons(objArmorMod.InternalId);
                        }

                        break;
                    }
                case ClipboardContentType.Cyberware:
                    {
                        // Paste Cyberware.
                        XmlNode objXmlNode = GlobalSettings.Clipboard.SelectSingleNode("/character/cyberware");
                        if (objXmlNode != null)
                        {
                            Cyberware objCyberware = new Cyberware(CharacterObject);
                            objCyberware.Load(objXmlNode, true);
                            if (objSelectedObject is Cyberware objCyberwareParent)
                            {
                                if (!objCyberwareParent.AllowPasteObject(objCyberware))
                                {
                                    objCyberware.DeleteCyberware();
                                    return;
                                }

                                objCyberware.Grade = objCyberwareParent.Grade;
                                objCyberwareParent.Children.Add(objCyberware);
                            }
                            else
                            {
                                if (!string.IsNullOrEmpty(objCyberware.LimbSlot) &&
                                    !objCyberware.GetValidLimbSlot(objCyberware.GetNodeXPath(GlobalSettings.Language)))
                                {
                                    objCyberware.DeleteCyberware();
                                    return;
                                }

                                CharacterObject.Cyberware.Add(objCyberware);
                            }

                            AddChildVehicles(objCyberware.InternalId);
                            AddChildWeapons(objCyberware.InternalId);
                        }

                        break;
                    }
                case ClipboardContentType.Gear:
                    {
                        // Paste Gear.
                        XmlNode objXmlNode = GlobalSettings.Clipboard.SelectSingleNode("/character/gear");
                        if (objXmlNode == null)
                            break;
                        Gear objGear = new Gear(CharacterObject);
                        objGear.Load(objXmlNode, true);
                        if (objSelectedObject is ICanPaste selected && selected.AllowPasteXml &&
                            objSelectedObject is IHasGear gear)
                        {
                            gear.GearChildren.Add(objGear);
                            if (gear is ICanEquip selectedEquip && !selectedEquip.Equipped)
                                objGear.ChangeEquippedStatus(false);
                        }
                        else
                        {
                            CharacterObject.Gear.Add(objGear);
                        }

                        AddChildVehicles(objGear.InternalId);
                        AddChildWeapons(objGear.InternalId);
                        break;
                    }
                case ClipboardContentType.Lifestyle:
                    {
                        // Lifestyle Tab.
                        if (tabStreetGearTabs.SelectedTab != tabLifestyle)
                            break;

                        // Paste Lifestyle.
                        XmlNode objXmlNode = GlobalSettings.Clipboard.SelectSingleNode("/character/lifestyle");
                        if (objXmlNode == null)
                            break;

                        Lifestyle objLifestyle = new Lifestyle(CharacterObject);
                        objLifestyle.Load(objXmlNode, true);
                        // Reset the number of months back to 1 since 0 isn't valid in Create Mode.
                        objLifestyle.Increments = 1;
                        CharacterObject.Lifestyles.Add(objLifestyle);
                        break;
                    }
                case ClipboardContentType.Vehicle:
                    {
                        // Paste Vehicle.
                        XmlNode objXmlNode = GlobalSettings.Clipboard.SelectSingleNode("/character/vehicle");
                        Vehicle objVehicle = new Vehicle(CharacterObject);
                        objVehicle.Load(objXmlNode, true);
                        CharacterObject.Vehicles.Add(objVehicle);
                        break;
                    }
                case ClipboardContentType.Weapon:
                    {
                        // Paste Weapon.
                        XmlNode objXmlNode = GlobalSettings.Clipboard.SelectSingleNode("/character/weapon");
                        if (objXmlNode != null)
                        {
                            Weapon objWeapon;
                            switch (objSelectedObject)
                            {
                                case Weapon objWeaponParent when !objWeaponParent.AllowPasteXml:
                                    return;

                                case Weapon objWeaponParent:
                                    objWeapon = new Weapon(CharacterObject);
                                    objWeapon.Load(objXmlNode, true);
                                    objWeaponParent.Children.Add(objWeapon);
                                    break;

                                case WeaponMount objWeaponMount when !objWeaponMount.AllowPasteXml:
                                    return;

                                case WeaponMount objWeaponMount:
                                    objWeapon = new Weapon(CharacterObject);
                                    objWeapon.Load(objXmlNode, true);
                                    objWeaponMount.Weapons.Add(objWeapon);
                                    break;

                                case VehicleMod objMod when !objMod.AllowPasteXml:
                                    return;

                                case VehicleMod objMod:
                                    objWeapon = new Weapon(CharacterObject);
                                    objWeapon.Load(objXmlNode, true);
                                    objMod.Weapons.Add(objWeapon);
                                    break;

                                default:
                                    objWeapon = new Weapon(CharacterObject);
                                    objWeapon.Load(objXmlNode, true);
                                    CharacterObject.Weapons.Add(objWeapon);
                                    break;
                            }

                            AddChildVehicles(objWeapon.InternalId);
                            AddChildWeapons(objWeapon.InternalId);
                        }

                        break;
                    }
                case ClipboardContentType.WeaponAccessory:
                    {
                        if (!(objSelectedObject is Weapon selectedWeapon && selectedWeapon.AllowPasteXml))
                            break;
                        // Paste Armor.
                        XmlNode objXmlNode = GlobalSettings.Clipboard.SelectSingleNode("/character/accessory");
                        if (objXmlNode != null)
                        {
                            WeaponAccessory objMod = new WeaponAccessory(CharacterObject);
                            objMod.Load(objXmlNode, true);
                            selectedWeapon.WeaponAccessories.Add(objMod);

                            AddChildVehicles(objMod.InternalId);
                            AddChildWeapons(objMod.InternalId);
                        }

                        break;
                    }
                default:
                    Utils.BreakIfDebug();
                    break;
            }

            void AddChildWeapons(string parentId)
            {
                XmlNodeList objXmlNodeList = GlobalSettings.Clipboard.SelectNodes("/character/weapons/weapon");
                if (!(objXmlNodeList?.Count > 0))
                    return;
                foreach (XmlNode objLoopNode in objXmlNodeList)
                {
                    Weapon objWeapon = new Weapon(CharacterObject);
                    objWeapon.Load(objLoopNode, true);
                    CharacterObject.Weapons.Add(objWeapon);
                    objWeapon.ParentID = parentId;
                }
            }
            void AddChildVehicles(string parentId)
            {
                // Add any Vehicles that come with the Cyberware.
                XmlNodeList objXmlNodeList = GlobalSettings.Clipboard.SelectNodes("/character/vehicles/vehicle");
                if (!(objXmlNodeList?.Count > 0))
                    return;
                foreach (XmlNode objLoopNode in objXmlNodeList)
                {
                    Vehicle objVehicle = new Vehicle(CharacterObject);
                    objVehicle.Load(objLoopNode, true);
                    CharacterObject.Vehicles.Add(objVehicle);
                    objVehicle.ParentID = parentId;
                }
            }
        }

        private async void mnuSpecialConvertToFreeSprite_Click(object sender, EventArgs e)
        {
            XmlNode objXmlPower = (await CharacterObject.LoadDataAsync("critterpowers.xml")).SelectSingleNode("/chummer/powers/power[name = \"Denial\"]");
            CritterPower objPower = new CritterPower(CharacterObject);
            objPower.Create(objXmlPower);
            objPower.CountTowardsLimit = false;
            if (objPower.InternalId.IsEmptyGuid())
                return;

            await CharacterObject.CritterPowers.AddAsync(objPower);

            CharacterObject.MetatypeCategory = "Free Sprite";
        }

        #endregion Menu Events

        #region Martial Tab Control Events

        private async void treMartialArts_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedMartialArt();
        }

        private async Task RefreshSelectedMartialArt(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                object objSelectedNodeTag = await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token);
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblMartialArtSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblMartialArtSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblMartialArtSource, token);
                }
                else
                {
                    await lblMartialArtSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblMartialArtSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                switch (objSelectedNodeTag)
                {
                    case MartialArt objMartialArt:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = !objMartialArt.IsQuality, token);
                        break;

                    case ICanRemove _:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = true, token);
                        break;

                    default:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = false, token);
                        await SourceString.Blank.SetControlAsync(lblMartialArtSource, token);
                        break;
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        #endregion Martial Tab Control Events

        #region Button Events

        private async void cmdAddSpell_Click(object sender, EventArgs e)
        {
            // Open the Spells XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("spells.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectSpell> frmPickSpell = await ThreadSafeForm<SelectSpell>.GetAsync(() => new SelectSpell(CharacterObject)))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickSpell.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;

                        blnAddAgain = frmPickSpell.MyForm.AddAgain;

                        XmlNode objXmlSpell
                            = objXmlDocument.SelectSingleNode("/chummer/spells/spell[id = "
                                                              + frmPickSpell.MyForm.SelectedSpell.CleanXPath() + ']');

                        Spell objSpell = new Spell(CharacterObject);
                        objSpell.Create(objXmlSpell, string.Empty, frmPickSpell.MyForm.Limited, frmPickSpell.MyForm.Extended,
                                        frmPickSpell.MyForm.Alchemical);
                        if (objSpell.InternalId.IsEmptyGuid())
                        {
                            objSpell.Dispose();
                            continue;
                        }

                        objSpell.FreeBonus = frmPickSpell.MyForm.FreeBonus;
                        // Barehanded Adept
                        if (objSpell.FreeBonus && CharacterObject.AdeptEnabled && !CharacterObject.MagicianEnabled
                            && (objSpell.Range == "T" || objSpell.Range == "T (A)"))
                        {
                            objSpell.BarehandedAdept = true;
                        }

                        await CharacterObject.Spells.AddAsync(objSpell);
                    }
                } while (blnAddAgain);
            }
        }

        private void cmdDeleteSpell_Click(object sender, EventArgs e)
        {
            // Locate the Spell that is selected in the tree.
            if (!(treSpells.SelectedNode?.Tag is Spell objSpell))
                return;
            // Spells that come from Initiation Grades can't be deleted normally.
            if (objSpell.Grade != 0)
                return;
            objSpell.Remove();
        }

        private async void cmdAddSpirit_Click(object sender, EventArgs e)
        {
            await AddSpirit();
        }

        private async void cmdAddSprite_Click(object sender, EventArgs e)
        {
            await AddSprite();
        }

        private async void cmdAddContact_Click(object sender, EventArgs e)
        {
            await AddContact();
        }

        private async void cmdAddEnemy_Click(object sender, EventArgs e)
        {
            await AddEnemy();
        }

        private async void cmdAddPet_Click(object sender, EventArgs e)
        {
            await AddPet();
        }

        private async void tsAddFromFile_Click(object sender, EventArgs e)
        {
            try
            {
                await AddContactsFromFile(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddCyberware_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickCyberware(null, Improvement.ImprovementSource.Cyberware);
            }
            while (blnAddAgain);
        }

        private void cmdDeleteCyberware_Click(object sender, EventArgs e)
        {
            if (!(treCyberware.SelectedNode?.Tag is ICanRemove selectedObject))
                return;
            selectedObject.Remove();
        }

        private async void cmdAddComplexForm_Click(object sender, EventArgs e)
        {
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("complexforms.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    // The number of Complex Forms cannot exceed twice the character's RES.
                    if (CharacterObject.ComplexForms.Count >= CharacterObject.RES.Value * 2
                        + await ImprovementManager.ValueOfAsync(CharacterObject, Improvement.ImprovementType.ComplexFormLimit)
                        && !CharacterObject.IgnoreRules)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ComplexFormLimit"),
                                               await LanguageManager.GetStringAsync("MessageTitle_ComplexFormLimit"),
                                               MessageBoxButtons.OK, MessageBoxIcon.Information);
                        break;
                    }

                    XmlNode objXmlComplexForm;
                    // Let the user select a Program.
                    using (ThreadSafeForm<SelectComplexForm> frmPickComplexForm = await ThreadSafeForm<SelectComplexForm>.GetAsync(() => new SelectComplexForm(CharacterObject)))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickComplexForm.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;

                        blnAddAgain = frmPickComplexForm.MyForm.AddAgain;

                        objXmlComplexForm = objXmlDocument.SelectSingleNode(
                            "/chummer/complexforms/complexform[id = "
                            + frmPickComplexForm.MyForm.SelectedComplexForm.CleanXPath()
                            + ']');
                    }

                    if (objXmlComplexForm == null)
                        continue;

                    ComplexForm objComplexForm = new ComplexForm(CharacterObject);
                    objComplexForm.Create(objXmlComplexForm);
                    if (objComplexForm.InternalId.IsEmptyGuid())
                        continue;

                    await CharacterObject.ComplexForms.AddAsync(objComplexForm);
                } while (blnAddAgain);
            }
        }

        private async void cmdAddAIProgram_Click(object sender, EventArgs e)
        {
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("programs.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    XmlNode objXmlProgram;
                    // Let the user select a Program.
                    using (ThreadSafeForm<SelectAIProgram> frmPickProgram = await ThreadSafeForm<SelectAIProgram>.GetAsync(() => new SelectAIProgram(CharacterObject)))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickProgram.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        {
                            break;
                        }

                        blnAddAgain = frmPickProgram.MyForm.AddAgain;

                        objXmlProgram = objXmlDocument.SelectSingleNode(
                            "/chummer/programs/program[id = " + frmPickProgram.MyForm.SelectedProgram.CleanXPath() + ']');
                    }

                    if (objXmlProgram == null)
                        continue;

                    // Check for SelectText.
                    string strExtra = string.Empty;
                    XmlNode xmlSelectText = objXmlProgram.SelectSingleNode("bonus/selecttext");
                    if (xmlSelectText != null)
                    {
                        string strDescription = string.Format(GlobalSettings.CultureInfo,
                                                              await LanguageManager.GetStringAsync(
                                                                  "String_Improvement_SelectText"),
                                                              objXmlProgram["translate"]?.InnerText
                                                              ?? objXmlProgram["name"]?.InnerText);
                        using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                                   () => new SelectText
                                   {
                                       Description = strDescription
                                   }))
                        {
                            if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                                continue;
                            strExtra = frmPickText.MyForm.SelectedValue;
                        }
                    }

                    AIProgram objProgram = new AIProgram(CharacterObject);
                    objProgram.Create(objXmlProgram, strExtra);
                    if (objProgram.InternalId.IsEmptyGuid())
                        continue;

                    await CharacterObject.AIPrograms.AddAsync(objProgram);
                } while (blnAddAgain);
            }
        }

        private void cmdDeleteArmor_Click(object sender, EventArgs e)
        {
            if (!(treArmor.SelectedNode?.Tag is ICanRemove selectedObject))
                return;
            selectedObject.Remove();
        }

        private async void cmdAddBioware_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickCyberware(null, Improvement.ImprovementSource.Bioware);
            }
            while (blnAddAgain);
        }

        private async void cmdAddWeapon_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            Location location = null;
            if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objLocation)
            {
                location = objLocation;
            }
            do
            {
                blnAddAgain = await AddWeapon(location);
            }
            while (blnAddAgain);
        }

        private async ValueTask<bool> AddWeapon(Location objLocation = null)
        {
            using (await CursorWait.NewAsync(this))
            {
                using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(() => new SelectWeapon(CharacterObject)))
                {
                    // Make sure the dialogue window was not canceled.
                    if (await frmPickWeapon.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return false;

                    // Open the Weapons XML file and locate the selected piece.
                    XmlNode objXmlWeapon
                        = (await CharacterObject.LoadDataAsync("weapons.xml")).SelectSingleNode(
                            "/chummer/weapons/weapon[id = " + frmPickWeapon.MyForm.SelectedWeapon.CleanXPath() + ']');
                    if (objXmlWeapon == null)
                        return frmPickWeapon.MyForm.AddAgain;

                    List<Weapon> lstWeapons = new List<Weapon>(1);
                    Weapon objWeapon = new Weapon(CharacterObject);
                    objWeapon.Create(objXmlWeapon, lstWeapons);
                    objWeapon.DiscountCost = frmPickWeapon.MyForm.BlackMarketDiscount;
                    if (frmPickWeapon.MyForm.FreeCost)
                    {
                        objWeapon.Cost = "0";
                    }

                    //objWeapon.Location = objLocation;
                    if (objLocation != null)
                        await objLocation.Children.AddAsync(objWeapon);
                    await CharacterObject.Weapons.AddAsync(objWeapon);

                    foreach (Weapon objExtraWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objExtraWeapon);
                    }

                    return frmPickWeapon.MyForm.AddAgain;
                }
            }
        }

        private void cmdDeleteWeapon_Click(object sender, EventArgs e)
        {
            if (!(treWeapons.SelectedNode?.Tag is ICanRemove objSelectedNode))
                return;
            objSelectedNode.Remove();
        }

        private async void cmdAddLifestyle_Click(object sender, EventArgs e)
        {
            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    Lifestyle objLifestyle;
                    using (ThreadSafeForm<SelectLifestyle> frmPickLifestyle = await ThreadSafeForm<SelectLifestyle>.GetAsync(() => new SelectLifestyle(CharacterObject)))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickLifestyle.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        {
                            frmPickLifestyle.MyForm.SelectedLifestyle.Dispose();
                            return;
                        }

                        blnAddAgain = frmPickLifestyle.MyForm.AddAgain;
                        objLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;
                    }

                    await CharacterObject.Lifestyles.AddAsync(objLifestyle);
                } while (blnAddAgain);
            }
        }

        private void cmdDeleteLifestyle_Click(object sender, EventArgs e)
        {
            // Delete the selected Lifestyle.
            if (!(treLifestyles.SelectedNode?.Tag is ICanRemove objSelectedObject))
                return;
            objSelectedObject.Remove();
        }

        private async void cmdAddGear_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            string strSelectedId = string.Empty;
            if (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objNode)
            {
                strSelectedId = objNode.InternalId;
            }
            do
            {
                blnAddAgain = await PickGear(strSelectedId);
            }
            while (blnAddAgain);
        }

        private void cmdDeleteGear_Click(object sender, EventArgs e)
        {
            if (!(treGear.SelectedNode?.Tag is ICanRemove objSelectedGear))
                return;
            objSelectedGear.Remove();
        }

        private async ValueTask<bool> AddVehicle(Location objLocation = null)
        {
            using (await CursorWait.NewAsync(this))
            using (ThreadSafeForm<SelectVehicle> frmPickVehicle = await ThreadSafeForm<SelectVehicle>.GetAsync(() => new SelectVehicle(CharacterObject)))
            {
                // Make sure the dialogue window was not canceled.
                if (await frmPickVehicle.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return false;

                // Open the Vehicles XML file and locate the selected piece.
                XmlNode objXmlVehicle = (await CharacterObject.LoadDataAsync("vehicles.xml")).SelectSingleNode(
                    "/chummer/vehicles/vehicle[id = " + frmPickVehicle.MyForm.SelectedVehicle.CleanXPath() + ']');
                if (objXmlVehicle == null)
                    return frmPickVehicle.MyForm.AddAgain;
                Vehicle objVehicle = new Vehicle(CharacterObject);
                objVehicle.Create(objXmlVehicle);
                // Update the Used Vehicle information if applicable.
                if (frmPickVehicle.MyForm.UsedVehicle)
                {
                    objVehicle.Avail = frmPickVehicle.MyForm.UsedAvail;
                    objVehicle.Cost = frmPickVehicle.MyForm.UsedCost.ToString(GlobalSettings.InvariantCultureInfo);
                }

                objVehicle.DiscountCost = frmPickVehicle.MyForm.BlackMarketDiscount;
                if (frmPickVehicle.MyForm.FreeCost)
                {
                    objVehicle.Cost = "0";
                }

                //objVehicle.Location = objLocation;
                if (objLocation != null)
                    await objLocation.Children.AddAsync(objVehicle);

                await CharacterObject.Vehicles.AddAsync(objVehicle);

                return frmPickVehicle.MyForm.AddAgain;
            }
        }

        private async void cmdAddVehicle_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await AddVehicle(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) as Location);
            }
            while (blnAddAgain);
        }

        private async void cmdDeleteVehicle_Click(object sender, EventArgs e)
        {
            try
            {
                await DeleteVehicle(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async ValueTask DeleteVehicle(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!await cmdDeleteVehicle.DoThreadSafeFuncAsync(x => x.Enabled, token))
                return;
            // Delete the selected Vehicle.
            object objSelectedNodeTag = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token);
            switch (objSelectedNodeTag)
            {
                // Delete the selected Vehicle.
                case null:
                    return;

                case VehicleMod objMod:
                    {
                        // If this is the Obsolete Mod, the user must select a percentage. This will create an Expense that costs X% of the Vehicle's base cost to remove the special Obsolete Mod.
                        if (objMod.Name == "Obsolete" ||
                            objMod.Name == "Obsolescent" && CharacterObjectSettings.AllowObsolescentUpgrade)
                        {
                            decimal decPercentage;
                            string strRetrofit = await LanguageManager.GetStringAsync("String_Retrofit");
                            using (ThreadSafeForm<SelectNumber> frmModPercent = await ThreadSafeForm<SelectNumber>.GetAsync(() => new SelectNumber
                                   {
                                       Minimum = 0,
                                       Maximum = 1000000,
                                       Description = strRetrofit
                                   }, token))
                            {
                                if (await frmModPercent.ShowDialogSafeAsync(this, token) == DialogResult.Cancel)
                                    return;

                                decPercentage = frmModPercent.MyForm.SelectedValue;
                            }

                            decimal decVehicleCost = objMod.Parent.OwnCost;

                            // Make sure the character has enough Nuyen for the expense.
                            decimal decCost = decVehicleCost * decPercentage / 100;

                            // Create a Vehicle Mod for the Retrofit.
                            VehicleMod objRetrofit = new VehicleMod(CharacterObject);

                            XmlDocument objVehiclesDoc = await CharacterObject.LoadDataAsync("vehicles.xml", token: token);
                            XmlNode objXmlNode = objVehiclesDoc.SelectSingleNode("/chummer/mods/mod[name = \"Retrofit\"]");
                            objRetrofit.Create(objXmlNode, 0, objMod.Parent);
                            objRetrofit.Cost = decCost.ToString(GlobalSettings.InvariantCultureInfo);
                            objRetrofit.IncludedInVehicle = true;
                            await objMod.Parent.Mods.AddAsync(objRetrofit);
                        }

                        objMod.DeleteVehicleMod();
                        break;
                    }
                case ICanRemove selectedObject:
                    {
                        selectedObject.Remove();
                        break;
                    }
            }
        }

        private void cmdAddMartialArt_Click(object sender, EventArgs e)
        {
            MartialArt.Purchase(CharacterObject);
        }

        private void cmdDeleteMartialArt_Click(object sender, EventArgs e)
        {
            if (!(treMartialArts.SelectedNode?.Tag is ICanRemove objSelectedNode))
                return;
            objSelectedNode.Remove();
        }

        private async void cmdAddMugshot_Click(object sender, EventArgs e)
        {
            try
            {
                if (!await AddMugshot(GenericToken))
                    return;
                string strText = await LanguageManager.GetStringAsync("String_Of")
                                 + CharacterObject.Mugshots.Count.ToString(GlobalSettings.CultureInfo);
                await lblNumMugshots.DoThreadSafeAsync(x => x.Text = strText, GenericToken);
                await nudMugshotIndex.DoThreadSafeAsync(x =>
                {
                    ++x.Maximum;
                    x.Value = CharacterObject.Mugshots.Count;
                }, GenericToken);
                await SetDirty(true);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteMugshot_Click(object sender, EventArgs e)
        {
            if (CharacterObject.Mugshots.Count == 0)
                return;
            try
            {
                RemoveMugshot(await nudMugshotIndex.DoThreadSafeFuncAsync(x => x.ValueAsInt) - 1);
                string strText = await LanguageManager.GetStringAsync("String_Of")
                                 + CharacterObject.Mugshots.Count.ToString(GlobalSettings.CultureInfo);
                await lblNumMugshots.DoThreadSafeAsync(x => x.Text = strText, GenericToken);
                await nudMugshotIndex.DoThreadSafeAsync(x =>
                {
                    --x.Maximum;
                    if (x.Value > x.Maximum)
                        x.Value = x.Maximum;
                    else
                    {
                        chkIsMainMugshot.DoThreadSafe(y =>
                        {
                            if (x.ValueAsInt - 1 == CharacterObject.MainMugshotIndex)
                                y.Checked = true;
                            else if (y.Checked)
                                y.Checked = false;
                        });

                        UpdateMugshot(picMugshot, x.ValueAsInt - 1);
                    }
                }, GenericToken);
                await SetDirty(true);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void nudMugshotIndex_ValueChanged(object sender, EventArgs e)
        {
            if (CharacterObject.Mugshots.Count == 0)
            {
                nudMugshotIndex.Minimum = 0;
                nudMugshotIndex.Maximum = 0;
                nudMugshotIndex.Value = 0;
            }
            else
            {
                nudMugshotIndex.Minimum = 1;
                if (nudMugshotIndex.Value < nudMugshotIndex.Minimum)
                    nudMugshotIndex.Value = nudMugshotIndex.Maximum;
                else if (nudMugshotIndex.Value > nudMugshotIndex.Maximum)
                    nudMugshotIndex.Value = nudMugshotIndex.Minimum;
            }

            if (nudMugshotIndex.ValueAsInt - 1 == CharacterObject.MainMugshotIndex)
                chkIsMainMugshot.Checked = true;
            else if (chkIsMainMugshot.Checked)
                chkIsMainMugshot.Checked = false;

            UpdateMugshot(picMugshot, nudMugshotIndex.ValueAsInt - 1);
        }

        private async void chkIsMainMugshot_CheckedChanged(object sender, EventArgs e)
        {
            bool blnStatusChanged = false;
            int intSelectedIndex = await nudMugshotIndex.DoThreadSafeFuncAsync(x => x.ValueAsInt);
            switch (await chkIsMainMugshot.DoThreadSafeFuncAsync(x => x.Checked))
            {
                case true when CharacterObject.MainMugshotIndex != intSelectedIndex - 1:
                    CharacterObject.MainMugshotIndex = intSelectedIndex - 1;
                    blnStatusChanged = true;
                    break;

                case false when intSelectedIndex - 1 == CharacterObject.MainMugshotIndex:
                    CharacterObject.MainMugshotIndex = -1;
                    blnStatusChanged = true;
                    break;
            }

            if (blnStatusChanged)
            {
                await SetDirty(true);
            }
        }

        private async void cmdAddMetamagic_Click(object sender, EventArgs e)
        {
            using (await CursorWait.NewAsync(this))
            {
                if (CharacterObject.MAGEnabled)
                {
                    // Make sure that the Initiate Grade is not attempting to go above the character's MAG CharacterAttribute.
                    if (CharacterObject.InitiateGrade + 1 > CharacterObject.MAG.TotalValue ||
                        CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept
                                                                           && CharacterObject.InitiateGrade + 1
                                                                           > CharacterObject.MAGAdept.TotalValue)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotIncreaseInitiateGrade"),
                                               await LanguageManager.GetStringAsync("MessageTitle_CannotIncreaseInitiateGrade"),
                                               MessageBoxButtons.OK,
                                               MessageBoxIcon.Information);
                        return;
                    }

                    // Create the Initiate Grade object.
                    InitiationGrade objGrade = new InitiationGrade(CharacterObject);
                    objGrade.Create(CharacterObject.InitiateGrade + 1, false, chkInitiationGroup.Checked,
                                    chkInitiationOrdeal.Checked, chkInitiationSchooling.Checked);
                    CharacterObject.InitiationGrades.AddWithSort(objGrade);
                }
                else if (CharacterObject.RESEnabled)
                {
                    string strText = await LanguageManager.GetStringAsync("Button_AddEcho");
                    await cmsMetamagic.DoThreadSafeAsync(() =>
                    {
                        tsMetamagicAddArt.Visible = false;
                        tsMetamagicAddEnchantment.Visible = false;
                        tsMetamagicAddEnhancement.Visible = false;
                        tsMetamagicAddRitual.Visible = false;
                        tsMetamagicAddMetamagic.Text = strText;
                    });

                    // Make sure that the Initiate Grade is not attempting to go above the character's RES CharacterAttribute.
                    if (CharacterObject.SubmersionGrade + 1 > CharacterObject.RES.TotalValue)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotIncreaseSubmersionGrade"),
                                               await LanguageManager.GetStringAsync("MessageTitle_CannotIncreaseSubmersionGrade"),
                                               MessageBoxButtons.OK,
                                               MessageBoxIcon.Information);
                        return;
                    }

                    // Create the Initiate Grade object.
                    InitiationGrade objGrade = new InitiationGrade(CharacterObject);
                    objGrade.Create(CharacterObject.SubmersionGrade + 1, true, chkInitiationGroup.Checked,
                                    chkInitiationOrdeal.Checked, chkInitiationSchooling.Checked);
                    CharacterObject.InitiationGrades.AddWithSort(objGrade);
                }
            }
        }

        private void cmdDeleteMetamagic_Click(object sender, EventArgs e)
        {
            if (!(treMetamagic.SelectedNode?.Tag is ICanRemove selectedObject))
                return;
            selectedObject.Remove();
        }

        private async void cmdAddCritterPower_Click(object sender, EventArgs e)
        {
            // Make sure the Critter is allowed to have Optional Powers.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("critterpowers.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectCritterPower> frmPickCritterPower = await ThreadSafeForm<SelectCritterPower>.GetAsync(() => new SelectCritterPower(CharacterObject)))
                    {
                        if (await frmPickCritterPower.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;

                        blnAddAgain = frmPickCritterPower.MyForm.AddAgain;

                        XmlNode objXmlPower = objXmlDocument.SelectSingleNode(
                            "/chummer/powers/power[id = " + frmPickCritterPower.MyForm.SelectedPower.CleanXPath() + ']');
                        CritterPower objPower = new CritterPower(CharacterObject);
                        objPower.Create(objXmlPower, frmPickCritterPower.MyForm.SelectedRating);
                        objPower.PowerPoints = frmPickCritterPower.MyForm.PowerPoints;
                        if (objPower.InternalId.IsEmptyGuid())
                            continue;

                        await CharacterObject.CritterPowers.AddAsync(objPower);
                    }
                } while (blnAddAgain);
            }
        }

        private void cmdDeleteCritterPower_Click(object sender, EventArgs e)
        {
            // If the selected object is not a critter or it comes from an initiate grade, we don't want to remove it.
            if (!(treCritterPowers.SelectedNode?.Tag is CritterPower objCritterPower) || objCritterPower.Grade != 0)
                return;
            objCritterPower.Remove();
        }

        private void cmdDeleteComplexForm_Click(object sender, EventArgs e)
        {
            if (!(treComplexForms.SelectedNode?.Tag is ICanRemove objSelectedObject))
                return;
            objSelectedObject.Remove();
        }

        private void cmdDeleteAIProgram_Click(object sender, EventArgs e)
        {
            // Delete the selected AI Program.
            if (!(treAIPrograms.SelectedNode?.Tag is ICanRemove objSelectedObject))
                return;
            objSelectedObject.Remove();
        }

        private async void cmdLifeModule_Click(object sender, EventArgs e)
        {
            XmlNode xmlStagesParentNode = (await CharacterObject.LoadDataAsync("lifemodules.xml")).SelectSingleNode("chummer/stages");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    //from 1 to second highest life module order possible (ye hardcoding is bad, but extra stage is a niche case)
                    int intStage;
                    for (intStage = 1; intStage < 5; ++intStage)
                    {
                        XmlNode xmlStageNode = xmlStagesParentNode?.SelectSingleNode(
                            "stage[@order = " + intStage.ToString(GlobalSettings.InvariantCultureInfo).CleanXPath()
                                              + ']');
                        if (xmlStageNode == null)
                        {
                            --intStage;
                            break;
                        }

                        if (!CharacterObject.Qualities.Any(x => x.Type == QualityType.LifeModule
                                                                && x.Stage == xmlStageNode.InnerText))
                        {
                            break;
                        }
                    }

                    //i--; //Counter last increment
                    XmlNode objXmlLifeModule;
                    using (ThreadSafeForm<SelectLifeModule> frmSelectLifeModule = await ThreadSafeForm<SelectLifeModule>.GetAsync(() => new SelectLifeModule(CharacterObject, intStage)))
                    {
                        if (await frmSelectLifeModule.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;

                        blnAddAgain = frmSelectLifeModule.MyForm.AddAgain;
                        objXmlLifeModule = frmSelectLifeModule.MyForm.SelectedNode;
                    }

                    List<Weapon> lstWeapons = new List<Weapon>(1);
                    Quality objLifeModule = new Quality(CharacterObject);

                    objLifeModule.Create(objXmlLifeModule, QualitySource.LifeModule, lstWeapons);
                    if (objLifeModule.InternalId.IsEmptyGuid())
                        continue;

                    //Is there any reason not to add it?
                    if (true)
                    {
                        await CharacterObject.Qualities.AddAsync(objLifeModule);

                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }
                    }

                    //Stupid hardcoding but no sane way
                    //To do group skills (not that anything else is sane)
                } while (blnAddAgain);
            }
        }

        private async void cmdAddQuality_Click(object sender, EventArgs e)
        {
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("qualities.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectQuality> frmPickQuality = await ThreadSafeForm<SelectQuality>.GetAsync(() => new SelectQuality(CharacterObject)))
                    {
                        // Don't do anything else if the form was canceled.
                        if (await frmPickQuality.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;

                        blnAddAgain = frmPickQuality.MyForm.AddAgain;
                        int intRatingToAdd = frmPickQuality.MyForm.SelectedRating;

                        XmlNode objXmlQuality = objXmlDocument.SelectSingleNode(
                            "/chummer/qualities/quality[id = " + frmPickQuality.MyForm.SelectedQuality.CleanXPath() + ']');
                        int intDummy = 0;
                        if (objXmlQuality != null && objXmlQuality["nolevels"] == null
                                                  && objXmlQuality.TryGetInt32FieldQuickly("limit", ref intDummy))
                        {
                            intRatingToAdd -= CharacterObject.Qualities.Count(x =>
                                                                                  x.SourceIDString.Equals(
                                                                                      frmPickQuality.MyForm.SelectedQuality,
                                                                                      StringComparison
                                                                                          .InvariantCultureIgnoreCase)
                                                                                  && string.IsNullOrEmpty(
                                                                                      x.SourceName));
                        }

                        for (int i = 1; i <= intRatingToAdd; ++i)
                        {
                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            Quality objQuality = new Quality(CharacterObject);

                            objQuality.Create(objXmlQuality, QualitySource.Selected, lstWeapons);
                            if (objQuality.InternalId.IsEmptyGuid())
                            {
                                // If the Quality could not be added, remove the Improvements that were added during the Quality Creation process.
                                await ImprovementManager.RemoveImprovementsAsync(CharacterObject,
                                    Improvement.ImprovementSource.Quality,
                                    objQuality.InternalId);
                                break;
                            }

                            if (frmPickQuality.MyForm.FreeCost)
                                objQuality.BP = 0;

                            // Make sure that adding the Quality would not cause the character to exceed their BP limits.
                            bool blnAddItem = true;
                            if (objQuality.ContributeToLimit && !CharacterObject.IgnoreRules)
                            {
                                // If the item being checked would cause the limit of 25 BP spent on Positive Qualities to be exceed, do not let it be checked and display a message.
                                int intMaxQualityAmount = CharacterObjectSettings.QualityKarmaLimit;
                                string strAmount =
                                    CharacterObjectSettings.QualityKarmaLimit.ToString(GlobalSettings.CultureInfo) +
                                    await LanguageManager.GetStringAsync("String_Space") +
                                    await LanguageManager.GetStringAsync("String_Karma");

                                // Add the cost of the Quality that is being added.
                                int intBP = objQuality.BP;

                                if (objQuality.Type == QualityType.Negative)
                                {
                                    // Check if adding this Quality would put the character over their limit.
                                    if (!CharacterObjectSettings.ExceedNegativeQualities)
                                    {
                                        intBP += CharacterObject.NegativeQualityLimitKarma;
                                        if (intBP < intMaxQualityAmount * -1)
                                        {
                                            Program.ShowMessageBox(this,
                                                                   string.Format(GlobalSettings.CultureInfo,
                                                                       await LanguageManager.GetStringAsync(
                                                                           "Message_NegativeQualityLimit"),
                                                                       strAmount),
                                                                   await LanguageManager.GetStringAsync(
                                                                       "MessageTitle_NegativeQualityLimit"),
                                                                   MessageBoxButtons.OK, MessageBoxIcon.Information);
                                            blnAddItem = false;
                                        }
                                        else if (CharacterObject.MetatypeBP < 0
                                                 && intBP + CharacterObject.MetatypeBP < intMaxQualityAmount * -1)
                                        {
                                            Program.ShowMessageBox(this,
                                                                   string.Format(GlobalSettings.CultureInfo,
                                                                       await LanguageManager.GetStringAsync(
                                                                           "Message_NegativeQualityAndMetatypeLimit"),
                                                                       strAmount),
                                                                   await LanguageManager.GetStringAsync(
                                                                       "MessageTitle_NegativeQualityLimit"),
                                                                   MessageBoxButtons.OK, MessageBoxIcon.Information);
                                            blnAddItem = false;
                                        }
                                    }
                                }
                                // Check if adding this Quality would put the character over their limit.
                                else if (!CharacterObjectSettings.ExceedPositiveQualities)
                                {
                                    intBP += CharacterObject.PositiveQualityKarma;
                                    if (intBP > intMaxQualityAmount)
                                    {
                                        Program.ShowMessageBox(this,
                                                               string.Format(GlobalSettings.CultureInfo,
                                                                             await LanguageManager.GetStringAsync(
                                                                                 "Message_PositiveQualityLimit"),
                                                                             strAmount),
                                                               await LanguageManager.GetStringAsync(
                                                                   "MessageTitle_PositiveQualityLimit"),
                                                               MessageBoxButtons.OK, MessageBoxIcon.Information);
                                        blnAddItem = false;
                                    }
                                }
                            }

                            if (blnAddItem)
                            {
                                await CharacterObject.Qualities.AddAsync(objQuality);

                                // Add any created Weapons to the character.
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon);
                                }
                            }
                            else
                            {
                                // If the Quality could not be added, remove the Improvements that were added during the Quality Creation process.
                                await ImprovementManager.RemoveImprovementsAsync(CharacterObject,
                                    Improvement.ImprovementSource.Quality,
                                    objQuality.InternalId);
                                break;
                            }
                        }
                    }
                } while (blnAddAgain);
            }
        }

        /*
        private Quality AddQuality(XmlNode objXmlAddQuality, XmlNode objXmlSelectedQuality)
        {
            string strForceValue = string.Empty;
            if (objXmlAddQuality.Attributes["select"] != null)
                strForceValue = objXmlAddQuality.Attributes["select"].InnerText;
            bool blnAddQuality = true;

            // Make sure the character does not yet have this Quality.
            foreach (Quality objCharacterQuality in _objCharacter.Qualities)
            {
                if (objCharacterQuality.Name == objXmlAddQuality.InnerText && objCharacterQuality.Extra == strForceValue)
                {
                    blnAddQuality = false;
                    break;
                }
            }

            if (blnAddQuality)
            {
                List<Weapon> objAddWeapons = new List<Weapon>(1);
                Quality objAddQuality = new Quality(_objCharacter);
                objAddQuality.Create(objXmlSelectedQuality, _objCharacter, QualitySource.Selected, lstWeapons, strForceValue);

                // Add any created Weapons to the character.
                foreach (Weapon objWeapon in objAddWeapons)
                {
                    _objCharacter.Weapons.Add(objWeapon);
                }

                return objAddQuality;
            }

            return null;
        }
        */

        private async ValueTask<bool> RemoveQuality(Quality objSelectedQuality, bool blnConfirmDelete = true, bool blnCompleteDelete = true)
        {
            XmlNode objXmlDeleteQuality = await objSelectedQuality.GetNodeAsync();
            switch (objSelectedQuality.OriginSource)
            {
                // Qualities that come from a Metatype cannot be removed.
                case QualitySource.Metatype:
                case QualitySource.Heritage:
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_MetavariantQuality"), await LanguageManager.GetStringAsync("MessageTitle_MetavariantQuality"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return false;

                case QualitySource.Improvement:
                    Program.ShowMessageBox(this, string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ImprovementQuality"), await objSelectedQuality.GetSourceNameAsync(GlobalSettings.Language)),
                        await LanguageManager.GetStringAsync("MessageTitle_MetavariantQuality"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return false;
            }

            using (await CursorWait.NewAsync(this))
            {
                if (objSelectedQuality.OriginSource == QualitySource.MetatypeRemovable)
                {
                    int intBP = 0;
                    if (objSelectedQuality.Type == QualityType.Negative
                        && objXmlDeleteQuality.TryGetInt32FieldQuickly("karma", ref intBP))
                    {
                        intBP = -intBP;
                    }

                    intBP *= CharacterObjectSettings.KarmaQuality;
                    int intShowBP = intBP;
                    if (blnCompleteDelete)
                        intShowBP *= objSelectedQuality.Levels;
                    string strBP = intShowBP.ToString(GlobalSettings.CultureInfo)
                                   + await LanguageManager.GetStringAsync("String_Space")
                                   + await LanguageManager.GetStringAsync("String_Karma");

                    if (blnConfirmDelete &&
                        !CommonFunctions.ConfirmDelete(string.Format(GlobalSettings.CultureInfo,
                                                                     await LanguageManager.GetStringAsync(
                                                                         blnCompleteDelete
                                                                             ? "Message_DeleteMetatypeQuality"
                                                                             : "Message_LowerMetatypeQualityLevel"),
                                                                     strBP)))
                        return false;

                    // Remove any Improvements that the Quality might have.
                    XmlNode xmlDeleteQualityNoBonus = objXmlDeleteQuality.Clone();
                    if (xmlDeleteQualityNoBonus["bonus"] != null)
                        xmlDeleteQualityNoBonus["bonus"].InnerText = string.Empty;
                    if (xmlDeleteQualityNoBonus["firstlevelbonus"] != null)
                        xmlDeleteQualityNoBonus["firstlevelbonus"].InnerText = string.Empty;

                    List<Weapon> lstWeapons = new List<Weapon>(1);
                    Quality objReplaceQuality = new Quality(CharacterObject);

                    objReplaceQuality.Create(xmlDeleteQualityNoBonus, QualitySource.MetatypeRemovedAtChargen,
                                             lstWeapons);
                    objReplaceQuality.BP *= -1;
                    // If a Negative Quality is being bought off, the replacement one is Positive.
                    if (objSelectedQuality.Type == QualityType.Positive)
                    {
                        objReplaceQuality.Type = QualityType.Negative;
                        if (!string.IsNullOrEmpty(objReplaceQuality.Extra))
                            objReplaceQuality.Extra += ',' + await LanguageManager.GetStringAsync("String_Space");
                        objReplaceQuality.Extra += await LanguageManager.GetStringAsync("String_ExpenseRemovePositiveQuality");
                    }
                    else
                    {
                        objReplaceQuality.Type = QualityType.Positive;
                        if (!string.IsNullOrEmpty(objReplaceQuality.Extra))
                            objReplaceQuality.Extra += ',' + await LanguageManager.GetStringAsync("String_Space");
                        objReplaceQuality.Extra += await LanguageManager.GetStringAsync("String_ExpenseRemoveNegativeQuality");
                    }

                    // The replacement Quality does not count towards the BP limit of the new type, nor should it be printed.
                    objReplaceQuality.AllowPrint = false;
                    objReplaceQuality.ContributeToLimit = false;
                    await CharacterObject.Qualities.AddAsync(objReplaceQuality);
                    // The replacement Quality no longer adds its weapons to the character
                }
                else
                {
                    if (blnConfirmDelete && !CommonFunctions.ConfirmDelete(
                            blnCompleteDelete
                                ? await LanguageManager.GetStringAsync("Message_DeleteQuality")
                                : await LanguageManager.GetStringAsync("Message_LowerQualityLevel")))
                        return false;

                    if (objSelectedQuality.OriginSource == QualitySource.MetatypeRemovedAtChargen)
                    {
                        XPathNavigator xmlCharacterNode = await CharacterObject.GetNodeXPathAsync();
                        if (xmlCharacterNode != null)
                        {
                            XmlDocument xmlQualitiesDoc = await CharacterObject.LoadDataAsync("qualities.xml");
                            // Create the Qualities that come with the Metatype.
                            foreach (XPathNavigator objXmlQualityItem in xmlCharacterNode.Select(
                                         "qualities/*/quality[. = " + objSelectedQuality.Name.CleanXPath() + ']'))
                            {
                                XmlNode objXmlQuality = xmlQualitiesDoc.SelectSingleNode(
                                    "/chummer/qualities/quality[name = " + objXmlQualityItem.Value.CleanXPath() + ']');
                                Quality objQuality = new Quality(CharacterObject);
                                string strForceValue = objXmlQualityItem.GetAttribute("select", string.Empty);
                                QualitySource objSource = objXmlQualityItem.GetAttribute("removable", string.Empty)
                                                          == bool.TrueString
                                    ? QualitySource.MetatypeRemovable
                                    : QualitySource.Metatype;
                                objQuality.Create(objXmlQuality, objSource, CharacterObject.Weapons, strForceValue);
                                await CharacterObject.Qualities.AddAsync(objQuality);
                            }
                        }
                    }
                }

                if (objSelectedQuality.Type == QualityType.LifeModule)
                {
                    objXmlDeleteQuality
                        = Quality.GetNodeOverrideable(objSelectedQuality.SourceIDString,
                                                      await CharacterObject.LoadDataAsync("lifemodules.xml"));
                }

                // Fix for legacy characters with old addqualities improvements.
                await RemoveAddedQualities(objXmlDeleteQuality?.CreateNavigator().Select("addqualities/addquality"));

                // Perform removal
                objSelectedQuality.DeleteQuality(blnCompleteDelete);
            }

            return true;
        }

        private async void cmdDeleteQuality_Click(object sender, EventArgs e)
        {
            try
            {
                await DeleteQuality(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async ValueTask DeleteQuality(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            // Locate the selected Quality.
            if (!(await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is Quality objSelectedQuality))
                return;
            string strInternalIDToRemove = objSelectedQuality.InternalId;
            // Can't do a foreach because we're removing items, this is the next best thing
            bool blnFirstRemoval = true;
            for (int i = CharacterObject.Qualities.Count - 1; i >= 0; --i)
            {
                Quality objLoopQuality = CharacterObject.Qualities[i];
                if (objLoopQuality.InternalId != strInternalIDToRemove)
                    continue;
                if (!await RemoveQuality(objLoopQuality, blnFirstRemoval))
                    break;
                blnFirstRemoval = false;
                if (i > CharacterObject.Qualities.Count)
                {
                    i = CharacterObject.Qualities.Count;
                }
            }
        }

        private async void cmdAddLocation_Click(object sender, EventArgs e)
        {
            // Add a new location to the Armor Tree.
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                    return;
                Location objLocation = new Location(CharacterObject, CharacterObject.GearLocations, frmPickText.MyForm.SelectedValue);
                await CharacterObject.GearLocations.AddAsync(objLocation);
            }
        }

        private async void cmdAddWeaponLocation_Click(object sender, EventArgs e)
        {
            // Add a new location to the Armor Tree.
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                    return;
                Location objLocation = new Location(CharacterObject, CharacterObject.WeaponLocations, frmPickText.MyForm.SelectedValue);
                await CharacterObject.WeaponLocations.AddAsync(objLocation);
            }
        }

        private async void cmdCreateStackedFocus_Click(object sender, EventArgs e)
        {
            int intFree = 0;
            List<Gear> lstGear = new List<Gear>(2);
            List<Gear> lstStack = new List<Gear>(2);

            // Run through all of the Foci the character has and count the un-Bonded ones.
            foreach (Gear objGear in CharacterObject.Gear)
            {
                if ((objGear.Category == "Foci" || objGear.Category == "Metamagic Foci") && !objGear.Bonded)
                {
                    intFree++;
                    lstGear.Add(objGear);
                }
            }

            // If the character does not have at least 2 un-Bonded Foci, display an error and leave.
            if (intFree < 2)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotStackFoci"), await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_SelectItemFocus");
            DialogResult eResult;
            // Let the character select the Foci they'd like to stack, stopping when they either click Cancel or there are no more items left in the list.
            do
            {
                using (ThreadSafeForm<SelectItem> frmPickItem = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem
                       {
                           Description = strDescription,
                           AllowAutoSelect = false
                       }))
                {
                    frmPickItem.MyForm.SetGearMode(lstGear);
                    eResult = await frmPickItem.ShowDialogSafeAsync(this);
                    if (eResult != DialogResult.OK)
                        continue;
                    // Move the item from the Gear list to the Stack list.
                    foreach (Gear objGear in lstGear)
                    {
                        if (objGear.InternalId == frmPickItem.MyForm.SelectedItem)
                        {
                            objGear.Bonded = true;
                            lstStack.Add(objGear);
                            lstGear.Remove(objGear);
                            break;
                        }
                    }
                }
            } while (lstGear.Count > 0 && eResult != DialogResult.Cancel);

                    // Make sure at least 2 Foci were selected.
            if (lstStack.Count < 2)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_StackedFocusMinimum"), await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Make sure the combined Force of the Foci do not exceed 6.
            if (!CharacterObjectSettings.AllowHigherStackedFoci)
            {
                int intCombined = lstStack.Sum(objGear => objGear.Rating);
                if (intCombined > 6)
                {
                    foreach (Gear objGear in lstStack)
                        objGear.Bonded = false;
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_StackedFocusForce"), await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }
            }

            // Create the Stacked Focus.
            StackedFocus objStack = new StackedFocus(CharacterObject);
            foreach (Gear objGear in lstStack)
                await objStack.Gear.AddAsync(objGear);
            await CharacterObject.StackedFoci.AddAsync(objStack);

            // Remove the Gear from the character and replace it with a Stacked Focus item.
            decimal decCost = 0;
            foreach (Gear objGear in lstStack)
            {
                decCost += objGear.TotalCost;
                await CharacterObject.Gear.RemoveAsync(objGear);
            }

            Gear objStackItem = new Gear(CharacterObject)
            {
                Category = "Stacked Focus",
                Name = "Stacked Focus: " + objStack.CurrentDisplayName,
                MinRating = string.Empty,
                MaxRating = string.Empty,
                Source = "SR5",
                Page = "1",
                Cost = decCost.ToString(GlobalSettings.CultureInfo),
                Avail = "0"
            };

            await CharacterObject.Gear.AddAsync(objStackItem);

            objStack.GearId = objStackItem.InternalId;
        }

        private async void cmdAddArmor_Click(object sender, EventArgs e)
        {
            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddArmor(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) as Location);
                } while (blnAddAgain);
            }
        }

        private async ValueTask<bool> AddArmor(Location objLocation = null)
        {
            using (ThreadSafeForm<SelectArmor> frmPickArmor = await ThreadSafeForm<SelectArmor>.GetAsync(() => new SelectArmor(CharacterObject)))
            {
                // Make sure the dialogue window was not canceled.
                if (await frmPickArmor.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return false;

                // Open the Armor XML file and locate the selected piece.
                XmlNode objXmlArmor
                    = (await CharacterObject.LoadDataAsync("armor.xml")).SelectSingleNode(
                        "/chummer/armors/armor[id = " + frmPickArmor.MyForm.SelectedArmor.CleanXPath() + ']');

                List<Weapon> lstWeapons = new List<Weapon>(1);
                Armor objArmor = new Armor(CharacterObject);

                objArmor.Create(objXmlArmor, frmPickArmor.MyForm.Rating, lstWeapons);
                objArmor.DiscountCost = frmPickArmor.MyForm.BlackMarketDiscount;
                if (objArmor.InternalId.IsEmptyGuid())
                    return frmPickArmor.MyForm.AddAgain;
                if (frmPickArmor.MyForm.FreeCost)
                {
                    objArmor.Cost = "0";
                }

                //objArmor.Location = objLocation;
                if (objLocation != null)
                    await objLocation.Children.AddAsync(objArmor);
                await CharacterObject.Armor.AddAsync(objArmor);

                foreach (Weapon objWeapon in lstWeapons)
                {
                    await CharacterObject.Weapons.AddAsync(objWeapon);
                }

                return frmPickArmor.MyForm.AddAgain;
            }
        }

        private async void cmdAddArmorBundle_Click(object sender, EventArgs e)
        {
            // Add a new location to the Armor Tree.
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                    return;
                Location objLocation = new Location(CharacterObject, CharacterObject.ArmorLocations, frmPickText.MyForm.SelectedValue);
                await CharacterObject.ArmorLocations.AddAsync(objLocation);
            }
        }

        private async void cmdArmorEquipAll_Click(object sender, EventArgs e)
        {
            object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag);
            if (objSelected is Location selectedLocation)
            {
                // Equip all of the Armor in the Armor Bundle.
                foreach (Armor objArmor in selectedLocation.Children.OfType<Armor>())
                {
                    if (objArmor.Location == selectedLocation)
                    {
                        objArmor.Equipped = true;
                    }
                }
            }
            else if (objSelected?.ToString() == "Node_SelectedArmor")
            {
                foreach (Armor objArmor in CharacterObject.Armor.Where(objArmor => !objArmor.Equipped && objArmor.Location == null))
                {
                    objArmor.Equipped = true;
                }
            }
            else
            {
                return;
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdArmorUnEquipAll_Click(object sender, EventArgs e)
        {
            object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag);
            if (objSelected is Location selectedLocation)
            {
                // Equip all of the Armor in the Armor Bundle.
                foreach (Armor objArmor in selectedLocation.Children.OfType<Armor>())
                {
                    if (objArmor.Location == selectedLocation)
                    {
                        objArmor.Equipped = false;
                    }
                }
            }
            else if (objSelected?.ToString() == "Node_SelectedArmor")
            {
                foreach (Armor objArmor in CharacterObject.Armor.Where(objArmor =>
                                                                           objArmor.Equipped && objArmor.Location == null))
                {
                    objArmor.Equipped = false;
                }
            }
            else
            {
                return;
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cmdAddVehicleLocation_Click(object sender, EventArgs e)
        {
            ICollection<Location> destCollection;
            // Make sure a Vehicle is selected.
            object objSelected = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag);
            if (objSelected is Vehicle objVehicle)
            {
                destCollection = objVehicle.Locations;
            }
            else if (objSelected == null || objSelected.ToString() == "Node_SelectedVehicles")
            {
                destCollection = CharacterObject.VehicleLocations;
            }
            else
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectVehicleLocation"), await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                    return;
                Location objLocation = new Location(CharacterObject, destCollection, frmPickText.MyForm.SelectedValue);
                destCollection.Add(objLocation);
            }
        }

        #endregion Button Events

        #region ContextMenu Events

        private async void tsCyberwareAddAsPlugin_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Cyberware window.
            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objCyberware && !string.IsNullOrWhiteSpace(objCyberware.AllowedSubsystems)))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectCyberware"), await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickCyberware(objCyberware, objCyberware.SourceType);
            }
            while (blnAddAgain);
        }

        private async void tsVehicleCyberwareAddAsPlugin_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Cyberware window.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objCyberware && !string.IsNullOrWhiteSpace(objCyberware.AllowedSubsystems)))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectCyberware"), await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickCyberware(objCyberware, objCyberware.SourceType);
            }
            while (blnAddAgain);
        }

        private async void tsWeaponAddAccessory_Click(object sender, EventArgs e)
        {
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectWeaponAccessory"),
                    await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon"),
                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }
            // Accessories cannot be added to Cyberweapons.
            if (objWeapon.Cyberware)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CyberweaponNoAccessory"), await LanguageManager.GetStringAsync("MessageTitle_CyberweaponNoAccessory"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Weapons XML file and locate the selected Weapon.
            XmlNode objXmlWeapon = await objWeapon.GetNodeAsync();
            if (objXmlWeapon == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotFindWeapon"), await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            XmlDocument xmlDocument = await CharacterObject.LoadDataAsync("weapons.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    // Make sure the Weapon allows Accessories to be added to it.
                    if (!objWeapon.AllowAccessory)
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotModifyWeapon"),
                                               await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon"),
                                               MessageBoxButtons.OK, MessageBoxIcon.Information);
                        break;
                    }

                    using (ThreadSafeForm<SelectWeaponAccessory> frmPickWeaponAccessory
                           = await ThreadSafeForm<SelectWeaponAccessory>.GetAsync(() => new SelectWeaponAccessory(CharacterObject)
                           {
                               ParentWeapon = objWeapon
                           }))
                    {
                        if (await frmPickWeaponAccessory.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickWeaponAccessory.MyForm.AddAgain;

                        // Locate the selected piece.
                        objXmlWeapon = xmlDocument.SelectSingleNode(
                            "/chummer/accessories/accessory[id = "
                            + frmPickWeaponAccessory.MyForm.SelectedAccessory.CleanXPath()
                            + ']');

                        WeaponAccessory objAccessory = new WeaponAccessory(CharacterObject);
                        objAccessory.Create(objXmlWeapon, frmPickWeaponAccessory.MyForm.SelectedMount,
                                            frmPickWeaponAccessory.MyForm.SelectedRating);
                        objAccessory.Parent = objWeapon;
                        objAccessory.DiscountCost = frmPickWeaponAccessory.MyForm.BlackMarketDiscount;

                        if (frmPickWeaponAccessory.MyForm.FreeCost)
                        {
                            objAccessory.Cost = "0";
                        }

                        await objWeapon.WeaponAccessories.AddAsync(objAccessory);
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsAddArmorMod_Click(object sender, EventArgs e)
        {
            // Make sure a parent item is selected, then open the Select Accessory window.
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Armor objArmor))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectArmor"), await LanguageManager.GetStringAsync("MessageTitle_SelectArmor"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Armor XML file and locate the selected Armor.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("armor.xml");

            XmlNode objXmlArmor = await objArmor.GetNodeAsync();

            string strAllowedCategories = objArmor.Category + ',' + objArmor.Name;
            bool blnExcludeGeneralCategory = false;
            XmlNode xmlAddModCategory = objXmlArmor["forcemodcategory"];
            if (xmlAddModCategory != null)
            {
                strAllowedCategories = xmlAddModCategory.InnerText;
                blnExcludeGeneralCategory = true;
            }
            else
            {
                xmlAddModCategory = objXmlArmor["addmodcategory"];
                if (xmlAddModCategory != null)
                {
                    strAllowedCategories += ',' + xmlAddModCategory.InnerText;
                }
            }

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectArmorMod> frmPickArmorMod = await ThreadSafeForm<SelectArmorMod>.GetAsync(
                               () => new SelectArmorMod(CharacterObject, objArmor)
                               {
                                   ArmorCost = objArmor.OwnCost,
                                   ArmorCapacity
                                       = Convert.ToDecimal(
                                           objArmor.CalculatedCapacity(GlobalSettings.InvariantCultureInfo),
                                           GlobalSettings.InvariantCultureInfo),
                                   AllowedCategories = strAllowedCategories,
                                   ExcludeGeneralCategory = blnExcludeGeneralCategory,
                                   CapacityDisplayStyle = objArmor.CapacityDisplayStyle
                               }))
                    {
                        if (await frmPickArmorMod.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickArmorMod.MyForm.AddAgain;

                        // Locate the selected piece.
                        objXmlArmor = objXmlDocument.SelectSingleNode(
                            "/chummer/mods/mod[id = " + frmPickArmorMod.MyForm.SelectedArmorMod.CleanXPath() + ']');

                        ArmorMod objMod = new ArmorMod(CharacterObject);
                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        int intRating
                            = Convert.ToInt32(objXmlArmor?["maxrating"]?.InnerText, GlobalSettings.InvariantCultureInfo)
                              > 1
                                ? frmPickArmorMod.MyForm.SelectedRating
                                : 0;

                        objMod.Create(objXmlArmor, intRating, lstWeapons);
                        if (objMod.InternalId.IsEmptyGuid())
                            continue;

                        if (frmPickArmorMod.MyForm.FreeCost)
                        {
                            objMod.Cost = "0";
                        }

                        await objArmor.ArmorMods.AddAsync(objMod);

                        // Add any Weapons created by the Mod.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsGearAddAsPlugin_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Cyberware window.
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objGear))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickGear(objGear.InternalId);
            }
            while (blnAddAgain);
        }

        private async void tsVehicleAddWeaponMount_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Vehicle objVehicle))
                return;
            using (await CursorWait.NewAsync(this))
            using (ThreadSafeForm<CreateWeaponMount> frmPickVehicleMod
                   = await ThreadSafeForm<CreateWeaponMount>.GetAsync(() => new CreateWeaponMount(objVehicle, CharacterObject)))
            {
                if (await frmPickVehicleMod.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;
                await objVehicle.WeaponMounts.AddAsync(frmPickVehicleMod.MyForm.WeaponMount);
            }
        }

        private async void tsVehicleAddMod_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x =>
            {
                TreeNode objTemp = x.SelectedNode;
                while (objTemp?.Level > 1)
                    objTemp = objTemp.Parent;
                return objTemp;
            });

            // Make sure a parent items is selected, then open the Select Vehicle Mod window.
            if (!(objSelectedNode?.Tag is Vehicle objVehicle))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectVehicle"), await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Vehicles XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("vehicles.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectVehicleMod> frmPickVehicleMod
                           = await ThreadSafeForm<SelectVehicleMod>.GetAsync(
                               () => new SelectVehicleMod(CharacterObject, objVehicle, objVehicle.Mods)))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickVehicleMod.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickVehicleMod.MyForm.AddAgain;

                        XmlNode objXmlMod
                            = objXmlDocument.SelectSingleNode("/chummer/mods/mod[id = "
                                                              + frmPickVehicleMod.MyForm.SelectedMod.CleanXPath() + ']');

                        VehicleMod objMod = new VehicleMod(CharacterObject)
                        {
                            DiscountCost = frmPickVehicleMod.MyForm.BlackMarketDiscount
                        };
                        objMod.Create(objXmlMod, frmPickVehicleMod.MyForm.SelectedRating, objVehicle,
                                      frmPickVehicleMod.MyForm.Markup);

                        // Make sure that the Armor Rating does not exceed the maximum allowed by the Vehicle.
                        if (objMod.Name.StartsWith("Armor", StringComparison.Ordinal))
                        {
                            if (objMod.Rating > objVehicle.MaxArmor)
                            {
                                objMod.Rating = objVehicle.MaxArmor;
                            }
                        }
                        else
                        {
                            switch (objMod.Category)
                            {
                                case "Handling":
                                    {
                                        if (objMod.Rating > objVehicle.MaxHandling)
                                        {
                                            objMod.Rating = objVehicle.MaxHandling;
                                        }

                                        break;
                                    }
                                case "Speed":
                                    {
                                        if (objMod.Rating > objVehicle.MaxSpeed)
                                        {
                                            objMod.Rating = objVehicle.MaxSpeed;
                                        }

                                        break;
                                    }
                                case "Acceleration":
                                    {
                                        if (objMod.Rating > objVehicle.MaxAcceleration)
                                        {
                                            objMod.Rating = objVehicle.MaxAcceleration;
                                        }

                                        break;
                                    }
                                case "Sensor":
                                    {
                                        if (objMod.Rating > objVehicle.MaxSensor)
                                        {
                                            objMod.Rating = objVehicle.MaxSensor;
                                        }

                                        break;
                                    }
                                default:
                                    {
                                        if (objMod.Name.StartsWith("Pilot Program", StringComparison.Ordinal)
                                            && objMod.Rating > objVehicle.MaxPilot)
                                        {
                                            objMod.Rating = objVehicle.MaxPilot;
                                        }

                                        break;
                                    }
                            }
                        }

                        // Check the item's Cost and make sure the character can afford it.
                        if (frmPickVehicleMod.MyForm.FreeCost)
                            objMod.Cost = "0";
                        else
                        {
                            // Multiply the cost if applicable.
                            decimal decOldCost = objMod.TotalCost;
                            decimal decCost = decOldCost;
                            char chrAvail = objMod.TotalAvailTuple().Suffix;
                            switch (chrAvail)
                            {
                                case 'R' when CharacterObjectSettings.MultiplyRestrictedCost:
                                    decCost *= CharacterObjectSettings.RestrictedCostMultiplier;
                                    break;

                                case 'F' when CharacterObjectSettings.MultiplyForbiddenCost:
                                    decCost *= CharacterObjectSettings.ForbiddenCostMultiplier;
                                    break;
                            }

                            decCost -= decOldCost;
                            objMod.Markup = decCost;
                        }

                        await objVehicle.Mods.AddAsync(objMod);
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleAddWeaponWeapon_Click(object sender, EventArgs e)
        {
            // Make sure that a Weapon Mount has been selected.
            // Attempt to locate the selected VehicleMod.
            WeaponMount objWeaponMount = null;
            VehicleMod objMod = null;
            Vehicle objVehicle = null;
            switch (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag))
            {
                case WeaponMount selectedMount:
                    objWeaponMount = selectedMount;
                    objVehicle = selectedMount.Parent;
                    break;

                case VehicleMod selectedMod when (selectedMod.Name.StartsWith("Mechanical Arm", StringComparison.Ordinal) || selectedMod.Name.Contains("Drone Arm")):
                    objMod = selectedMod;
                    objVehicle = selectedMod.Parent;
                    break;
            }

            if (objWeaponMount == null && objMod == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotAddWeapon"),
                    await LanguageManager.GetStringAsync("MessageTitle_CannotAddWeapon"), MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
                return;
            }

            if (objWeaponMount?.IsWeaponsFull == true)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_WeaponMountFull"),
                    await LanguageManager.GetStringAsync("MessageTitle_CannotAddWeapon"), MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
                return;
            }

            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("weapons.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(
                               () => new SelectWeapon(CharacterObject)
                               {
                                   LimitToCategories = objMod != null
                                       ? objMod.WeaponMountCategories
                                       : objWeaponMount?.AllowedWeaponCategories ?? string.Empty
                               }))
                    {
                        if (await frmPickWeapon.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            return;

                        // Open the Weapons XML file and locate the selected piece.
                        XmlNode objXmlWeapon = objXmlDocument.SelectSingleNode(
                            "/chummer/weapons/weapon[id = " + frmPickWeapon.MyForm.SelectedWeapon.CleanXPath() + ']');

                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        Weapon objWeapon = new Weapon(CharacterObject)
                        {
                            ParentVehicle = objVehicle,
                            ParentVehicleMod = objMod,
                            ParentMount = objMod == null ? objWeaponMount : null
                        };
                        objWeapon.Create(objXmlWeapon, lstWeapons);
                        objWeapon.DiscountCost = frmPickWeapon.MyForm.BlackMarketDiscount;

                        if (frmPickWeapon.MyForm.FreeCost)
                        {
                            objWeapon.Cost = "0";
                        }

                        if (objMod != null)
                            await objMod.Weapons.AddAsync(objWeapon);
                        else
                            await objWeaponMount.Weapons.AddAsync(objWeapon);

                        foreach (Weapon objLoopWeapon in lstWeapons)
                        {
                            if (objMod == null)
                                await objWeaponMount.Weapons.AddAsync(objLoopWeapon);
                            else
                                await objMod.Weapons.AddAsync(objLoopWeapon);
                        }

                        blnAddAgain = frmPickWeapon.MyForm.AddAgain && (objMod != null || !objWeaponMount.IsWeaponsFull);
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleAddWeaponAccessory_Click(object sender, EventArgs e)
        {
            // Attempt to locate the selected VehicleWeapon.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
            {
                Program.ShowMessageBox(
                    this, await LanguageManager.GetStringAsync("Message_VehicleWeaponAccessories"),
                    await LanguageManager.GetStringAsync("MessageTitle_VehicleWeaponAccessories"), MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
                return;
            }

            // Open the Weapons XML file and locate the selected Weapon.
            XmlNode objXmlWeapon = await objWeapon.GetNodeAsync();
            if (objXmlWeapon == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CannotFindWeapon"),
                                                await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon"),
                                                MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("weapons.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    // Make sure the Weapon allows Accessories to be added to it.
                    if (!objWeapon.AllowAccessory)
                    {
                        Program.ShowMessageBox(
                            this, await LanguageManager.GetStringAsync("Message_CannotModifyWeapon"),
                            await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon"),
                            MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return;
                    }

                    using (ThreadSafeForm<SelectWeaponAccessory> frmPickWeaponAccessory
                           = await ThreadSafeForm<SelectWeaponAccessory>.GetAsync(() => new SelectWeaponAccessory(CharacterObject)
                           {
                               ParentWeapon = objWeapon
                           }))
                    {
                        if (await frmPickWeaponAccessory.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickWeaponAccessory.MyForm.AddAgain;

                        // Locate the selected piece.
                        objXmlWeapon = objXmlDocument.SelectSingleNode(
                            "/chummer/accessories/accessory[id = "
                            + frmPickWeaponAccessory.MyForm.SelectedAccessory.CleanXPath()
                            + ']');

                        WeaponAccessory objAccessory = new WeaponAccessory(CharacterObject);
                        objAccessory.Create(objXmlWeapon, frmPickWeaponAccessory.MyForm.SelectedMount,
                                            frmPickWeaponAccessory.MyForm.SelectedRating);
                        objAccessory.Parent = objWeapon;
                        objAccessory.DiscountCost = frmPickWeaponAccessory.MyForm.BlackMarketDiscount;

                        if (frmPickWeaponAccessory.MyForm.FreeCost)
                        {
                            objAccessory.Cost = "0";
                        }

                        await objWeapon.WeaponAccessories.AddAsync(objAccessory);
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleAddUnderbarrelWeapon_Click(object sender, EventArgs e)
        {
            // Attempt to locate the selected VehicleWeapon.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objSelectedWeapon))
            {
                Program.ShowMessageBox(
                    this, await LanguageManager.GetStringAsync("Message_VehicleWeaponUnderbarrel"),
                    await LanguageManager.GetStringAsync("MessageTitle_VehicleWeaponUnderbarrel"), MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
                return;
            }

            using (await CursorWait.NewAsync(this))
            using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(
                       () => new SelectWeapon(CharacterObject)
                       {
                           LimitToCategories = "Underbarrel Weapons",
                           ParentWeapon = objSelectedWeapon
                       }))
            {
                frmPickWeapon.MyForm.Mounts.UnionWith(
                    objSelectedWeapon.AccessoryMounts.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries));

                // Make sure the dialogue window was not canceled.
                if (await frmPickWeapon.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // Open the Weapons XML file and locate the selected piece.
                XmlNode objXmlWeapon
                    = (await CharacterObject.LoadDataAsync("weapons.xml")).SelectSingleNode(
                        "/chummer/weapons/weapon[id = " + frmPickWeapon.MyForm.SelectedWeapon.CleanXPath() + ']');

                List<Weapon> lstWeapons = new List<Weapon>(1);
                Weapon objWeapon = new Weapon(CharacterObject)
                {
                    ParentVehicle = objSelectedWeapon.ParentVehicle
                };
                objWeapon.Create(objXmlWeapon, lstWeapons);
                objWeapon.DiscountCost = frmPickWeapon.MyForm.BlackMarketDiscount;

                if (frmPickWeapon.MyForm.FreeCost)
                {
                    objWeapon.Cost = "0";
                }

                objWeapon.Parent = objSelectedWeapon;
                await objSelectedWeapon.UnderbarrelWeapons.AddAsync(objWeapon);
                if (!objSelectedWeapon.AllowAccessory)
                    objWeapon.AllowAccessory = false;

                foreach (Weapon objLoopWeapon in lstWeapons)
                {
                    await objSelectedWeapon.UnderbarrelWeapons.AddAsync(objLoopWeapon);
                    if (!objSelectedWeapon.AllowAccessory)
                        objLoopWeapon.AllowAccessory = false;
                }
            }
        }

        private async void tsMartialArtsAddTechnique_Click(object sender, EventArgs e)
        {
            // Select the Martial Arts node if we're currently on a child.
            await treMartialArts.DoThreadSafeAsync(x =>
            {
                while (x.SelectedNode?.Level > 1)
                    x.SelectedNode = x.SelectedNode.Parent;
            });

            if (await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode == null || x.SelectedNode.Level <= 0))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectMartialArtTechnique"), await LanguageManager.GetStringAsync("MessageTitle_SelectMartialArtTechnique"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            if (!(await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is MartialArt objMartialArt))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectMartialArtTechnique"), await LanguageManager.GetStringAsync("MessageTitle_SelectMartialArtTechnique"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            XmlDocument xmlDocument = await CharacterObject.LoadDataAsync("martialarts.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    XmlNode xmlTechnique;
                    using (ThreadSafeForm<SelectMartialArtTechnique> frmPickMartialArtTechnique
                           = await ThreadSafeForm<SelectMartialArtTechnique>.GetAsync(
                               () => new SelectMartialArtTechnique(CharacterObject, objMartialArt)))
                    {
                        if (await frmPickMartialArtTechnique.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            return;

                        blnAddAgain = frmPickMartialArtTechnique.MyForm.AddAgain;

                        // Open the Martial Arts XML file and locate the selected piece.
                        xmlTechnique = xmlDocument.SelectSingleNode(
                            "/chummer/techniques/technique[id = "
                            + frmPickMartialArtTechnique.MyForm.SelectedTechnique.CleanXPath() + ']');
                    }

                    // Create the Improvements for the Technique if there are any.
                    MartialArtTechnique objTechnique = new MartialArtTechnique(CharacterObject);
                    objTechnique.Create(xmlTechnique);
                    if (objTechnique.InternalId.IsEmptyGuid())
                        return;

                    await objMartialArt.Techniques.AddAsync(objTechnique);
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleAddGear_Click(object sender, EventArgs e)
        {
            Vehicle objSelectedVehicle;
            Location objLocation = null;
            switch (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag))
            {
                case Vehicle vehicle:
                    objSelectedVehicle = vehicle;
                    break;

                case Location location:
                    objLocation = location;
                    objSelectedVehicle = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode.Parent.Tag) as Vehicle;
                    break;

                default:
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectGearVehicle"), await LanguageManager.GetStringAsync("MessageTitle_SelectGearVehicle"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
            }
            try
            {
                await PurchaseVehicleGear(objSelectedVehicle, objLocation, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleSensorAddAsPlugin_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode);
            // Make sure a parent items is selected, then open the Select Gear window.
            if (objSelectedNode == null || objSelectedNode.Level < 2)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_ModifyVehicleGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Make sure the Gear was found.
            if (!(objSelectedNode.Tag is Gear objSensor))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_ModifyVehicleGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
            string strCategories = string.Empty;
            XPathNodeIterator xmlAddonCategoryList = (await objSensor.GetNodeXPathAsync())?.Select("addoncategory");
            if (xmlAddonCategoryList?.Count > 0)
            {
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                        sbdCategories.Append(objXmlCategory.Value).Append(',');
                    // Remove the trailing comma.
                    --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }
            }

            List<Weapon> lstWeapons = new List<Weapon>(1);
            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    Gear objGear;
                    lstWeapons.Clear();
                    using (ThreadSafeForm<SelectGear> frmPickGear
                           = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject, 0, 1, objSensor, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                 && (!objSensor.Capacity.Contains('[')
                                                                     || objSensor.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        // Open the Gear XML file and locate the selected piece.
                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty, false);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;
                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";
                        // If the item was marked as free, change its cost.
                        if (frmPickGear.MyForm.FreeCost)
                        {
                            objGear.Cost = "0";
                        }
                    }

                    IsRefreshing = true;
                    try
                    {
                        nudVehicleGearQty.Increment = objGear.CostFor;
                        //nudVehicleGearQty.Minimum = objGear.CostFor;
                    }
                    finally
                    {
                        IsRefreshing = false;
                    }

                    await objSensor.Children.AddAsync(objGear);

                    if (lstWeapons.Count > 0)
                    {
                        CharacterObject.Vehicles.FindVehicleGear(objSensor.InternalId, out Vehicle objVehicle,
                                                                 out WeaponAccessory _, out Cyberware _);
                        if (objVehicle != null)
                        {
                            foreach (Weapon objWeapon in lstWeapons)
                            {
                                await objVehicle.Weapons.AddAsync(objWeapon);
                            }
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleGearNotes_Click(object sender, EventArgs e)
        {
            switch (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag))
            {
                case Gear objGear:
                    {
                        using (ThreadSafeForm<EditNotes> frmItemNotes = await ThreadSafeForm<EditNotes>.GetAsync(() => new EditNotes(objGear.Notes, objGear.NotesColor)))
                        {
                            if (await frmItemNotes.ShowDialogSafeAsync(this) != DialogResult.OK)
                                return;
                            objGear.Notes = frmItemNotes.MyForm.Notes;
                            objGear.NotesColor = frmItemNotes.MyForm.NotesColor;
                            await SetDirty(true);

                            await treVehicles.DoThreadSafeAsync(x =>
                            {
                                x.SelectedNode.ForeColor = objGear.PreferredColor;
                                x.SelectedNode.ToolTipText = objGear.Notes.WordWrap();
                            });
                        }

                        break;
                    }
            }
        }

        private async void tsAdvancedLifestyle_Click(object sender, EventArgs e)
        {
            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    Lifestyle objLifestyle = new Lifestyle(CharacterObject);
                    using (ThreadSafeForm<SelectLifestyleAdvanced> frmPickLifestyle
                           = await ThreadSafeForm<SelectLifestyleAdvanced>.GetAsync(() => new SelectLifestyleAdvanced(CharacterObject, objLifestyle)))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickLifestyle.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        {
                            if (!ReferenceEquals(objLifestyle, frmPickLifestyle.MyForm.SelectedLifestyle)
                                && frmPickLifestyle.MyForm.SelectedLifestyle != null)
                                frmPickLifestyle.MyForm.SelectedLifestyle.Dispose();
                            return;
                        }

                        blnAddAgain = frmPickLifestyle.MyForm.AddAgain;

                        objLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;
                    }

                    objLifestyle.StyleType = LifestyleType.Advanced;

                    await CharacterObject.Lifestyles.AddAsync(objLifestyle);
                } while (blnAddAgain);
            }
        }

        private async void tsWeaponName_Click(object sender, EventArgs e)
        {
            await treWeapons.DoThreadSafeAsync(x =>
            {
                while (x.SelectedNode?.Level > 1)
                    x.SelectedNode = x.SelectedNode.Parent;
            });

            // Make sure a parent item is selected, then open the Select Accessory window.
            if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode == null || x.SelectedNode.Level <= 0))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectWeaponName"), await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Get the information for the currently selected Weapon.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectWeaponName"), await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_WeaponName");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objWeapon.CustomName,
                       AllowEmptyString = true
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objWeapon.CustomName = frmPickText.MyForm.SelectedValue;
            }

            await treWeapons.DoThreadSafeAsync(x => x.SelectedNode.Text = objWeapon.CurrentDisplayName);

            await SetDirty(true);
        }

        private async void tsGearName_Click(object sender, EventArgs e)
        {
            if (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode == null || x.SelectedNode.Level <= 0))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectGearName"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Get the information for the currently selected Gear.
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objGear))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectGearName"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_GearName");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objGear.GearName,
                       AllowEmptyString = true
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objGear.GearName = frmPickText.MyForm.SelectedValue;
            }

            await treGear.DoThreadSafeAsync(x => x.SelectedNode.Text = objGear.CurrentDisplayName);

            await SetDirty(true);
        }

        private async void tsWeaponAddUnderbarrel_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode);
            // Locate the Weapon that is selected in the tree.
            if (!(objSelectedNode?.Tag is Weapon objSelectedWeapon))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectWeaponUnderbarrel"), await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            if (objSelectedWeapon.Cyberware)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CyberwareUnderbarrel"), await LanguageManager.GetStringAsync("MessageTitle_WeaponUnderbarrel"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            using (await CursorWait.NewAsync(this))
            using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(
                       () => new SelectWeapon(CharacterObject)
                       {
                           LimitToCategories = "Underbarrel Weapons",
                           ParentWeapon = objSelectedWeapon
                       }))
            {
                frmPickWeapon.MyForm.Mounts.UnionWith(
                    objSelectedWeapon.AccessoryMounts.SplitNoAlloc('/', StringSplitOptions.RemoveEmptyEntries));

                // Make sure the dialogue window was not canceled.
                if (await frmPickWeapon.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                // Open the Weapons XML file and locate the selected piece.
                XmlNode objXmlWeapon
                    = (await CharacterObject.LoadDataAsync("weapons.xml")).SelectSingleNode(
                        "/chummer/weapons/weapon[id = " + frmPickWeapon.MyForm.SelectedWeapon.CleanXPath() + ']');

                List<Weapon> lstWeapons = new List<Weapon>(1);
                Weapon objWeapon = new Weapon(CharacterObject);
                objWeapon.Create(objXmlWeapon, lstWeapons);
                objWeapon.DiscountCost = frmPickWeapon.MyForm.BlackMarketDiscount;
                objWeapon.Parent = objSelectedWeapon;
                objWeapon.AllowAccessory = objSelectedWeapon.AllowAccessory;
                if (!objSelectedWeapon.AllowAccessory)
                    objWeapon.AllowAccessory = false;

                if (frmPickWeapon.MyForm.FreeCost)
                {
                    objWeapon.Cost = "0";
                }

                await objSelectedWeapon.UnderbarrelWeapons.AddAsync(objWeapon);
            }
        }

        private async void tsGearRename_Click(object sender, EventArgs e)
        {
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objGear))
                return;
            using (ThreadSafeForm<SelectText> frmPickText
                   = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText()))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;
                objGear.Extra = frmPickText.MyForm.SelectedValue;
                await treGear.DoThreadSafeAsync(x => x.SelectedNode.Text = objGear.CurrentDisplayName);
                await SetDirty(true);
            }
        }

        private async void tsArmorLocationAddArmor_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await AddArmor(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) as Location);
            }
            while (blnAddAgain);
        }

        private async void tsAddArmorGear_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Gear window.
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Armor objArmor))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectArmor"), await LanguageManager.GetStringAsync("MessageTitle_SelectArmor"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            bool blnAddAgain;
            do
            {
                // Select the root Gear node then open the Select Gear window.
                blnAddAgain = await PickArmorGear(objArmor.InternalId, true);
            }
            while (blnAddAgain);
        }

        private async void tsArmorGearAddAsPlugin_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode);
            // Make sure a parent items is selected, then open the Select Gear window.
            if (objSelectedNode == null || objSelectedNode.Level <= 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectArmor"), await LanguageManager.GetStringAsync("MessageTitle_SelectArmor"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string selectedGuid = string.Empty;
            switch (objSelectedNode.Tag)
            {
                // Make sure the selected item is another piece of Gear.
                case ArmorMod objMod when string.IsNullOrEmpty(objMod.GearCapacity):
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectArmor"), await LanguageManager.GetStringAsync("MessageTitle_SelectArmor"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;

                case ArmorMod objMod:
                    selectedGuid = objMod.InternalId;
                    break;

                case Gear objGear:
                    selectedGuid = objGear.InternalId;
                    break;
            }
            bool blnAddAgain;
            do
            {
                blnAddAgain = await PickArmorGear(selectedGuid);
            }
            while (blnAddAgain);
        }

        private async void tsArmorNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsQualityNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMartialArtsNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsSpellNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsComplexFormNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAIProgramNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCritterPowersNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsLifestyleNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponMountLocation_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is WeaponMount objWeaponMount))
                return;
            string strDescription = await LanguageManager.GetStringAsync("String_VehicleName");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objWeaponMount.Location
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objWeaponMount.Location = frmPickText.MyForm.SelectedValue;
            }

            treVehicles.SelectedNode.Text = objWeaponMount.CurrentDisplayName;
        }

        private async void tsVehicleName_Click(object sender, EventArgs e)
        {
            await treVehicles.DoThreadSafeAsync(x =>
            {
                while (x.SelectedNode?.Level > 1)
                {
                    x.SelectedNode = x.SelectedNode.Parent;
                }
            });

            // Make sure a parent item is selected.
            if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode == null || x.SelectedNode.Level <= 0))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectVehicleName"), await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Get the information for the currently selected Vehicle.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Vehicle objVehicle))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectVehicleName"), await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_VehicleName");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objVehicle.CustomName,
                       AllowEmptyString = true
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objVehicle.CustomName = frmPickText.MyForm.SelectedValue;
            }

            await treVehicles.DoThreadSafeAsync(x => x.SelectedNode.Text = objVehicle.CurrentDisplayName);
        }

        private async void tsVehicleAddCyberware_Click(object sender, EventArgs e)
        {
            if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is string)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_VehicleCyberwarePlugin"), await LanguageManager.GetStringAsync("MessageTitle_NoCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            Cyberware objCyberwareParent = null;
            string strNeedleId = (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) as IHasInternalId)?.InternalId;
            VehicleMod objMod = CharacterObject.Vehicles.FindVehicleMod(x => x.InternalId == strNeedleId, out Vehicle objVehicle, out WeaponMount _);
            if (objMod == null)
                objCyberwareParent = CharacterObject.Vehicles.FindVehicleCyberware(x => x.InternalId == strNeedleId, out objMod);

            if (objCyberwareParent == null && objMod?.AllowCyberware != true)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_VehicleCyberwarePlugin"), await LanguageManager.GetStringAsync("MessageTitle_NoCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Cyberware XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("cyberware.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectCyberware> frmPickCyberware
                           = await ThreadSafeForm<SelectCyberware>.GetAsync(() => new SelectCyberware(
                                                                                CharacterObject,
                                                                                Improvement.ImprovementSource.Cyberware,
                                                                                objCyberwareParent ?? (object) objMod)))
                    {
                        if (objCyberwareParent == null)
                        {
                            //frmPickCyberware.SetGrade = "Standard";
                            frmPickCyberware.MyForm.MaximumCapacity = objMod.CapacityRemaining;
                            frmPickCyberware.MyForm.Subsystems = objMod.Subsystems;
                            using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                            out HashSet<string> setDisallowedMounts))
                            using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                            out HashSet<string> setHasMounts))
                            {
                                foreach (Cyberware objLoopCyberware in objMod.Cyberware.DeepWhere(
                                             x => x.Children, x => string.IsNullOrEmpty(x.PlugsIntoModularMount)))
                                {
                                    foreach (string strLoop in objLoopCyberware.BlocksMounts.SplitNoAlloc(
                                                 ',', StringSplitOptions.RemoveEmptyEntries))
                                    {
                                        if (!setDisallowedMounts.Contains(strLoop + objLoopCyberware.Location))
                                            setDisallowedMounts.Add(strLoop + objLoopCyberware.Location);
                                    }

                                    string strLoopHasModularMount = objLoopCyberware.HasModularMount;
                                    if (!string.IsNullOrEmpty(strLoopHasModularMount)
                                        && !setHasMounts.Contains(strLoopHasModularMount))
                                        setHasMounts.Add(strLoopHasModularMount);
                                }

                                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdDisallowedMounts))
                                {
                                    foreach (string strLoop in setDisallowedMounts)
                                    {
                                        if (!strLoop.EndsWith("Right", StringComparison.Ordinal)
                                            && (!strLoop.EndsWith("Left", StringComparison.Ordinal)
                                                || setDisallowedMounts.Contains(
                                                    strLoop.Substring(0, strLoop.Length - 4) + "Right")))
                                            sbdDisallowedMounts.Append(strLoop.TrimEndOnce("Left")).Append(',');
                                    }

                                    // Remove trailing ","
                                    if (sbdDisallowedMounts.Length > 0)
                                        --sbdDisallowedMounts.Length;
                                    frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                                }

                                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdHasMounts))
                                {
                                    foreach (string strLoop in setHasMounts)
                                        sbdHasMounts.Append(strLoop).Append(',');
                                    // Remove trailing ","
                                    if (sbdHasMounts.Length > 0)
                                        --sbdHasMounts.Length;
                                    frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                                }
                            }
                        }
                        else
                        {
                            frmPickCyberware.MyForm.ForcedGrade = objCyberwareParent.Grade;
                            // If the Cyberware has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that conume Capacity).
                            if (!objCyberwareParent.Capacity.Contains('[')
                                || objCyberwareParent.Capacity.Contains("/["))
                            {
                                frmPickCyberware.MyForm.Subsystems = objCyberwareParent.AllowedSubsystems;
                                frmPickCyberware.MyForm.MaximumCapacity = objCyberwareParent.CapacityRemaining;

                                // Do not allow the user to add a new piece of Cyberware if its Capacity has been reached.
                                if (CharacterObjectSettings.EnforceCapacity && objCyberwareParent.CapacityRemaining < 0)
                                {
                                    Program.ShowMessageBox(
                                        this, await LanguageManager.GetStringAsync("Message_CapacityReached"),
                                        await LanguageManager.GetStringAsync("MessageTitle_CapacityReached"),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                                    break;
                                }
                            }

                            frmPickCyberware.MyForm.CyberwareParent = objCyberwareParent;
                            frmPickCyberware.MyForm.Subsystems = objCyberwareParent.AllowedSubsystems;
                            using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                            out HashSet<string> setDisallowedMounts))
                            using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                            out HashSet<string> setHasMounts))
                            {
                                foreach (string strLoop in objCyberwareParent.BlocksMounts.SplitNoAlloc(
                                             ',', StringSplitOptions.RemoveEmptyEntries))
                                    setDisallowedMounts.Add(strLoop + objCyberwareParent.Location);
                                string strLoopHasModularMount = objCyberwareParent.HasModularMount;
                                if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                    setHasMounts.Add(strLoopHasModularMount);
                                foreach (Cyberware objLoopCyberware in objCyberwareParent.Children.DeepWhere(
                                             x => x.Children, x => string.IsNullOrEmpty(x.PlugsIntoModularMount)))
                                {
                                    foreach (string strLoop in objLoopCyberware.BlocksMounts.SplitNoAlloc(
                                                 ',', StringSplitOptions.RemoveEmptyEntries))
                                    {
                                        if (!setDisallowedMounts.Contains(strLoop + objLoopCyberware.Location))
                                            setDisallowedMounts.Add(strLoop + objLoopCyberware.Location);
                                    }

                                    strLoopHasModularMount = objLoopCyberware.HasModularMount;
                                    if (!string.IsNullOrEmpty(strLoopHasModularMount)
                                        && !setHasMounts.Contains(strLoopHasModularMount))
                                        setHasMounts.Add(strLoopHasModularMount);
                                }

                                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdDisallowedMounts))
                                {
                                    foreach (string strLoop in setDisallowedMounts)
                                    {
                                        if (!strLoop.EndsWith("Right", StringComparison.Ordinal)
                                            && (!strLoop.EndsWith("Left", StringComparison.Ordinal)
                                                || setDisallowedMounts.Contains(
                                                    strLoop.Substring(0, strLoop.Length - 4) + "Right")))
                                            sbdDisallowedMounts.Append(strLoop.TrimEndOnce("Left")).Append(',');
                                    }

                                    // Remove trailing ","
                                    if (sbdDisallowedMounts.Length > 0)
                                        --sbdDisallowedMounts.Length;
                                    frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                                }

                                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdHasMounts))
                                {
                                    foreach (string strLoop in setHasMounts)
                                        sbdHasMounts.Append(strLoop).Append(',');
                                    // Remove trailing ","
                                    if (sbdHasMounts.Length > 0)
                                        --sbdHasMounts.Length;
                                    frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                                }
                            }
                        }

                        frmPickCyberware.MyForm.LockGrade();
                        frmPickCyberware.MyForm.ParentVehicle = objVehicle ?? objMod.Parent;
                        
                        if (await frmPickCyberware.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickCyberware.MyForm.AddAgain;

                        XmlNode objXmlCyberware = objXmlDocument.SelectSingleNode(
                            "/chummer/cyberwares/cyberware[id = " + frmPickCyberware.MyForm.SelectedCyberware.CleanXPath()
                                                                  + ']');
                        Cyberware objCyberware = new Cyberware(CharacterObject);
                        if (!objCyberware.Purchase(objXmlCyberware, Improvement.ImprovementSource.Cyberware,
                                                   frmPickCyberware.MyForm.SelectedGrade, frmPickCyberware.MyForm.SelectedRating,
                                                   objVehicle, objMod.Cyberware, CharacterObject.Vehicles,
                                                   objMod.Weapons,
                                                   frmPickCyberware.MyForm.Markup, frmPickCyberware.MyForm.FreeCost,
                                                   frmPickCyberware.MyForm.BlackMarketDiscount, true,
                                                   "String_ExpensePurchaseVehicleCyberware", objCyberwareParent))
                            objCyberware.DeleteCyberware();
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsArmorName_Click(object sender, EventArgs e)
        {
            await treArmor.DoThreadSafeAsync(x =>
            {
                while (x.SelectedNode?.Level > 1)
                    x.SelectedNode = x.SelectedNode.Parent;
            });

            // Make sure a parent item is selected, then open the Select Accessory window.
            if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode == null || x.SelectedNode.Level <= 0))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectArmorName"), await LanguageManager.GetStringAsync("MessageTitle_SelectArmor"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Get the information for the currently selected Armor.
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Armor objArmor))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectArmorName"), await LanguageManager.GetStringAsync("MessageTitle_SelectArmor"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_ArmorName");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objArmor.CustomName,
                       AllowEmptyString = true
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objArmor.CustomName = frmPickText.MyForm.SelectedValue;
            }

            await treArmor.DoThreadSafeAsync(x => x.SelectedNode.Text = objArmor.CurrentDisplayName);

            await SetDirty(true);
        }

        private async void tsLifestyleName_Click(object sender, EventArgs e)
        {
            // Get the information for the currently selected Lifestyle.
            if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasCustomName objCustomName))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectLifestyleName"), await LanguageManager.GetStringAsync("MessageTitle_SelectLifestyle"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string strDescription = await LanguageManager.GetStringAsync("String_LifestyleName");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                   {
                       Description = strDescription,
                       DefaultString = objCustomName.CustomName,
                       AllowEmptyString = true
                   }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                if (objCustomName.CustomName == frmPickText.MyForm.SelectedValue)
                    return;
                objCustomName.CustomName = frmPickText.MyForm.SelectedValue;

                await treLifestyles.DoThreadSafeAsync(x => x.SelectedNode.Text = objCustomName.CurrentDisplayName);

                await SetDirty(true);
            }
        }

        private async void tsGearRenameLocation_Click(object sender, EventArgs e)
        {
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objLocation))
                return;
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                       () => new SelectText
                       {
                           Description = strDescription,
                           DefaultString = objLocation.Name
                       }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objLocation.Name = frmPickText.MyForm.SelectedValue;
            }

            await treGear.DoThreadSafeAsync(x => x.SelectedNode.Text = objLocation.DisplayName());

            await SetDirty(true);
        }

        private async void tsWeaponRenameLocation_Click(object sender, EventArgs e)
        {
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objLocation))
                return;
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                       () => new SelectText
                       {
                           Description = strDescription,
                           DefaultString = objLocation.Name
                       }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objLocation.Name = frmPickText.MyForm.SelectedValue;
            }

            await treWeapons.DoThreadSafeAsync(x => x.SelectedNode.Text = objLocation.DisplayName());

            await SetDirty(true);
        }

        private async void tsCreateSpell_Click(object sender, EventArgs e)
        {
            // Run through the list of Active Skills and pick out the two applicable ones.
            int intSkillValue = Math.Max((await CharacterObject.SkillsSection.GetActiveSkillAsync("Spellcasting"))?.Rating ?? 0, (await CharacterObject.SkillsSection.GetActiveSkillAsync("Ritual Spellcasting"))?.Rating ?? 0);

            // The maximum number of Spells a character can start with is 2 x (highest of Spellcasting or Ritual Spellcasting Skill).
            if (CharacterObject.Spells.Count >= 2 * intSkillValue + await ImprovementManager.ValueOfAsync(CharacterObject, Improvement.ImprovementType.SpellLimit) && !CharacterObject.IgnoreRules)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SpellLimit"), await LanguageManager.GetStringAsync("MessageTitle_SpellLimit"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // The character is still allowed to add Spells, so show the Create Spell window.
            using (ThreadSafeForm<CreateSpell> frmSpell = await ThreadSafeForm<CreateSpell>.GetAsync(() => new CreateSpell(CharacterObject)))
            {
                if (await frmSpell.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                Spell objSpell = frmSpell.MyForm.SelectedSpell;
                await CharacterObject.Spells.AddAsync(objSpell);
            }
        }

        private async void tsArmorRenameLocation_Click(object sender, EventArgs e)
        {
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objLocation))
                return;
            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                       () => new SelectText
                       {
                           Description = strDescription,
                           DefaultString = objLocation.Name
                       }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objLocation.Name = frmPickText.MyForm.SelectedValue;
            }

            await treArmor.DoThreadSafeAsync(x => x.SelectedNode.Text = objLocation.DisplayName());

            await SetDirty(true);
        }

        private async void tsCyberwareAddGear_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode);
            // Make sure a parent items is selected, then open the Select Gear window.
            if (objSelectedNode == null || objSelectedNode.Level <= 0)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectCyberware"), await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Make sure the Cyberware is allowed to accept Gear.
            if (!(objSelectedNode.Tag is Cyberware objCyberware) || objCyberware.AllowGear == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CyberwareGear"), await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Gear XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    string strCategories = string.Empty;
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        using (XmlNodeList xmlGearCategoryList = objCyberware.AllowGear?.SelectNodes("gearcategory"))
                        {
                            if (xmlGearCategoryList != null)
                            {
                                foreach (XmlNode objXmlCategory in xmlGearCategoryList)
                                    sbdCategories.Append(objXmlCategory.InnerText).Append(',');
                                if (sbdCategories.Length > 0)
                                    --sbdCategories.Length;
                                strCategories = sbdCategories.ToString();
                            }
                        }
                    }

                    string strGearNames = string.Empty;
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdGearNames))
                    {
                        using (XmlNodeList xmlGearNameList = objCyberware.AllowGear?.SelectNodes("gearname"))
                        {
                            if (xmlGearNameList?.Count > 0)
                            {
                                foreach (XmlNode objXmlName in xmlGearNameList)
                                    sbdGearNames.Append(objXmlName.InnerText).Append(',');
                                --sbdGearNames.Length;
                                strGearNames = sbdGearNames.ToString();
                            }
                        }
                    }

                    using (ThreadSafeForm<SelectGear> frmPickGear
                           = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject, 0, 1, objCyberware, strCategories, strGearNames)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objCyberware.Capacity) &&
                            objCyberware.Capacity != "0" && (!objCyberware.Capacity.Contains('[') ||
                                                             objCyberware.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objNewGear = new Gear(CharacterObject);
                        objNewGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty,
                                          objCyberware.IsModularCurrentlyEquipped);
                        objNewGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        objNewGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                        if (objNewGear.InternalId.IsEmptyGuid())
                            continue;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objNewGear.Cost = '(' + objNewGear.Cost + ") * 0.5";
                        // If the item was marked as free, change its cost.
                        if (frmPickGear.MyForm.FreeCost)
                        {
                            objNewGear.Cost = "0";
                        }

                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }

                        await objCyberware.GearChildren.AddAsync(objNewGear);
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleCyberwareAddGear_Click(object sender, EventArgs e)
        {
            // Make sure a parent items is selected, then open the Select Gear window.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objCyberware))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_SelectCyberware"), await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Make sure the Cyberware is allowed to accept Gear.
            if (objCyberware.AllowGear == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CyberwareGear"), await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Gear XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    string strCategories;
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XmlNode objXmlCategory in objCyberware.AllowGear)
                            sbdCategories.Append(objXmlCategory.InnerText).Append(',');
                        if (sbdCategories.Length > 0)
                            --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }

                    using (ThreadSafeForm<SelectGear> frmPickGear
                           = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject, 0, 1, objCyberware, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objCyberware.Capacity) &&
                            objCyberware.Capacity != "0" && (!objCyberware.Capacity.Contains('[') ||
                                                             objCyberware.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objNewGear = new Gear(CharacterObject);
                        objNewGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty, false);
                        objNewGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        objNewGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                        if (objNewGear.InternalId.IsEmptyGuid())
                            continue;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objNewGear.Cost = '(' + objNewGear.Cost + ") * 0.5";
                        // If the item was marked as free, change its cost.
                        if (frmPickGear.MyForm.FreeCost)
                        {
                            objNewGear.Cost = "0";
                        }

                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }

                        await objCyberware.GearChildren.AddAsync(objNewGear);
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsCyberwareGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode);
            // Make sure a parent items is selected, then open the Select Gear window.
            if (objSelectedNode == null || objSelectedNode.Level < 2)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Locate the Vehicle Sensor Gear.
            if (!(objSelectedNode.Tag is Gear objSensor))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            CharacterObject.Cyberware.FindCyberwareGear(objSensor.InternalId, out Cyberware objCyberware);
            // Open the Gear XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
            string strCategories = string.Empty;
            XPathNodeIterator xmlAddonCategoryList = (await objSensor.GetNodeXPathAsync())?.Select("addoncategory");
            if (xmlAddonCategoryList?.Count > 0)
            {
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                        sbdCategories.Append(objXmlCategory.Value).Append(',');
                    // Remove the trailing comma.
                    --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }
            }

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectGear> frmPickGear
                           = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject, 0, 1, objSensor, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                 && (!objSensor.Capacity.Contains('[')
                                                                     || objSensor.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty,
                                       (objSensor.Parent as Gear)?.Equipped
                                       ?? objCyberware?.IsModularCurrentlyEquipped == true);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";
                        // If the item was marked as free, change its cost.
                        if (frmPickGear.MyForm.FreeCost)
                        {
                            objGear.Cost = "0";
                        }

                        await objSensor.Children.AddAsync(objGear);

                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleCyberwareGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode);
            // Make sure a parent items is selected, then open the Select Gear window.
            if (objSelectedNode == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Locate the Vehicle Sensor Gear.
            if (!(objSelectedNode.Tag is Gear objSensor))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Gear XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
            string strCategories = string.Empty;
            XPathNodeIterator xmlAddonCategoryList = (await objSensor.GetNodeXPathAsync())?.Select("addoncategory");
            if (xmlAddonCategoryList?.Count > 0)
            {
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                        sbdCategories.Append(objXmlCategory.Value).Append(',');
                    // Remove the trailing comma.
                    --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }
            }

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectGear> frmPickGear
                           = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject, 0, 1, objSensor, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                 && (!objSensor.Capacity.Contains('[')
                                                                     || objSensor.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty, false);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";
                        // If the item was marked as free, change its cost.
                        if (frmPickGear.MyForm.FreeCost)
                        {
                            objGear.Cost = "0";
                        }

                        await objSensor.Children.AddAsync(objGear);

                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsWeaponAccessoryAddGear_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode);

            // Make sure the Weapon Accessory is allowed to accept Gear.
            if (!(objSelectedNode?.Tag is WeaponAccessory objAccessory) || objAccessory.AllowGear == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_WeaponGear"), await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // Open the Gear XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
            string strCategories;
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
            {
                foreach (XmlNode objXmlCategory in objAccessory.AllowGear)
                    sbdCategories.Append(objXmlCategory.InnerText).Append(',');
                if (sbdCategories.Length > 0)
                    --sbdCategories.Length;
                strCategories = sbdCategories.ToString();
            }

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectGear> frmPickGear
                           = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject, 0, 1, objAccessory, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty,
                                       objAccessory.Equipped);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";
                        // If the item was marked as free, change its cost.
                        if (frmPickGear.MyForm.FreeCost)
                        {
                            objGear.Cost = "0";
                        }

                        await objAccessory.GearChildren.AddAsync(objGear);

                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsWeaponAccessoryGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objSensor))
            // Make sure the Gear was found.
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            CharacterObject.Weapons.FindWeaponGear(objSensor.InternalId, out WeaponAccessory objAccessory);

            string strCategories = string.Empty;
            XPathNodeIterator xmlAddonCategoryList = (await objSensor.GetNodeXPathAsync())?.Select("addoncategory");
            if (xmlAddonCategoryList?.Count > 0)
            {
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                        sbdCategories.Append(objXmlCategory.Value).Append(',');
                    // Remove the trailing comma.
                    --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }
            }

            // Open the Gear XML file and locate the selected piece.
            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectGear> frmPickGear
                           = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject, 0, 1, objSensor, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                 && (!objSensor.Capacity.Contains('[')
                                                                     || objSensor.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty,
                                       (objSensor.Parent as Gear)?.Equipped ?? objAccessory?.Equipped == true);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";
                        // If the item was marked as free, change its cost.
                        if (frmPickGear.MyForm.FreeCost)
                        {
                            objGear.Cost = "0";
                        }

                        await objSensor.Children.AddAsync(objGear);

                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon);
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleRenameLocation_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objLocation))
                return;

            string strDescription = await LanguageManager.GetStringAsync("String_AddLocation");
            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                       () => new SelectText
                       {
                           Description = strDescription,
                           DefaultString = objLocation.Name
                       }))
            {
                if (await frmPickText.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                objLocation.Name = frmPickText.MyForm.SelectedValue;
            }

            treVehicles.SelectedNode.Text = objLocation.DisplayName();

            await SetDirty(true);
        }

        private async void tsCreateNaturalWeapon_Click(object sender, EventArgs e)
        {
            using (ThreadSafeForm<CreateNaturalWeapon> frmCreateNaturalWeapon = await ThreadSafeForm<CreateNaturalWeapon>.GetAsync(() => new CreateNaturalWeapon(CharacterObject)))
            {
                if (await frmCreateNaturalWeapon.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                Weapon objWeapon = frmCreateNaturalWeapon.MyForm.SelectedWeapon;
                await CharacterObject.Weapons.AddAsync(objWeapon);
            }
        }

        private async void tsVehicleWeaponAccessoryGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            // Make sure the Gear was found.
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objSensor))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear"), await LanguageManager.GetStringAsync("MessageTitle_SelectGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
            string strCategories = string.Empty;
            XPathNodeIterator xmlAddonCategoryList = (await objSensor.GetNodeXPathAsync())?.Select("addoncategory");
            if (xmlAddonCategoryList?.Count > 0)
            {
                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                        sbdCategories.Append(objXmlCategory.Value).Append(',');
                    // Remove the trailing comma.
                    --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }
            }

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectGear> frmPickGear
                           = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject, 0, 1, objSensor, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                 && (!objSensor.Capacity.Contains('[')
                                                                     || objSensor.Capacity.Contains("/[")))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        // Open the Gear XML file and locate the selected piece.
                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty, false);

                        if (objGear.InternalId.IsEmptyGuid())
                            continue;

                        objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = '(' + objGear.Cost + ") * 0.5";
                        // If the item was marked as free, change its cost.
                        if (frmPickGear.MyForm.FreeCost)
                        {
                            objGear.Cost = "0";
                        }

                        await objSensor.Children.AddAsync(objGear);

                        // Create any Weapons that came with this Gear.
                        if (lstWeapons.Count > 0)
                        {
                            CharacterObject.Vehicles.FindVehicleGear(objGear.InternalId, out Vehicle objVehicle,
                                                                     out WeaponAccessory _, out Cyberware _);
                            foreach (Weapon objWeapon in lstWeapons)
                            {
                                await objVehicle.Weapons.AddAsync(objWeapon);
                            }
                        }
                    }
                } while (blnAddAgain);
            }
        }

        private async void tsVehicleWeaponAccessoryAddGear_Click(object sender, EventArgs e)
        {
            TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode);

            // Make sure the Weapon Accessory is allowed to accept Gear.
            if (!(objSelectedNode?.Tag is WeaponAccessory objAccessory) || objAccessory.AllowGear == null)
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_WeaponGear"), await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
            string strCategories;
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
            {
                foreach (XmlNode objXmlCategory in objAccessory.AllowGear)
                    sbdCategories.Append(objXmlCategory.InnerText).Append(',');
                if (sbdCategories.Length > 0)
                    --sbdCategories.Length;
                strCategories = sbdCategories.ToString();
            }

            using (await CursorWait.NewAsync(this))
            {
                bool blnAddAgain;
                do
                {
                    using (ThreadSafeForm<SelectGear> frmPickGear
                           = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject, 0, 1, objAccessory, strCategories)))
                    {
                        if (!string.IsNullOrEmpty(strCategories))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                        if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                            break;
                        blnAddAgain = frmPickGear.MyForm.AddAgain;

                        // Open the Gear XML file and locate the selected piece.
                        XmlNode objXmlGear
                            = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                              + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objNewGear = new Gear(CharacterObject);
                        objNewGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty, false);

                        if (objNewGear.InternalId.IsEmptyGuid())
                            continue;

                        objNewGear.Quantity = frmPickGear.MyForm.SelectedQty;

                        objNewGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objNewGear.Cost = '(' + objNewGear.Cost + ") * 0.5";
                        // If the item was marked as free, change its cost.
                        if (frmPickGear.MyForm.FreeCost)
                        {
                            objNewGear.Cost = "0";
                        }

                        await objAccessory.GearChildren.AddAsync(objNewGear);

                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objLoopWeapon in lstWeapons)
                        {
                            await objAccessory.Parent.Children.AddAsync(objLoopWeapon);
                        }
                    }
                } while (blnAddAgain);
            }
        }

        #endregion ContextMenu Events

        #region Additional Common Tab Control Events

        private async void treQualities_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedQuality();
        }

        private async Task RefreshSelectedQuality(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            await tlpCommonLeftSide.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                // Locate the selected Quality.
                Quality objQuality = await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag as Quality, token);
                await UpdateQualityLevelValue(objQuality, token);
                if (objQuality == null)
                {
                    await lblQualitySourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblQualityBPLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblQualitySource.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblQualityBP.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                else
                {
                    await lblQualitySourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblQualityBPLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblQualitySource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblQualityBP.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objQuality.SetSourceDetailAsync(lblQualitySource, token);
                    string strText
                        = (objQuality.BP * objQuality.Levels * CharacterObjectSettings.KarmaQuality).ToString(
                              GlobalSettings.CultureInfo) +
                          await LanguageManager.GetStringAsync("String_Space")
                          + await LanguageManager.GetStringAsync("String_Karma");
                    await lblQualityBP.DoThreadSafeAsync(x => x.Text = strText, token);
                }
            }
            finally
            {
                await tlpCommonLeftSide.DoThreadSafeAsync(x => x.ResumeLayout(), token);
            }
        }

        private async ValueTask UpdateQualityLevelValue(Quality objSelectedQuality = null, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objSelectedQuality == null
                || objSelectedQuality.OriginSource == QualitySource.Improvement
                || objSelectedQuality.OriginSource == QualitySource.Metatype
                || objSelectedQuality.OriginSource == QualitySource.Heritage
                || objSelectedQuality.Levels == 0)
            {
                await nudQualityLevel.DoThreadSafeAsync(x =>
                {
                    x.Value = 1;
                    x.Enabled = false;
                }, token);
                return;
            }
            token.ThrowIfCancellationRequested();
            XPathNavigator objQualityNode = await objSelectedQuality.GetNodeXPathAsync();
            string strLimitString = objQualityNode != null
                ? (await objQualityNode.SelectSingleNodeAndCacheExpressionAsync("chargenlimit"))?.Value
                  ?? (await objQualityNode.SelectSingleNodeAndCacheExpressionAsync("limit"))?.Value
                : string.Empty;
            token.ThrowIfCancellationRequested();
            if (!string.IsNullOrWhiteSpace(strLimitString) && await objQualityNode.SelectSingleNodeAndCacheExpressionAsync("nolevels") == null && int.TryParse(strLimitString, out int intMaxRating))
            {
                await nudQualityLevel.DoThreadSafeAsync(x =>
                {
                    x.Maximum = intMaxRating;
                    x.Value = objSelectedQuality.Levels;
                    x.Enabled = true;
                }, token);
            }
            else
            {
                await nudQualityLevel.DoThreadSafeAsync(x =>
                {
                    x.Value = 1;
                    x.Enabled = false;
                }, token);
            }
        }

        private bool _blnSkipQualityLevelChanged;

        private async void nudQualityLevel_ValueChanged(object sender, EventArgs e)
        {
            if (_blnSkipQualityLevelChanged)
                return;
            // Locate the selected Quality.
            if (!(await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Quality objSelectedQuality))
                return;
            int intCurrentLevels = objSelectedQuality.Levels;
            int intSelectedLevels = await nudQualityLevel.DoThreadSafeFuncAsync(x => x.ValueAsInt);
            // Adding new levels
            for (; intSelectedLevels > intCurrentLevels; ++intCurrentLevels)
            {
                if (!(await objSelectedQuality.GetNodeXPathAsync()).RequirementsMet(CharacterObject, await LanguageManager.GetStringAsync("String_Quality")))
                {
                    await UpdateQualityLevelValue(objSelectedQuality);
                    break;
                }
                List<Weapon> lstWeapons = new List<Weapon>(1);
                Quality objQuality = new Quality(CharacterObject);

                objQuality.Create(await objSelectedQuality.GetNodeAsync(), QualitySource.Selected, lstWeapons, objSelectedQuality.Extra);
                if (objQuality.InternalId.IsEmptyGuid())
                {
                    // If the Quality could not be added, remove the Improvements that were added during the Quality Creation process.
                    await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Quality, objQuality.InternalId);
                    await UpdateQualityLevelValue(objSelectedQuality);
                    break;
                }

                objQuality.BP = objSelectedQuality.BP;
                objQuality.ContributeToLimit = objSelectedQuality.ContributeToLimit;

                // Make sure that adding the Quality would not cause the character to exceed their BP limits.
                bool blnAddItem = true;
                if (objQuality.ContributeToLimit && !CharacterObject.IgnoreRules)
                {
                    // If the item being checked would cause the limit of 25 BP spent on Positive Qualities to be exceed, do not let it be checked and display a message.
                    string strAmount = CharacterObjectSettings.QualityKarmaLimit.ToString(GlobalSettings.CultureInfo) + await LanguageManager.GetStringAsync("String_Space") + await LanguageManager.GetStringAsync("String_Karma");
                    int intMaxQualityAmount = CharacterObjectSettings.QualityKarmaLimit;

                    // Add the cost of the Quality that is being added.
                    int intBP = objQuality.BP;

                    if (objQuality.Type == QualityType.Negative)
                    {
                        // Check if adding this Quality would put the character over their limit.
                        if (!CharacterObjectSettings.ExceedNegativeQualities)
                        {
                            intBP += CharacterObject.NegativeQualityLimitKarma;
                            if (intBP < intMaxQualityAmount * -1)
                            {
                                Program.ShowMessageBox(this, string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_NegativeQualityLimit"), strAmount),
                                    await LanguageManager.GetStringAsync("MessageTitle_NegativeQualityLimit"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                                blnAddItem = false;
                            }
                            else if (CharacterObject.MetatypeBP < 0 && intBP + CharacterObject.MetatypeBP < intMaxQualityAmount * -1)
                            {
                                Program.ShowMessageBox(this, string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_NegativeQualityAndMetatypeLimit"), strAmount),
                                    await LanguageManager.GetStringAsync("MessageTitle_NegativeQualityLimit"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                                blnAddItem = false;
                            }
                        }
                    }
                    // Check if adding this Quality would put the character over their limit.
                    else if (!CharacterObjectSettings.ExceedPositiveQualities)
                    {
                        intBP += CharacterObject.PositiveQualityKarma;
                        if (intBP > intMaxQualityAmount)
                        {
                            Program.ShowMessageBox(this,
                                string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_PositiveQualityLimit"), strAmount),
                                await LanguageManager.GetStringAsync("MessageTitle_PositiveQualityLimit"),
                                MessageBoxButtons.OK, MessageBoxIcon.Information);
                            blnAddItem = false;
                        }
                    }
                }

                if (blnAddItem)
                {
                    //to avoid an System.InvalidOperationException: Cannot change ObservableCollection during a CollectionChanged event.
                    _blnSkipQualityLevelChanged = true;
                    await CharacterObject.Qualities.AddAsync(objQuality);
                    _blnSkipQualityLevelChanged = false;

                    // Add any created Weapons to the character.
                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objWeapon);
                    }
                }
                else
                {
                    // If the Quality could not be added, remove the Improvements that were added during the Quality Creation process.
                    await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Quality, objQuality.InternalId);
                    await UpdateQualityLevelValue(objSelectedQuality);
                    break;
                }
            }
            // Removing levels
            for (; intSelectedLevels < intCurrentLevels; --intCurrentLevels)
            {
                Quality objInvisibleQuality = CharacterObject.Qualities.FirstOrDefault(x => x.SourceIDString == objSelectedQuality.SourceIDString && x.Extra == objSelectedQuality.Extra && x.SourceName == objSelectedQuality.SourceName && x.InternalId != objSelectedQuality.InternalId);
                if (objInvisibleQuality == null || !await RemoveQuality(objInvisibleQuality, false, false))
                {
                    if (!await RemoveQuality(objSelectedQuality, false, false))
                        await UpdateQualityLevelValue(objSelectedQuality);
                    break;
                }
            }
        }

        #endregion Additional Common Tab Control Events

        #region Additional Cyberware Tab Control Events

        private async void treCyberware_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedCyberware(GenericToken);
                await DoRefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboCyberwareGrade_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || IsLoading)
                return;
            string strSelectedGrade = await cboCyberwareGrade.DoThreadSafeFuncAsync(x => x.SelectedValue?.ToString());
            if (string.IsNullOrEmpty(strSelectedGrade) ||
                !(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objCyberware))
                return;
            // Locate the selected piece of Cyberware.
            Grade objNewGrade = CharacterObject.GetGrades(objCyberware.SourceType).FirstOrDefault(x => x.Name == strSelectedGrade);
            if (objNewGrade == null)
                return;
            // Updated the selected Cyberware Grade.
            objCyberware.Grade = objNewGrade;

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkPrototypeTranshuman_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objCyberware))
                return;
            // Update the selected Cyberware Rating.
            objCyberware.PrototypeTranshuman = await chkPrototypeTranshuman.DoThreadSafeFuncAsync(x => x.Checked);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void nudCyberwareRating_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            switch (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag))
            {
                // Locate the selected piece of Cyberware.
                case Cyberware objCyberware:
                    {
                        // Update the selected Cyberware Rating.
                        objCyberware.Rating = await nudCyberwareRating.DoThreadSafeFuncAsync(x => x.ValueAsInt);

                        // See if a Bonus node exists.
                        if (objCyberware.Bonus?.InnerXml.Contains("Rating") == true || objCyberware.PairBonus?.InnerXml.Contains("Rating") == true || objCyberware.WirelessOn && objCyberware.WirelessBonus?.InnerXml.Contains("Rating") == true)
                        {
                            // If the Bonus contains "Rating", remove the existing Improvements and create new ones.
                            await ImprovementManager.RemoveImprovementsAsync(CharacterObject, objCyberware.SourceType, objCyberware.InternalId);
                            if (objCyberware.Bonus != null)
                                await ImprovementManager.CreateImprovementsAsync(CharacterObject, objCyberware.SourceType, objCyberware.InternalId, objCyberware.Bonus, objCyberware.Rating, objCyberware.CurrentDisplayNameShort);
                            if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                await ImprovementManager.CreateImprovementsAsync(CharacterObject, objCyberware.SourceType, objCyberware.InternalId, objCyberware.WirelessBonus, objCyberware.Rating, objCyberware.CurrentDisplayNameShort);

                            if (objCyberware.PairBonus != null)
                            {
                                List<Cyberware> lstPairableCyberwares = CharacterObject.Cyberware.DeepWhere(x => x.Children, x => objCyberware.IncludePair.Contains(x.Name) && x.Extra == objCyberware.Extra && x.IsModularCurrentlyEquipped).ToList();
                                int intCyberwaresCount = lstPairableCyberwares.Count;
                                // Need to use slightly different logic if this cyberware has a location (Left or Right) and only pairs with itself because Lefts can only be paired with Rights and Rights only with Lefts
                                if (!string.IsNullOrEmpty(objCyberware.Location) && objCyberware.IncludePair.All(x => x == objCyberware.Name))
                                {
                                    int intMatchLocationCount = 0;
                                    int intNotMatchLocationCount = 0;
                                    foreach (Cyberware objPairableCyberware in lstPairableCyberwares)
                                    {
                                        if (objPairableCyberware.Location != objCyberware.Location)
                                            ++intNotMatchLocationCount;
                                        else
                                            ++intMatchLocationCount;
                                    }
                                    // Set the count to the total number of cyberwares in matching pairs, which would mean 2x the number of whichever location contains the fewest members (since every single one of theirs would have a pair)
                                    intCyberwaresCount = Math.Min(intNotMatchLocationCount, intMatchLocationCount) * 2;
                                }
                                foreach (Cyberware objLoopCyberware in lstPairableCyberwares)
                                {
                                    await ImprovementManager.RemoveImprovementsAsync(CharacterObject, objLoopCyberware.SourceType, objLoopCyberware.InternalId + "Pair");
                                    // Go down the list and create pair bonuses for every second item
                                    if (intCyberwaresCount > 0 && (intCyberwaresCount & 1) == 0)
                                    {
                                        await ImprovementManager.CreateImprovementsAsync(CharacterObject, objLoopCyberware.SourceType, objLoopCyberware.InternalId + "Pair", objLoopCyberware.PairBonus, objLoopCyberware.Rating, objLoopCyberware.CurrentDisplayNameShort);
                                    }
                                    --intCyberwaresCount;
                                }
                            }

                            if (!objCyberware.IsModularCurrentlyEquipped)
                                objCyberware.ChangeModularEquip(false);
                        }

                        await treCyberware.DoThreadSafeAsync(x => x.SelectedNode.Text = objCyberware.CurrentDisplayName);
                        break;
                    }
                case Gear objGear:
                    {
                        // Find the selected piece of Gear.
                        if (objGear.Category == "Foci" || objGear.Category == "Metamagic Foci" || objGear.Category == "Stacked Focus")
                        {
                            if (!await objGear.RefreshSingleFocusRating(treFoci, await nudCyberwareRating.DoThreadSafeFuncAsync(x => x.ValueAsInt)))
                            {
                                IsRefreshing = true;
                                try
                                {
                                    await nudCyberwareRating.DoThreadSafeAsync(x => x.ValueAsInt = objGear.Rating);
                                }
                                finally
                                {
                                    IsRefreshing = false;
                                }

                                return;
                            }
                        }
                        else
                            objGear.Rating = await nudCyberwareRating.DoThreadSafeFuncAsync(x => x.ValueAsInt);

                        // See if a Bonus node exists.
                        if (objGear.Bonus != null || objGear.WirelessOn && objGear.WirelessBonus != null)
                        {
                            await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId);
                            if (!string.IsNullOrEmpty(objGear.Extra))
                            {
                                ImprovementManager.ForcedValue = objGear.Extra.TrimEndOnce(", Hacked");
                            }
                            if (objGear.Bonus != null)
                                await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId, objGear.Bonus, objGear.Rating, objGear.CurrentDisplayNameShort);
                            if (objGear.WirelessOn && objGear.WirelessBonus != null)
                                await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId, objGear.WirelessBonus, objGear.Rating, objGear.CurrentDisplayNameShort);

                            if (!objGear.Equipped)
                                objGear.ChangeEquippedStatus(false);
                        }

                        await treCyberware.DoThreadSafeAsync(x => x.SelectedNode.Text = objGear.CurrentDisplayName);
                        break;
                    }
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        #endregion Additional Cyberware Tab Control Events

        #region Additional Street Gear Tab Control Events

        private async void treWeapons_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedWeapon(GenericToken);
                await DoRefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treWeapons_ItemDrag(object sender, ItemDragEventArgs e)
        {
            string strSelectedWeapon = treWeapons.SelectedNode?.Tag.ToString();
            if (string.IsNullOrEmpty(strSelectedWeapon) || treWeapons.SelectedNode.Level != 1)
                return;

            // Do not allow the root element to be moved.
            if (strSelectedWeapon == "Node_SelectedWeapons")
                return;
            _intDragLevel = treWeapons.SelectedNode.Level;
            DoDragDrop(e.Item, DragDropEffects.Move);
        }

        private void treWeapons_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private async void treWeapons_DragDrop(object sender, DragEventArgs e)
        {
            try
            {
                await DoTreeDragDrop(sender, e, treWeapons, ItemTreeViewTypes.Weapons, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treWeapons_DragOver(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = ((TreeView)sender).GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (objNode.Level <= _intDragLevel)
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background colour for all other Nodes.
            treWeapons.ClearNodeBackground(objNode);
        }

        private async void treArmor_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedArmor(GenericToken);
                await DoRefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treArmor_ItemDrag(object sender, ItemDragEventArgs e)
        {
            if (treArmor.SelectedNode == null || treArmor.SelectedNode.Level != 1)
                return;

            _intDragLevel = treArmor.SelectedNode.Level;
            DoDragDrop(e.Item, DragDropEffects.Move);
        }

        private void treArmor_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private async void treArmor_DragDrop(object sender, DragEventArgs e)
        {
            try
            {
                await DoTreeDragDrop(sender, e, treArmor, ItemTreeViewTypes.Armor, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treArmor_DragOver(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = ((TreeView)sender).GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (objNode.Level <= _intDragLevel)
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background colour for all other Nodes.
            treArmor.ClearNodeBackground(objNode);
        }

        private async void treLifestyles_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedLifestyle(GenericToken);
                await DoRefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treLifestyles_DoubleClick(object sender, EventArgs e)
        {
            if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Lifestyle objLifestyle))
                return;

            string strGuid = objLifestyle.InternalId;
            int intMonths = objLifestyle.Increments;
            int intPosition = await CharacterObject.Lifestyles.IndexOfAsync(CharacterObject.Lifestyles.FirstOrDefault(p => p.InternalId == objLifestyle.InternalId));

            if (objLifestyle.StyleType != LifestyleType.Standard)
            {
                Lifestyle newLifestyle = objLifestyle;
                // Edit Advanced Lifestyle.
                using (ThreadSafeForm<SelectLifestyleAdvanced> frmPickLifestyle
                       = await ThreadSafeForm<SelectLifestyleAdvanced>.GetAsync(
                           () => new SelectLifestyleAdvanced(CharacterObject, newLifestyle)))
                {
                    if (await frmPickLifestyle.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    {
                        if (!ReferenceEquals(objLifestyle, frmPickLifestyle.MyForm.SelectedLifestyle))
                            frmPickLifestyle.MyForm.SelectedLifestyle.Dispose();
                        return;
                    }

                    // Update the selected Lifestyle and refresh the list.
                    objLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;
                }
            }
            else
            {
                // Edit Basic Lifestyle.
                using (ThreadSafeForm<SelectLifestyle> frmPickLifestyle
                       = await ThreadSafeForm<SelectLifestyle>.GetAsync(() => new SelectLifestyle(CharacterObject)))
                {
                    frmPickLifestyle.MyForm.SetLifestyle(objLifestyle);

                    if (await frmPickLifestyle.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    {
                        frmPickLifestyle.MyForm.SelectedLifestyle.Dispose();
                        return;
                    }

                    // Update the selected Lifestyle and refresh the list.
                    objLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;
                }
            }
            objLifestyle.Increments = intMonths;

            objLifestyle.SetInternalId(strGuid);
            CharacterObject.Lifestyles[intPosition] = objLifestyle;

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        /*
        private void treLifestyles_ItemDrag(object sender, ItemDragEventArgs e)
        {
            if (treLifestyles.SelectedNode == null || treLifestyles.SelectedNode.Level != 1)
                return;

            _intDragLevel = treLifestyles.SelectedNode.Level;
            DoDragDrop(e.Item, DragDropEffects.Move);
        }

        private void treLifestyles_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private void treLifestyles_DragDrop(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode nodDestination = ((TreeView)sender).GetNodeAt(pt);

            int intNewIndex = 0;
            if (nodDestination != null)
            {
                intNewIndex = nodDestination.Index;
            }
            else
            {
                intNewIndex = treLifestyles.Nodes[treLifestyles.Nodes.Count - 1].Nodes.Count;
                nodDestination = treLifestyles.Nodes[treLifestyles.Nodes.Count - 1];
            }

            // Put the lifestyle in the right location (or lack thereof)
            CommonFunctions.MoveLifestyleNode(CharacterObject, intNewIndex, nodDestination, treLifestyles);

            // Put the lifestyle in the right order in the tree
            MoveTreeNode(treLifestyles.FindNodeByTag(objSelected?.Tag), intNewIndex);
            // Update the entire tree to prevent any holes in the sort order
            treLifestyles.CacheSortOrder();

            // Clear the background color for all Nodes.
            treLifestyles.ClearNodeBackground(null);

            await SetDirty(true);
        }
        */

        private void treLifestyles_DragOver(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = ((TreeView)sender).GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (objNode.Level <= _intDragLevel)
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background colour for all other Nodes.
            treLifestyles.ClearNodeBackground(objNode);
        }

        private async void nudLifestyleMonths_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            // Locate the selected Lifestyle.
            if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Lifestyle objLifestyle))
                return;

            IsRefreshing = true;
            try
            {
                objLifestyle.Increments = await nudLifestyleMonths.DoThreadSafeFuncAsync(x => x.ValueAsInt);
            }
            finally
            {
                IsRefreshing = false;
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void treGear_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedGear(GenericToken);
                await DoRefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudGearRating_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objGear))
                return;

            if (objGear.Category == "Foci" || objGear.Category == "Metamagic Foci" || objGear.Category == "Stacked Focus")
            {
                if (!await objGear.RefreshSingleFocusRating(treFoci, await nudGearRating.DoThreadSafeFuncAsync(x => x.ValueAsInt)))
                {
                    IsRefreshing = true;
                    try
                    {
                        await nudGearRating.DoThreadSafeAsync(x => x.ValueAsInt = objGear.Rating);
                    }
                    finally
                    {
                        IsRefreshing = false;
                    }

                    return;
                }
            }
            else
                objGear.Rating = await nudGearRating.DoThreadSafeFuncAsync(x => x.ValueAsInt);

            if (objGear.Bonus != null || objGear.WirelessOn && objGear.WirelessBonus != null)
            {
                await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId);
                if (!string.IsNullOrEmpty(objGear.Extra))
                {
                    ImprovementManager.ForcedValue = objGear.Extra.TrimEndOnce(", Hacked");
                }
                if (objGear.Bonded || (objGear.Category != "Foci" && objGear.Category != "Metamagic Foci" && objGear.Category != "Stacked Focus"))
                {
                    if (objGear.Bonus != null)
                        await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId, objGear.Bonus, objGear.Rating, objGear.CurrentDisplayNameShort);
                    if (objGear.WirelessOn && objGear.WirelessBonus != null)
                        await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId, objGear.WirelessBonus, objGear.Rating, objGear.CurrentDisplayNameShort);
                }

                if (!objGear.Equipped)
                    objGear.ChangeEquippedStatus(false);
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void nudGearQty_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            // Attempt to locate the selected piece of Gear.
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objGear))
                return;
            objGear.Quantity = await nudGearQty.DoThreadSafeFuncAsync(x => x.Value);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void nudDrugQty_ValueChanged(object sender, EventArgs e)
        {
            // Don't attempt to do anything while the data is still being populated.
            if (IsLoading || IsRefreshing)
                return;

            if (!(await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Drug objDrug))
                return;
            objDrug.Quantity = await nudDrugQty.DoThreadSafeFuncAsync(x => x.ValueAsInt);
            await RefreshSelectedDrug();

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkArmorEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag);
            if (objSelected == null)
                return;

            bool blnChecked = await chkArmorEquipped.DoThreadSafeFuncAsync(x => x.Checked);

            // Locate the selected Armor or Armor Mod.
            switch (objSelected)
            {
                case Armor objArmor:
                    objArmor.Equipped = blnChecked;
                    break;

                case ArmorMod objMod:
                    objMod.Equipped = blnChecked;
                    break;

                case Gear objGear:
                    objGear.Equipped = blnChecked;
                    if (blnChecked)
                    {
                        CharacterObject.Armor.FindArmorGear(objGear.InternalId, out Armor objParentArmor, out ArmorMod objParentMod);
                        // Add the Gear's Improvements to the character.
                        if (objParentArmor.Equipped && objParentMod?.Equipped != false)
                        {
                            objGear.ChangeEquippedStatus(true);
                        }
                    }
                    else
                    {
                        objGear.ChangeEquippedStatus(false);
                    }

                    break;

                default:
                    return;
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkWeaponEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            object objSelected = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag);
            if (objSelected == null)
                return;

            bool blnChecked = await chkWeaponEquipped.DoThreadSafeFuncAsync(x => x.Checked);
            // Determine if this is a Weapon.
            switch (objSelected)
            {
                case Weapon objWeapon:
                    objWeapon.Equipped = blnChecked;
                    break;

                case Gear objGear:
                    // Find the selected Gear.
                    objGear.Equipped = blnChecked;
                    objGear.ChangeEquippedStatus(blnChecked);
                    break;

                case WeaponAccessory objAccessory:
                    objAccessory.Equipped = blnChecked;
                    break;

                default:
                    return;
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkIncludedInWeapon_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            // Locate the selected Weapon Accessory or Modification.
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is WeaponAccessory objAccessory))
                return;
            objAccessory.IncludedInWeapon = await chkIncludedInWeapon.DoThreadSafeFuncAsync(x => x.Checked);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private void treGear_ItemDrag(object sender, ItemDragEventArgs e)
        {
            string strSelected = treGear.SelectedNode?.Tag.ToString();
            if (string.IsNullOrEmpty(strSelected) || strSelected == "Node_SelectedGear")
                return;
            if (e.Button == MouseButtons.Left)
            {
                if (treGear.SelectedNode.Level > 1 || treGear.SelectedNode.Level < 0)
                    return;
                DragButton = MouseButtons.Left;
            }
            else
            {
                if (treGear.SelectedNode.Level == 0)
                    return;
                DragButton = MouseButtons.Right;
            }

            _intDragLevel = treGear.SelectedNode.Level;
            DoDragDrop(e.Item, DragDropEffects.Move);
        }

        private void treGear_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private async void treGear_DragDrop(object sender, DragEventArgs e)
        {
            try
            {
                await DoTreeDragDrop(sender, e, treGear, ItemTreeViewTypes.Gear, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treGear_DragOver(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = ((TreeView)sender).GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (DragButton == MouseButtons.Left)
            {
                if (objNode.Level <= _intDragLevel)
                    objNode.BackColor = ColorManager.ControlDarker;
            }
            else
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background color for all other Nodes.
            treGear.ClearNodeBackground(objNode);
        }

        private async void chkGearEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            // Attempt to locate the selected piece of Gear.
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objSelectedGear))
                return;
            bool blnChecked = await chkGearEquipped.DoThreadSafeFuncAsync(x => x.Checked);
            objSelectedGear.Equipped = blnChecked;
            objSelectedGear.ChangeEquippedStatus(blnChecked);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private void chkGearHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || treGear.SelectedNode == null)
                return;
            if (!(treGear.SelectedNode?.Tag is IHasMatrixAttributes objCommlink))
                return;
            objCommlink.SetHomeNode(CharacterObject, chkGearHomeNode.Checked);
        }

        private void chkArmorHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || treArmor.SelectedNode == null)
                return;
            if (!(treArmor.SelectedNode?.Tag is IHasMatrixAttributes objCommlink))
                return;
            objCommlink.SetHomeNode(CharacterObject, chkArmorHomeNode.Checked);
        }

        private void chkWeaponHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || treWeapons.SelectedNode == null)
                return;
            if (!(treWeapons.SelectedNode?.Tag is IHasMatrixAttributes objCommlink))
                return;
            objCommlink.SetHomeNode(CharacterObject, chkWeaponHomeNode.Checked);
        }

        private void chkCyberwareHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(treCyberware.SelectedNode?.Tag is IHasMatrixAttributes objCommlink))
                return;
            objCommlink.SetHomeNode(CharacterObject, chkCyberwareHomeNode.Checked);
        }

        private async void chkCommlinks_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                await RefreshGears(treGear, cmsGearLocation, cmsGear, await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, GenericToken));
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void chkGearActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || treGear.SelectedNode == null)
                return;

            // Attempt to locate the selected piece of Gear.
            if (!(treGear.SelectedNode?.Tag is IHasMatrixAttributes objSelectedCommlink))
                return;
            objSelectedCommlink.SetActiveCommlink(CharacterObject, chkGearActiveCommlink.Checked);
        }

        private void chkArmorActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || treArmor.SelectedNode == null)
                return;

            // Attempt to locate the selected piece of Gear.
            if (!(treArmor.SelectedNode?.Tag is IHasMatrixAttributes objSelectedCommlink))
                return;
            objSelectedCommlink.SetActiveCommlink(CharacterObject, chkArmorActiveCommlink.Checked);
        }

        private void chkWeaponActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || treWeapons.SelectedNode == null)
                return;

            // Attempt to locate the selected piece of Gear.
            if (!(treWeapons.SelectedNode?.Tag is IHasMatrixAttributes objSelectedCommlink))
                return;
            objSelectedCommlink.SetActiveCommlink(CharacterObject, chkWeaponActiveCommlink.Checked);
        }

        private void chkCyberwareActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            if (!(treCyberware.SelectedNode?.Tag is IHasMatrixAttributes objSelectedCommlink))
                return;
            objSelectedCommlink.SetActiveCommlink(CharacterObject, chkCyberwareActiveCommlink.Checked);
        }

        private void chkVehicleActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            if (!(treVehicles.SelectedNode?.Tag is IHasMatrixAttributes objSelectedCommlink))
                return;
            objSelectedCommlink.SetActiveCommlink(CharacterObject, chkVehicleActiveCommlink.Checked);
        }

        private async void cboGearAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboGearAttack.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboGearAttack, cboGearAttack,
                        cboGearSleaze, cboGearDataProcessing, cboGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboGearSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboGearSleaze.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboGearSleaze, cboGearAttack,
                        cboGearSleaze, cboGearDataProcessing, cboGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboGearDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboGearDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboGearDataProcessing, cboGearAttack,
                        cboGearSleaze, cboGearDataProcessing, cboGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboGearFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboGearFirewall.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboGearFirewall, cboGearAttack,
                        cboGearSleaze, cboGearDataProcessing, cboGearFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboVehicleAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboVehicleAttack.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboVehicleAttack, cboVehicleAttack,
                        cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboVehicleSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboVehicleSleaze.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboVehicleSleaze, cboVehicleAttack,
                        cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboVehicleFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboVehicleFirewall.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboVehicleFirewall, cboVehicleAttack,
                        cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboVehicleDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboVehicleDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboVehicleDataProcessing, cboVehicleAttack,
                        cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboCyberwareAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboCyberwareAttack.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboCyberwareAttack, cboCyberwareAttack,
                        cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboCyberwareSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboCyberwareSleaze.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboCyberwareSleaze, cboCyberwareAttack,
                        cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboCyberwareDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboCyberwareDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboCyberwareDataProcessing, cboCyberwareAttack,
                        cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void cboCyberwareFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || !await cboCyberwareFirewall.DoThreadSafeFuncAsync(x => x.Enabled))
                return;

            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasMatrixAttributes objTarget))
                return;

            IsRefreshing = true;
            try
            {
                if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                        CharacterObject, cboCyberwareFirewall, cboCyberwareAttack,
                        cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall))
                {
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        #endregion Additional Street Gear Tab Control Events

        #region Additional Drug Tab Control Events

        private async void treCustomDrugs_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedDrug(GenericToken);
                await DoRefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Drug Tab Control Events

        #region Additional Vehicle Tab Control Events

        private async void treVehicles_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedVehicle(GenericToken);
                await DoRefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treVehicles_ItemDrag(object sender, ItemDragEventArgs e)
        {
            switch (treVehicles.SelectedNode?.Tag)
            {
                // Determine if this is a piece of Gear or a Vehicle. If not, don't let the user drag it.
                case Gear _:
                    DragButton = e.Button;
                    DraggingGear = true;
                    _intDragLevel = treVehicles.SelectedNode.Level;
                    DoDragDrop(e.Item, DragDropEffects.Move);
                    break;

                case Vehicle _:
                    DragButton = e.Button;
                    DraggingGear = false;
                    _intDragLevel = treVehicles.SelectedNode.Level;
                    DoDragDrop(e.Item, DragDropEffects.Move);
                    break;
            }
        }

        private void treVehicles_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private async void treVehicles_DragDrop(object sender, DragEventArgs e)
        {
            try
            {
                await DoTreeDragDrop(sender, e, treVehicles, ItemTreeViewTypes.Vehicles, GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void treVehicles_DragOver(object sender, DragEventArgs e)
        {
            Point pt = ((TreeView)sender).PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = ((TreeView)sender).GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (DragButton == MouseButtons.Left)
            {
                if (objNode.Level <= _intDragLevel)
                    objNode.BackColor = ColorManager.ControlDarker;
            }
            else
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background color for all other Nodes.
            treVehicles.ClearNodeBackground(objNode);
        }

        private async void nudVehicleRating_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            switch (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag))
            {
                case VehicleMod objMod:
                    objMod.Rating = await nudVehicleRating.DoThreadSafeFuncAsync(x => x.ValueAsInt);
                    await treVehicles.DoThreadSafeAsync(x => x.SelectedNode.Text = objMod.CurrentDisplayName);
                    break;

                case Gear objGear:
                    {
                        if (objGear.Category == "Foci" || objGear.Category == "Metamagic Foci" || objGear.Category == "Stacked Focus")
                        {
                            if (!await objGear.RefreshSingleFocusRating(treFoci, await nudVehicleRating.DoThreadSafeFuncAsync(x => x.ValueAsInt)))
                            {
                                IsRefreshing = true;
                                try
                                {
                                    await nudVehicleRating.DoThreadSafeAsync(x => x.ValueAsInt = objGear.Rating);
                                }
                                finally
                                {
                                    IsRefreshing = false;
                                }
                                return;
                            }
                        }
                        else
                            objGear.Rating = await nudVehicleRating.DoThreadSafeFuncAsync(x => x.ValueAsInt);
                        await treVehicles.DoThreadSafeAsync(x => x.SelectedNode.Text = objGear.CurrentDisplayName);
                        break;
                    }
                case WeaponAccessory objAccessory:
                    objAccessory.Rating = await nudVehicleRating.DoThreadSafeFuncAsync(x => x.ValueAsInt);
                    await treVehicles.DoThreadSafeAsync(x => x.SelectedNode.Text = objAccessory.CurrentDisplayName);
                    break;

                case Cyberware objCyberware:
                    objCyberware.Rating = await nudVehicleRating.DoThreadSafeFuncAsync(x => x.ValueAsInt);
                    await treVehicles.DoThreadSafeAsync(x => x.SelectedNode.Text = objCyberware.CurrentDisplayName);
                    break;

                default:
                    return;
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkVehicleWeaponAccessoryInstalled_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is ICanEquip objEquippable))
                return;
            objEquippable.Equipped = await chkVehicleWeaponAccessoryInstalled.DoThreadSafeFuncAsync(x => x.Checked);

            await SetDirty(true);
        }

        private async void nudVehicleGearQty_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Gear objGear))
                return;
            objGear.Quantity = await nudVehicleGearQty.DoThreadSafeFuncAsync(x => x.Value);
            await treVehicles.DoThreadSafeAsync(x => x.SelectedNode.Text = objGear.CurrentDisplayName);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private void chkVehicleHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(treVehicles.SelectedNode?.Tag is IHasMatrixAttributes objTarget))
                return;
            objTarget.SetHomeNode(CharacterObject, chkVehicleHomeNode.Checked);
        }

        #endregion Additional Vehicle Tab Control Events

        #region Additional Spells and Spirits Tab Control Events

        private async void treSpells_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedSpell();
        }

        private async void treFoci_AfterCheck(object sender, TreeViewEventArgs e)
        {
            if (!e.Node.Checked)
            {
                if (!(e.Node.Tag is IHasInternalId objId))
                    return;
                Focus objFocus = await CharacterObject.Foci.FindAsync(x => x.GearObject.InternalId == objId.InternalId);

                // Mark the Gear as not Bonded and remove any Improvements.
                Gear objGear = objFocus?.GearObject;

                if (objGear != null)
                {
                    objGear.Bonded = false;
                    await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId);
                    await CharacterObject.Foci.RemoveAsync(objFocus);
                }
                else
                {
                    // This is a Stacked Focus.
                    StackedFocus objStack = await CharacterObject.StackedFoci.FindAsync(x => x.InternalId == objId.InternalId);

                    if (objStack != null)
                    {
                        objStack.Bonded = false;
                        await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.StackedFocus, objStack.InternalId);
                    }
                }
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void treFoci_BeforeCheck(object sender, TreeViewCancelEventArgs e)
        {
            if (IsRefreshing)
                return;

            TreeView treViewToUse = e.Node.TreeView;

            // Don't bother to do anything since a node is being unchecked.
            if (await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Checked))
                return;

            string strSelectedId = (await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Tag) as IHasInternalId)?.InternalId ?? string.Empty;

            // Locate the Focus that is being touched.
            Gear objSelectedFocus = CharacterObject.Gear.DeepFindById(strSelectedId);

            // Set the Focus count to 1 and get its current Rating (Force). This number isn't used in the following loops because it isn't yet checked or unchecked.
            int intFociCount = 1;
            int intFociTotal;

            if (objSelectedFocus != null)
                intFociTotal = objSelectedFocus.Rating;
            else
            {
                // This is a Stacked Focus.
                intFociTotal = (await CharacterObject.StackedFoci.FindAsync(x => x.InternalId == strSelectedId))?.TotalForce ?? 0;
            }

            await treViewToUse.DoThreadSafeAsync(y =>
            {
                // Run through the list of items. Count the number of Foci the character would have bonded including this one, plus the total Force of all checked Foci.
                foreach (TreeNode objNode in y.Nodes)
                {
                    if (objNode.Checked)
                    {
                        string strNodeId = objNode.Tag.ToString();
                        ++intFociCount;
                        intFociTotal += CharacterObject.Gear.FirstOrDefault(x => x.InternalId == strNodeId && x.Bonded)
                                                       ?.Rating ?? 0;
                        intFociTotal += CharacterObject.StackedFoci.Find(x => x.InternalId == strNodeId && x.Bonded)
                                                       ?.TotalForce ?? 0;
                    }
                }
            });

            if (!CharacterObject.IgnoreRules)
            {
                if (intFociTotal > CharacterObject.MAG.TotalValue * 5 ||
                    CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept && CharacterObject.InitiateGrade + 1 > CharacterObject.MAGAdept.TotalValue)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_FocusMaximumForce"), await LanguageManager.GetStringAsync("MessageTitle_FocusMaximum"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    e.Cancel = true;
                    return;
                }

                if (intFociCount > CharacterObject.MAG.TotalValue ||
                    CharacterObjectSettings.MysAdeptSecondMAGAttribute && CharacterObject.IsMysticAdept && intFociCount > CharacterObject.MAGAdept.TotalValue)
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_FocusMaximumNumber"), await LanguageManager.GetStringAsync("MessageTitle_FocusMaximum"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    e.Cancel = true;
                    return;
                }
            }

            if (objSelectedFocus != null)
            {
                Focus objFocus = new Focus(CharacterObject)
                {
                    GearObject = objSelectedFocus
                };

                if (objSelectedFocus.Equipped && (objSelectedFocus.Bonus != null || objSelectedFocus.WirelessOn && objSelectedFocus.WirelessBonus != null))
                {
                    if (!string.IsNullOrEmpty(objSelectedFocus.Extra))
                        ImprovementManager.ForcedValue = objSelectedFocus.Extra;
                    if (objSelectedFocus.Bonus != null)
                    {
                        if (!await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objSelectedFocus.InternalId, objSelectedFocus.Bonus, objSelectedFocus.Rating, objSelectedFocus.CurrentDisplayNameShort))
                        {
                            // Clear created improvements
                            objSelectedFocus.ChangeEquippedStatus(false);
                            objSelectedFocus.ChangeEquippedStatus(true);
                            e.Cancel = true;
                            return;
                        }
                        objSelectedFocus.Extra = ImprovementManager.SelectedValue;
                    }
                    if (objSelectedFocus.WirelessOn
                        && objSelectedFocus.WirelessBonus != null
                        && !await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objSelectedFocus.InternalId, objSelectedFocus.WirelessBonus, objSelectedFocus.Rating, objSelectedFocus.CurrentDisplayNameShort))
                    {
                        // Clear created improvements
                        objSelectedFocus.ChangeEquippedStatus(false);
                        objSelectedFocus.ChangeEquippedStatus(true);
                        e.Cancel = true;
                        return;
                    }
                }

                e.Node.Text = objSelectedFocus.CurrentDisplayName;
                await CharacterObject.Foci.AddAsync(objFocus);
                objSelectedFocus.Bonded = true;
            }
            else
            {
                // This is a Stacked Focus.
                StackedFocus objStack = await CharacterObject.StackedFoci.FindAsync(x => x.InternalId == strSelectedId);
                if (objStack != null)
                {
                    Gear objStackGear = CharacterObject.Gear.DeepFindById(objStack.GearId);
                    if (objStackGear.Equipped)
                    {
                        foreach (Gear objGear in objStack.Gear)
                        {
                            if (objGear.Bonus == null && (!objGear.WirelessOn || objGear.WirelessBonus == null))
                                continue;
                            if (!string.IsNullOrEmpty(objGear.Extra))
                                ImprovementManager.ForcedValue = objGear.Extra;
                            if (objGear.Bonus != null)
                            {
                                if (!await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.StackedFocus, objStack.InternalId, objGear.Bonus, objGear.Rating, objGear.CurrentDisplayNameShort))
                                {
                                    // Clear created improvements
                                    objStackGear.ChangeEquippedStatus(false);
                                    objStackGear.ChangeEquippedStatus(true);
                                    e.Cancel = true;
                                    return;
                                }
                                objGear.Extra = ImprovementManager.SelectedValue;
                            }
                            if (objGear.WirelessOn
                                && objGear.WirelessBonus != null
                                && !await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.StackedFocus, objStack.InternalId, objGear.WirelessBonus, objGear.Rating, objGear.CurrentDisplayNameShort))
                            {
                                // Clear created improvements
                                objStackGear.ChangeEquippedStatus(false);
                                objStackGear.ChangeEquippedStatus(true);
                                e.Cancel = true;
                                return;
                            }
                        }
                    }
                    objStack.Bonded = true;
                    await treViewToUse.DoThreadSafeAsync(x => x.SelectedNode.Text = objStackGear.CurrentDisplayName);
                }
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void nudArmorRating_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            switch (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag))
            {
                // Locate the selected ArmorMod.
                case ArmorMod objMod:
                    {
                        objMod.Rating = await nudArmorRating.DoThreadSafeFuncAsync(x => x.ValueAsInt);
                        await treArmor.DoThreadSafeAsync(x => x.SelectedNode.Text = objMod.CurrentDisplayName);

                        // See if a Bonus node exists.
                        if (objMod.Bonus?.InnerXml.Contains("Rating") == true || objMod.WirelessOn && objMod.WirelessBonus?.InnerXml.Contains("Rating") == true)
                        {
                            // If the Bonus contains "Rating", remove the existing Improvements and create new ones.
                            await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.ArmorMod, objMod.InternalId);
                            if (objMod.Bonus != null)
                                await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.ArmorMod, objMod.InternalId, objMod.Bonus, objMod.Rating, objMod.CurrentDisplayNameShort);
                            if (objMod.WirelessOn && objMod.WirelessBonus != null)
                                await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.ArmorMod, objMod.InternalId, objMod.WirelessBonus, objMod.Rating, objMod.CurrentDisplayNameShort);
                        }

                        break;
                    }
                case Gear objGear:
                    {
                        if (objGear.Category == "Foci" || objGear.Category == "Metamagic Foci" || objGear.Category == "Stacked Focus")
                        {
                            if (!await objGear.RefreshSingleFocusRating(treFoci, await nudArmorRating.DoThreadSafeFuncAsync(x => x.ValueAsInt)))
                            {
                                IsRefreshing = true;
                                try
                                {
                                    await nudArmorRating.DoThreadSafeAsync(x => x.ValueAsInt = objGear.Rating);
                                }
                                finally
                                {
                                    IsRefreshing = false;
                                }
                                return;
                            }
                        }
                        else
                            objGear.Rating = await nudArmorRating.DoThreadSafeFuncAsync(x => x.ValueAsInt);
                        await treArmor.DoThreadSafeAsync(x => x.SelectedNode.Text = objGear.CurrentDisplayName);

                        // See if a Bonus node exists.
                        if (objGear.Bonus?.InnerXml.Contains("Rating") == true || objGear.WirelessOn && objGear.WirelessBonus?.InnerXml.Contains("Rating") == true)
                        {
                            // If the Bonus contains "Rating", remove the existing Improvements and create new ones.
                            await ImprovementManager.RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId);
                            if (objGear.Bonus != null)
                                await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId, objGear.Bonus, objGear.Rating, objGear.CurrentDisplayNameShort);
                            if (objGear.WirelessOn && objGear.WirelessBonus != null)
                                await ImprovementManager.CreateImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear, objGear.InternalId, objGear.WirelessBonus, objGear.Rating, objGear.CurrentDisplayNameShort);

                            if (!objGear.Equipped)
                                objGear.ChangeEquippedStatus(false);
                        }

                        break;
                    }
                case Armor objArmor:
                    objArmor.Rating = await nudArmorRating.DoThreadSafeFuncAsync(x => x.ValueAsInt);
                    await treArmor.DoThreadSafeAsync(x => x.SelectedNode.Text = objArmor.CurrentDisplayName);
                    break;
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void cboTradition_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing || IsDisposed)
                return;

            string strSelectedId = await cboTradition.DoThreadSafeFuncAsync(x => x.SelectedValue?.ToString());
            if (string.IsNullOrEmpty(strSelectedId))
                return;

            XmlNode xmlTradition = (await CharacterObject.LoadDataAsync("traditions.xml"))
                .SelectSingleNode("/chummer/traditions/tradition[id = " + strSelectedId.CleanXPath()
                                                                        + ']');

            if (xmlTradition == null)
            {
                await lblTraditionName.DoThreadSafeAsync(x => x.Visible = false);
                await txtTraditionName.DoThreadSafeAsync(x => x.Visible = false);
                await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = false);
                await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = false);
                await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = false);
                await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = false);
                await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = false);
                await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = false);
                await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = false);
                await cboSpiritCombat.DoThreadSafeAsync(x => x.Visible = false);
                await cboSpiritDetection.DoThreadSafeAsync(x => x.Visible = false);
                await cboSpiritHealth.DoThreadSafeAsync(x => x.Visible = false);
                await cboSpiritIllusion.DoThreadSafeAsync(x => x.Visible = false);
                await cboSpiritManipulation.DoThreadSafeAsync(x => x.Visible = false);

                if (CharacterObject.MagicTradition.Type == TraditionType.MAG)
                {
                    CharacterObject.MagicTradition.ResetTradition();
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }

                await cboTradition.DoThreadSafeAsync(x => x.SelectedValue = CharacterObject.MagicTradition.SourceID);
            }
            else if (strSelectedId == Tradition.CustomMagicalTraditionGuid)
            {
                if (CharacterObject.MagicTradition.Create(xmlTradition))
                {
                    await lblTraditionName.DoThreadSafeAsync(x => x.Visible = true);
                    await txtTraditionName.DoThreadSafeAsync(x => x.Visible = true);
                    await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = true);
                    await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = true);
                    await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = true);
                    await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = true);
                    await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = true);
                    await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = false);
                    await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = false);
                    await cboSpiritCombat.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = true;
                        x.Visible = true;
                    });
                    await cboSpiritDetection.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = true;
                        x.Visible = true;
                    });
                    await cboSpiritHealth.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = true;
                        x.Visible = true;
                    });
                    await cboSpiritIllusion.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = true;
                        x.Visible = true;
                    });
                    await cboSpiritManipulation.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = true;
                        x.Visible = true;
                    });

                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
                else
                {
                    CharacterObject.MagicTradition.ResetTradition();
                    await cboTradition.DoThreadSafeAsync(x => x.SelectedValue = CharacterObject.MagicTradition.SourceID);
                }
            }
            else if (CharacterObject.MagicTradition.Create(xmlTradition))
            {
                await lblTraditionName.DoThreadSafeAsync(x => x.Visible = false);
                await txtTraditionName.DoThreadSafeAsync(x => x.Visible = false);
                await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = true);
                await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = true);
                await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = true);
                await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = true);
                await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = true);
                await cboSpiritCombat.DoThreadSafeAsync(x =>
                {
                    x.Enabled = false;
                    x.Visible = true;
                });
                await cboSpiritDetection.DoThreadSafeAsync(x =>
                {
                    x.Enabled = false;
                    x.Visible = true;
                });
                await cboSpiritHealth.DoThreadSafeAsync(x =>
                {
                    x.Enabled = false;
                    x.Visible = true;
                });
                await cboSpiritIllusion.DoThreadSafeAsync(x =>
                {
                    x.Enabled = false;
                    x.Visible = true;
                });
                await cboSpiritManipulation.DoThreadSafeAsync(x =>
                {
                    x.Enabled = false;
                    x.Visible = true;
                });

                await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = true);
                await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = true);
                await CharacterObject.MagicTradition.SetSourceDetailAsync(lblTraditionSource);

                await RequestCharacterUpdate();
                await SetDirty(true);
            }
            else
            {
                CharacterObject.MagicTradition.ResetTradition();
                await cboTradition.DoThreadSafeAsync(x => x.SelectedValue = CharacterObject.MagicTradition.SourceID);
            }

            await cboDrain.DoThreadSafeAsync(x => x.Visible = (!CharacterObject.AdeptEnabled || CharacterObject.MagicianEnabled) &&
                                                              CharacterObject.MagicTradition.CanChooseDrainAttribute);
        }

        #endregion Additional Spells and Spirits Tab Control Events

        #region Additional Sprites and Complex Forms Tab Control Events

        private async void treComplexForms_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedComplexForm();
        }

        private async void cboStream_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing || CharacterObject.MagicTradition.Type == TraditionType.MAG)
                return;
            string strSelectedId = await cboStream.DoThreadSafeFuncAsync(x => x.SelectedValue?.ToString());
            if (string.IsNullOrEmpty(strSelectedId) || strSelectedId == CharacterObject.MagicTradition.SourceIDString)
                return;

            XmlNode xmlNewStreamNode = (await CharacterObject.LoadDataAsync("streams.xml")).SelectSingleNode("/chummer/traditions/tradition[id = " + strSelectedId.CleanXPath() + ']');
            if (xmlNewStreamNode != null && CharacterObject.MagicTradition.Create(xmlNewStreamNode, true))
            {
                await RequestCharacterUpdate();
                await SetDirty(true);
            }
            else
            {
                if (CharacterObject.MagicTradition.Type == TraditionType.RES)
                {
                    CharacterObject.MagicTradition.ResetTradition();
                    await RequestCharacterUpdate();
                    await SetDirty(true);
                }
                await cboStream.DoThreadSafeAsync(x => x.SelectedValue = CharacterObject.MagicTradition.SourceID);
            }
        }

        private void treComplexForms_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteComplexForm_Click(sender, e);
            }
        }

        #endregion Additional Sprites and Complex Forms Tab Control Events

        #region Additional AI Advanced Programs Tab Control Events

        private async void treAIPrograms_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await RefreshSelectedAIProgram(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedAIProgram(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                // Locate the Program that is selected in the tree.
                if (await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is AIProgram objProgram)
                {
                    string strText = await objProgram.DisplayRequiresProgramAsync(GlobalSettings.Language);
                    await lblAIProgramsRequires.DoThreadSafeAsync(x => x.Text = strText, token);
                    await objProgram.SetSourceDetailAsync(lblAIProgramsSource, token);
                }
                else
                {
                    await lblAIProgramsRequires.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await SourceString.Blank.SetControlAsync(lblAIProgramsSource, token);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private void treAIPrograms_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteAIProgram_Click(sender, e);
            }
        }

        #endregion Additional AI Advanced Programs Tab Control Events

        #region Additional Initiation Tab Control Events

        private void chkInitiationGroup_EnabledChanged(object sender, EventArgs e)
        {
            if (!chkInitiationGroup.Enabled)
            {
                chkInitiationGroup.Checked = false;
            }
        }

        private async void chkInitiationSchooling_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            await UpdateInitiationCost();
        }

        private void chkInitiationSchooling_EnabledChanged(object sender, EventArgs e)
        {
            if (!chkInitiationSchooling.Enabled)
            {
                chkInitiationSchooling.Checked = false;
            }
        }

        private async void treMetamagic_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedMetamagic();
        }

        private async Task RefreshSelectedMetamagic(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!CharacterObject.InitiationEnabled)
                return;
            IsRefreshing = true;
            try
            {
                string strText;
                switch (await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token))
                {
                    case Metamagic objMetamagic:
                        {
                            strText = await LanguageManager.GetStringAsync(
                                objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic
                                    ? "Button_RemoveMetamagic"
                                    : "Button_RemoveEcho");
                            await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Enabled = objMetamagic.Grade >= 0;
                            }, token);
                            await objMetamagic.SetSourceDetailAsync(lblMetamagicSource, token);
                            break;
                        }
                    case Art objArt:
                        {
                            strText = await LanguageManager.GetStringAsync(
                                objArt.SourceType == Improvement.ImprovementSource.Metamagic
                                    ? "Button_RemoveMetamagic"
                                    : "Button_RemoveEcho");
                            await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Enabled = objArt.Grade >= 0;
                            }, token);
                            await objArt.SetSourceDetailAsync(lblMetamagicSource, token);
                            break;
                        }
                    case Spell objSpell:
                        {
                            strText = await LanguageManager.GetStringAsync("Button_RemoveMetamagic");
                            await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Enabled = objSpell.Grade >= 0;
                            }, token);
                            await objSpell.SetSourceDetailAsync(lblMetamagicSource, token);
                            break;
                        }
                    case ComplexForm objComplexForm:
                        {
                            strText = await LanguageManager.GetStringAsync("Button_RemoveEcho");
                            await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Enabled = objComplexForm.Grade >= 0;
                            }, token);
                            await objComplexForm.SetSourceDetailAsync(lblMetamagicSource, token);
                            break;
                        }
                    case Enhancement objEnhancement:
                        {
                            strText = await LanguageManager.GetStringAsync(
                                objEnhancement.SourceType == Improvement.ImprovementSource.Metamagic
                                    ? "Button_RemoveMetamagic"
                                    : "Button_RemoveEcho");
                            await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Enabled = objEnhancement.Grade >= 0;
                            }, token);
                            await objEnhancement.SetSourceDetailAsync(lblMetamagicSource, token);
                            break;
                        }
                    default:
                    {
                        strText = await LanguageManager.GetStringAsync(
                            CharacterObject.MAGEnabled
                                ? "Button_RemoveInitiateGrade"
                                : "Button_RemoveSubmersionGrade");
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = true;
                        }, token);
                        await SourceString.Blank.SetControlAsync(lblMetamagicSource, token);
                        break;
                    }
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private void txtGroupNotes_KeyDown(object sender, KeyEventArgs e)
        {
            if (!e.Control || e.KeyCode != Keys.A)
                return;
            e.SuppressKeyPress = true;
            ((TextBox)sender)?.SelectAll();
        }

        #endregion Additional Initiation Tab Control Events

        #region Additional Critter Powers Tab Control Events

        private async void treCritterPowers_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing)
                return;
            await RefreshSelectedCritterPower();
        }

        private async Task RefreshSelectedCritterPower(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                // Look for the selected Critter Power.
                if (await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is CritterPower
                    objPower)
                {
                    await cmdDeleteCritterPower.DoThreadSafeAsync(x => x.Enabled = objPower.Grade == 0, token);
                    await lblCritterPowerName.DoThreadSafeAsync(x => x.Text = objPower.CurrentDisplayName, token);
                    string strText = await objPower.DisplayCategoryAsync(GlobalSettings.Language);
                    await lblCritterPowerCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objPower.DisplayTypeAsync(GlobalSettings.Language);
                    await lblCritterPowerType.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objPower.DisplayActionAsync(GlobalSettings.Language);
                    await lblCritterPowerAction.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objPower.DisplayRangeAsync(GlobalSettings.Language);
                    await lblCritterPowerRange.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objPower.DisplayDurationAsync(GlobalSettings.Language);
                    await lblCritterPowerDuration.DoThreadSafeAsync(x => x.Text = strText, token);
                    await chkCritterPowerCount.DoThreadSafeAsync(x => x.Checked = objPower.CountTowardsLimit, token);
                    await objPower.SetSourceDetailAsync(lblCritterPowerSource, token);
                    if (objPower.PowerPoints > 0)
                    {
                        await lblCritterPowerPointCost.DoThreadSafeAsync(x =>
                        {
                            x.Text = objPower.PowerPoints.ToString(GlobalSettings
                                                                       .CultureInfo);
                            x.Visible = true;
                        }, token);
                        await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    }
                    else
                    {
                        await lblCritterPowerPointCost.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    }
                }
                else
                {
                    await cmdDeleteCritterPower.DoThreadSafeAsync(x => x.Enabled = false, token);
                    await lblCritterPowerName.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblCritterPowerCategory.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblCritterPowerType.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblCritterPowerAction.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblCritterPowerRange.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await lblCritterPowerDuration.DoThreadSafeAsync(x => x.Text = string.Empty, token);
                    await chkCritterPowerCount.DoThreadSafeAsync(x => x.Checked = false, token);
                    await SourceString.Blank.SetControlAsync(lblCritterPowerSource, token);
                    await lblCritterPowerPointCost.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void chkCritterPowerCount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            // Locate the selected Critter Power.
            if (!(await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is CritterPower objPower))
                return;
            objPower.CountTowardsLimit = await chkCritterPowerCount.DoThreadSafeFuncAsync(x => x.Checked);

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        #endregion Additional Critter Powers Tab Control Events

        #region Tree KeyDown Events

        private async void treQualities_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                try
                {
                    await DeleteQuality(GenericToken);
                }
                catch (OperationCanceledException)
                {
                    //swallow this
                }
            }
        }

        private void treSpells_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteSpell_Click(sender, e);
            }
        }

        private void treCyberware_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteCyberware_Click(sender, e);
            }
        }

        private void treLifestyles_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteLifestyle_Click(sender, e);
            }
        }

        private void treArmor_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteArmor_Click(sender, e);
            }
        }

        private void treWeapons_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteWeapon_Click(sender, e);
            }
        }

        private void treGear_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteGear_Click(sender, e);
            }
        }

        private async void treVehicles_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                try
                {
                    await DeleteVehicle(GenericToken);
                }
                catch (OperationCanceledException)
                {
                    //swallow this
                }
            }
        }

        private void treMartialArts_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteMartialArt_Click(sender, e);
            }
        }

        private void treCritterPowers_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteCritterPower_Click(sender, e);
            }
        }

        private void treMetamagic_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                cmdDeleteMetamagic_Click(sender, e);
            }
        }

        #endregion Tree KeyDown Events

        #region Other Control Events

        private async void tabCharacterTabs_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await DoRefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tabStreetGearTabs_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            try
            {
                await DoRefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private enum CmdOperation { None, Up, Down }

        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            CmdOperation op = CmdOperation.None;

            // Determine which custom operation we're attempting, if any
            switch (keyData)
            {
                case Keys.Up | Keys.Alt:
                    op = CmdOperation.Up;
                    break;

                case Keys.Down | Keys.Alt:
                    op = CmdOperation.Down;
                    break;
            }

            if (op != CmdOperation.Up && op != CmdOperation.Down)
                return base.ProcessCmdKey(ref msg, keyData);
            bool up = op == CmdOperation.Up;
            bool requireParentSortable = false;
            TreeView treActiveView = null;

            if (tabCharacterTabs.SelectedTab == tabStreetGear)
            {
                // Lifestyle Tab.
                if (tabStreetGearTabs.SelectedTab == tabLifestyle)
                {
                    treActiveView = treLifestyles;
                }
                // Armor Tab.
                else if (tabStreetGearTabs.SelectedTab == tabArmor)
                {
                    treActiveView = treArmor;
                }
                // Weapons Tab.
                else if (tabStreetGearTabs.SelectedTab == tabWeapons)
                {
                    treActiveView = treWeapons;
                }
                // Gear Tab.
                else if (tabStreetGearTabs.SelectedTab == tabGear)
                {
                    treActiveView = treGear;
                }
                // Drugs Tab.
                else if (tabStreetGearTabs.SelectedTab == tabDrugs)
                {
                    treActiveView = treCustomDrugs;
                }
            }
            // Cyberware Tab.
            else if (tabCharacterTabs.SelectedTab == tabCyberware)
            {
                // Top-level cyberware is sorted alphabetically, but we can re-arrange any plugins/gear inside them
                requireParentSortable = true;
                treActiveView = treCyberware;
            }
            // Vehicles Tab.
            else if (tabCharacterTabs.SelectedTab == tabVehicles)
            {
                treActiveView = treVehicles;
            }
            // Critter Powers Tab.
            else if (tabCharacterTabs.SelectedTab == tabCritter)
            {
                treActiveView = treCritterPowers;
            }

            if (treActiveView == null)
                return true;
            TreeNode objSelectedNode = treActiveView.SelectedNode;
            TreeNode objParentNode = objSelectedNode?.Parent;
            TreeNodeCollection lstNodes = objParentNode?.Nodes ?? treActiveView.Nodes;

            if (requireParentSortable && !(objParentNode?.Tag is ICanSort))
                return true;
            int intNewIndex = lstNodes.IndexOf(objSelectedNode);
            intNewIndex = up ? Math.Max(0, intNewIndex - 1) : Math.Min(lstNodes.Count - 1, intNewIndex + 1);

            Utils.RunWithoutThreadLock(() => MoveTreeNode(objSelectedNode, intNewIndex));

            // Returning true tells the program to consume the input
            return true;

            // If none of our key combinations are used then use the default logic
        }

        #endregion Other Control Events

        #region Custom Methods

        /// <summary>
        /// Calculate the BP used by Primary Attributes.
        /// </summary>
        private static async ValueTask<int> CalculateAttributeBP(IAsyncEnumerable<CharacterAttrib> attribs, IAsyncEnumerable<CharacterAttrib> extraAttribs = null)
        {
            // Primary and Special Attributes are calculated separately since you can only spend a maximum of 1/2 your BP allotment on Primary Attributes.
            // Special Attributes are not subject to the 1/2 of max BP rule.
            int intBP = await attribs.SumAsync(att => att.TotalKarmaCostAsync);
            if (extraAttribs != null)
            {
                intBP += await extraAttribs.SumAsync(att => att.TotalKarmaCostAsync);
            }
            return intBP;
        }

        private int CalculateAttributePriorityPoints(IEnumerable<CharacterAttrib> attribs, IEnumerable<CharacterAttrib> extraAttribs = null)
        {
            int intAtt = 0;
            if (CharacterObject.EffectiveBuildMethodUsesPriorityTables)
            {
                // Get the total of "free points" spent
                intAtt += attribs.Sum(att => att.SpentPriorityPoints);
                if (extraAttribs != null)
                {
                    // Get the total of "free points" spent
                    intAtt += extraAttribs.Sum(att => att.SpentPriorityPoints);
                }
            }
            return intAtt;
        }

        private async ValueTask<string> BuildAttributes(IAsyncReadOnlyCollection<CharacterAttrib> attribs, IAsyncReadOnlyCollection<CharacterAttrib> extraAttribs = null, bool special = false)
        {
            int bp = await CalculateAttributeBP(attribs, extraAttribs);
            string s = bp.ToString(GlobalSettings.CultureInfo) + await LanguageManager.GetStringAsync("String_Space") + await LanguageManager.GetStringAsync("String_Karma");
            if (CharacterObject.EffectiveBuildMethodUsesPriorityTables)
            {
                int att = CalculateAttributePriorityPoints(attribs, extraAttribs);
                int total = special ? CharacterObject.TotalSpecial : CharacterObject.TotalAttributes;
                if (bp > 0)
                {
                    s = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("String_OverPriorityPoints"),
                        total - att, total, bp);
                }
                else
                {
                    s = (total - att).ToString(GlobalSettings.CultureInfo) + await LanguageManager.GetStringAsync("String_Of") + total.ToString(GlobalSettings.CultureInfo);
                }
            }
            return s;
        }

        /// <summary>
        /// Calculate the number of Build Points the character has remaining.
        /// </summary>
        private async ValueTask<int> CalculateBP(bool blnDoUIUpdate = true, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            int intKarmaPointsRemain = CharacterObjectSettings.BuildKarma;
            //int intPointsUsed = 0; // used as a running total for each section
            const int intFreestyleBPMin = 0;
            int intFreestyleBP = 0;
            string strSpace = await LanguageManager.GetStringAsync("String_Space");
            string strPoints = blnDoUIUpdate ? await LanguageManager.GetStringAsync("String_Karma") : string.Empty;

            // ------------------------------------------------------------------------------
            // Metatype/Metavariant only cost points when working with BP (or when the Metatype Costs Karma option is enabled when working with Karma).
            if (!CharacterObject.EffectiveBuildMethodUsesPriorityTables)
            {
                // Subtract the BP used for Metatype.
                intKarmaPointsRemain -= CharacterObject.MetatypeBP * CharacterObjectSettings.MetatypeCostsKarmaMultiplier;
            }
            else
            {
                intKarmaPointsRemain -= CharacterObject.MetatypeBP;
            }

            token.ThrowIfCancellationRequested();

            // ------------------------------------------------------------------------------
            // Calculate the points used by Contacts.
            int intPointsInContacts = 0;

            int intContactPoints = CharacterObject.ContactPoints;
            int intContactPointsLeft = intContactPoints;
            int intHighPlacesFriends = 0;
            foreach (Contact objContact in CharacterObject.Contacts)
            {
                // Don't care about free contacts
                if (objContact.EntityType != ContactType.Contact || objContact.Free)
                    continue;

                if (objContact.Connection >= 8 && CharacterObject.FriendsInHighPlaces)
                {
                    intHighPlacesFriends += objContact.Connection + objContact.Loyalty;
                }
                else if (!objContact.IsGroup)
                {
                    int over = intContactPointsLeft - objContact.ContactPoints;

                    //Prefers to eat 0, we went over
                    if (over < 0)
                    {
                        //over is negative so to add we substract
                        //instead of +abs(over)
                        intPointsInContacts -= over;
                        intContactPointsLeft = 0; //we went over so we know none are left
                    }
                    else
                    {
                        //otherwise just set;
                        intContactPointsLeft = over;
                    }
                }
            }

            CharacterObject.ContactPointsUsed = intContactPointsLeft;

            if (intPointsInContacts > 0 || CharacterObject.CHA.Value * 4 < intHighPlacesFriends)
            {
                intPointsInContacts += Math.Max(0, intHighPlacesFriends - CharacterObject.CHA.Value * 4);
            }

            intKarmaPointsRemain -= intPointsInContacts;

            token.ThrowIfCancellationRequested();
            // ------------------------------------------------------------------------------
            // Calculate the BP used by Qualities.
            int intLifeModuleQualities = 0;

            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                          out StringBuilder sbdPositiveQualityTooltip))
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                          out StringBuilder sbdNegativeQualityTooltip))
            {
                foreach (Quality objLoopQuality in CharacterObject.Qualities.Where(q => q.ContributeToBP))
                {
                    if (objLoopQuality.Type == QualityType.LifeModule)
                    {
                        intLifeModuleQualities += objLoopQuality.BP * CharacterObjectSettings.KarmaQuality;
                        if (blnDoUIUpdate)
                        {
                            sbdPositiveQualityTooltip.AppendFormat(
                                GlobalSettings.CultureInfo, "{0}{1}({2})", objLoopQuality.CurrentDisplayName,
                                strSpace, objLoopQuality.BP * CharacterObjectSettings.KarmaQuality).AppendLine();
                        }
                    }
                    else if (blnDoUIUpdate)
                    {
                        switch (objLoopQuality.Type)
                        {
                            case QualityType.Positive:
                                sbdPositiveQualityTooltip.AppendFormat(
                                    GlobalSettings.CultureInfo, "{0}{1}({2})", objLoopQuality.CurrentDisplayName,
                                    strSpace, objLoopQuality.BP * CharacterObjectSettings.KarmaQuality).AppendLine();
                                break;

                            case QualityType.Negative:
                                sbdNegativeQualityTooltip.AppendFormat(
                                    GlobalSettings.CultureInfo, "{0}{1}({2})", objLoopQuality.CurrentDisplayName,
                                    strSpace, objLoopQuality.BP * CharacterObjectSettings.KarmaQuality).AppendLine();
                                break;
                        }
                    }
                }

                if (blnDoUIUpdate)
                {
                    token.ThrowIfCancellationRequested();
                    if (CharacterObject.Contacts.Any(x => x.EntityType == ContactType.Contact && x.IsGroup && !x.Free))
                    {
                        sbdPositiveQualityTooltip.AppendLine(await LanguageManager.GetStringAsync("Label_GroupContacts"));
                        foreach (Contact objGroupContact in CharacterObject.Contacts.Where(x =>
                                     x.EntityType == ContactType.Contact && x.IsGroup && !x.Free))
                        {
                            string strNameToUse = objGroupContact.GroupName;
                            if (string.IsNullOrEmpty(strNameToUse))
                            {
                                strNameToUse = objGroupContact.Name;
                                if (string.IsNullOrEmpty(strNameToUse))
                                    strNameToUse = await LanguageManager.GetStringAsync("String_Unknown");
                            }
                            else if (!string.IsNullOrWhiteSpace(objGroupContact.Name))
                                strNameToUse += '/' + objGroupContact.Name;
                            sbdPositiveQualityTooltip.AppendFormat(GlobalSettings.CultureInfo, "{0}{1}({2})",
                                                                   strNameToUse,
                                                                   strSpace,
                                                                   objGroupContact.ContactPoints
                                                                   * CharacterObjectSettings.KarmaContact).AppendLine();
                        }
                    }

                    await lblPositiveQualitiesBP.SetToolTipAsync(sbdPositiveQualityTooltip.ToString(), token);
                    await lblNegativeQualitiesBP.SetToolTipAsync(sbdNegativeQualityTooltip.ToString(), token);
                }
            }

            int intQualityPointsUsed = intLifeModuleQualities - CharacterObject.NegativeQualityKarma + CharacterObject.PositiveQualityKarmaTotal;

            intKarmaPointsRemain -= intQualityPointsUsed;
            intFreestyleBP += intQualityPointsUsed;
            // Changelings must either have a balanced negative and positive number of metagenic qualities, or have 1 more point of positive than negative.
            // If the latter, karma is used to balance them out.
            if (CharacterObject.MetagenicPositiveQualityKarma + CharacterObject.MetagenicNegativeQualityKarma == 1)
                intKarmaPointsRemain--;

            token.ThrowIfCancellationRequested();

            // ------------------------------------------------------------------------------
            // Update Primary Attributes and Special Attributes values.
            int intAttributePointsUsed = await CalculateAttributeBP(CharacterObject.AttributeSection.AttributeList);
            intAttributePointsUsed += await CalculateAttributeBP(CharacterObject.AttributeSection.SpecialAttributeList);
            intKarmaPointsRemain -= intAttributePointsUsed;

            token.ThrowIfCancellationRequested();

            // ------------------------------------------------------------------------------
            // Include the BP used by Martial Arts.
            int intMartialArtsPoints = 0;
            string strColon = await LanguageManager.GetStringAsync("String_Colon");
            string strOf = await LanguageManager.GetStringAsync("String_Of");
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                          out StringBuilder sbdMartialArtsBPToolTip))
            {
                foreach (MartialArt objMartialArt in CharacterObject.MartialArts)
                {
                    token.ThrowIfCancellationRequested();
                    if (objMartialArt.IsQuality)
                        continue;
                    int intLoopCost = objMartialArt.Cost;
                    intMartialArtsPoints += intLoopCost;

                    if (blnDoUIUpdate)
                    {
                        if (sbdMartialArtsBPToolTip.Length > 0)
                            sbdMartialArtsBPToolTip.AppendLine().Append(strSpace).Append('+').Append(strSpace);
                        sbdMartialArtsBPToolTip.Append(objMartialArt.CurrentDisplayName).Append(strSpace).Append('(')
                                               .Append(intLoopCost.ToString(GlobalSettings.CultureInfo)).Append(')');

                        bool blnIsFirst = true;
                        foreach (MartialArtTechnique objTechnique in objMartialArt.Techniques)
                        {
                            token.ThrowIfCancellationRequested();
                            if (blnIsFirst)
                            {
                                blnIsFirst = false;
                                continue;
                            }

                            intLoopCost = CharacterObjectSettings.KarmaTechnique;
                            intMartialArtsPoints += intLoopCost;

                            sbdMartialArtsBPToolTip.AppendLine().Append(strSpace).Append('+').Append(strSpace)
                                                   .Append(objTechnique.CurrentDisplayName).Append(strSpace)
                                                   .Append('(')
                                                   .Append(intLoopCost.ToString(GlobalSettings.CultureInfo))
                                                   .Append(')');
                        }
                    }
                    else
                        // Add in the Techniques
                        intMartialArtsPoints += Math.Max(objMartialArt.Techniques.Count - 1, 0)
                                                * CharacterObjectSettings.KarmaTechnique;
                }

                token.ThrowIfCancellationRequested();

                if (blnDoUIUpdate)
                    await lblBuildMartialArts.SetToolTipAsync(sbdMartialArtsBPToolTip.ToString(), token);
            }

            intKarmaPointsRemain -= intMartialArtsPoints;

            token.ThrowIfCancellationRequested();
            // ------------------------------------------------------------------------------
            // Calculate the BP used by Skill Groups.
            int intSkillGroupsPoints = CharacterObject.SkillsSection.SkillGroups.TotalCostKarma();
            intKarmaPointsRemain -= intSkillGroupsPoints;

            token.ThrowIfCancellationRequested();
            // ------------------------------------------------------------------------------
            // Calculate the BP used by Active Skills.
            int skillPointsKarma = CharacterObject.SkillsSection.Skills.TotalCostKarma();
            intKarmaPointsRemain -= skillPointsKarma;

            token.ThrowIfCancellationRequested();
            // ------------------------------------------------------------------------------
            // Calculate the points used by Knowledge Skills.
            int knowledgeKarmaUsed = CharacterObject.SkillsSection.KnowledgeSkills.TotalCostKarma();

            token.ThrowIfCancellationRequested();
            //TODO: Remaining is named USED?
            intKarmaPointsRemain -= knowledgeKarmaUsed;

            intFreestyleBP += knowledgeKarmaUsed;

            token.ThrowIfCancellationRequested();
            // ------------------------------------------------------------------------------
            // Calculate the BP used by Resources/Nuyen.
            int intNuyenBP = CharacterObject.NuyenBP.StandardRound();

            intKarmaPointsRemain -= intNuyenBP;

            intFreestyleBP += intNuyenBP;

            token.ThrowIfCancellationRequested();
            // ------------------------------------------------------------------------------
            // Calculate the BP used by Spells.
            int intSpellPointsUsed = 0;
            int intRitualPointsUsed = 0;
            int intPrepPointsUsed = 0;
            if (CharacterObject.MagicianEnabled
                || CharacterObject.AdeptEnabled
                || (await ImprovementManager.GetCachedImprovementListForValueOfAsync(CharacterObject, Improvement.ImprovementType.FreeSpells)).Count > 0
                || (await ImprovementManager.GetCachedImprovementListForValueOfAsync(CharacterObject, Improvement.ImprovementType.FreeSpellsATT)).Count > 0
                || (await ImprovementManager.GetCachedImprovementListForValueOfAsync(CharacterObject, Improvement.ImprovementType.FreeSpellsSkill)).Count > 0)
            {
                // Count the number of Spells the character currently has and make sure they do not try to select more Spells than they are allowed.
                int spells = CharacterObject.Spells.Count(spell => spell.Grade == 0 && !spell.Alchemical && spell.Category != "Rituals" && !spell.FreeBonus);
                int intTouchOnlySpells = CharacterObject.Spells.Count(spell => spell.Grade == 0 && !spell.Alchemical && spell.Category != "Rituals" && (spell.Range == "T (A)" || spell.Range == "T") && !spell.FreeBonus);
                int rituals = CharacterObject.Spells.Count(spell => spell.Grade == 0 && !spell.Alchemical && spell.Category == "Rituals" && !spell.FreeBonus);
                int preps = CharacterObject.Spells.Count(spell => spell.Grade == 0 && spell.Alchemical && !spell.FreeBonus);

                token.ThrowIfCancellationRequested();

                // Each spell costs KarmaSpell.
                int spellCost = CharacterObject.SpellKarmaCost("Spells");
                int ritualCost = CharacterObject.SpellKarmaCost("Rituals");
                int prepCost = CharacterObject.SpellKarmaCost("Preparations");
                int limit = CharacterObject.FreeSpells;

                token.ThrowIfCancellationRequested();

                // Factor in any qualities that can be bought with spell points.
                // It is only karma-efficient to use spell points for Mastery qualities if real spell karma cost is not greater than unmodified spell karma cost
                if (spellCost <= CharacterObjectSettings.KarmaSpell && CharacterObject.FreeSpells > 0)
                {
                    int intQualityKarmaToSpellPoints = CharacterObjectSettings.KarmaSpell;
                    if (intQualityKarmaToSpellPoints != 0)
                    {
                        // Assume that every [spell cost] karma spent on a Mastery quality is paid for with a priority-given spell point instead, as that is the most karma-efficient.
                        int intMasteryQualityKarmaUsed = CharacterObject.Qualities.Where(objQuality => objQuality.CanBuyWithSpellPoints)
                                                                        .Sum(objQuality => objQuality.BP);
                        if (intMasteryQualityKarmaUsed != 0)
                        {
                            intQualityKarmaToSpellPoints
                                = Math.Min(
                                    limit,
                                    intMasteryQualityKarmaUsed * CharacterObjectSettings.KarmaQuality
                                    / CharacterObjectSettings.KarmaSpell);
                            spells += intQualityKarmaToSpellPoints;
                            // Add the karma paid for by spell points back into the available karma pool.
                            intKarmaPointsRemain += intQualityKarmaToSpellPoints * CharacterObjectSettings.KarmaSpell;
                        }
                    }
                }

                token.ThrowIfCancellationRequested();

                int intLimitMod = (await ImprovementManager.ValueOfAsync(CharacterObject, Improvement.ImprovementType.SpellLimit)
                                   + await ImprovementManager.ValueOfAsync(CharacterObject, Improvement.ImprovementType.FreeSpells)).StandardRound();
                int intLimitModTouchOnly = 0;
                foreach (Improvement imp in await ImprovementManager.GetCachedImprovementListForValueOfAsync(CharacterObject, Improvement.ImprovementType.FreeSpellsATT))
                {
                    token.ThrowIfCancellationRequested();
                    int intAttValue = CharacterObject.GetAttribute(imp.ImprovedName).TotalValue;
                    if (imp.UniqueName.Contains("half"))
                        intAttValue = (intAttValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intLimitModTouchOnly += intAttValue;
                    else
                        intLimitMod += intAttValue;
                }

                foreach (Improvement imp in await ImprovementManager.GetCachedImprovementListForValueOfAsync(CharacterObject, Improvement.ImprovementType.FreeSpellsSkill))
                {
                    token.ThrowIfCancellationRequested();
                    Skill skill = await CharacterObject.SkillsSection.GetActiveSkillAsync(imp.ImprovedName);
                    if (skill == null)
                        continue;
                    int intSkillValue = skill.TotalBaseRating;

                    if (imp.UniqueName.Contains("half"))
                        intSkillValue = (intSkillValue + 1) / 2;
                    if (imp.UniqueName.Contains("touchonly"))
                        intLimitModTouchOnly += intSkillValue;
                    else
                        intLimitMod += intSkillValue;
                    //TODO: I don't like this being hardcoded, even though I know full well CGL are never going to reuse this.
                    spells -= skill.Specializations.Count(
                        spec => CharacterObject.Spells.Any(spell => spell.Category == spec.Name && !spell.FreeBonus));
                }

                token.ThrowIfCancellationRequested();

                if (nudMysticAdeptMAGMagician.Value > 0)
                {
                    int intPPBought = nudMysticAdeptMAGMagician.ValueAsInt;
                    if (CharacterObjectSettings.PrioritySpellsAsAdeptPowers)
                    {
                        spells += Math.Min(limit, intPPBought);
                        intPPBought = Math.Max(0, intPPBought - limit);
                    }
                    intAttributePointsUsed = intPPBought * CharacterObject.Settings.KarmaMysticAdeptPowerPoint;
                    intKarmaPointsRemain -= intAttributePointsUsed;
                }
                spells -= intTouchOnlySpells - Math.Max(0, intTouchOnlySpells - intLimitModTouchOnly);

                int spellPoints = limit + intLimitMod;
                int ritualPoints = limit + intLimitMod;
                int prepPoints = limit + intLimitMod;
                for (int i = limit + intLimitMod; i > 0; i--)
                {
                    token.ThrowIfCancellationRequested();
                    if (spells > 0)
                    {
                        spells--;
                        spellPoints--;
                    }
                    else if (rituals > 0)
                    {
                        rituals--;
                        ritualPoints--;
                    }
                    else if (preps > 0)
                    {
                        preps--;
                        prepPoints--;
                    }
                    else
                    {
                        break;
                    }
                }

                intKarmaPointsRemain -= Math.Max(0, spells) * spellCost;
                intKarmaPointsRemain -= Math.Max(0, rituals) * ritualCost;
                intKarmaPointsRemain -= Math.Max(0, preps) * prepCost;

                intSpellPointsUsed += Math.Max(Math.Max(0, spells) * spellCost, 0);
                intRitualPointsUsed += Math.Max(Math.Max(0, rituals) * ritualCost, 0);
                intPrepPointsUsed += Math.Max(Math.Max(0, preps) * prepCost, 0);
                if (blnDoUIUpdate
                    && (lblBuildPrepsBP != null
                        || lblSpellsBP != null
                        || lblBuildRitualsBP != null))
                {
                    token.ThrowIfCancellationRequested();
                    string strFormat = "{0}" + strSpace + '' + strSpace + "{1}" + strSpace + await LanguageManager.GetStringAsync("String_Karma")
                                       + strSpace + '=' + strSpace + "{2}" + strSpace + await LanguageManager.GetStringAsync("String_Karma");
                    if (lblSpellsBP != null)
                        await lblSpellsBP.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo, strFormat, spells, spellCost, intSpellPointsUsed), token);
                    if (lblBuildRitualsBP != null)
                        await lblBuildRitualsBP.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo, strFormat, rituals, spellCost, intRitualPointsUsed), token);
                    if (lblBuildPrepsBP != null)
                        await lblBuildPrepsBP.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo, strFormat, preps, spellCost, intPrepPointsUsed), token);
                    if (limit + intLimitMod > 0)
                    {
                        if (lblBuildPrepsBP != null)
                        {
                            string strText = string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}", prepPoints + spellPoints + ritualPoints - 2 * (limit + intLimitMod), strOf, spellPoints + ritualPoints - (limit + intLimitMod));
                            if (intPrepPointsUsed > 0)
                                strText += string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}{1}{3}", strColon, strSpace, intPrepPointsUsed, strPoints);
                            await lblBuildPrepsBP.DoThreadSafeAsync(x => x.Text = strText, token);
                        }
                        if (lblSpellsBP != null)
                        {
                            string strText = string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}", prepPoints + spellPoints + ritualPoints - 2 * (limit + intLimitMod), strOf, prepPoints + ritualPoints - (limit + intLimitMod));
                            if (intSpellPointsUsed > 0)
                                strText += string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}{1}{3}", strColon, strSpace, intSpellPointsUsed, strPoints);
                            await lblSpellsBP.DoThreadSafeAsync(x => x.Text = strText, token);
                        }
                        if (lblBuildRitualsBP != null)
                        {
                            string strText = string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}", prepPoints + spellPoints + ritualPoints - 2 * (limit + intLimitMod), strOf, prepPoints + spellPoints - (limit + intLimitMod));
                            if (intRitualPointsUsed > 0)
                                strText += string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}{1}{3}", strColon, strSpace, intRitualPointsUsed, strPoints);
                            await lblBuildRitualsBP.DoThreadSafeAsync(x => x.Text = strText, token);
                        }
                    }
                    else if (intLimitMod == 0)
                    {
                        if (lblBuildPrepsBP != null)
                        {
                            await lblBuildPrepsBP.DoThreadSafeAsync(x => x.Text =
                                                                        intPrepPointsUsed.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints, token);
                        }

                        if (lblSpellsBP != null)
                        {
                            await lblSpellsBP.DoThreadSafeAsync(x => x.Text =
                                                                    intSpellPointsUsed.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints, token);
                        }

                        if (lblBuildRitualsBP != null)
                        {
                            await lblBuildRitualsBP.DoThreadSafeAsync(x => x.Text =
                                                                          intRitualPointsUsed.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints, token);
                        }
                    }
                    else
                    {
                        //TODO: Make the costs render better, currently looks wrong as hell
                        strFormat = "{0}" + strOf + "{1}" + strColon + strSpace + "{2}" + strSpace + strPoints;
                        if (lblBuildPrepsBP != null)
                        {
                            await lblBuildPrepsBP.DoThreadSafeAsync(x => x.Text =
                                                                        string.Format(
                                                                            GlobalSettings.CultureInfo, strFormat,
                                                                            prepPoints + spellPoints + ritualPoints
                                                                            - 2 * intLimitMod,
                                                                            spellPoints + ritualPoints - intLimitMod,
                                                                            intPrepPointsUsed), token);
                        }

                        if (lblSpellsBP != null)
                        {
                            await lblSpellsBP.DoThreadSafeAsync(x => x.Text =
                                                                    string.Format(GlobalSettings.CultureInfo, strFormat,
                                                                        prepPoints + spellPoints + ritualPoints
                                                                        - 2 * intLimitMod,
                                                                        prepPoints + ritualPoints - intLimitMod,
                                                                        intSpellPointsUsed), token);
                        }

                        if (lblBuildRitualsBP != null)
                        {
                            await lblBuildRitualsBP.DoThreadSafeAsync(x => x.Text =
                                                                          string.Format(
                                                                              GlobalSettings.CultureInfo, strFormat,
                                                                              prepPoints + spellPoints + ritualPoints
                                                                              - 2 * intLimitMod,
                                                                              prepPoints + spellPoints - intLimitMod,
                                                                              intRitualPointsUsed), token);
                        }
                    }
                }
            }

            intFreestyleBP += intSpellPointsUsed + intRitualPointsUsed + intPrepPointsUsed;

            token.ThrowIfCancellationRequested();
            // ------------------------------------------------------------------------------
            // Calculate the BP used by Foci.
            int intFociPointsUsed = 0;
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                          out StringBuilder sbdFociPointsTooltip))
            {
                foreach (Focus objFocus in CharacterObject.Foci)
                {
                    token.ThrowIfCancellationRequested();
                    intFociPointsUsed += objFocus.BindingKarmaCost();

                    if (!blnDoUIUpdate)
                        continue;
                    if (sbdFociPointsTooltip.Length > 0)
                        sbdFociPointsTooltip.AppendLine().Append(strSpace).Append('+').Append(strSpace);
                    sbdFociPointsTooltip.Append(objFocus.GearObject.CurrentDisplayName).Append(strSpace).Append('(')
                                        .Append(objFocus.BindingKarmaCost().ToString(GlobalSettings.CultureInfo))
                                        .Append(')');
                }

                intKarmaPointsRemain -= intFociPointsUsed;

                // Calculate the BP used by Stacked Foci.
                foreach (StackedFocus objFocus in CharacterObject.StackedFoci)
                {
                    token.ThrowIfCancellationRequested();
                    if (!objFocus.Bonded)
                        continue;
                    int intBindingCost = objFocus.BindingCost;
                    intKarmaPointsRemain -= intBindingCost;
                    intFociPointsUsed += intBindingCost;

                    if (!blnDoUIUpdate)
                        continue;
                    if (sbdFociPointsTooltip.Length > 0)
                        sbdFociPointsTooltip.AppendLine().Append(strSpace).Append('+').Append(strSpace);
                    sbdFociPointsTooltip.Append(objFocus.CurrentDisplayName).Append(strSpace).Append('(')
                                        .Append(intBindingCost.ToString(GlobalSettings.CultureInfo)).Append(')');
                }

                intFreestyleBP += intFociPointsUsed;

                if (blnDoUIUpdate)
                {
                    await lblBuildFoci.SetToolTipAsync(sbdFociPointsTooltip.ToString(), token);
                }
            }

            token.ThrowIfCancellationRequested();
            // ------------------------------------------------------------------------------
            // Calculate the BP used by Spirits and Sprites.
            int intSpiritPointsUsed = 0;
            int intSpritePointsUsed = 0;
            foreach (Spirit objSpirit in CharacterObject.Spirits)
            {
                token.ThrowIfCancellationRequested();
                int intLoopKarma = objSpirit.ServicesOwed * CharacterObjectSettings.KarmaSpirit;
                // Each Sprite costs KarmaSpirit x Services Owed.
                intKarmaPointsRemain -= intLoopKarma;
                if (objSpirit.EntityType == SpiritType.Spirit)
                {
                    intSpiritPointsUsed += intLoopKarma;
                    // Each Fettered Spirit costs 3 x Force.
                    if (objSpirit.Fettered)
                    {
                        intKarmaPointsRemain -= objSpirit.Force * CharacterObjectSettings.KarmaSpiritFettering;
                        intSpiritPointsUsed += objSpirit.Force * CharacterObjectSettings.KarmaSpiritFettering;
                    }
                }
                else
                {
                    intSpritePointsUsed += intLoopKarma;
                }
            }
            intFreestyleBP += intSpiritPointsUsed + intSpritePointsUsed;

            token.ThrowIfCancellationRequested();
            // ------------------------------------------------------------------------------
            // Calculate the BP used by Complex Forms.
            int intFormsPointsUsed = 0;
            foreach (ComplexForm objComplexForm in CharacterObject.ComplexForms)
            {
                token.ThrowIfCancellationRequested();
                if (objComplexForm.Grade == 0)
                    ++intFormsPointsUsed;
            }
            if (intFormsPointsUsed > CharacterObject.CFPLimit)
                intKarmaPointsRemain -= (intFormsPointsUsed - CharacterObject.CFPLimit) * CharacterObject.ComplexFormKarmaCost;
            intFreestyleBP += intFormsPointsUsed;

            token.ThrowIfCancellationRequested();
            // ------------------------------------------------------------------------------
            // Calculate the BP used by Programs and Advanced Programs.
            int intAINormalProgramPointsUsed = 0;
            int intAIAdvancedProgramPointsUsed = 0;
            foreach (AIProgram objProgram in CharacterObject.AIPrograms)
            {
                token.ThrowIfCancellationRequested();
                if (objProgram.CanDelete)
                {
                    if (objProgram.IsAdvancedProgram)
                        ++intAIAdvancedProgramPointsUsed;
                    else
                        ++intAINormalProgramPointsUsed;
                }
            }
            int intKarmaCost = 0;
            int intNumAdvancedProgramPointsAsNormalPrograms = 0;
            if (intAINormalProgramPointsUsed > CharacterObject.AINormalProgramLimit)
            {
                if (intAIAdvancedProgramPointsUsed < CharacterObject.AIAdvancedProgramLimit)
                {
                    intNumAdvancedProgramPointsAsNormalPrograms = Math.Min(intAINormalProgramPointsUsed - CharacterObject.AINormalProgramLimit, CharacterObject.AIAdvancedProgramLimit - intAIAdvancedProgramPointsUsed);
                    intAINormalProgramPointsUsed -= intNumAdvancedProgramPointsAsNormalPrograms;
                }
                if (intAINormalProgramPointsUsed > CharacterObject.AINormalProgramLimit)
                    intKarmaCost += (intAINormalProgramPointsUsed - CharacterObject.AINormalProgramLimit) * CharacterObject.AIProgramKarmaCost;
            }
            if (intAIAdvancedProgramPointsUsed > CharacterObject.AIAdvancedProgramLimit)
            {
                intKarmaCost += (intAIAdvancedProgramPointsUsed - CharacterObject.AIAdvancedProgramLimit) * CharacterObject.AIAdvancedProgramKarmaCost;
            }
            intKarmaPointsRemain -= intKarmaCost;
            intFreestyleBP += intAIAdvancedProgramPointsUsed + intAINormalProgramPointsUsed + intNumAdvancedProgramPointsAsNormalPrograms;

            token.ThrowIfCancellationRequested();
            // ------------------------------------------------------------------------------
            // Calculate the BP used by Initiation.
            int intInitiationPoints = 0;
            foreach (InitiationGrade objGrade in CharacterObject.InitiationGrades)
            {
                token.ThrowIfCancellationRequested();
                intInitiationPoints += objGrade.KarmaCost;
                // Add the Karma cost of extra Metamagic/Echoes to the Initiation cost.
                int metamagicKarma = Math.Max(CharacterObject.Metamagics.Count(x => x.Grade == objGrade.Grade) - 1, 0);
                intInitiationPoints += CharacterObjectSettings.KarmaMetamagic * metamagicKarma;
            }

            // Add the Karma cost of extra Metamagic/Echoes to the Initiation cost.
            intInitiationPoints += CharacterObject.Enhancements.Count * 2;
            /*
            foreach (Enhancement objEnhancement in CharacterObject.Enhancements)
            {
                intInitiationPoints += 2;
            }
            */
            foreach (Power objPower in CharacterObject.Powers)
            {
                token.ThrowIfCancellationRequested();
                intInitiationPoints += objPower.Enhancements.Count * 2;
                /*
                foreach (Enhancement objEnhancement in objPower.Enhancements)
                    intInitiationPoints += 2;
                    */
            }

            // Joining a Network does not cost Karma for Technomancers, so this only applies to Magicians/Adepts.
            // Check to see if the character is a member of a Group.
            if (CharacterObject.GroupMember && CharacterObject.MAGEnabled)
                intInitiationPoints += CharacterObjectSettings.KarmaJoinGroup;

            intKarmaPointsRemain -= intInitiationPoints;
            intFreestyleBP += intInitiationPoints;

            // Add the Karma cost of any Critter Powers.
            foreach (CritterPower objPower in CharacterObject.CritterPowers)
            {
                token.ThrowIfCancellationRequested();
                intKarmaPointsRemain -= objPower.Karma;
            }

            CharacterObject.Karma = intKarmaPointsRemain;

            if (!blnDoUIUpdate)
                return intKarmaPointsRemain;
            token.ThrowIfCancellationRequested();
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                          out StringBuilder sbdContactPoints))
            {
                sbdContactPoints.Append(CharacterObject.ContactPointsUsed.ToString(GlobalSettings.CultureInfo));
                if (CharacterObject.FriendsInHighPlaces)
                {
                    sbdContactPoints.Append('/')
                                    .Append(Math.Max(0, CharacterObject.CHA.Value * 4 - intHighPlacesFriends)
                                                .ToString(GlobalSettings.CultureInfo));
                }

                sbdContactPoints.Append(strOf).Append(intContactPoints.ToString(GlobalSettings.CultureInfo));
                if (CharacterObject.FriendsInHighPlaces)
                {
                    sbdContactPoints.Append('/')
                                    .Append((CharacterObject.CHA.Value * 4).ToString(GlobalSettings.CultureInfo));
                }

                if (intPointsInContacts > 0 || CharacterObject.CHA.Value * 4 < intHighPlacesFriends)
                {
                    sbdContactPoints.Append(strSpace).Append('(')
                                    .Append(intPointsInContacts.ToString(GlobalSettings.CultureInfo)).Append(strSpace)
                                    .Append(strPoints).Append(')');
                }

                string strContactPoints = sbdContactPoints.ToString();
                await lblContactsBP.DoThreadSafeAsync(x => x.Text = strContactPoints, token);
                await lblContactPoints.DoThreadSafeAsync(x => x.Text = strContactPoints, token);
            }
            
            string strTemp = await BuildAttributes(CharacterObject.AttributeSection.AttributeList);
            token.ThrowIfCancellationRequested();
            await lblAttributesBP.DoThreadSafeAsync(x => x.Text = strTemp, token);
            string strTemp2 = await BuildAttributes(CharacterObject.AttributeSection.SpecialAttributeList, null, true);
            token.ThrowIfCancellationRequested();
            await lblPBuildSpecial.DoThreadSafeAsync(x => x.Text = strTemp2, token);
            await lblMartialArtsBP.DoThreadSafeAsync(x => x.Text = intMartialArtsPoints.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints, token);
            await lblNuyenBP.DoThreadSafeAsync(x => x.Text = intNuyenBP.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints, token);
            await lblFociBP.DoThreadSafeAsync(x => x.Text = intFociPointsUsed.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints, token);
            await lblSpiritsBP.DoThreadSafeAsync(x => x.Text = intSpiritPointsUsed.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints, token);
            await lblSpritesBP.DoThreadSafeAsync(x => x.Text = intSpritePointsUsed.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints, token);
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                          out StringBuilder sbdComplexFormsBP))
            {
                if (CharacterObject.CFPLimit > 0)
                {
                    sbdComplexFormsBP.Append(intFormsPointsUsed.ToString(GlobalSettings.CultureInfo)).Append(strOf)
                                     .Append(CharacterObject.CFPLimit.ToString(GlobalSettings.CultureInfo));
                    if (intFormsPointsUsed > CharacterObject.CFPLimit)
                    {
                        sbdComplexFormsBP.Append(strColon).Append(strSpace)
                                         .Append(((intFormsPointsUsed - CharacterObject.CFPLimit)
                                                  * CharacterObject.ComplexFormKarmaCost)
                                                 .ToString(GlobalSettings.CultureInfo)).Append(strSpace)
                                         .Append(strPoints);
                    }
                }
                else
                {
                    sbdComplexFormsBP
                        .Append(((intFormsPointsUsed - CharacterObject.CFPLimit) * CharacterObject.ComplexFormKarmaCost)
                                .ToString(GlobalSettings.CultureInfo)).Append(strSpace).Append(strPoints);
                }
                await lblComplexFormsBP.DoThreadSafeAsync(x => x.Text = sbdComplexFormsBP.ToString(), token);
            }
            await lblAINormalProgramsBP.DoThreadSafeAsync(
                x => x.Text = ((intAINormalProgramPointsUsed - CharacterObject.AINormalProgramLimit)
                               * CharacterObject.AIProgramKarmaCost).ToString(GlobalSettings.CultureInfo) + strSpace
                    + strPoints, token);
            await lblAIAdvancedProgramsBP.DoThreadSafeAsync(
                x => x.Text = ((intAIAdvancedProgramPointsUsed - CharacterObject.AIAdvancedProgramLimit)
                               * CharacterObject.AIAdvancedProgramKarmaCost).ToString(GlobalSettings.CultureInfo)
                              + strSpace + strPoints, token);
            await lblInitiationBP.DoThreadSafeAsync(x => x.Text = intInitiationPoints.ToString(GlobalSettings.CultureInfo)
                                                                  + strSpace + strPoints, token);
            // ------------------------------------------------------------------------------
            // Update the number of BP remaining in the StatusBar.
            Color objControlTextColor = await ColorManager.ControlTextAsync;
            await tsMain.DoThreadSafeAsync(() =>
            {
                tslKarmaRemaining.Text = intKarmaPointsRemain.ToString(GlobalSettings.CultureInfo);
                if (_blnFreestyle)
                {
                    tslKarma.Text = Math.Max(intFreestyleBP, intFreestyleBPMin).ToString(GlobalSettings.CultureInfo);
                    tslKarma.ForeColor = intFreestyleBP < intFreestyleBPMin
                        ? ColorManager.ErrorColor
                        : objControlTextColor;
                }
                else
                {
                    tslKarma.Text = CharacterObjectSettings.BuildKarma.ToString(GlobalSettings.CultureInfo);
                    tslKarma.ForeColor = objControlTextColor;
                }
            }, token);

            return intKarmaPointsRemain;
        }

        private async Task UpdateSkillRelatedInfo(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strKarma = await LanguageManager.GetStringAsync("String_Karma");
            string strOf = await LanguageManager.GetStringAsync("String_Of");
            string strColon = await LanguageManager.GetStringAsync("String_Colon");
            string strSpace = await LanguageManager.GetStringAsync("String_Space");
            string strZeroKarma = 0.ToString(GlobalSettings.CultureInfo) + strSpace + strKarma;
            //Update Skill Labels
            //Active skills
            string strTemp = strZeroKarma;
            int intActiveSkillPointsMaximum = CharacterObject.SkillsSection.SkillPointsMaximum;
            if (intActiveSkillPointsMaximum > 0)
            {
                strTemp = CharacterObject.SkillsSection.SkillPoints.ToString(GlobalSettings.CultureInfo) + strOf + intActiveSkillPointsMaximum.ToString(GlobalSettings.CultureInfo);
            }
            int intActiveSkillsTotalCostKarma = CharacterObject.SkillsSection.Skills.TotalCostKarma();
            if (intActiveSkillsTotalCostKarma > 0)
            {
                if (strTemp != strZeroKarma)
                {
                    strTemp += strColon + strSpace + intActiveSkillsTotalCostKarma.ToString(GlobalSettings.CultureInfo) + strSpace + strKarma;
                }
                else
                {
                    strTemp = intActiveSkillsTotalCostKarma.ToString(GlobalSettings.CultureInfo) + strSpace + strKarma;
                }
            }
            await lblActiveSkillsBP.DoThreadSafeAsync(x => x.Text = strTemp, token);
            //Knowledge skills
            string strTemp2 = strZeroKarma;
            int intKnowledgeSkillPointsMaximum = CharacterObject.SkillsSection.KnowledgeSkillPoints;
            if (intKnowledgeSkillPointsMaximum > 0)
            {
                strTemp2 = CharacterObject.SkillsSection.KnowledgeSkillPointsRemain.ToString(GlobalSettings.CultureInfo) + strOf + intKnowledgeSkillPointsMaximum.ToString(GlobalSettings.CultureInfo);
            }
            int intKnowledgeSkillsTotalCostKarma = CharacterObject.SkillsSection.KnowledgeSkills.TotalCostKarma();
            if (intKnowledgeSkillsTotalCostKarma > 0)
            {
                if (strTemp2 != strZeroKarma)
                {
                    strTemp2 += strColon + strSpace + intKnowledgeSkillsTotalCostKarma.ToString(GlobalSettings.CultureInfo) + strSpace + strKarma;
                }
                else
                {
                    strTemp2 = intKnowledgeSkillsTotalCostKarma.ToString(GlobalSettings.CultureInfo) + strSpace + strKarma;
                }
            }
            await lblKnowledgeSkillsBP.DoThreadSafeAsync(x => x.Text = strTemp2, token);
            //Groups
            string strTemp3 = strZeroKarma;
            int intSkillGroupPointsMaximum = CharacterObject.SkillsSection.SkillGroupPointsMaximum;
            if (intSkillGroupPointsMaximum > 0)
            {
                strTemp3 = CharacterObject.SkillsSection.SkillGroupPoints.ToString(GlobalSettings.CultureInfo) + strOf + intSkillGroupPointsMaximum.ToString(GlobalSettings.CultureInfo);
            }
            int intSkillGroupsTotalCostKarma = CharacterObject.SkillsSection.SkillGroups.TotalCostKarma();
            if (intSkillGroupsTotalCostKarma > 0)
            {
                if (strTemp3 != strZeroKarma)
                {
                    strTemp3 += strColon + strSpace + intSkillGroupsTotalCostKarma.ToString(GlobalSettings.CultureInfo) + strSpace + strKarma;
                }
                else
                {
                    strTemp3 = intSkillGroupsTotalCostKarma.ToString(GlobalSettings.CultureInfo) + strSpace + strKarma;
                }
            }
            await lblSkillGroupsBP.DoThreadSafeAsync(x => x.Text = strTemp3, token);
        }

        private bool _blnFileUpdateQueued;

        protected override async void LiveUpdateFromCharacterFile(object sender, FileSystemEventArgs e)
        {
            if (_blnFileUpdateQueued)
                return;
            _blnFileUpdateQueued = true;
            try
            {
                while (IsDirty || IsLoading || SkipUpdate || IsCharacterUpdateRequested)
                    await Utils.SafeSleepAsync(GenericToken);

                string strCharacterFile = CharacterObject.FileName;
                if (string.IsNullOrEmpty(strCharacterFile) || !File.Exists(strCharacterFile))
                    return;

                // Character is not dirty and their savefile was updated outside of Chummer5 while it is open, so reload them
                using (await CursorWait.NewAsync(this, true))
                {
                    using (await CursorWait.NewAsync(this))
                    using (LoadingBar frmLoadingBar = await Program.CreateAndShowProgressBarAsync(
                               Path.GetFileName(CharacterObject.FileName),
                               Character.NumLoadingSections))
                    {
                        SkipUpdate = true;
                        try
                        {
                            await CharacterObject.LoadAsync(frmLoadingBar, token: GenericToken);
                            await frmLoadingBar.PerformStepAsync(await LanguageManager.GetStringAsync("String_UI"),
                                                                 token: GenericToken);

                            await this.DoThreadSafeAsync(() =>
                            {
                                // Select the Magician's Tradition.
                                if (CharacterObject.MagicTradition.Type == TraditionType.MAG)
                                    cboTradition.SelectedValue = CharacterObject.MagicTradition.SourceID;
                                else if (cboTradition.SelectedIndex == -1 && cboTradition.Items.Count > 0)
                                    cboTradition.SelectedIndex = 0;

                                // Select the Technomancer's Stream.
                                if (CharacterObject.MagicTradition.Type == TraditionType.RES)
                                    cboStream.SelectedValue = CharacterObject.MagicTradition.SourceID;
                                else if (cboStream.SelectedIndex == -1 && cboStream.Items.Count > 0)
                                    cboStream.SelectedIndex = 0;
                            }, GenericToken);
                        }
                        finally
                        {
                            SkipUpdate = false;
                        }
                    }

                    // Immediately call character update because we know it's necessary
                    await RequestCharacterUpdate();
                    try
                    {
                        await UpdateCharacterInfoTask;
                    }
                    catch (OperationCanceledException)
                    {
                        return;
                    }

                    IsDirty = false;

                    if (CharacterObject.InternalIdsNeedingReapplyImprovements.Count > 0 && !Utils.IsUnitTest
                        && Program.ShowMessageBox(
                            this, await LanguageManager.GetStringAsync("Message_ImprovementLoadError"),
                            await LanguageManager.GetStringAsync("MessageTitle_ImprovementLoadError"),
                            MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation) == DialogResult.Yes)
                    {
                        await DoReapplyImprovements(CharacterObject.InternalIdsNeedingReapplyImprovements);
                        await CharacterObject.InternalIdsNeedingReapplyImprovements.ClearAsync();
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
            finally
            {
                _blnFileUpdateQueued = false;
            }
        }

        /// <summary>
        /// Update the Character information.
        /// </summary>
        protected override async Task DoUpdateCharacterInfo(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            while (SkipUpdate)
                await Utils.SafeSleepAsync(token);
            SkipUpdate = true;
            try
            {
                Task tskAutosave = Task.CompletedTask;
                if (AutosaveStopWatch.Elapsed.Minutes >= 5 && IsDirty)
                {
                    tskAutosave = AutoSaveCharacter(token);
                }
                using (await CursorWait.NewAsync(this, true, token))
                {
                    // TODO: DataBind these wherever possible

                    // Calculate the number of Build Points remaining.
                    await CalculateBP(true, token);
                    await CalculateNuyen(token);
                    if (CharacterObject.Metatype == "Free Spirit" && !CharacterObject.IsCritter ||
                        CharacterObject.MetatypeCategory.EndsWith("Spirits", StringComparison.Ordinal))
                    {
                        await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblCritterPowerPoints.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = CharacterObject.CalculateFreeSpiritPowerPoints();
                        }, token);
                    }
                    else if (CharacterObject.IsFreeSprite)
                    {
                        await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblCritterPowerPoints.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = CharacterObject.CalculateFreeSpritePowerPoints();
                        }, token);
                    }
                    else
                    {
                        await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCritterPowerPoints.DoThreadSafeAsync(x => x.Visible = false, token);
                    }
                    await Task.WhenAll(RefreshSelectedQuality(token), RefreshSelectedCyberware(token),
                                       RefreshSelectedArmor(token),
                                       RefreshSelectedGear(token), RefreshSelectedDrug(token),
                                       RefreshSelectedLifestyle(token),
                                       RefreshSelectedVehicle(token), RefreshSelectedWeapon(token),
                                       RefreshSelectedSpell(token),
                                       RefreshSelectedComplexForm(token), RefreshSelectedCritterPower(token),
                                       RefreshSelectedAIProgram(token), RefreshSelectedMetamagic(token),
                                       RefreshSelectedMartialArt(token), UpdateInitiationCost(token),
                                       UpdateSkillRelatedInfo(token));
                    await tskAutosave;
                }
            }
            finally
            {
                SkipUpdate = false;
            }
        }

        /// <summary>
        /// Calculate the amount of Nuyen the character has remaining.
        /// </summary>
        private async ValueTask<decimal> CalculateNuyen(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            decimal decDeductions = 0;
            decimal decStolenDeductions = 0;
            decimal decStolenNuyenAllowance
                = await ImprovementManager.ValueOfAsync(CharacterObject, Improvement.ImprovementType.Nuyen,
                                                        strImprovedName: "Stolen");
            token.ThrowIfCancellationRequested();
            //If the character has the Stolen Gear quality or something similar, we need to handle the nuyen a little differently.
            if (decStolenNuyenAllowance != 0)
            {
                decDeductions
                    += await CharacterObject.Cyberware.SumParallelAsync(x => x.NonStolenTotalCost, token)
                       + await CharacterObject.Armor.SumParallelAsync(x => x.NonStolenTotalCost, token)
                       + await CharacterObject.Weapons.SumParallelAsync(x => x.NonStolenTotalCost, token)
                       + await CharacterObject.Gear.SumParallelAsync(x => x.NonStolenTotalCost, token)
                       + await CharacterObject.Vehicles.SumParallelAsync(x => x.NonStolenTotalCost, token)
                       + await CharacterObject.Drugs.SumParallelAsync(x => x.NonStolenTotalCost, token);
                decStolenDeductions
                    += await CharacterObject.Cyberware.SumParallelAsync(x => x.StolenTotalCost, token)
                       + await CharacterObject.Armor.SumParallelAsync(x => x.StolenTotalCost, token)
                       + await CharacterObject.Weapons.SumParallelAsync(x => x.StolenTotalCost, token)
                       + await CharacterObject.Gear.SumParallelAsync(x => x.StolenTotalCost, token)
                       + await CharacterObject.Vehicles.SumParallelAsync(x => x.StolenTotalCost, token)
                       + await CharacterObject.Drugs.SumParallelAsync(x => x.StolenTotalCost, token);
            }
            else
            {
                decDeductions += await CharacterObject.Cyberware.SumParallelAsync(x => x.TotalCost, token)
                                 + await CharacterObject.Armor.SumParallelAsync(x => x.TotalCost, token)
                                 + await CharacterObject.Weapons.SumParallelAsync(x => x.TotalCost, token)
                                 + await CharacterObject.Gear.SumParallelAsync(x => x.TotalCost, token)
                                 + await CharacterObject.Vehicles.SumParallelAsync(x => x.TotalCost, token)
                                 + await CharacterObject.Drugs.SumParallelAsync(x => x.TotalCost, token);
            }

            token.ThrowIfCancellationRequested();
            // Initiation Grade cost.
            decDeductions += await CharacterObject.Lifestyles.SumParallelAsync(x => x.TotalCost, token)
                             + 10000 * await CharacterObject.InitiationGrades.CountAsync(x => x.Schooling, token);
            token.ThrowIfCancellationRequested();

            CharacterObject.StolenNuyen = decStolenNuyenAllowance - decStolenDeductions;
            return CharacterObject.Nuyen = CharacterObject.TotalStartingNuyen - decDeductions;
        }

        /// <summary>
        /// Refresh the information for the currently displayed piece of Cyberware.
        /// </summary>
        private async Task RefreshSelectedCyberware(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpCyberware.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                TreeNode objSelectedNode = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, token);
                object objSelectedNodeTag = objSelectedNode?.Tag;
                if (objSelectedNodeTag == null || objSelectedNode.Level == 0)
                {
                    await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbCyberwareMatrix.DoThreadSafeAsync(x => x.Visible = false, token);

                    // Buttons
                    await cmdDeleteCyberware.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                    return;
                }
                if (objSelectedNodeTag is IHasRating objHasRating)
                {
                    string strText = string.Format(
                        GlobalSettings.CultureInfo,
                        await LanguageManager.GetStringAsync(
                            "Label_RatingFormat"),
                        await LanguageManager.GetStringAsync(
                            objHasRating.RatingLabel));
                    await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                }
                string strESSFormat = CharacterObjectSettings.EssenceFormat;
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblCyberwareSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblCyberwareSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblCyberwareSource, token);
                }
                else
                {
                    await lblCyberwareSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblCyberwareSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                if (objSelectedNodeTag is IHasStolenProperty loot && (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(
                            CharacterObject,
                            Improvement.ImprovementType.Nuyen, "Stolen"))
                                                                     .Count > 0)
                {
                    await chkCyberwareStolen.DoThreadSafeAsync(x => x.Visible = true, token);
                    await chkCyberwareStolen.DoThreadSafeAsync(x => x.Checked = loot.Stolen, token);
                }
                else
                {
                    await chkCyberwareStolen.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                switch (objSelectedNodeTag)
                {
                    // Locate the selected piece of Cyberware.
                    case Cyberware objCyberware:
                    {
                        await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbCyberwareMatrix.DoThreadSafeAsync(x => x.Visible = objCyberware.SourceType == Improvement.ImprovementSource.Cyberware, token);

                        // Buttons
                        await cmdDeleteCyberware.DoThreadSafeAsync(x => x.Enabled = string.IsNullOrEmpty(objCyberware.ParentID), token);

                        // gpbCyberwareCommon
                        await lblCyberwareName.DoThreadSafeAsync(x => x.Text = objCyberware.CurrentDisplayName, token);
                        string strText = await objCyberware.DisplayCategoryAsync(GlobalSettings.Language);
                        await lblCyberwareCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        // Cyberware Grade is not available for Genetech items.
                        // Cyberware Grade is only available on root-level items (sub-components cannot have a different Grade than the piece they belong to).
                        await cboCyberwareGrade.DoThreadSafeAsync(x => x.Enabled = objCyberware.Parent == null
                                                                      && !objCyberware.Suite
                                                                      && string.IsNullOrWhiteSpace(
                                                                          objCyberware.ForceGrade), token);
                        bool blnIgnoreSecondHand
                            = (await objCyberware.GetNodeXPathAsync())?.SelectSingleNode("nosecondhand") != null;
                        await PopulateCyberwareGradeList(
                            objCyberware.SourceType == Improvement.ImprovementSource.Bioware,
                            blnIgnoreSecondHand,
                            await cboCyberwareGrade.DoThreadSafeFuncAsync(x => x.Enabled, token) ? string.Empty : objCyberware.Grade.Name);
                        await lblCyberwareGradeLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await cboCyberwareGrade.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.SelectedValue = objCyberware.Grade.Name;
                            if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                x.SelectedIndex = 0;
                        }, token);
                        await lblCyberwareEssenceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblCyberwareEssence.DoThreadSafeAsync(x => x.Visible = true, token);
                        if (objCyberware.Parent == null || objCyberware.AddToParentESS)
                        {
                            decimal decCalculatedEss = await objCyberware.CalculatedESSAsync;
                            if (objCyberware.Parent == null)
                                await lblCyberwareEssence.DoThreadSafeAsync(x => x.Text = decCalculatedEss.ToString(strESSFormat, GlobalSettings.CultureInfo), token);
                            else
                                await lblCyberwareEssence.DoThreadSafeAsync(x => x.Text = '+' + decCalculatedEss.ToString(strESSFormat, GlobalSettings.CultureInfo), token);
                        }
                        else
                            await lblCyberwareEssence.DoThreadSafeAsync(x => x.Text = 0.0m.ToString(strESSFormat, GlobalSettings.CultureInfo), token);
                        await lblCyberwareAvail.DoThreadSafeAsync(x => x.Text = objCyberware.DisplayTotalAvail, token);
                        await cmdCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = !string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount), token);
                        // Enable and set the Rating values as needed.
                        if (objCyberware.MaxRating == 0)
                        {
                            await nudCyberwareRating.DoThreadSafeAsync(x =>
                            {
                                x.Maximum = 0;
                                x.Minimum = 0;
                                x.Value = 0;
                                x.Visible = false;
                            }, token);
                            await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await nudCyberwareRating.DoThreadSafeAsync(x =>
                            {
                                x.Maximum = objCyberware.MaxRating;
                                x.Minimum = objCyberware.MinRating;
                                x.Value = objCyberware.Rating;
                                x.Visible = true;
                                x.Enabled = x.Maximum != x.Minimum
                                            && string.IsNullOrEmpty(objCyberware.ParentID);
                            }, token);
                            await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblCyberwareCapacity.DoThreadSafeAsync(x => x.Text = objCyberware.DisplayCapacity, token);
                        await lblCyberwareCost.DoThreadSafeAsync(x => x.Text
                                                                     = objCyberware.TotalCost.ToString(
                                                                         CharacterObjectSettings.NuyenFormat,
                                                                         GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        if (objCyberware.Category.Equals("Cyberlimb", StringComparison.Ordinal)
                            || objCyberware.AllowedSubsystems.Contains("Cyberlimb"))
                        {
                            await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblCyberlimbAGI.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objCyberware.GetAttributeTotalValue("AGI").ToString(GlobalSettings.CultureInfo);
                            }, token);
                            await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblCyberlimbSTR.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objCyberware.GetAttributeTotalValue("STR")
                                                     .ToString(GlobalSettings.CultureInfo);
                            }, token);
                        }
                        else
                        {
                            await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblCyberlimbAGI.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblCyberlimbSTR.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = CharacterObject.GenerateBlackMarketMappings(
                                                                 await (await CharacterObject
                                                                         .LoadDataXPathAsync(
                                                                             objCyberware.SourceType
                                                                             == Improvement.ImprovementSource.Cyberware
                                                                                 ? "cyberware.xml"
                                                                                 : "bioware.xml", token: token))
                                                                     .SelectSingleNodeAndCacheExpressionAsync(
                                                                         "/chummer"))
                                                             .Contains(objCyberware.Category);
                            await chkCyberwareBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = !string.IsNullOrEmpty(objCyberware.ParentID)
                                    ? objCyberware.Parent?.DiscountCost == true
                                    : objCyberware.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkCyberwareBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await chkPrototypeTranshuman.DoThreadSafeAsync(x =>
                        {
                            x.Visible = CharacterObject.IsPrototypeTranshuman;
                            x.Enabled = objCyberware.Parent == null
                                        && objCyberware.SourceType == Improvement.ImprovementSource.Bioware;
                            x.Checked = objCyberware.PrototypeTranshuman && CharacterObject.IsPrototypeTranshuman;
                        }, token);
                        token.ThrowIfCancellationRequested();
                        // gpbCyberwareMatrix
                        if (await gpbCyberwareMatrix.DoThreadSafeFuncAsync(x => x.Visible, token))
                        {
                            int intDeviceRating = objCyberware.GetTotalMatrixAttribute("Device Rating");
                            await lblCyberDeviceRating.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                            await objCyberware.RefreshMatrixAttributeComboBoxesAsync(
                                cboCyberwareAttack, cboCyberwareSleaze, cboCyberwareDataProcessing,
                                cboCyberwareFirewall, token);

                            await chkCyberwareActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Visible = objCyberware.IsCommlink;
                                x.Checked = objCyberware.IsActiveCommlink(CharacterObject);
                            }, token);
                            if (CharacterObject.IsAI)
                            {
                                await chkCyberwareHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = objCyberware.IsHomeNode(CharacterObject);
                                    x.Enabled = chkCyberwareActiveCommlink.Visible &&
                                                objCyberware.GetTotalMatrixAttribute("Program Limit")
                                                >= (CharacterObject.DEP.TotalValue > intDeviceRating
                                                    ? 2
                                                    : 1);
                                }, token);
                            }
                            else
                                await chkCyberwareHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await treCyberware.DoThreadSafeAsync(() => objSelectedNode.Text = objCyberware.CurrentDisplayName, token);
                        break;
                    }
                    case Gear objGear:
                    {
                        await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbCyberwareMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteCyberware.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token);
                        // gpbCyberwareCommon
                        await lblCyberwareName.DoThreadSafeAsync(x => x.Text = objGear.CurrentDisplayNameShort, token);
                        await lblCyberwareCategory.DoThreadSafeAsync(x => x.Text = objGear.DisplayCategory(GlobalSettings.Language), token);
                        await lblCyberwareGradeLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cboCyberwareGrade.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberwareEssenceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberwareEssence.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberwareAvail.DoThreadSafeAsync(x => x.Text = objGear.DisplayTotalAvail, token);
                        await cmdCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        int intGearMaxRatingValue = objGear.MaxRatingValue;
                        if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                        {
                            int intGearMinRatingValue = objGear.MinRatingValue;
                            await nudCyberwareRating.DoThreadSafeAsync(x =>
                            {
                                if (objGear.MinRatingValue > 0)
                                    x.Minimum = intGearMinRatingValue;
                                else if (intGearMinRatingValue == 0 && objGear.Name.Contains("Credstick,"))
                                    x.Minimum = 0;
                                else
                                    x.Minimum = 1;
                                x.Maximum = intGearMaxRatingValue;
                                x.Value = objGear.Rating;
                                x.Enabled = nudCyberwareRating.Minimum != nudCyberwareRating.Maximum
                                            && string.IsNullOrEmpty(objGear.ParentID);
                                x.Visible = true;
                            }, token);
                            await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        }
                        else
                        {
                            await nudCyberwareRating.DoThreadSafeAsync(x =>
                            {
                                x.Minimum = 0;
                                x.Maximum = 0;
                                x.Visible = false;
                            }, token);
                            await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        await lblCyberwareCapacity.DoThreadSafeAsync(x => x.Text = objGear.DisplayCapacity, token);
                        await lblCyberwareCost.DoThreadSafeAsync(x => x.Text =
                                                                     objGear.TotalCost.ToString(CharacterObjectSettings.NuyenFormat, GlobalSettings.CultureInfo)
                                                                     + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberlimbAGI.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblCyberlimbSTR.DoThreadSafeAsync(x => x.Visible = false, token);
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = !objGear.IncludedInParent && CharacterObject
                                                                           .GenerateBlackMarketMappings(
                                                                               await (await CharacterObject
                                                                                       .LoadDataXPathAsync("gear.xml", token: token))
                                                                                   .SelectSingleNodeAndCacheExpressionAsync(
                                                                                       "/chummer"))
                                                                           .Contains(objGear.Category);
                            await chkCyberwareBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objGear.IncludedInParent
                                    ? (objGear.Parent as ICanBlackMarketDiscount)?.DiscountCost == true
                                    : objGear.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkCyberwareBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await chkPrototypeTranshuman.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // gpbCyberwareMatrix
                        int intDeviceRating = objGear.GetTotalMatrixAttribute("Device Rating");
                        await lblCyberDeviceRating.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objGear.RefreshMatrixAttributeComboBoxesAsync(cboCyberwareAttack, cboCyberwareSleaze,
                                                                            cboCyberwareDataProcessing,
                                                                            cboCyberwareFirewall, token);
                        token.ThrowIfCancellationRequested();
                        await chkCyberwareActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objGear.IsCommlink;
                            x.Checked = objGear.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkCyberwareHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objGear.IsHomeNode(CharacterObject);
                                x.Enabled = chkCyberwareActiveCommlink.Visible
                                            && objGear.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating
                                                ? 2
                                                : 1);
                            }, token);
                        }
                        else
                            await chkCyberwareHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        await treCyberware.DoThreadSafeAsync(() => objSelectedNode.Text = objGear.CurrentDisplayName, token);
                        break;
                    }
                }
            }
            finally
            {
                await flpCyberware.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Weapon.
        /// </summary>
        private async Task RefreshSelectedWeapon(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpWeapons.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, token);
                object objSelectedNodeTag = objSelectedNode?.Tag;
                if (objSelectedNodeTag == null || objSelectedNode.Level <= 0)
                {
                    await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                    token.ThrowIfCancellationRequested();
                    // Buttons
                    await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                    return;
                }
                string strSpace = await LanguageManager.GetStringAsync("String_Space");
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblWeaponSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblWeaponSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblWeaponSource, token);
                }
                else
                {
                    await lblWeaponSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblWeaponSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                if (objSelectedNodeTag is IHasRating objHasRating)
                {
                    string strText = string.Format(
                        GlobalSettings.CultureInfo,
                        await LanguageManager.GetStringAsync(
                            "Label_RatingFormat"),
                        await LanguageManager.GetStringAsync(
                            objHasRating.RatingLabel));
                    await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                }
                if (objSelectedNodeTag is IHasStolenProperty loot
                    && (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(
                            CharacterObject,
                            Improvement.ImprovementType.Nuyen,
                            "Stolen")).Count > 0)
                {
                    await chkWeaponStolen.DoThreadSafeAsync(x => x.Visible = true, token);
                    await chkWeaponStolen.DoThreadSafeAsync(x => x.Checked = loot.Stolen, token);
                }
                else
                {
                    await chkWeaponStolen.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                switch (objSelectedNodeTag)
                {
                    case Weapon objWeapon:
                    {
                        await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = !objWeapon.IncludedInWeapon &&
                                                                    !objWeapon.Cyberware &&
                                                                    objWeapon.Category != "Gear" &&
                                                                    !objWeapon.Category.StartsWith(
                                                                        "Quality", StringComparison.Ordinal) &&
                                                                    string.IsNullOrEmpty(objWeapon.ParentID), token);
                        token.ThrowIfCancellationRequested();
                        // gpbWeaponsCommon
                        await lblWeaponName.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayName, token);
                        string strText = await objWeapon.DisplayCategoryAsync(GlobalSettings.Language);
                        await lblWeaponCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponCapacity.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponAvail.DoThreadSafeAsync(x => x.Text = objWeapon.DisplayTotalAvail, token);
                        await lblWeaponCost.DoThreadSafeAsync(x => x.Text
                                                                  = objWeapon.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                      GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponSlots.DoThreadSafeAsync(x => x.Visible = true, token);
                        if (!string.IsNullOrWhiteSpace(objWeapon.AccessoryMounts))
                        {
                            if (!GlobalSettings.Language.Equals(GlobalSettings.DefaultLanguage,
                                                                StringComparison.OrdinalIgnoreCase))
                            {
                                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdSlotsText))
                                {
                                    foreach (string strMount in objWeapon.AccessoryMounts.SplitNoAlloc(
                                                 '/', StringSplitOptions.RemoveEmptyEntries))
                                        sbdSlotsText
                                            .Append(await LanguageManager.GetStringAsync("String_Mount" + strMount))
                                            .Append('/');
                                    if (sbdSlotsText.Length > 0)
                                        --sbdSlotsText.Length;
                                    await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = sbdSlotsText.ToString(), token);
                                }
                            }
                            else
                                await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = objWeapon.AccessoryMounts, token);
                        }
                        else
                        {
                            string strNone = await LanguageManager.GetStringAsync("String_None");
                            await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = strNone, token);
                        }

                        token.ThrowIfCancellationRequested();
                        await lblWeaponConcealLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponConceal.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objWeapon.DisplayConcealability;
                        }, token);
                        strText = await LanguageManager.GetStringAsync(objWeapon.Parent == null
                                                                           ? "Checkbox_Equipped"
                                                                           : "Checkbox_Installed");
                        await chkWeaponEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = !objWeapon.IncludedInWeapon;
                            x.Checked = objWeapon.Equipped;
                        }, token);
                        await chkIncludedInWeapon.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objWeapon.Parent != null;
                            x.Enabled = false;
                            x.Checked = objWeapon.IncludedInWeapon;
                        }, token);
                        token.ThrowIfCancellationRequested();
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = !objWeapon.IncludedInWeapon && CharacterObject
                                                                             .GenerateBlackMarketMappings(
                                                                                 await (await CharacterObject
                                                                                         .LoadDataXPathAsync(
                                                                                             "weapons.xml", token: token))
                                                                                     .SelectSingleNodeAndCacheExpressionAsync(
                                                                                         "/chummer"))
                                                                             .Contains(objWeapon.Category);
                            await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objWeapon.IncludedInWeapon
                                    ? objWeapon.Parent?.DiscountCost == true
                                    : objWeapon.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        // gpbWeaponsWeapon
                        strText = await LanguageManager.GetStringAsync("String_Weapon");
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Text = strText, token);
                        await lblWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponDamage.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objWeapon.DisplayDamage;
                        }, token);
                        await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponAP.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objWeapon.DisplayTotalAP;
                        }, token);
                        await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponAccuracy.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objWeapon.DisplayAccuracy;
                        }, token);
                        await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponDicePool.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objWeapon.DicePool.ToString(GlobalSettings.CultureInfo);
                        }, token);
                        await lblWeaponDicePool.SetToolTipAsync(objWeapon.DicePoolTooltip, token);
                        if (objWeapon.RangeType == "Ranged")
                        {
                            await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponRC.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.DisplayTotalRC;
                            }, token);
                            await lblWeaponRC.SetToolTipAsync(objWeapon.RCToolTip, token);
                            await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponAmmo.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.DisplayAmmo;
                            }, token);
                            await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponMode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.DisplayMode;
                            }, token);

                            await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponRangeMain.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayRange, token);
                            await lblWeaponRangeAlternate.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayAlternateRange, token);
                            Dictionary<string, string> dictionaryRanges
                                = objWeapon.GetRangeStrings(GlobalSettings.CultureInfo);
                            await lblWeaponRangeShortLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Short"), token);
                            await lblWeaponRangeMediumLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Medium"), token);
                            await lblWeaponRangeLongLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Long"), token);
                            await lblWeaponRangeExtremeLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Extreme"), token);
                            await lblWeaponRangeShort.DoThreadSafeAsync(x => x.Text = dictionaryRanges["short"], token);
                            await lblWeaponRangeMedium.DoThreadSafeAsync(x => x.Text = dictionaryRanges["medium"], token);
                            await lblWeaponRangeLong.DoThreadSafeAsync(x => x.Text = dictionaryRanges["long"], token);
                            await lblWeaponRangeExtreme.DoThreadSafeAsync(x => x.Text = dictionaryRanges["extreme"], token);
                            await lblWeaponAlternateRangeShort.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternateshort"], token);
                            await lblWeaponAlternateRangeMedium.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternatemedium"], token);
                            await lblWeaponAlternateRangeLong.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternatelong"], token);
                            await lblWeaponAlternateRangeExtreme.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternateextreme"], token);
                        }
                        else
                        {
                            await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponReach.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.TotalReach.ToString(GlobalSettings.CultureInfo);
                            }, token);
                            await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponRC.DoThreadSafeAsync(x => x.Visible = false, token);
                            if (objWeapon.Ammo != "0")
                            {
                                await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblWeaponAmmo.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objWeapon.DisplayAmmo;
                                }, token);
                            }
                            else
                            {
                                await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token);
                            }
                            await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token);
                            await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        // gpbWeaponsMatrix
                        int intDeviceRating = objWeapon.GetTotalMatrixAttribute("Device Rating");
                        await lblWeaponDeviceRating.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await lblWeaponAttack.DoThreadSafeAsync(x => x.Text = objWeapon.GetTotalMatrixAttribute("Attack")
                                                                    .ToString(GlobalSettings.CultureInfo), token);
                        await lblWeaponSleaze.DoThreadSafeAsync(x => x.Text = objWeapon.GetTotalMatrixAttribute("Sleaze")
                                                                    .ToString(GlobalSettings.CultureInfo), token);
                        await lblWeaponDataProcessing.DoThreadSafeAsync(x => x.Text = objWeapon.GetTotalMatrixAttribute("Data Processing")
                                                                            .ToString(GlobalSettings.CultureInfo), token);
                        await lblWeaponFirewall.DoThreadSafeAsync(x => x.Text = objWeapon.GetTotalMatrixAttribute("Firewall")
                                                                      .ToString(GlobalSettings.CultureInfo), token);
                        await chkWeaponActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objWeapon.IsCommlink;
                            x.Checked = objWeapon.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkWeaponHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objWeapon.IsHomeNode(CharacterObject);
                                x.Enabled = objWeapon.IsCommlink &&
                                            objWeapon.GetTotalMatrixAttribute("Program Limit") >=
                                            (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                            }, token);
                        }
                        else
                            await chkWeaponHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        break;
                    }
                    case WeaponAccessory objSelectedAccessory:
                    {
                        await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = !objSelectedAccessory.IncludedInWeapon &&
                                                                    string.IsNullOrEmpty(objSelectedAccessory.ParentID), token);
                        // gpbWeaponsCommon
                        await lblWeaponName.DoThreadSafeAsync(x => x.Text = objSelectedAccessory.CurrentDisplayName, token);
                        string strText = await LanguageManager.GetStringAsync("String_WeaponAccessory");
                        await lblWeaponCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        if (objSelectedAccessory.MaxRating > 0)
                        {
                            await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                lblWeaponRating.Text = objSelectedAccessory.Rating.ToString(GlobalSettings.CultureInfo);
                            }, token);
                        }
                        else
                        {
                            await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponCapacity.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponAvail.DoThreadSafeAsync(x => x.Text = objSelectedAccessory.DisplayTotalAvail, token);
                        await lblWeaponCost.DoThreadSafeAsync(x => x.Text
                                                                  = objSelectedAccessory.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                      GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponSlots.DoThreadSafeAsync(x => x.Visible = true, token);
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdSlotsText))
                        {
                            sbdSlotsText.Append(objSelectedAccessory.Mount);
                            if (sbdSlotsText.Length > 0
                                && !GlobalSettings.Language.Equals(GlobalSettings.DefaultLanguage,
                                                                   StringComparison.OrdinalIgnoreCase))
                            {
                                sbdSlotsText.Clear();
                                foreach (string strMount in objSelectedAccessory.Mount.SplitNoAlloc(
                                             '/', StringSplitOptions.RemoveEmptyEntries))
                                    sbdSlotsText.Append(await LanguageManager.GetStringAsync("String_Mount" + strMount))
                                                .Append('/');
                                --sbdSlotsText.Length;
                            }
                            token.ThrowIfCancellationRequested();
                            if (!string.IsNullOrEmpty(objSelectedAccessory.ExtraMount)
                                && objSelectedAccessory.ExtraMount != "None")
                            {
                                bool boolHaveAddedItem = false;
                                foreach (string strCurrentExtraMount in objSelectedAccessory.ExtraMount.SplitNoAlloc(
                                             '/', StringSplitOptions.RemoveEmptyEntries))
                                {
                                    if (!boolHaveAddedItem)
                                    {
                                        sbdSlotsText.Append(strSpace).Append('+').Append(strSpace);
                                        boolHaveAddedItem = true;
                                    }

                                    sbdSlotsText
                                        .Append(await LanguageManager.GetStringAsync(
                                                    "String_Mount" + strCurrentExtraMount))
                                        .Append('/');
                                }

                                // Remove the trailing /
                                if (boolHaveAddedItem)
                                    --sbdSlotsText.Length;
                            }
                            await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = sbdSlotsText.ToString(), token);
                        }
                        await lblWeaponConcealLabel.DoThreadSafeAsync(x => x.Visible = objSelectedAccessory.TotalConcealability != 0, token);
                        await lblWeaponConceal.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objSelectedAccessory.TotalConcealability != 0;
                            x.Text
                                = objSelectedAccessory.TotalConcealability.ToString(
                                    "+#,0;-#,0;0", GlobalSettings.CultureInfo);
                        }, token);
                        strText = await LanguageManager.GetStringAsync(objSelectedAccessory.Parent == null
                                                                           ? "Checkbox_Equipped"
                                                                           : "Checkbox_Installed");
                        await chkWeaponEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = !objSelectedAccessory.IncludedInWeapon;
                            x.Checked = objSelectedAccessory.Equipped;
                        }, token);
                        await chkIncludedInWeapon.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objSelectedAccessory.Parent != null;
                            x.Enabled = CharacterObjectSettings.AllowEditPartOfBaseWeapon;
                            x.Checked = objSelectedAccessory.IncludedInWeapon;
                        }, token);
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = !objSelectedAccessory.IncludedInWeapon
                                              && CharacterObject
                                                 .GenerateBlackMarketMappings(
                                                     await (await CharacterObject
                                                             .LoadDataXPathAsync("weapons.xml", token: token))
                                                         .SelectSingleNodeAndCacheExpressionAsync(
                                                             "/chummer"))
                                                 .Contains(objSelectedAccessory.Parent?.Category);
                            await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objSelectedAccessory.IncludedInWeapon
                                    ? objSelectedAccessory.Parent?.DiscountCost == true
                                    : objSelectedAccessory.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        // gpbWeaponsWeapon
                        strText = await LanguageManager.GetStringAsync("String_WeaponAccessory");
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Text = strText, token);
                        if (string.IsNullOrEmpty(objSelectedAccessory.Damage))
                        {
                            await lblWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponDamage.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = !string.IsNullOrEmpty(objSelectedAccessory.Damage), token);
                            await lblWeaponDamage.DoThreadSafeAsync(x =>
                            {
                                x.Visible = !string.IsNullOrEmpty(objSelectedAccessory
                                                                      .Damage);
                                x.Text = Convert
                                         .ToInt32(objSelectedAccessory.Damage,
                                                  GlobalSettings.InvariantCultureInfo)
                                         .ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (string.IsNullOrEmpty(objSelectedAccessory.AP))
                        {
                            await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponAP.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponAP.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = Convert
                                         .ToInt32(objSelectedAccessory.AP, GlobalSettings.InvariantCultureInfo)
                                         .ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (objSelectedAccessory.Accuracy == 0)
                        {
                            await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponAccuracy.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponAccuracy.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text
                                    = objSelectedAccessory.Accuracy.ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (objSelectedAccessory.DicePool == 0)
                        {
                            await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponDicePool.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponDicePool.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text
                                    = objSelectedAccessory.DicePool.ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token);
                        if (string.IsNullOrEmpty(objSelectedAccessory.RC))
                        {
                            await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponRC.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponRC.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = Convert
                                         .ToInt32(objSelectedAccessory.RC, GlobalSettings.InvariantCultureInfo)
                                         .ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (objSelectedAccessory.TotalAmmoBonus != 0
                            || (!string.IsNullOrEmpty(objSelectedAccessory.ModifyAmmoCapacity)
                                && objSelectedAccessory.ModifyAmmoCapacity != "0"))
                        {
                            await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = true, token);
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdAmmoBonus))
                            {
                                int intAmmoBonus = objSelectedAccessory.TotalAmmoBonus;
                                if (intAmmoBonus != 0)
                                    sbdAmmoBonus.Append(
                                        (intAmmoBonus / 100.0m).ToString("+#,0%;-#,0%;0%", GlobalSettings.CultureInfo));
                                if (!string.IsNullOrEmpty(objSelectedAccessory.ModifyAmmoCapacity)
                                    && objSelectedAccessory.ModifyAmmoCapacity != "0")
                                    sbdAmmoBonus.Append(objSelectedAccessory.ModifyAmmoCapacity);
                                await lblWeaponAmmo.DoThreadSafeAsync(x => x.Text = sbdAmmoBonus.ToString(), token);
                            }
                        }
                        else
                        {
                            await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = false, token);
                        break;
                    }
                    case Gear objGear:
                    {
                        await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token);
                        token.ThrowIfCancellationRequested();
                        // gpbWeaponsCommon
                        await lblWeaponName.DoThreadSafeAsync(x => x.Text = objGear.CurrentDisplayNameShort, token);
                        await lblWeaponCategory.DoThreadSafeAsync(x => x.Text = objGear.DisplayCategory(GlobalSettings.Language), token);
                        int intGearMaxRatingValue = objGear.MaxRatingValue;
                        if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                        {
                            await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblWeaponRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objGear.Rating.ToString(GlobalSettings.CultureInfo);
                            }, token);
                        }
                        else
                        {
                            await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblWeaponRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblWeaponCapacity.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objGear.DisplayCapacity;
                        }, token);
                        await lblWeaponAvail.DoThreadSafeAsync(x => x.Text = objGear.DisplayTotalAvail, token);
                        await lblWeaponCost.DoThreadSafeAsync(x => x.Text
                                                                  = objGear.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                      GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponSlots.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponConcealLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblWeaponConceal.DoThreadSafeAsync(x => x.Visible = false, token);
                        string strText = await LanguageManager.GetStringAsync(
                            "Checkbox_Equipped");
                        await chkWeaponEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = !objGear.IncludedInParent;
                            x.Checked = objGear.Equipped;
                        }, token);
                        await chkIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = !objGear.IncludedInParent && CharacterObject
                                                                           .GenerateBlackMarketMappings(
                                                                               await (await CharacterObject
                                                                                       .LoadDataXPathAsync("gear.xml", token: token))
                                                                                   .SelectSingleNodeAndCacheExpressionAsync(
                                                                                       "/chummer"))
                                                                           .Contains(objGear.Category);
                            await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objGear.IncludedInParent
                                    ? (objGear.Parent as ICanBlackMarketDiscount)?.DiscountCost == true
                                    : objGear.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        // gpbWeaponsMatrix
                        int intDeviceRating = objGear.GetTotalMatrixAttribute("Device Rating");
                        await lblWeaponDeviceRating.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await lblWeaponAttack.DoThreadSafeAsync(x => x.Text = objGear.GetTotalMatrixAttribute("Attack")
                                                                    .ToString(GlobalSettings.CultureInfo), token);
                        await lblWeaponSleaze.DoThreadSafeAsync(x => x.Text = objGear.GetTotalMatrixAttribute("Sleaze")
                                                                    .ToString(GlobalSettings.CultureInfo), token);
                        await lblWeaponDataProcessing.DoThreadSafeAsync(x => x.Text = objGear.GetTotalMatrixAttribute("Data Processing")
                                                                            .ToString(GlobalSettings.CultureInfo), token);
                        await lblWeaponFirewall.DoThreadSafeAsync(x => x.Text = objGear.GetTotalMatrixAttribute("Firewall")
                                                                      .ToString(GlobalSettings.CultureInfo), token);
                        await chkWeaponActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objGear.IsCommlink;
                            x.Checked = objGear.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkWeaponHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objGear.IsHomeNode(CharacterObject);
                                x.Enabled = objGear.IsCommlink &&
                                            objGear.GetTotalMatrixAttribute("Program Limit") >=
                                            (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                            }, token);
                        }
                        else
                            await chkWeaponHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        break;
                    }
                    default:
                        await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        // Buttons
                        await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = false, token);
                        break;
                }
            }
            finally
            {
                await flpWeapons.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Armor.
        /// </summary>
        private async Task RefreshSelectedArmor(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpArmor.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                TreeNode objSelectedNode = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode, token);
                object objSelectedNodeTag = objSelectedNode?.Tag;
                if (objSelectedNodeTag == null)
                {
                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token);
                    // Buttons
                    await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token);
                    return;
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblArmorSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblArmorSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblArmorSource, token);
                }
                else
                {
                    await lblArmorSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblArmorSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasStolenProperty loot && (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(
                            CharacterObject,
                            Improvement.ImprovementType.Nuyen, "Stolen")).Count > 0)
                {
                    await chkArmorStolen.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Checked = loot.Stolen;
                    }, token);
                }
                else
                {
                    await chkArmorStolen.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasRating objHasRating)
                {
                    string strText = string.Format(
                        GlobalSettings.CultureInfo,
                        await LanguageManager.GetStringAsync(
                            "Label_RatingFormat"),
                        await LanguageManager.GetStringAsync(
                            objHasRating.RatingLabel));
                    await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is Armor objArmor)
                {
                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                    await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token);
                    token.ThrowIfCancellationRequested();
                    // Buttons
                    await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = true, token);
                    token.ThrowIfCancellationRequested();
                    // gpbArmorCommon
                    await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblArmorValue.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Text = objArmor.DisplayArmorValue;
                    }, token);
                    await lblArmorAvail.DoThreadSafeAsync(x => x.Text = objArmor.DisplayTotalAvail, token);
                    await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = objArmor.DisplayCapacity, token);
                    await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await nudArmorRating.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblArmorCost.DoThreadSafeAsync(x => x.Text
                                                             = objArmor.TotalCost.ToString(
                                                                   CharacterObjectSettings.NuyenFormat, GlobalSettings.CultureInfo)
                                                               + LanguageManager.GetString("String_NuyenSymbol"), token);
                    await chkArmorEquipped.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Checked = objArmor.Equipped;
                        x.Enabled = true;
                    }, token);
                    await chkIncludedInArmor.DoThreadSafeAsync(x => x.Visible = false, token);
                    token.ThrowIfCancellationRequested();
                    if (CharacterObject.BlackMarketDiscount)
                    {
                        bool blnEnabled = CharacterObject
                                          .GenerateBlackMarketMappings(
                                              await (await CharacterObject.LoadDataXPathAsync(
                                                      "armor.xml", token: token))
                                                  .SelectSingleNodeAndCacheExpressionAsync(
                                                      "/chummer")).Contains(objArmor.Category);
                        await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = blnEnabled;
                            x.Checked = objArmor.DiscountCost;
                        }, token);
                    }
                    else
                    {
                        await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = false;
                            x.Checked = false;
                        }, token);
                    }
                    token.ThrowIfCancellationRequested();
                    // gpbArmorMatrix
                    int intDeviceRating = objArmor.GetTotalMatrixAttribute("Device Rating");
                    await lblArmorDeviceRating.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                    await lblArmorAttack.DoThreadSafeAsync(x => x.Text
                                                               = objArmor.GetTotalMatrixAttribute("Attack").ToString(GlobalSettings.CultureInfo), token);
                    await lblArmorSleaze.DoThreadSafeAsync(x => x.Text
                                                               = objArmor.GetTotalMatrixAttribute("Sleaze").ToString(GlobalSettings.CultureInfo), token);
                    await lblArmorDataProcessing.DoThreadSafeAsync(x => x.Text = objArmor.GetTotalMatrixAttribute("Data Processing")
                                                                       .ToString(GlobalSettings.CultureInfo), token);
                    await lblArmorFirewall.DoThreadSafeAsync(x => x.Text = objArmor.GetTotalMatrixAttribute("Firewall")
                                                                 .ToString(GlobalSettings.CultureInfo), token);
                    await chkArmorActiveCommlink.DoThreadSafeAsync(x =>
                    {
                        x.Visible = objArmor.IsCommlink;
                        x.Checked = objArmor.IsActiveCommlink(CharacterObject);
                    }, token);
                    if (CharacterObject.IsAI)
                    {
                        await chkArmorHomeNode.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objArmor.IsHomeNode(CharacterObject);
                            x.Enabled = objArmor.IsCommlink &&
                                        objArmor.GetTotalMatrixAttribute("Program Limit") >=
                                        (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                        }, token);
                    }
                    else
                        await chkArmorHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                else
                {
                    string strSpace = await LanguageManager.GetStringAsync("String_Space");
                    if (objSelectedNodeTag is ArmorMod objArmorMod)
                    {
                        await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = !objArmorMod.IncludedInArmor, token);
                        token.ThrowIfCancellationRequested();
                        // gpbArmorCommon
                        if (objArmorMod.Armor != 0)
                        {
                            await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblArmorValue.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objArmorMod.Armor.ToString("+0;-0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        else
                        {
                            await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblArmorValue.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblArmorAvail.DoThreadSafeAsync(x => x.Text = objArmorMod.DisplayTotalAvail, token);
                        await lblArmorCapacity.DoThreadSafeAsync(
                            x => x.Text = objArmorMod.Parent.CapacityDisplayStyle == CapacityStyle.Zero
                                ? "[0]"
                                : objArmorMod.CalculatedCapacity, token);
                        if (!string.IsNullOrEmpty(objArmorMod.GearCapacity))
                        {
                            string strText = objArmorMod.GearCapacity + '/'
                                                                      + lblArmorCapacity.Text
                                                                      + strSpace + '('
                                                                      +
                                                                      objArmorMod.GearCapacityRemaining.ToString(
                                                                          "#,0.##", GlobalSettings.CultureInfo) +
                                                                      strSpace
                                                                      + await LanguageManager.GetStringAsync(
                                                                          "String_Remaining") + ')';
                            await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = strText, token);
                        }

                        if (objArmorMod.MaximumRating > 1)
                        {
                            await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await nudArmorRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Maximum = objArmorMod.MaximumRating;
                                x.Value = objArmorMod.Rating;
                                x.Enabled = !objArmorMod.IncludedInArmor;
                            }, token);
                        }
                        else
                        {
                            await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await nudArmorRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblArmorCost.DoThreadSafeAsync(x => x.Text
                                                                 = objArmorMod.TotalCost.ToString(
                                                                     CharacterObjectSettings.NuyenFormat,
                                                                     GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await chkArmorEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objArmorMod.Equipped;
                            x.Enabled = true;
                        }, token);
                        await chkIncludedInArmor.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objArmorMod.IncludedInArmor;
                        }, token);
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = !objArmorMod.IncludedInArmor && CharacterObject
                                                                              .GenerateBlackMarketMappings(
                                                                                  await (await CharacterObject
                                                                                          .LoadDataXPathAsync(
                                                                                              "armor.xml", token: token))
                                                                                      .SelectSingleNodeAndCacheExpressionAsync(
                                                                                          "/chummer/modcategories"))
                                                                              .Contains(objArmorMod.Category);
                            await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objArmorMod.IncludedInArmor
                                    ? objArmorMod.Parent?.DiscountCost == true
                                    : objArmorMod.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                    }
                    else
                    {
                        switch (objSelectedNodeTag)
                        {
                            case Gear objSelectedGear:
                            {
                                await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                                await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                                await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token);
                                token.ThrowIfCancellationRequested();
                                // Buttons
                                await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = !objSelectedGear.IncludedInParent, token);
                                token.ThrowIfCancellationRequested();
                                // gpbArmorCommon
                                await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblArmorValue.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblArmorAvail.DoThreadSafeAsync(x => x.Text = objSelectedGear.DisplayTotalAvail, token);
                                CharacterObject.Armor.FindArmorGear(objSelectedGear.InternalId, out objArmor,
                                                                    out objArmorMod);
                                if (objArmorMod != null)
                                    await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = objSelectedGear.CalculatedCapacity, token);
                                else if (objArmor.CapacityDisplayStyle == CapacityStyle.Zero)
                                    await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = '[' + 0.ToString(GlobalSettings.CultureInfo) + ']', token);
                                else
                                    await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = objSelectedGear.CalculatedArmorCapacity, token);
                                int intMaxRatingValue = objSelectedGear.MaxRatingValue;
                                if (intMaxRatingValue > 1 && intMaxRatingValue != int.MaxValue)
                                {
                                    await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                    await nudArmorRating.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Maximum = intMaxRatingValue;
                                        int intMinRatingValue = objSelectedGear.MinRatingValue;
                                        x.Minimum = intMinRatingValue;
                                        x.Value = objSelectedGear.Rating;
                                        x.Enabled = intMinRatingValue != intMaxRatingValue
                                                    && string.IsNullOrEmpty(objSelectedGear.ParentID);
                                    }, token);
                                }
                                else
                                {
                                    await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                    await nudArmorRating.DoThreadSafeAsync(x => x.Visible = false, token);
                                }

                                await lblArmorCost.DoThreadSafeAsync(x => x.Text
                                                                         = objSelectedGear.TotalCost.ToString(
                                                                             CharacterObjectSettings.NuyenFormat,
                                                                             GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                                await chkArmorEquipped.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = objSelectedGear.Equipped;
                                    x.Enabled = true;
                                }, token);
                                await chkIncludedInArmor.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = objSelectedGear.IncludedInParent;
                                }, token);
                                if (CharacterObject.BlackMarketDiscount)
                                {
                                    bool blnEnabled = !objSelectedGear.IncludedInParent
                                                      && CharacterObject
                                                         .GenerateBlackMarketMappings(
                                                             await (await CharacterObject
                                                                     .LoadDataXPathAsync(
                                                                         "gear.xml", token: token))
                                                                 .SelectSingleNodeAndCacheExpressionAsync(
                                                                     "/chummer"))
                                                         .Contains(objSelectedGear.Category);
                                    await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                                    {
                                        x.Enabled = blnEnabled;
                                        x.Checked = objSelectedGear.IncludedInParent
                                            ? (objSelectedGear.Parent as ICanBlackMarketDiscount)?.DiscountCost == true
                                            : objSelectedGear.DiscountCost;
                                    }, token);
                                }
                                else
                                {
                                    await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                                    {
                                        x.Enabled = false;
                                        x.Checked = false;
                                    }, token);
                                }
                                token.ThrowIfCancellationRequested();
                                // gpbArmorMatrix
                                int intDeviceRating = objSelectedGear.GetTotalMatrixAttribute("Device Rating");
                                await lblArmorDeviceRating.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                                await lblArmorAttack.DoThreadSafeAsync(x => x.Text = objSelectedGear.GetTotalMatrixAttribute("Attack")
                                                                           .ToString(GlobalSettings.CultureInfo), token);
                                await lblArmorSleaze.DoThreadSafeAsync(x => x.Text = objSelectedGear.GetTotalMatrixAttribute("Sleaze")
                                                                           .ToString(GlobalSettings.CultureInfo), token);
                                await lblArmorDataProcessing.DoThreadSafeAsync(x => x.Text = objSelectedGear.GetTotalMatrixAttribute("Data Processing")
                                                                                   .ToString(GlobalSettings.CultureInfo), token);
                                await lblArmorFirewall.DoThreadSafeAsync(x => x.Text = objSelectedGear.GetTotalMatrixAttribute("Firewall")
                                                                             .ToString(GlobalSettings.CultureInfo), token);
                                await chkArmorActiveCommlink.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = objSelectedGear.IsCommlink;
                                    x.Checked = objSelectedGear.IsActiveCommlink(CharacterObject);
                                }, token);
                                if (CharacterObject.IsAI)
                                {
                                    await chkArmorHomeNode.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Checked = objSelectedGear.IsHomeNode(CharacterObject);
                                        x.Enabled = objSelectedGear.IsCommlink &&
                                                    objSelectedGear.GetTotalMatrixAttribute("Program Limit")
                                                    >=
                                                    (CharacterObject.DEP.TotalValue > intDeviceRating
                                                        ? 2
                                                        : 1);
                                    }, token);
                                }
                                else
                                    await chkArmorHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                                token.ThrowIfCancellationRequested();
                                break;
                            }
                            case Location objLocation:
                            {
                                await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                                await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                                await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = true, token);
                                token.ThrowIfCancellationRequested();
                                // Buttons
                                await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = true, token);
                                token.ThrowIfCancellationRequested();
                                // gpbArmorLocation
                                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdArmorEquipped))
                                {
                                    foreach (Armor objLoopArmor in CharacterObject.Armor.Where(
                                                 objLoopArmor =>
                                                     objLoopArmor.Equipped && objLoopArmor.Location == objLocation))
                                    {
                                        sbdArmorEquipped
                                            .Append(objLoopArmor.CurrentDisplayName).Append(strSpace).Append('(')
                                            .Append(objLoopArmor.DisplayArmorValue).AppendLine(')');
                                    }
                                    token.ThrowIfCancellationRequested();
                                    if (sbdArmorEquipped.Length > 0)
                                    {
                                        --sbdArmorEquipped.Length;
                                        await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = sbdArmorEquipped.ToString(), token);
                                    }
                                    else
                                    {
                                        string strNone = await LanguageManager.GetStringAsync("String_None");
                                        await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = strNone, token);
                                    }
                                }
                                token.ThrowIfCancellationRequested();
                                break;
                            }
                            default:
                            {
                                if (objSelectedNodeTag.ToString() == "Node_SelectedArmor")
                                {
                                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                                    await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = true, token);
                                    // Buttons
                                    await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token);
                                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                               out StringBuilder sbdArmorEquipped))
                                    {
                                        foreach (Armor objLoopArmor in CharacterObject.Armor.Where(
                                                     objLoopArmor =>
                                                         objLoopArmor.Equipped && objLoopArmor.Location == null))
                                        {
                                            sbdArmorEquipped.Append(objLoopArmor.CurrentDisplayName).Append(strSpace)
                                                            .Append('(')
                                                            .Append(objLoopArmor.DisplayArmorValue).AppendLine(')');
                                        }
                                        if (sbdArmorEquipped.Length > 0)
                                        {
                                            --sbdArmorEquipped.Length;
                                            await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = sbdArmorEquipped.ToString(), token);
                                        }
                                        else
                                        {
                                            string strNone = await LanguageManager.GetStringAsync("String_None");
                                            await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = strNone, token);
                                        }
                                    }
                                }
                                else
                                {
                                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                                    await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token);
                                    // Buttons
                                    await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token);
                                }
                                break;
                            }
                        }
                    }
                }
            }
            finally
            {
                await flpArmor.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Gear.
        /// </summary>
        private async Task RefreshSelectedGear(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpGear.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, token);
                object objSelectedNodeTag = objSelectedNode?.Tag;
                if (objSelectedNodeTag == null || objSelectedNode.Level == 0)
                {
                    await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                    token.ThrowIfCancellationRequested();
                    // Buttons
                    await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                    return;
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasStolenProperty loot && (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(
                            CharacterObject,
                            Improvement.ImprovementType.Nuyen, "Stolen"))
                                                                     .Count > 0)
                {
                    await chkGearStolen.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Checked = loot.Stolen;
                    }, token);
                }
                else
                {
                    await chkGearStolen.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblGearSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblGearSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblGearSource, token);
                }
                else
                {
                    await lblGearSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblGearSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is IHasRating objHasRating)
                {
                    string strText = string.Format(
                        GlobalSettings.CultureInfo,
                        await LanguageManager.GetStringAsync(
                            "Label_RatingFormat"),
                        await LanguageManager.GetStringAsync(
                            objHasRating.RatingLabel));
                    await lblGearRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                }
                token.ThrowIfCancellationRequested();
                if (objSelectedNodeTag is Gear objGear)
                {
                    await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                    await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = true, token);

                    // Buttons
                    await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token);

                    // gpbGearCommon
                    await lblGearName.DoThreadSafeAsync(x => x.Text = objGear.CurrentDisplayNameShort, token);
                    await lblGearCategory.DoThreadSafeAsync(x => x.Text = objGear.DisplayCategory(GlobalSettings.Language), token);
                    int intGearMaxRatingValue = objGear.MaxRatingValue;
                    if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                    {
                        int intGearMinRatingValue = objGear.MinRatingValue;
                        await nudGearRating.DoThreadSafeAsync(x =>
                        {
                            if (intGearMinRatingValue > 0)
                                x.Minimum = intGearMinRatingValue;
                            else if (intGearMinRatingValue == 0 && objGear.Name.Contains("Credstick,"))
                                x.Minimum = 0;
                            else
                                x.Minimum = 1;
                            x.Maximum = objGear.MaxRatingValue;
                            x.Value = objGear.Rating;
                            x.Enabled = x.Minimum != x.Maximum && string.IsNullOrEmpty(objGear.ParentID);
                        }, token);
                    }
                    else
                    {
                        await nudGearRating.DoThreadSafeAsync(x =>
                        {
                            x.Minimum = 0;
                            x.Maximum = 0;
                            x.Enabled = false;
                        }, token);
                    }
                    await nudGearQty.DoThreadSafeAsync(x => x.Increment = objGear.CostFor, token);
                    if (objGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
                    {
                        int intDecimalPlaces = CharacterObjectSettings.MaxNuyenDecimals;
                        if (intDecimalPlaces <= 0)
                        {
                            await nudGearQty.DoThreadSafeAsync(x =>
                            {
                                x.DecimalPlaces = 0;
                                x.Minimum = 1.0m;
                            }, token);
                        }
                        else
                        {
                            await nudGearQty.DoThreadSafeAsync(x => x.DecimalPlaces = intDecimalPlaces, token);
                            decimal decMinimum = 1.0m;
                            // Need a for loop instead of a power system to maintain exact precision
                            for (int i = 0; i < intDecimalPlaces; ++i)
                                decMinimum /= 10.0m;
                            await nudGearQty.DoThreadSafeAsync(x => x.Minimum = decMinimum, token);
                        }
                    }
                    else if (objGear.Category == "Currency")
                    {
                        await nudGearQty.DoThreadSafeAsync(x =>
                        {
                            x.DecimalPlaces = 2;
                            x.Minimum = 0.01m;
                        }, token);
                    }
                    else
                    {
                        await nudGearQty.DoThreadSafeAsync(x =>
                        {
                            x.DecimalPlaces = 0;
                            x.Minimum = 1.0m;
                        }, token);
                    }
                    await nudGearQty.DoThreadSafeAsync(x =>
                    {
                        x.Value = objGear.Quantity;
                        x.Enabled = !objGear.IncludedInParent;
                    }, token);
                    try
                    {
                        await lblGearCost.DoThreadSafeAsync(x => x.Text
                                                                = objGear.TotalCost.ToString(CharacterObjectSettings.NuyenFormat + LanguageManager.GetString("String_NuyenSymbol"),
                                                                    GlobalSettings.CultureInfo), token);
                    }
                    catch (FormatException)
                    {
                        await lblGearCost.DoThreadSafeAsync(x => x.Text = objGear.Cost + LanguageManager.GetString("String_NuyenSymbol"), token);
                    }
                    await lblGearAvail.DoThreadSafeAsync(x => x.Text = objGear.DisplayTotalAvail, token);
                    await lblGearCapacity.DoThreadSafeAsync(x => x.Text = objGear.DisplayCapacity, token);
                    await chkGearEquipped.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Checked = objGear.Equipped;
                    }, token);
                    // If this is a Program, determine if its parent Gear (if any) is a Commlink. If so, show the Equipped checkbox.
                    if (objGear.IsProgram && objGear.Parent is IHasMatrixAttributes objCommlink
                                          && objCommlink.IsCommlink)
                    {
                        string strText = await LanguageManager.GetStringAsync("Checkbox_SoftwareRunning");
                        await chkGearEquipped.DoThreadSafeAsync(x => x.Text = strText, token);
                    }
                    else
                    {
                        string strText = await LanguageManager.GetStringAsync("Checkbox_Equipped");
                        await chkGearEquipped.DoThreadSafeAsync(x => x.Text = strText, token);
                    }
                    token.ThrowIfCancellationRequested();
                    if (CharacterObject.BlackMarketDiscount)
                    {
                        bool blnEnabled = !objGear.IncludedInParent && CharacterObject
                                                                       .GenerateBlackMarketMappings(
                                                                           await (await CharacterObject
                                                                                   .LoadDataXPathAsync("gear.xml", token: token))
                                                                               .SelectSingleNodeAndCacheExpressionAsync(
                                                                                   "/chummer"))
                                                                       .Contains(objGear.Category);
                        await chkGearBlackMarketDiscount.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = blnEnabled;
                            x.Checked = objGear.IncludedInParent
                                ? (objGear.Parent as ICanBlackMarketDiscount)?.DiscountCost == true
                                : objGear.DiscountCost;
                        }, token);
                    }
                    else
                    {
                        await chkGearBlackMarketDiscount.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = false;
                            x.Checked = false;
                        }, token);
                    }
                    token.ThrowIfCancellationRequested();
                    // gpbGearMatrix
                    int intDeviceRating = objGear.GetTotalMatrixAttribute("Device Rating");
                    await lblGearDeviceRating.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                    await objGear.RefreshMatrixAttributeComboBoxesAsync(cboGearAttack, cboGearSleaze,
                                                                        cboGearDataProcessing, cboGearFirewall, token);
                    await chkGearActiveCommlink.DoThreadSafeAsync(x =>
                    {
                        x.Checked = objGear.IsActiveCommlink(CharacterObject);
                        x.Visible = objGear.IsCommlink;
                    }, token);
                    if (CharacterObject.IsAI)
                    {
                        await chkGearHomeNode.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objGear.IsHomeNode(CharacterObject);
                            x.Enabled = objGear.IsCommlink &&
                                        objGear.GetTotalMatrixAttribute("Program Limit") >=
                                        (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                        }, token);
                    }
                    else
                        await chkGearHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                    token.ThrowIfCancellationRequested();
                    await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = objGear.CurrentDisplayName, token);
                }
                else
                {
                    await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                    // Buttons
                    await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                }
                token.ThrowIfCancellationRequested();
            }
            finally
            {
                await flpGear.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        protected override string FormMode => LanguageManager.GetString("Title_CreateNewCharacter");

        /// <summary>
        /// Save the Character.
        /// </summary>
        public override async ValueTask<bool> SaveCharacter(bool blnNeedConfirm = true, bool blnDoCreated = false, CancellationToken token = default)
        {
            return await base.SaveCharacter(blnNeedConfirm, blnDoCreated || await chkCharacterCreated.DoThreadSafeFuncAsync(x => x.Checked, token), token);
        }

        /// <summary>
        /// Save the Character using the Save As dialogue box.
        /// </summary>
        /// <param name="blnDoCreated">If True, forces the character to be saved in Career Mode (if possible to do so).</param>
        /// <param name="token">Cancellation token to use.</param>
        public override async ValueTask<bool> SaveCharacterAs(bool blnDoCreated = false, CancellationToken token = default)
        {
            return await base.SaveCharacterAs(blnDoCreated || await chkCharacterCreated.DoThreadSafeFuncAsync(x => x.Checked, token), token);
        }

        /// <summary>
        /// Save the character as Created and re-open it in Career Mode.
        /// </summary>
        public override async Task<bool> SaveCharacterAsCreated(CancellationToken token = default)
        {
            using (await CursorWait.NewAsync(this, token: token))
            {
                // If the character was built with Karma, record their staring Karma amount (if any).
                if (CharacterObject.Karma > 0)
                {
                    ExpenseLogEntry objKarma = new ExpenseLogEntry(CharacterObject);
                    objKarma.Create(CharacterObject.Karma,
                                    await LanguageManager.GetStringAsync("Label_SelectBP_StartingKarma"),
                                    ExpenseType.Karma, DateTime.Now);
                    CharacterObject.ExpenseEntries.AddWithSort(objKarma);

                    // Create an Undo entry so that the starting Karma amount can be modified if needed.
                    ExpenseUndo objKarmaUndo = new ExpenseUndo();
                    objKarmaUndo.CreateKarma(KarmaExpenseType.ManualAdd, string.Empty);
                    objKarma.Undo = objKarmaUndo;
                }

                List<CharacterAttrib> lstAttributesToAdd = null;
                if (CharacterObject.MetatypeCategory == "Shapeshifter")
                {
                    lstAttributesToAdd = new List<CharacterAttrib>(AttributeSection.AttributeStrings.Count);
                    XmlDocument xmlDoc = await CharacterObject.LoadDataAsync("metatypes.xml", token: token);
                    string strMetavariantXPath = "/chummer/metatypes/metatype[id = "
                                                 + CharacterObject.MetatypeGuid
                                                                  .ToString("D", GlobalSettings.InvariantCultureInfo)
                                                                  .CleanXPath()
                                                 + "]/metavariants/metavariant[id = "
                                                 + CharacterObject.MetavariantGuid
                                                                  .ToString("D", GlobalSettings.InvariantCultureInfo)
                                                                  .CleanXPath()
                                                 + ']';
                    foreach (CharacterAttrib objOldAttribute in CharacterObject.AttributeSection.AttributeList)
                    {
                        CharacterAttrib objNewAttribute = new CharacterAttrib(CharacterObject, objOldAttribute.Abbrev,
                                                                              CharacterAttrib.AttributeCategory
                                                                                  .Shapeshifter);
                        AttributeSection.CopyAttribute(objOldAttribute, objNewAttribute, strMetavariantXPath, xmlDoc);
                        lstAttributesToAdd.Add(objNewAttribute);
                    }

                    foreach (CharacterAttrib objAttributeToAdd in lstAttributesToAdd)
                    {
                        await CharacterObject.AttributeSection.AttributeList.AddAsync(objAttributeToAdd);
                    }
                }

                // Create an Expense Entry for Starting Nuyen.
                ExpenseLogEntry objNuyen = new ExpenseLogEntry(CharacterObject);
                objNuyen.Create(CharacterObject.Nuyen, await LanguageManager.GetStringAsync("Title_LifestyleNuyen"),
                                ExpenseType.Nuyen, DateTime.Now);
                CharacterObject.ExpenseEntries.AddWithSort(objNuyen);

                // Create an Undo entry so that the Starting Nuyen amount can be modified if needed.
                ExpenseUndo objNuyenUndo = new ExpenseUndo();
                objNuyenUndo.CreateNuyen(NuyenExpenseType.ManualAdd, string.Empty);
                objNuyen.Undo = objNuyenUndo;

                CharacterObject.Created = true;

                using (LoadingBar frmLoadingBar = await Program.CreateAndShowProgressBarAsync())
                {
                    await frmLoadingBar.PerformStepAsync(CharacterObject.CharacterName,
                                                        LoadingBar.ProgressBarTextPatterns.Saving, token);
                    _blnFileUpdateQueued = true;
                    try
                    {
                        if (!await CharacterObject.SaveAsync(token: token))
                        {
                            await CharacterObject.ExpenseEntries.ClearAsync();
                            if (lstAttributesToAdd != null)
                            {
                                foreach (CharacterAttrib objAttributeToAdd in lstAttributesToAdd)
                                {
                                    await CharacterObject.AttributeSection.AttributeList.RemoveAsync(objAttributeToAdd);
                                }
                            }

                            CharacterObject.Created = false;
                            return false;
                        }
                    }
                    finally
                    {
                        _blnFileUpdateQueued = false;
                    }

                    IsDirty = false;
                }

                IsReopenQueued = true;
                await this.DoThreadSafeAsync(x =>
                {
                    x.FormClosed += ReopenCharacter;
                    x.Close();
                }, token);
            }
            return true;
        }

        /// <summary>
        /// Open the Select Cyberware window and handle adding to the Tree and Character.
        /// </summary>
        private async ValueTask<bool> PickCyberware(Cyberware objSelectedCyberware, Improvement.ImprovementSource objSource)
        {
            using (ThreadSafeForm<SelectCyberware> frmPickCyberware
                   = await ThreadSafeForm<SelectCyberware>.GetAsync(
                       () => new SelectCyberware(CharacterObject, objSource, objSelectedCyberware)))
            {
                List<Improvement> lstImprovements;
                decimal decMultiplier = 1.0m;
                switch (objSource)
                {
                    // Apply the character's Cyberware Essence cost multiplier if applicable.
                    case Improvement.ImprovementSource.Cyberware:
                        {
                            lstImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.CyberwareEssCost);
                            if (lstImprovements.Count != 0)
                            {
                                foreach (Improvement objImprovement in lstImprovements)
                                {
                                    decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterESSMultiplier *= decMultiplier;
                            }

                            lstImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.CyberwareTotalEssMultiplier);
                            if (lstImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstImprovements)
                                {
                                    decMultiplier *= objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                            }

                            lstImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.CyberwareEssCostNonRetroactive);
                            if (lstImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstImprovements)
                                {
                                    decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterESSMultiplier *= decMultiplier;
                            }

                            lstImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.CyberwareTotalEssMultiplierNonRetroactive);
                            if (lstImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstImprovements)
                                {
                                    decMultiplier *= objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                            }

                            break;
                        }
                    // Apply the character's Bioware Essence cost multiplier if applicable.
                    case Improvement.ImprovementSource.Bioware:
                        {
                            lstImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.BiowareEssCost);
                            if (lstImprovements.Count != 0)
                            {
                                foreach (Improvement objImprovement in lstImprovements)
                                {
                                    decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterESSMultiplier = decMultiplier;
                            }

                            lstImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.BiowareTotalEssMultiplier);
                            if (lstImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstImprovements)
                                {
                                    decMultiplier *= objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                            }

                            lstImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.BiowareEssCostNonRetroactive);
                            if (lstImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstImprovements)
                                {
                                    decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterESSMultiplier = decMultiplier;
                            }

                            lstImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.BiowareTotalEssMultiplierNonRetroactive);
                            if (lstImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstImprovements)
                                {
                                    decMultiplier *= objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                            }

                            // Apply the character's Basic Bioware Essence cost multiplier if applicable.
                            lstImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.BasicBiowareEssCost);
                            if (lstImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstImprovements)
                                {
                                    decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.BasicBiowareESSMultiplier = decMultiplier;
                            }

                            // Apply the character's Genetech Essence cost multiplier if applicable.
                            lstImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.GenetechEssMultiplier);
                            if (lstImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstImprovements)
                                {
                                    decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.GenetechEssMultiplier = decMultiplier;
                            }

                            // Genetech Cost multiplier.
                            lstImprovements
                                = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                    CharacterObject, Improvement.ImprovementType.GenetechCostMultiplier);
                            if (lstImprovements.Count != 0)
                            {
                                decMultiplier = 1.0m;
                                foreach (Improvement objImprovement in lstImprovements)
                                {
                                    decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                }

                                frmPickCyberware.MyForm.GenetechCostMultiplier = decMultiplier;
                            }

                            break;
                        }
                }

                Dictionary<string, int> dicDisallowedMounts = new Dictionary<string, int>(6);
                Dictionary<string, int> dicHasMounts = new Dictionary<string, int>(6);
                if (objSelectedCyberware != null)
                {
                    frmPickCyberware.MyForm.ForcedGrade = objSelectedCyberware.Grade;
                    frmPickCyberware.MyForm.LockGrade();
                    frmPickCyberware.MyForm.Subsystems = objSelectedCyberware.AllowedSubsystems;
                    // If the Cyberware has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that consume Capacity).
                    if (!objSelectedCyberware.Capacity.Contains('['))
                    {
                        frmPickCyberware.MyForm.MaximumCapacity = objSelectedCyberware.CapacityRemaining;
                    }

                    foreach (string strLoop in objSelectedCyberware.BlocksMounts.SplitNoAlloc(',',
                        StringSplitOptions.RemoveEmptyEntries))
                    {
                        if (!dicDisallowedMounts.ContainsKey(strLoop))
                            dicDisallowedMounts.Add(strLoop, int.MaxValue);
                    }
                    string strLoopHasModularMount = objSelectedCyberware.HasModularMount;
                    if (!string.IsNullOrEmpty(strLoopHasModularMount) && !dicHasMounts.ContainsKey(strLoopHasModularMount))
                        dicHasMounts.Add(strLoopHasModularMount, int.MaxValue);
                    foreach (Cyberware objLoopCyberware in objSelectedCyberware.Children.DeepWhere(x => x.Children, x => string.IsNullOrEmpty(x.PlugsIntoModularMount)))
                    {
                        foreach (string strLoop in objLoopCyberware.BlocksMounts.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries))
                        {
                            string strKey = strLoop;
                            if (objSelectedCyberware.Location != objLoopCyberware.Location)
                                strKey += objLoopCyberware.Location;
                            if (!dicDisallowedMounts.ContainsKey(strKey))
                                dicDisallowedMounts.Add(strKey, int.MaxValue);
                        }
                        strLoopHasModularMount = objSelectedCyberware.Location != objLoopCyberware.Location
                            ? objLoopCyberware.HasModularMount + objLoopCyberware.Location
                            : objLoopCyberware.HasModularMount;
                        if (!string.IsNullOrEmpty(strLoopHasModularMount) && !dicHasMounts.ContainsKey(strLoopHasModularMount))
                            dicHasMounts.Add(strLoopHasModularMount, int.MaxValue);
                    }
                }
                else
                {
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setLoopDisallowedMounts))
                    using (new FetchSafelyFromPool<HashSet<string>>(Utils.StringHashSetPool,
                                                                    out HashSet<string> setLoopHasModularMount))
                    {
                        foreach (Cyberware objLoopCyberware in CharacterObject.Cyberware)
                        {
                            setLoopDisallowedMounts.Clear();
                            setLoopDisallowedMounts.AddRange(objLoopCyberware.BlocksMounts.SplitNoAlloc(',', StringSplitOptions.RemoveEmptyEntries));
                            setLoopHasModularMount.Clear();
                            if (!string.IsNullOrEmpty(objLoopCyberware.HasModularMount))
                                setLoopHasModularMount.Add(objLoopCyberware.HasModularMount);
                            foreach (Cyberware objInnerLoopCyberware in objLoopCyberware.Children.DeepWhere(
                                         x => x.Children, x => string.IsNullOrEmpty(x.PlugsIntoModularMount)))
                            {
                                foreach (string strLoop in objInnerLoopCyberware.BlocksMounts.SplitNoAlloc(
                                             ',', StringSplitOptions.RemoveEmptyEntries))
                                    setLoopDisallowedMounts.Add(strLoop);
                                if (!string.IsNullOrEmpty(objInnerLoopCyberware.HasModularMount))
                                    setLoopHasModularMount.Add(objInnerLoopCyberware.HasModularMount);
                            }

                            foreach (string strLoop in setLoopDisallowedMounts)
                            {
                                string strKey = strLoop + objLoopCyberware.Location;
                                if (!dicDisallowedMounts.ContainsKey(strKey))
                                    dicDisallowedMounts.Add(strKey, objLoopCyberware.LimbSlotCount);
                                else
                                    dicDisallowedMounts[strKey] += objLoopCyberware.LimbSlotCount;
                            }

                            foreach (string strLoop in setLoopHasModularMount)
                            {
                                string strKey = strLoop + objLoopCyberware.Location;
                                if (!dicHasMounts.ContainsKey(strKey))
                                    dicHasMounts.Add(strKey, objLoopCyberware.LimbSlotCount);
                                else
                                    dicHasMounts[strKey] += objLoopCyberware.LimbSlotCount;
                            }
                        }
                    }
                }

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                              out StringBuilder sbdDisallowedMounts))
                {
                    foreach (KeyValuePair<string, int> kvpLoop in dicDisallowedMounts)
                    {
                        string strKey = kvpLoop.Key;
                        if (strKey.EndsWith("Right", StringComparison.Ordinal))
                            continue;
                        int intValue = kvpLoop.Value;
                        if (strKey.EndsWith("Left", StringComparison.Ordinal))
                        {
                            strKey = strKey.TrimEndOnce("Left", true);
                            intValue = dicDisallowedMounts.ContainsKey(strKey + "Right")
                                ? 2 * Math.Min(intValue, dicDisallowedMounts[strKey + "Right"])
                                : 0;
                            if (dicDisallowedMounts.TryGetValue(strKey, out int intExistingValue))
                                intValue += intExistingValue;
                        }

                        if (intValue >= await CharacterObject.LimbCountAsync(Cyberware.MountToLimbType(strKey)))
                            sbdDisallowedMounts.Append(strKey).Append(',');
                    }

                    // Remove trailing ","
                    if (sbdDisallowedMounts.Length > 0)
                        --sbdDisallowedMounts.Length;
                    frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                }

                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdHasMounts))
                {
                    foreach (KeyValuePair<string, int> kvpLoop in dicHasMounts)
                    {
                        string strKey = kvpLoop.Key;
                        if (strKey.EndsWith("Right", StringComparison.Ordinal))
                            continue;
                        int intValue = kvpLoop.Value;
                        if (strKey.EndsWith("Left", StringComparison.Ordinal))
                        {
                            strKey = strKey.TrimEndOnce("Left", true);
                            intValue = dicHasMounts.ContainsKey(strKey + "Right")
                                ? 2 * Math.Min(intValue, dicHasMounts[strKey + "Right"])
                                : 0;
                            if (dicHasMounts.TryGetValue(strKey, out int intExistingValue))
                                intValue += intExistingValue;
                        }

                        if (intValue >= await CharacterObject.LimbCountAsync(Cyberware.MountToLimbType(strKey)))
                            sbdHasMounts.Append(strKey).Append(',');
                    }

                    // Remove trailing ","
                    if (sbdHasMounts.Length > 0)
                        --sbdHasMounts.Length;
                    frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                }

                // Make sure the dialogue window was not canceled.
                if (await frmPickCyberware.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return false;

                // Open the Cyberware XML file and locate the selected piece.
                XmlNode objXmlCyberware = objSource == Improvement.ImprovementSource.Bioware
                    ? (await CharacterObject.LoadDataAsync("bioware.xml")).SelectSingleNode("/chummer/biowares/bioware[id = " + frmPickCyberware.MyForm.SelectedCyberware.CleanXPath() + ']')
                    : (await CharacterObject.LoadDataAsync("cyberware.xml")).SelectSingleNode("/chummer/cyberwares/cyberware[id = " + frmPickCyberware.MyForm.SelectedCyberware.CleanXPath() + ']');

                // Create the Cyberware object.
                Cyberware objCyberware = new Cyberware(CharacterObject);

                List<Weapon> lstWeapons = new List<Weapon>(1);
                List<Vehicle> lstVehicles = new List<Vehicle>(1);
                objCyberware.Create(objXmlCyberware, frmPickCyberware.MyForm.SelectedGrade, objSource, frmPickCyberware.MyForm.SelectedRating, lstWeapons, lstVehicles, true, true, string.Empty, objSelectedCyberware);
                if (objCyberware.InternalId.IsEmptyGuid())
                {
                    objCyberware.Dispose();
                    return false;
                }

                if (objCyberware.SourceID == Cyberware.EssenceAntiHoleGUID)
                {
                    CharacterObject.DecreaseEssenceHole(objCyberware.Rating);
                }
                else if (objCyberware.SourceID == Cyberware.EssenceHoleGUID)
                {
                    CharacterObject.IncreaseEssenceHole(objCyberware.Rating);
                }
                else
                {
                    objCyberware.DiscountCost = frmPickCyberware.MyForm.BlackMarketDiscount;
                    objCyberware.PrototypeTranshuman = frmPickCyberware.MyForm.PrototypeTranshuman;

                    // Apply the ESS discount if applicable.
                    if (CharacterObjectSettings.AllowCyberwareESSDiscounts)
                        objCyberware.ESSDiscount = frmPickCyberware.MyForm.SelectedESSDiscount;

                    if (frmPickCyberware.MyForm.FreeCost)
                        objCyberware.Cost = "0";

                    if (objSelectedCyberware != null)
                        await objSelectedCyberware.Children.AddAsync(objCyberware);
                    else
                        await CharacterObject.Cyberware.AddAsync(objCyberware);

                    CharacterObject.Weapons.AddRange(lstWeapons);
                    CharacterObject.Vehicles.AddRange(lstVehicles);
                }

                return frmPickCyberware.MyForm.AddAgain;
            }
        }

        /// <summary>
        /// Select a piece of Gear to be added to the character.
        /// </summary>
        private async ValueTask<bool> PickGear(string strSelectedId)
        {
            bool blnNullParent = false;
            Gear objSelectedGear = CharacterObject.Gear.DeepFindById(strSelectedId);
            Location objLocation = null;
            if (objSelectedGear == null)
            {
                blnNullParent = true;
                objLocation =
                    CharacterObject.GearLocations.FirstOrDefault(location => location.InternalId == strSelectedId);
            }

            // Open the Gear XML file and locate the selected Gear.
            XPathNavigator xmlParent = blnNullParent ? null : await objSelectedGear.GetNodeXPathAsync();

            using (await CursorWait.NewAsync(this))
            {
                string strCategories = string.Empty;

                if (xmlParent != null)
                {
                    XPathNodeIterator xmlAddonCategoryList = xmlParent.Select("addoncategory");
                    if (xmlAddonCategoryList.Count > 0)
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(
                                   Utils.StringBuilderPool, out StringBuilder sbdCategories))
                        {
                            foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                                sbdCategories.Append(objXmlCategory.Value).Append(',');
                            // Remove the trailing comma.
                            --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }
                }

                using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(
                           () => new SelectGear(CharacterObject,
                                                objSelectedGear?.ChildAvailModifier ?? 0,
                                                objSelectedGear?.ChildCostMultiplier ?? 1,
                                                objSelectedGear, strCategories)))
                {
                    if (!blnNullParent
                        && (!string.IsNullOrEmpty(objSelectedGear.Capacity) && !objSelectedGear.Capacity.Contains('[')
                            || objSelectedGear.Capacity.Contains("/[")))
                    {
                        // If the Gear has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that conume Capacity).
                        frmPickGear.MyForm.MaximumCapacity = objSelectedGear.CapacityRemaining;
                        if (!string.IsNullOrEmpty(strCategories))
                            frmPickGear.MyForm.ShowNegativeCapacityOnly = true;
                    }

                    // Make sure the dialogue window was not canceled.
                    if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return false;

                    // Open the Cyberware XML file and locate the selected piece.
                    XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
                    XmlNode objXmlGear
                        = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                          + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                    // Create the new piece of Gear.
                    List<Weapon> lstWeapons = new List<Weapon>(1);

                    Gear objGear = new Gear(CharacterObject);
                    objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty,
                                   objSelectedGear?.Equipped != false);
                    if (objGear.InternalId.IsEmptyGuid())
                        return frmPickGear.MyForm.AddAgain;
                    objGear.Quantity = frmPickGear.MyForm.SelectedQty;

                    // If a Commlink has just been added, see if the character already has one. If not, make it the active Commlink.
                    if (CharacterObject.ActiveCommlink == null && objGear.IsCommlink)
                    {
                        objGear.SetActiveCommlink(CharacterObject, true);
                    }

                    // reduce the cost for Black Market Pipeline
                    objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;
                    // Reduce the cost for Do It Yourself components.
                    if (frmPickGear.MyForm.DoItYourself)
                        objGear.Cost = '(' + objGear.Cost + ") * 0.5";
                    // If the item was marked as free, change its cost.
                    if (frmPickGear.MyForm.FreeCost)
                    {
                        objGear.Cost = "0";
                    }

                    // Create any Weapons that came with this Gear.
                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objWeapon);
                    }

                    ICollection<Gear> destinationGear =
                        blnNullParent ? CharacterObject.Gear : objSelectedGear.Children;
                    bool blnMatchFound = false;
                    foreach (Gear objExistingGear in destinationGear)
                    {
                        if (objExistingGear.Location == objLocation
                            && objGear.IsIdenticalToOtherGear(objExistingGear, true)
                            && Program.ShowMessageBox(this,
                                                      string.Format(GlobalSettings.CultureInfo,
                                                                    await LanguageManager.GetStringAsync(
                                                                        "Message_MergeIdentical"),
                                                                    objGear.CurrentDisplayNameShort),
                                                      await LanguageManager.GetStringAsync(
                                                          "MessageTitle_MergeIdentical"),
                                                      MessageBoxButtons.YesNo, MessageBoxIcon.Question)
                            == DialogResult.Yes)
                        {
                            // A match was found, so increase the quantity instead.
                            objExistingGear.Quantity += objGear.Quantity;
                            blnMatchFound = true;
                            break;
                        }
                    }

                    if (!blnMatchFound)
                    {
                        if (objLocation != null)
                            await objLocation.Children.AddAsync(objGear);
                        destinationGear.Add(objGear);
                    }
                    else
                    {
                        await RequestCharacterUpdate();
                        await SetDirty(true);
                    }

                    return frmPickGear.MyForm.AddAgain;
                }
            }
        }

        /// <summary>
        /// Select a piece of Gear and add it to a piece of Armor.
        /// </summary>
        /// <param name="blnShowArmorCapacityOnly">Whether or not only items that consume capacity should be shown.</param>
        /// <param name="strSelectedId">Id attached to the object to which the gear should be added.</param>
        private async ValueTask<bool> PickArmorGear(string strSelectedId, bool blnShowArmorCapacityOnly = false)
        {
            Gear objSelectedGear = null;
            ArmorMod objSelectedMod = null;
            Armor objSelectedArmor = CharacterObject.Armor.FindById(strSelectedId);
            if (objSelectedArmor == null)
            {
                objSelectedGear = CharacterObject.Armor.FindArmorGear(strSelectedId, out objSelectedArmor, out objSelectedMod);
                if (objSelectedGear == null)
                    objSelectedMod = CharacterObject.Armor.FindArmorMod(strSelectedId);
            }

            // Open the Gear XML file and locate the selected Gear.
            object objParent = objSelectedGear ?? objSelectedMod ?? (object)objSelectedArmor;
            using (await CursorWait.NewAsync(this))
            {
                string strCategories = string.Empty;
                if (!string.IsNullOrEmpty(strSelectedId) && objParent is IHasXmlDataNode objParentWithDataNode)
                {
                    XPathNodeIterator xmlAddonCategoryList
                        = (await objParentWithDataNode.GetNodeXPathAsync())?.Select("addoncategory");
                    if (xmlAddonCategoryList?.Count > 0)
                    {
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdCategories))
                        {
                            foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                                sbdCategories.Append(objXmlCategory.Value).Append(',');
                            // Remove the trailing comma.
                            if (sbdCategories.Length > 0)
                                --sbdCategories.Length;
                            strCategories = sbdCategories.ToString();
                        }
                    }
                }

                using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(
                           () => new SelectGear(CharacterObject, 0, 1, objParent, strCategories)
                           {
                               ShowArmorCapacityOnly = blnShowArmorCapacityOnly,
                               CapacityDisplayStyle = objSelectedMod != null
                                   ? CapacityStyle.Standard
                                   : objSelectedArmor.CapacityDisplayStyle
                           }))
                {
                    if (!string.IsNullOrEmpty(strSelectedId))
                    {
                        // If the Gear has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that conume Capacity).
                        if (objSelectedGear?.Capacity.Contains('[') == false)
                            frmPickGear.MyForm.MaximumCapacity = objSelectedGear.CapacityRemaining;
                        else if (objSelectedMod != null)
                            frmPickGear.MyForm.MaximumCapacity = objSelectedMod.GearCapacityRemaining;
                    }

                    // Make sure the dialogue window was not canceled.
                    if (await frmPickGear.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return false;

                    // Open the Cyberware XML file and locate the selected piece.
                    XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml");
                    XmlNode objXmlGear
                        = objXmlDocument.SelectSingleNode("/chummer/gears/gear[id = "
                                                          + frmPickGear.MyForm.SelectedGear.CleanXPath() + ']');

                    // Create the new piece of Gear.
                    List<Weapon> lstWeapons = new List<Weapon>(1);

                    Gear objGear = new Gear(CharacterObject);
                    objGear.Create(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty
                                   , objSelectedGear?.Equipped ?? objSelectedMod?.Equipped ?? objSelectedArmor.Equipped);

                    if (objGear.InternalId.IsEmptyGuid())
                        return frmPickGear.MyForm.AddAgain;

                    objGear.Quantity = frmPickGear.MyForm.SelectedQty;
                    objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                    if (objSelectedGear != null)
                        objGear.Parent = objSelectedGear;

                    // Reduce the cost for Do It Yourself components.
                    if (frmPickGear.MyForm.DoItYourself)
                        objGear.Cost = '(' + objGear.Cost + ") * 0.5";
                    // If the item was marked as free, change its cost.
                    if (frmPickGear.MyForm.FreeCost)
                    {
                        objGear.Cost = "0";
                    }

                    // Create any Weapons that came with this Gear.
                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objWeapon);
                    }

                    bool blnMatchFound = false;
                    // If this is Ammunition, see if the character already has it on them.
                    if (objGear.Category == "Ammunition" || !string.IsNullOrEmpty(objGear.AmmoForWeaponType))
                    {
                        foreach (Gear objCharacterGear in CharacterObject.Gear)
                        {
                            if (!objGear.IsIdenticalToOtherGear(objCharacterGear))
                                continue;
                            // A match was found, so increase the quantity instead.
                            objCharacterGear.Quantity += objGear.Quantity;
                            blnMatchFound = true;
                            break;
                        }
                    }

                    // Add the Gear.
                    if (!blnMatchFound)
                    {
                        if (!string.IsNullOrEmpty(objSelectedGear?.Name))
                        {
                            await objSelectedGear.Children.AddAsync(objGear);
                        }
                        else if (!string.IsNullOrEmpty(objSelectedMod?.Name))
                        {
                            await objSelectedMod.GearChildren.AddAsync(objGear);
                        }
                        else
                        {
                            await objSelectedArmor.GearChildren.AddAsync(objGear);
                        }
                    }

                    return frmPickGear.MyForm.AddAgain;
                }
            }
        }

        /// <summary>
        /// Refresh the currently-selected Lifestyle.
        /// </summary>
        private async Task RefreshSelectedLifestyle(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpLifestyleDetails.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                TreeNode objSelectedNode = await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode, token);
                object objSelectedNodeTag = objSelectedNode?.Tag;
                if (objSelectedNodeTag == null || objSelectedNode.Level <= 0 || !(objSelectedNodeTag is Lifestyle objLifestyle))
                {
                    await flpLifestyleDetails.DoThreadSafeAsync(x => x.Visible = false, token);
                    await cmdDeleteLifestyle.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                    return;
                }
                await flpLifestyleDetails.DoThreadSafeAsync(x => x.Visible = true, token);
                await cmdDeleteLifestyle.DoThreadSafeAsync(x => x.Enabled = true, token);
                string strSpace = await LanguageManager.GetStringAsync("String_Space");
                await lblLifestyleCost.DoThreadSafeAsync(x => x.Text
                                                             = objLifestyle.TotalMonthlyCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                 GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                await nudLifestyleMonths.DoThreadSafeAsync(x => x.Value = objLifestyle.Increments, token);
                string strText = objLifestyle.Dice.ToString(GlobalSettings.CultureInfo)
                                 + await LanguageManager.GetStringAsync("String_D6")
                                 + strSpace
                                 + '' + strSpace
                                 + objLifestyle.Multiplier.ToString(
                                     CharacterObjectSettings.NuyenFormat,
                                     GlobalSettings.CultureInfo) + await LanguageManager.GetStringAsync("String_NuyenSymbol");
                await lblLifestyleStartingNuyen.DoThreadSafeAsync(x => x.Text = strText, token);
                await objLifestyle.SetSourceDetailAsync(lblLifestyleSource, token);
                await lblLifestyleTotalCost.DoThreadSafeAsync(x => x.Text
                                                                  = objLifestyle.TotalCost.ToString(
                                                                        CharacterObjectSettings.NuyenFormat,
                                                                        GlobalSettings.CultureInfo)
                                                                    + LanguageManager.GetString("String_NuyenSymbol"), token);
                string strCostLabelString;
                string strIncrementString;
                // Change the Cost/Month label.
                switch (objLifestyle.IncrementType)
                {
                    case LifestyleIncrement.Day:
                        strCostLabelString = await LanguageManager.GetStringAsync("Label_SelectLifestyle_CostPerDay");
                        strIncrementString = await LanguageManager.GetStringAsync("String_Days");
                        break;

                    case LifestyleIncrement.Week:
                        strCostLabelString = await LanguageManager.GetStringAsync("Label_SelectLifestyle_CostPerWeek");
                        strIncrementString = await LanguageManager.GetStringAsync("String_Weeks");
                        break;

                    default:
                        strCostLabelString = await LanguageManager.GetStringAsync("Label_SelectLifestyle_CostPerMonth");
                        strIncrementString = await LanguageManager.GetStringAsync("String_Months");
                        break;
                }
                await lblLifestyleCostLabel.DoThreadSafeAsync(x => x.Text = strCostLabelString, token);
                string strMonthsLabel = strIncrementString + string.Format(
                    GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Label_LifestylePermanent"),
                    objLifestyle.IncrementsRequiredForPermanent.ToString(GlobalSettings.CultureInfo));
                await lblLifestyleMonthsLabel.DoThreadSafeAsync(x => x.Text = strMonthsLabel, token);
                token.ThrowIfCancellationRequested();
                if (!string.IsNullOrEmpty(objLifestyle.BaseLifestyle))
                {
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdQualities))
                    {
                        sbdQualities.AppendJoin(',' + Environment.NewLine,
                                                objLifestyle.LifestyleQualities.Select(
                                                    r => r.CurrentFormattedDisplayName));
                        foreach (Improvement objImprovement in await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                     CharacterObject, Improvement.ImprovementType.LifestyleCost))
                        {
                            if (sbdQualities.Length > 0)
                                sbdQualities.AppendLine(',');

                            sbdQualities.Append(CharacterObject.GetObjectName(objImprovement))
                                        .Append(await LanguageManager.GetStringAsync("String_Space")).Append('[')
                                        .Append(
                                            objImprovement.Value.ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo))
                                        .Append("%]");
                        }
                        await lblLifestyleQualities.DoThreadSafeAsync(x => x.Text = sbdQualities.ToString(), token);
                    }
                    await lblBaseLifestyle.DoThreadSafeAsync(x => x.Text = objLifestyle.CurrentDisplayName, token);
                    await lblLifestyleQualitiesLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblLifestyleQualities.DoThreadSafeAsync(x => x.Visible = true, token);
                }
                else
                {
                    string strError = await LanguageManager.GetStringAsync("String_Error");
                    await lblBaseLifestyle.DoThreadSafeAsync(x => x.Text = strError, token);
                    await lblLifestyleQualitiesLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblLifestyleQualities.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                //Controls Visibility and content of the City, District and Borough Labels
                if (!string.IsNullOrEmpty(objLifestyle.City))
                {
                    await lblLifestyleCity.DoThreadSafeAsync(x =>
                    {
                        x.Text = objLifestyle.City;
                        x.Visible = true;
                    }, token);
                    await lblLifestyleCityLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                }
                else
                {
                    await lblLifestyleCity.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblLifestyleCityLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                if (!string.IsNullOrEmpty(objLifestyle.District))
                {
                    await lblLifestyleDistrict.DoThreadSafeAsync(x =>
                    {
                        x.Text = objLifestyle.District;
                        x.Visible = true;
                    }, token);
                    await lblLifestyleDistrictLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                }
                else
                {
                    await lblLifestyleDistrict.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblLifestyleDistrictLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                if (!string.IsNullOrEmpty(objLifestyle.Borough))
                {
                    await lblLifestyleBorough.DoThreadSafeAsync(x =>
                    {
                        x.Text = objLifestyle.Borough;
                        x.Visible = true;
                    }, token);
                    await lblLifestyleBoroughLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                }
                else
                {
                    await lblLifestyleBorough.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblLifestyleBoroughLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                }
            }
            finally
            {
                await flpLifestyleDetails.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the currently-selected Vehicle.
        /// </summary>
        private async Task RefreshSelectedVehicle(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpVehicles.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, token);
                object objSelectedNodeTag = objSelectedNode?.Tag;
                if (objSelectedNodeTag == null || objSelectedNode.Level <= 0 || objSelectedNodeTag is Location)
                {
                    await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                    await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                    // Buttons
                    await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                    return;
                }
                string strSpace = await LanguageManager.GetStringAsync("String_Space");
                if (objSelectedNodeTag is IHasStolenProperty selectedLoot && (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(
                            CharacterObject,
                            Improvement.ImprovementType.Nuyen,
                            "Stolen")).Count > 0)
                {
                    await chkVehicleStolen.DoThreadSafeAsync(x =>
                    {
                        x.Visible = true;
                        x.Checked = selectedLoot.Stolen;
                    }, token);
                }
                else
                {
                    await chkVehicleStolen.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblVehicleSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                    await lblVehicleSource.DoThreadSafeAsync(x => x.Visible = true, token);
                    await objSelected.SetSourceDetailAsync(lblVehicleSource, token);
                }
                else
                {
                    await lblVehicleSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                    await lblVehicleSource.DoThreadSafeAsync(x => x.Visible = false, token);
                }
                if (objSelectedNodeTag is IHasRating objHasRating)
                {
                    string strText = string.Format(
                        GlobalSettings.CultureInfo,
                        await LanguageManager.GetStringAsync(
                            "Label_RatingFormat"),
                        await LanguageManager.GetStringAsync(
                            objHasRating.RatingLabel));
                    await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                }
                switch (objSelectedNodeTag)
                {
                    // Locate the selected Vehicle.
                    case Vehicle objVehicle:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = string.IsNullOrEmpty(objVehicle.ParentID), token);
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objVehicle.CurrentDisplayNameShort, token);
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = objVehicle.DisplayCategory(GlobalSettings.Language), token);
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await nudVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objVehicle.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objVehicle.TotalCost.ToString(
                                                                       CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        if (CharacterObjectSettings.BookEnabled("R5"))
                        {
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleSlots.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            string strText = objVehicle.Slots.ToString(GlobalSettings.CultureInfo) + strSpace
                                + '('
                                + (objVehicle.Slots - objVehicle.SlotsUsed).ToString(
                                    GlobalSettings.CultureInfo)
                                + strSpace + await LanguageManager.GetStringAsync("String_Remaining")
                                + ')';
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strText;
                            }, token);
                        }
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = CharacterObject
                                              .GenerateBlackMarketMappings(
                                                  await (await CharacterObject.LoadDataXPathAsync(
                                                          "vehicles.xml", token: token))
                                                      .SelectSingleNodeAndCacheExpressionAsync(
                                                          "/chummer"))
                                              .Contains(objVehicle.Category);
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objVehicle.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesVehicle
                        await lblVehicleHandling.DoThreadSafeAsync(x => x.Text = objVehicle.TotalHandling, token);
                        await lblVehicleAccel.DoThreadSafeAsync(x => x.Text = objVehicle.TotalAccel, token);
                        await lblVehicleSpeed.DoThreadSafeAsync(x => x.Text = objVehicle.TotalSpeed, token);
                        await lblVehiclePilot.DoThreadSafeAsync(x => x.Text = objVehicle.Pilot.ToString(GlobalSettings.CultureInfo), token);
                        await lblVehicleBody.DoThreadSafeAsync(x => x.Text = objVehicle.TotalBody.ToString(GlobalSettings.CultureInfo), token);
                        await lblVehicleArmor.DoThreadSafeAsync(x => x.Text = objVehicle.TotalArmor.ToString(GlobalSettings.CultureInfo), token);
                        await lblVehicleSeats.DoThreadSafeAsync(x => x.Text = objVehicle.TotalSeats.ToString(GlobalSettings.CultureInfo), token);
                        await lblVehicleSensor.DoThreadSafeAsync(x => x.Text = objVehicle.CalculatedSensor.ToString(GlobalSettings.CultureInfo), token);
                        if (CharacterObjectSettings.BookEnabled("R5"))
                        {
                            if (objVehicle.IsDrone && CharacterObjectSettings.DroneMods)
                            {
                                await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehiclePowertrain.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleCosmetic.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleElectromagneticLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleElectromagnetic.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleBodymod.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleWeaponsmod.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleProtection.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleDroneModSlots.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text
                                        = objVehicle.DroneModSlotsUsed.ToString(GlobalSettings.CultureInfo) + '/'
                                        + objVehicle.DroneModSlots.ToString(GlobalSettings.CultureInfo);
                                }, token);
                            }
                            else
                            {
                                await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehiclePowertrain.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.PowertrainModSlotsUsed();
                                }, token);
                                await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleCosmetic.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.CosmeticModSlotsUsed();
                                }, token);
                                await lblVehicleElectromagneticLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleElectromagnetic.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.ElectromagneticModSlotsUsed();
                                }, token);
                                await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleBodymod.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.BodyModSlotsUsed();
                                }, token);
                                await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleWeaponsmod.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.WeaponModSlotsUsed();
                                }, token);
                                await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleProtection.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objVehicle.ProtectionModSlotsUsed();
                                }, token);
                                await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleDroneModSlots.DoThreadSafeAsync(x => x.Visible = false, token);
                            }
                        }
                        else
                        {
                            await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehiclePowertrain.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleCosmetic.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleElectromagneticLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleElectromagnetic.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleBodymod.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponsmod.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleProtection.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleDroneModSlots.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesMatrix
                        int intDeviceRating = objVehicle.GetTotalMatrixAttribute("Device Rating");
                        await lblVehicleDevice.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objVehicle.RefreshMatrixAttributeComboBoxesAsync(
                            cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, token);
                        await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objVehicle.IsCommlink;
                            x.Checked = objVehicle.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objVehicle.IsHomeNode(CharacterObject);
                                x.Enabled = objVehicle.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                            }, token);
                        }
                        else
                            await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        await UpdateSensor(objVehicle, token);
                        break;
                    }
                    // Locate the selected VehicleMod.
                    case WeaponMount objWeaponMount:
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objWeaponMount.IncludedInVehicle, token);
                        // gpbVehiclesCommon
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = objWeaponMount.DisplayCategory(GlobalSettings.Language), token);
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objWeaponMount.CurrentDisplayName, token);
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await nudVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objWeaponMount.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objWeaponMount.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo), token);
                        await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleSlots.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objWeaponMount.CalculatedSlots.ToString(GlobalSettings.CultureInfo);
                        }, token);
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objWeaponMount.Equipped;
                            x.Enabled = !objWeaponMount.IncludedInVehicle;
                        }, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = !objWeaponMount.IncludedInVehicle && CharacterObject
                                .GenerateBlackMarketMappings(
                                    await (await CharacterObject.LoadDataXPathAsync("vehicles.xml", token: token))
                                        .SelectSingleNodeAndCacheExpressionAsync("/chummer/weaponmountcategories"))
                                .Contains(objWeaponMount.Category);
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objWeaponMount.IncludedInVehicle
                                    ? objWeaponMount.Parent?.DiscountCost == true
                                    : objWeaponMount.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        break;

                    case VehicleMod objMod:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objMod.IncludedInVehicle, token);
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objMod.CurrentDisplayName, token);
                        string strText = await LanguageManager.GetStringAsync("String_VehicleModification");
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        strText = await LanguageManager.GetStringAsync(objMod.RatingLabel);
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                        if (!objMod.MaxRating.Equals("qty", StringComparison.OrdinalIgnoreCase))
                        {
                            if (objMod.MaxRating.Equals("seats", StringComparison.OrdinalIgnoreCase))
                            {
                                objMod.MaxRating = objMod.Parent.TotalSeats.ToString(GlobalSettings.CultureInfo);
                            }
                            else if (objMod.MaxRating.Equals("body", StringComparison.OrdinalIgnoreCase))
                            {
                                objMod.MaxRating = objMod.Parent.TotalBody.ToString(GlobalSettings.CultureInfo);
                            }
                            token.ThrowIfCancellationRequested();
                            if (int.TryParse(objMod.MaxRating, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                                             out int intMaxRating) && intMaxRating > 0)
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                // If the Mod is Armor, use the lower of the Mod's maximum Rating and MaxArmor value for the Vehicle instead.
                                await nudVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Maximum = objMod.Name.StartsWith("Armor,", StringComparison.Ordinal)
                                        ? Math.Min(intMaxRating, objMod.Parent.MaxArmor)
                                        : intMaxRating;
                                    x.Minimum = 1;
                                    x.Visible = true;
                                    x.Value = objMod.Rating;
                                    x.Increment = 1;
                                    x.Enabled = !objMod.IncludedInVehicle;
                                }, token);
                            }
                            else
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await nudVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Minimum = 0;
                                    x.Increment = 1;
                                    x.Maximum = 0;
                                    x.Enabled = false;
                                    x.Visible = false;
                                }, token);
                            }
                        }
                        else
                        {
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await nudVehicleRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Minimum = 1;
                                x.Maximum = Vehicle.MaxWheels;
                                x.Value = objMod.Rating;
                                x.Increment = 1;
                                x.Enabled = !objMod.IncludedInVehicle;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objMod.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objMod.TotalCost.ToString(CharacterObjectSettings.NuyenFormat, GlobalSettings.CultureInfo)
                                                                     + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleSlots.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = objMod.CalculatedSlots.ToString(GlobalSettings.CultureInfo);
                        }, token);
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objMod.Equipped;
                            x.Enabled = !objMod.IncludedInVehicle;
                        }, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = !objMod.IncludedInVehicle && CharacterObject
                                                                           .GenerateBlackMarketMappings(
                                                                               await (await CharacterObject
                                                                                       .LoadDataXPathAsync(
                                                                                           "weapons.xml", token: token))
                                                                                   .SelectSingleNodeAndCacheExpressionAsync(
                                                                                       "/chummer/modcategories"))
                                                                           .Contains(objMod.Category);
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objMod.IncludedInVehicle
                                    ? (objMod.WeaponMountParent?.DiscountCost ?? objMod.Parent?.DiscountCost) == true
                                    : objMod.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        break;
                    }
                    case Weapon objWeapon:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objWeapon.Cyberware
                                                                     && objWeapon.Category != "Gear"
                                                                     && !objWeapon.IncludedInWeapon
                                                                     && string.IsNullOrEmpty(objWeapon.ParentID)
                                                                     && !objWeapon.Category.StartsWith(
                                                                         "Quality", StringComparison.Ordinal), token);
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayName, token);
                        string strText = await objWeapon.DisplayCategoryAsync(GlobalSettings.Language);
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await nudVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objWeapon.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objWeapon.TotalCost.ToString(CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleSlots.DoThreadSafeAsync(x => x.Visible = true, token);
                        if (!string.IsNullOrWhiteSpace(objWeapon.AccessoryMounts))
                        {
                            if (!GlobalSettings.Language.Equals(GlobalSettings.DefaultLanguage,
                                                                StringComparison.OrdinalIgnoreCase))
                            {
                                using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdSlotsText))
                                {
                                    foreach (string strMount in objWeapon.AccessoryMounts.SplitNoAlloc(
                                                 '/', StringSplitOptions.RemoveEmptyEntries))
                                        sbdSlotsText
                                            .Append(await LanguageManager.GetStringAsync("String_Mount" + strMount))
                                            .Append('/');
                                    --sbdSlotsText.Length;
                                    token.ThrowIfCancellationRequested();
                                    await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = sbdSlotsText.ToString(), token);
                                }
                            }
                            else
                                await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = objWeapon.AccessoryMounts, token);
                        }
                        else
                        {
                            string strNone = await LanguageManager.GetStringAsync("String_None");
                            await lblWeaponSlots.DoThreadSafeAsync(x => x.Text = strNone, token);
                        }

                        token.ThrowIfCancellationRequested();
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objWeapon.Equipped;
                            x.Enabled = objWeapon.ParentID != objWeapon.Parent?.InternalId
                                        && objWeapon.ParentID
                                        != objWeapon.ParentVehicle.InternalId;
                        }, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objWeapon.IncludedInWeapon;
                        }, token);
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = !objWeapon.IncludedInWeapon && CharacterObject
                                                                             .GenerateBlackMarketMappings(
                                                                                 await (await CharacterObject
                                                                                         .LoadDataXPathAsync(
                                                                                             "weapons.xml", token: token))
                                                                                     .SelectSingleNodeAndCacheExpressionAsync(
                                                                                         "/chummer"))
                                                                             .Contains(objWeapon.Category);
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objWeapon.IncludedInWeapon
                                    ? objWeapon.Parent?.DiscountCost == true
                                    : objWeapon.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesWeapon
                        await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleWeaponDamage.DoThreadSafeAsync(x =>
                        {
                            x.Text = objWeapon.DisplayDamage;
                            x.Visible = true;
                        }, token);
                        await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleWeaponAP.DoThreadSafeAsync(x =>
                        {
                            x.Text = objWeapon.DisplayTotalAP;
                            x.Visible = true;
                        }, token);
                        await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x =>
                        {
                            x.Text = objWeapon.DisplayAccuracy;
                            x.Visible = true;
                        }, token);
                        await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleWeaponDicePool.DoThreadSafeAsync(x =>
                        {
                            x.Text = objWeapon.DicePool.ToString(GlobalSettings
                                                                     .CultureInfo);
                            x.Visible = true;
                        }, token);
                        await lblVehicleWeaponDicePool.SetToolTipAsync(objWeapon.DicePoolTooltip, token);
                        if (objWeapon.RangeType == "Ranged")
                        {
                            await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponAmmo.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.DisplayAmmo;
                            }, token);
                            await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponMode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = objWeapon.DisplayMode;
                            }, token);
                            await cboVehicleWeaponFiringMode.DoThreadSafeAsync(x => x.SelectedValue = objWeapon.FireMode, token);
                            await tlpVehiclesWeaponRanges.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponRangeMain.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayRange, token);
                            await lblVehicleWeaponRangeAlternate.DoThreadSafeAsync(x => x.Text = objWeapon.CurrentDisplayAlternateRange, token);
                            Dictionary<string, string> dictionaryRanges
                                = objWeapon.GetRangeStrings(GlobalSettings.CultureInfo);
                            await lblVehicleWeaponRangeShortLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Short"), token);
                            await lblVehicleWeaponRangeMediumLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Medium"), token);
                            await lblVehicleWeaponRangeLongLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Long"), token);
                            await lblVehicleWeaponRangeExtremeLabel.DoThreadSafeAsync(x => x.Text = objWeapon.RangeModifier("Extreme"), token);
                            await lblVehicleWeaponRangeShort.DoThreadSafeAsync(x => x.Text = dictionaryRanges["short"], token);
                            await lblVehicleWeaponRangeMedium.DoThreadSafeAsync(x => x.Text = dictionaryRanges["medium"], token);
                            await lblVehicleWeaponRangeLong.DoThreadSafeAsync(x => x.Text = dictionaryRanges["long"], token);
                            await lblVehicleWeaponRangeExtreme.DoThreadSafeAsync(x => x.Text = dictionaryRanges["extreme"], token);
                            await lblVehicleWeaponAlternateRangeShort.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternateshort"], token);
                            await lblVehicleWeaponAlternateRangeMedium.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternatemedium"], token);
                            await lblVehicleWeaponAlternateRangeLong.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternatelong"], token);
                            await lblVehicleWeaponAlternateRangeExtreme.DoThreadSafeAsync(x => x.Text = dictionaryRanges["alternateextreme"], token);
                        }
                        else
                        {
                            if (objWeapon.Ammo != "0")
                            {
                                await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objWeapon.DisplayAmmo;
                                }, token);
                                await cboVehicleWeaponFiringMode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.SelectedValue = objWeapon.FireMode;
                                }, token);
                            }
                            else
                            {
                                await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token);
                                await cboVehicleWeaponFiringMode.DoThreadSafeAsync(x => x.Visible = false, token);
                            }
                            token.ThrowIfCancellationRequested();
                            await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token);
                            await tlpVehiclesWeaponRanges.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesMatrix
                        int intDeviceRating = objWeapon.GetTotalMatrixAttribute("Device Rating");
                        await lblVehicleDevice.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objWeapon.RefreshMatrixAttributeComboBoxesAsync(
                            cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, token);
                        await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objWeapon.IsCommlink;
                            x.Checked = objWeapon.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objWeapon.IsHomeNode(CharacterObject);
                                x.Enabled = objWeapon.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                            }, token);
                        }
                        else
                            await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        break;
                    }
                    case WeaponAccessory objAccessory:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objAccessory.IncludedInWeapon, token);
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objAccessory.CurrentDisplayName, token);
                        string strText = await LanguageManager.GetStringAsync("String_VehicleWeaponAccessory");
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        if (objAccessory.MaxRating > 0)
                        {
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await nudVehicleRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Minimum = 1;
                                x.Maximum = objAccessory.MaxRating;
                                x.Value = objAccessory.Rating;
                                x.Increment = 1;
                                x.Enabled = !objAccessory.IncludedInWeapon;
                            }, token);
                        }
                        else
                        {
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await nudVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objAccessory.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objAccessory.TotalCost.ToString(
                                                                       CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdMount))
                        {
                            foreach (string strCurrentMount in objAccessory.Mount.SplitNoAlloc(
                                         '/', StringSplitOptions.RemoveEmptyEntries))
                                sbdMount.Append(await LanguageManager.GetStringAsync("String_Mount" + strCurrentMount))
                                        .Append('/');
                            // Remove the trailing /
                            if (sbdMount.Length > 0)
                                --sbdMount.Length;
                            if (!string.IsNullOrEmpty(objAccessory.ExtraMount) && objAccessory.ExtraMount != "None")
                            {
                                bool boolHaveAddedItem = false;
                                foreach (string strCurrentExtraMount in objAccessory.ExtraMount.SplitNoAlloc(
                                             '/', StringSplitOptions.RemoveEmptyEntries))
                                {
                                    if (!boolHaveAddedItem)
                                    {
                                        sbdMount.Append(strSpace).Append('+').Append(strSpace);
                                        boolHaveAddedItem = true;
                                    }

                                    sbdMount.Append(await LanguageManager.GetStringAsync(
                                                        "String_Mount" + strCurrentExtraMount))
                                            .Append('/');
                                }
                                token.ThrowIfCancellationRequested();
                                // Remove the trailing /
                                if (boolHaveAddedItem)
                                    --sbdMount.Length;
                            }
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = sbdMount.ToString();
                            }, token);
                        }
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Enabled = true;
                            x.Checked = objAccessory.Equipped;
                        }, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objAccessory.IncludedInWeapon;
                        }, token);
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = !objAccessory.IncludedInWeapon && CharacterObject
                                .GenerateBlackMarketMappings(
                                    await (await CharacterObject
                                            .LoadDataXPathAsync(
                                                "weapons.xml", token: token))
                                        .SelectSingleNodeAndCacheExpressionAsync(
                                            "/chummer"))
                                .Contains(objAccessory.Parent.Category);
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objAccessory.IncludedInWeapon
                                    ? objAccessory.Parent?.DiscountCost == true
                                    : objAccessory.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        // gpbVehiclesWeapon
                        await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token);
                        await cboVehicleWeaponFiringMode.DoThreadSafeAsync(x => x.Visible = false, token);
                        if (string.IsNullOrEmpty(objAccessory.Damage))
                        {
                            await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponDamage.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = !string.IsNullOrEmpty(objAccessory.Damage), token);
                            await lblVehicleWeaponDamage.DoThreadSafeAsync(x =>
                            {
                                x.Visible = !string.IsNullOrEmpty(objAccessory
                                                                      .Damage);
                                x.Text = Convert
                                         .ToInt32(objAccessory.Damage,
                                                  GlobalSettings.InvariantCultureInfo)
                                         .ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (string.IsNullOrEmpty(objAccessory.AP))
                        {
                            await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponAP.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponAP.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = Convert
                                         .ToInt32(objAccessory.AP, GlobalSettings.InvariantCultureInfo)
                                         .ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (objAccessory.Accuracy == 0)
                        {
                            await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text
                                    = objAccessory.Accuracy.ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                        }
                        if (objAccessory.DicePool == 0)
                        {
                            await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponDicePool.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponDicePool.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text
                                    = objAccessory.DicePool.ToString("+#,0;-#,0;0", GlobalSettings.CultureInfo);
                            }, token);
                            await lblVehicleWeaponDicePool.SetToolTipAsync(string.Empty, token);
                        }
                        token.ThrowIfCancellationRequested();
                        if (objAccessory.TotalAmmoBonus != 0
                            || (!string.IsNullOrEmpty(objAccessory.ModifyAmmoCapacity)
                                && objAccessory.ModifyAmmoCapacity != "0"))
                        {
                            await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = true, token);
                            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdAmmoBonus))
                            {
                                int intAmmoBonus = objAccessory.TotalAmmoBonus;
                                if (intAmmoBonus != 0)
                                    sbdAmmoBonus.Append(
                                        (intAmmoBonus / 100.0m).ToString("+#,0%;-#,0%;0%", GlobalSettings.CultureInfo));
                                if (!string.IsNullOrEmpty(objAccessory.ModifyAmmoCapacity)
                                    && objAccessory.ModifyAmmoCapacity != "0")
                                    sbdAmmoBonus.Append(objAccessory.ModifyAmmoCapacity);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Text = sbdAmmoBonus.ToString(), token);
                            }
                        }
                        else
                        {
                            await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                            await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        break;
                    }
                    case Cyberware objCyberware:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = string.IsNullOrEmpty(objCyberware.ParentID), token);
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objCyberware.CurrentDisplayName, token);
                        string strText = await objCyberware.DisplayCategoryAsync(GlobalSettings.Language);
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                        strText = await LanguageManager.GetStringAsync(objCyberware.RatingLabel);
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                        if (objCyberware.MaxRating == 0)
                        {
                            await nudVehicleRating.DoThreadSafeAsync(x =>
                            {
                                x.Maximum = 0;
                                x.Minimum = 0;
                                x.Value = 0;
                                x.Visible = false;
                            }, token);
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        }
                        else
                        {
                            await nudVehicleRating.DoThreadSafeAsync(x =>
                            {
                                x.Maximum = objCyberware.MaxRating;
                                x.Minimum = objCyberware.MinRating;
                                x.Value = objCyberware.Rating;
                                x.Enabled = nudVehicleRating.Maximum == nudVehicleRating.Minimum
                                            && string.IsNullOrEmpty(objCyberware.ParentID);
                                x.Visible = true;
                            }, token);
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token);
                        await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objCyberware.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objCyberware.TotalCost.ToString(
                                                                       CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible
                                                                                   = !string.IsNullOrEmpty(objCyberware.PlugsIntoModularMount), token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        if (CharacterObject.BlackMarketDiscount && string.IsNullOrEmpty(objCyberware.ParentID))
                        {
                            bool blnEnabled = CharacterObject.GenerateBlackMarketMappings(
                                                                 await (await CharacterObject
                                                                         .LoadDataXPathAsync(
                                                                             objCyberware.SourceType
                                                                             == Improvement.ImprovementSource.Cyberware
                                                                                 ? "cyberware.xml"
                                                                                 : "bioware.xml", token: token))
                                                                     .SelectSingleNodeAndCacheExpressionAsync("/chummer"))
                                                             .Contains(objCyberware.Category);
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objCyberware.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesMatrix
                        int intDeviceRating = objCyberware.GetTotalMatrixAttribute("Device Rating");
                        await lblVehicleDevice.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objCyberware.RefreshMatrixAttributeComboBoxesAsync(
                            cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, token);
                        token.ThrowIfCancellationRequested();
                        await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objCyberware.IsCommlink;
                            x.Checked = objCyberware.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objCyberware.IsHomeNode(CharacterObject);
                                x.Enabled = chkVehicleActiveCommlink.Visible
                                            && objCyberware.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                            }, token);
                        }
                        else
                            await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        break;
                    }
                    case Gear objGear:
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token);
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token);
                        // gpbVehiclesCommon
                        await lblVehicleName.DoThreadSafeAsync(x => x.Text = objGear.CurrentDisplayNameShort, token);
                        await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = objGear.DisplayCategory(GlobalSettings.Language), token);
                        string strText = await LanguageManager.GetStringAsync(objGear.RatingLabel);
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token);
                        int intGearMaxRatingValue = objGear.MaxRatingValue;
                        if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                        {
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                            await nudVehicleRating.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Enabled = string.IsNullOrEmpty(objGear.ParentID);
                                x.Maximum = intGearMaxRatingValue;
                                x.Value = objGear.Rating;
                            }, token);
                        }
                        else
                        {
                            await nudVehicleRating.DoThreadSafeAsync(x =>
                            {
                                x.Minimum = 0;
                                x.Maximum = 0;
                                x.Visible = false;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await nudVehicleGearQty.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token);
                        if (objGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
                        {
                            int intDecimalPlaces = CharacterObjectSettings.MaxNuyenDecimals;
                            if (intDecimalPlaces <= 0)
                            {
                                await nudVehicleGearQty.DoThreadSafeAsync(x =>
                                {
                                    x.DecimalPlaces = 0;
                                    x.Minimum = 1.0m;
                                }, token);
                            }
                            else
                            {
                                await nudVehicleGearQty.DoThreadSafeAsync(x => x.DecimalPlaces = intDecimalPlaces, token);
                                decimal decMinimum = 1.0m;
                                // Need a for loop instead of a power system to maintain exact precision
                                for (int i = 0; i < intDecimalPlaces; ++i)
                                    decMinimum /= 10.0m;
                                await nudVehicleGearQty.DoThreadSafeAsync(x => x.Minimum = decMinimum, token);
                            }
                        }
                        else if (objGear.Category == "Currency")
                        {
                            await nudVehicleGearQty.DoThreadSafeAsync(x =>
                            {
                                x.DecimalPlaces = 2;
                                x.Minimum = 0.01m;
                            }, token);
                        }
                        else
                        {
                            await nudVehicleGearQty.DoThreadSafeAsync(x =>
                            {
                                x.DecimalPlaces = 0;
                                x.Minimum = 1.0m;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        await nudVehicleGearQty.DoThreadSafeAsync(x =>
                        {
                            x.Value = objGear.Quantity;
                            x.Increment = objGear.CostFor;
                            x.Visible = true;
                        }, token);
                        await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = objGear.DisplayTotalAvail, token);
                        await lblVehicleCost.DoThreadSafeAsync(x => x.Text
                                                                   = objGear.TotalCost.ToString(
                                                                       CharacterObjectSettings.NuyenFormat,
                                                                       GlobalSettings.CultureInfo) + LanguageManager.GetString("String_NuyenSymbol"), token);
                        await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token);
                        strText = objGear.CalculatedCapacity + strSpace + '('
                                  + objGear.CapacityRemaining.ToString(
                                      "#,0.##", GlobalSettings.CultureInfo) +
                                  strSpace + await LanguageManager.GetStringAsync("String_Remaining")
                                  + ')';
                        await lblVehicleSlots.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = strText;
                        }, token);
                        await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token);
                        await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        token.ThrowIfCancellationRequested();
                        if (CharacterObject.BlackMarketDiscount)
                        {
                            bool blnEnabled = !objGear.IncludedInParent && CharacterObject
                                                                           .GenerateBlackMarketMappings(
                                                                               await (await CharacterObject
                                                                                       .LoadDataXPathAsync("gear.xml", token: token))
                                                                                   .SelectSingleNodeAndCacheExpressionAsync(
                                                                                       "/chummer"))
                                                                           .Contains(objGear.Category);
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objGear.IncludedInParent
                                    ? (objGear.Parent as ICanBlackMarketDiscount)?.DiscountCost == true
                                    : objGear.DiscountCost;
                            }, token);
                        }
                        else
                        {
                            await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token);
                        }
                        token.ThrowIfCancellationRequested();
                        // gpbVehiclesMatrix
                        int intDeviceRating = objGear.GetTotalMatrixAttribute("Device Rating");
                        await lblVehicleDevice.DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token);
                        await objGear.RefreshMatrixAttributeComboBoxesAsync(
                            cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, token);

                        await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Visible = objGear.IsCommlink;
                            x.Checked = objGear.IsActiveCommlink(CharacterObject);
                        }, token);
                        if (CharacterObject.IsAI)
                        {
                            await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objGear.IsHomeNode(CharacterObject);
                                x.Enabled = objGear.IsCommlink
                                            && objGear.GetTotalMatrixAttribute("Program Limit")
                                            >= (CharacterObject.DEP.TotalValue > intDeviceRating ? 2 : 1);
                            }, token);
                        }
                        else
                            await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token);
                        break;
                    }
                    default:
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token);
                        // Buttons
                        await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = false, token);
                        break;
                }
            }
            finally
            {
                await flpVehicles.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the currently-selected Drug.
        /// </summary>
        private async Task RefreshSelectedDrug(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await flpDrugs.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                TreeNode objSelectedNode = await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode, token);
                object objSelectedNodeTag = objSelectedNode?.Tag;
                if (objSelectedNodeTag is Drug objDrug && objSelectedNode.Level != 0)
                {
                    await flpDrugs.DoThreadSafeAsync(x => x.Visible = true, token);
                    await btnDeleteCustomDrug.DoThreadSafeAsync(x => x.Enabled = true, token);
                    await lblDrugName.DoThreadSafeAsync(x => x.Text = objDrug.Name, token);
                    await lblDrugAvail.DoThreadSafeAsync(x => x.Text = objDrug.DisplayTotalAvail, token);
                    await lblDrugGrade.DoThreadSafeAsync(x => x.Text = objDrug.Grade.CurrentDisplayName, token);
                    await lblDrugCost.DoThreadSafeAsync(x => x.Text
                                                            = objDrug.Cost.ToString(
                                                                  CharacterObject.Settings.NuyenFormat, GlobalSettings.CultureInfo)
                                                              + LanguageManager.GetString("String_NuyenSymbol"), token);
                    await nudDrugQty.DoThreadSafeAsync(x =>
                    {
                        x.Value = objDrug.Quantity;
                        x.Visible = true;
                        x.Enabled = true;
                    }, token);
                    await lblDrugCategory.DoThreadSafeAsync(x => x.Text = objDrug.Category, token);
                    await lblDrugAddictionRating.DoThreadSafeAsync(x => x.Text = objDrug.AddictionRating.ToString(GlobalSettings.CultureInfo), token);
                    await lblDrugAddictionThreshold.DoThreadSafeAsync(x => x.Text = objDrug.AddictionThreshold.ToString(GlobalSettings.CultureInfo), token);
                    string strText = await objDrug.GetEffectDescriptionAsync();
                    await lblDrugEffect.DoThreadSafeAsync(x => x.Text = strText, token);
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdComponents))
                    {
                        foreach (DrugComponent objComponent in objDrug.Components)
                        {
                            sbdComponents.AppendLine(objComponent.CurrentDisplayName);
                        }
                        await lblDrugComponents.DoThreadSafeAsync(x => x.Text = sbdComponents.ToString(), token);
                    }
                }
                else
                {
                    await flpDrugs.DoThreadSafeAsync(x => x.Visible = false, token);
                    await btnDeleteCustomDrug.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                }
            }
            finally
            {
                await flpDrugs.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently selected Spell
        /// </summary>
        private async Task RefreshSelectedSpell(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await gpbMagicianSpell.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                TreeNode objSelectedNode = await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode, token);
                object objSelectedNodeTag = objSelectedNode?.Tag;
                if (objSelectedNodeTag is Spell objSpell && objSelectedNode.Level > 0)
                {
                    await gpbMagicianSpell.DoThreadSafeAsync(x => x.Visible = true, token);
                    await cmdDeleteSpell.DoThreadSafeAsync(x => x.Enabled = objSpell.Grade == 0, token);
                    string strText = await objSpell.DisplayDescriptorsAsync(GlobalSettings.Language);
                    if (string.IsNullOrEmpty(strText))
                        strText = await LanguageManager.GetStringAsync("String_None");
                    await lblSpellDescriptors.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayCategoryAsync(GlobalSettings.Language);
                    await lblSpellCategory.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayTypeAsync(GlobalSettings.Language);
                    await lblSpellType.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayRangeAsync(GlobalSettings.Language);
                    await lblSpellRange.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayDamageAsync(GlobalSettings.Language);
                    await lblSpellDamage.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayDurationAsync(GlobalSettings.Language);
                    await lblSpellDuration.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objSpell.DisplayDvAsync(GlobalSettings.Language);
                    await lblSpellDV.DoThreadSafeAsync(x => x.Text = strText, token);
                    await lblSpellDV.SetToolTipAsync(objSpell.DvTooltip, token);
                    await objSpell.SetSourceDetailAsync(lblSpellSource, token);
                    // Determine the size of the Spellcasting Dice Pool.
                    await lblSpellDicePool.DoThreadSafeAsync(x => x.Text = objSpell.DicePool.ToString(GlobalSettings.CultureInfo), token);
                    await lblSpellDicePool.SetToolTipAsync(objSpell.DicePoolTooltip, token);
                }
                else
                {
                    await gpbMagicianSpell.DoThreadSafeAsync(x => x.Visible = false, token);
                    await cmdDeleteSpell.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                }
            }
            finally
            {
                await gpbMagicianSpell.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently selected Complex Form.
        /// </summary>
        private async Task RefreshSelectedComplexForm(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.SuspendLayout(), token);
            try
            {
                TreeNode objSelectedNode = await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode, token);
                object objSelectedNodeTag = objSelectedNode?.Tag;
                if (objSelectedNodeTag is ComplexForm objComplexForm && objSelectedNode.Level > 0)
                {
                    await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.Visible = true, token);
                    await cmdDeleteComplexForm.DoThreadSafeAsync(x => x.Enabled = objComplexForm.Grade == 0, token);
                    string strText = await objComplexForm.DisplayTargetAsync(GlobalSettings.Language);
                    await lblTarget.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objComplexForm.DisplayDurationAsync(GlobalSettings.Language);
                    await lblDuration.DoThreadSafeAsync(x => x.Text = strText, token);
                    strText = await objComplexForm.DisplayFvAsync(GlobalSettings.Language);
                    await lblFV.DoThreadSafeAsync(x => x.Text = strText, token);
                    await lblFV.SetToolTipAsync(objComplexForm.FvTooltip, token);
                    await objComplexForm.SetSourceDetailAsync(lblSpellSource, token);
                    // Determine the size of the Threading Dice Pool.
                    await lblComplexFormDicePool.DoThreadSafeAsync(x => x.Text = objComplexForm.DicePool.ToString(GlobalSettings.CultureInfo), token);
                    await lblComplexFormDicePool.SetToolTipAsync(objComplexForm.DicePoolTooltip, token);
                }
                else
                {
                    await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.Visible = false, token);
                    await cmdDeleteComplexForm.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token);
                }
            }
            finally
            {
                await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.ResumeLayout(), token);
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Add or remove the Adapsin Cyberware Grade categories.
        /// </summary>
        public async Task PopulateCyberwareGradeList(bool blnBioware = false, bool blnIgnoreSecondHand = false, string strForceGrade = "")
        {
            List<Grade> objGradeList = await CharacterObject.GetGradesListAsync(blnBioware ? Improvement.ImprovementSource.Bioware : Improvement.ImprovementSource.Cyberware);
            using (new FetchSafelyFromPool<List<ListItem>>(Utils.ListItemListPool,
                                                           out List<ListItem> lstCyberwareGrades))
            {
                foreach (Grade objWareGrade in objGradeList)
                {
                    if (objWareGrade.Name == "None" && (string.IsNullOrEmpty(strForceGrade) || strForceGrade != "None"))
                        continue;
                    if (blnIgnoreSecondHand && objWareGrade.SecondHand)
                        continue;
                    if (blnBioware)
                    {
                        if (objWareGrade.Adapsin)
                            continue;

                        if ((await ImprovementManager
                                .GetCachedImprovementListForValueOfAsync(CharacterObject,
                                                                         Improvement.ImprovementType.DisableBiowareGrade)).Any(
                                x => objWareGrade.Name.Contains(x.ImprovedName)))
                            continue;
                    }
                    else
                    {
                        if (CharacterObject.AdapsinEnabled)
                        {
                            if (!objWareGrade.Adapsin && objGradeList.Any(x => objWareGrade.Name.Contains(x.Name)))
                            {
                                continue;
                            }
                        }
                        else if (objWareGrade.Adapsin)
                            continue;

                        if ((await ImprovementManager
                                .GetCachedImprovementListForValueOfAsync(CharacterObject,
                                                                         Improvement.ImprovementType.DisableCyberwareGrade)).Any(
                                x => objWareGrade.Name.Contains(x.ImprovedName)))
                            continue;
                    }

                    if (CharacterObject.BurnoutEnabled)
                    {
                        if (!objWareGrade.Burnout
                            && objGradeList.Any(x => objWareGrade.Burnout && objWareGrade.Name.Contains(x.Name)))
                        {
                            continue;
                        }
                    }
                    else if (objWareGrade.Burnout)
                        continue;

                    if (CharacterObjectSettings.BannedWareGrades.Any(s => objWareGrade.Name.Contains(s))
                        && !CharacterObject.IgnoreRules)
                        continue;

                    lstCyberwareGrades.Add(new ListItem(objWareGrade.Name, objWareGrade.CurrentDisplayName));
                }
                
                await cboCyberwareGrade.PopulateWithListItemsAsync(lstCyberwareGrades);
            }
        }

        /// <summary>
        /// Check the character and determine if it has broken any of the rules.
        /// </summary>
        public async ValueTask<bool> CheckCharacterValidity(bool blnUseArgBuildPoints = false, int intBuildPoints = 0, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (CharacterObject.IgnoreRules)
                return true;

            bool blnValid = true;
            using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                          out StringBuilder sbdMessage))
            {
                sbdMessage.Append(await LanguageManager.GetStringAsync("Message_InvalidBeginning"));
                using (await CursorWait.NewAsync(this, token: token))
                {
                    // Check if the character has more than 1 Martial Art, not counting qualities. TODO: Make the OTP check an optional rule. Make the Martial Arts limit an optional rule.
                    int intMartialArts = CharacterObject.MartialArts.Count(objArt => !objArt.IsQuality);
                    if (intMartialArts > 1)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .AppendFormat(GlobalSettings.CultureInfo,
                                                await LanguageManager.GetStringAsync("Message_InvalidPointExcess"),
                                                intMartialArts - 1)
                                  .Append(await LanguageManager.GetStringAsync("String_Space"))
                                  .Append(await LanguageManager.GetStringAsync("String_MartialArtsCount"));
                    }

                    // Check if the character has more than 5 Techniques in a Martial Art
                    if (CharacterObject.MartialArts.Count > 0)
                    {
                        int intTechniques = 0;
                        foreach (MartialArt objLoopArt in CharacterObject.MartialArts)
                            intTechniques += objLoopArt.Techniques.Count;
                        if (intTechniques > 5)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t')
                                      .AppendFormat(GlobalSettings.CultureInfo,
                                                    await LanguageManager.GetStringAsync("Message_InvalidPointExcess"),
                                                    intTechniques - 5)
                                      .Append(await LanguageManager.GetStringAsync("String_Space"))
                                      .Append(await LanguageManager.GetStringAsync("String_TechniquesCount"));
                        }
                    }

                    // if positive points > 25
                    if (CharacterObject.PositiveQualityKarma > CharacterObjectSettings.QualityKarmaLimit
                        && !CharacterObjectSettings.ExceedPositiveQualities)
                    {
                        sbdMessage.AppendLine().Append('\t').AppendFormat(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync("Message_PositiveQualityLimit"),
                            CharacterObjectSettings.QualityKarmaLimit);
                        blnValid = false;
                    }

                    // if negative points > 25
                    if (CharacterObject.NegativeQualityLimitKarma > CharacterObjectSettings.QualityKarmaLimit
                        && !CharacterObjectSettings.ExceedNegativeQualities)
                    {
                        sbdMessage.AppendLine().Append('\t').AppendFormat(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync("Message_NegativeQualityLimit"),
                            CharacterObjectSettings.QualityKarmaLimit);
                        blnValid = false;
                    }

                    if (CharacterObject.FriendsInHighPlaces)
                    {
                        if (CharacterObject.Contacts.Any(x => x.Connection < 8
                                                              && Math.Max(0, x.Connection) + Math.Max(0, x.Loyalty) > 7
                                                              && !x.Free))
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t')
                                      .Append(await LanguageManager.GetStringAsync("Message_HighContact"));
                        }
                    }
                    else if (CharacterObject.Contacts.Any(
                                 x => Math.Max(0, x.Connection) + Math.Max(0, x.Loyalty) > 7 && !x.Free))
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .Append(await LanguageManager.GetStringAsync("Message_HighContact"));
                    }

                    // Check if the character has gone over the Build Point total.
                    if (!blnUseArgBuildPoints)
                        intBuildPoints = await CalculateBP(false, token);
                    int intStagedPurchaseQualityPoints = await CharacterObject.Qualities
                                                                              .SumAsync(objQuality =>
                                                                                      objQuality.StagedPurchase
                                                                                      && objQuality.Type
                                                                                      == QualityType.Positive
                                                                                      && objQuality.ContributeToBP,
                                                                                  x => x.BP, token);
                    if (intBuildPoints + intStagedPurchaseQualityPoints < 0 && !_blnFreestyle)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .AppendFormat(GlobalSettings.CultureInfo,
                                                await LanguageManager.GetStringAsync("Message_InvalidPointExcess"),
                                                -(intBuildPoints + intStagedPurchaseQualityPoints))
                                  .Append(await LanguageManager.GetStringAsync("String_Space"))
                                  .Append(await LanguageManager.GetStringAsync("String_Karma"));
                    }

                    // if character has more than permitted Metagenic qualities
                    if (CharacterObject.MetagenicLimit > 0)
                    {
                        if (-CharacterObject.MetagenicNegativeQualityKarma > CharacterObject.MetagenicLimit)
                        {
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_OverNegativeMetagenicQualities"),
                                -CharacterObject.MetagenicNegativeQualityKarma, CharacterObject.MetagenicLimit);
                            blnValid = false;
                        }

                        if (CharacterObject.MetagenicPositiveQualityKarma > CharacterObject.MetagenicLimit)
                        {
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_OverPositiveMetagenicQualities"),
                                CharacterObject.MetagenicPositiveQualityKarma, CharacterObject.MetagenicLimit);
                            blnValid = false;
                        }

                        if (-CharacterObject.MetagenicNegativeQualityKarma
                            != CharacterObject.MetagenicPositiveQualityKarma &&
                            -CharacterObject.MetagenicNegativeQualityKarma
                            != CharacterObject.MetagenicPositiveQualityKarma - 1)
                        {
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_MetagenicQualitiesUnbalanced"),
                                -CharacterObject.MetagenicNegativeQualityKarma,
                                CharacterObject.MetagenicPositiveQualityKarma - 1,
                                CharacterObject.MetagenicPositiveQualityKarma);
                            blnValid = false;
                        }
                    }

                    // Check if the character has more attributes at their metatype max than allowed
                    if (CharacterObject.Settings.MaxNumberMaxAttributesCreate
                        < await CharacterObject.AttributeSection.AttributeList.GetCountAsync(token))
                    {
                        int intCountAttributesAtMax
                            = await CharacterObject.AttributeSection.AttributeList.CountAsync(
                                async x => x.MetatypeCategory == CharacterAttrib.AttributeCategory.Standard
                                           && await x.AtMetatypeMaximumAsync, token);
                        if (intCountAttributesAtMax > CharacterObject.Settings.MaxNumberMaxAttributesCreate)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                              await LanguageManager.GetStringAsync(
                                                                                  "Message_TooManyAttributesAtMax"),
                                                                              intCountAttributesAtMax,
                                                                              CharacterObject.Settings
                                                                                  .MaxNumberMaxAttributesCreate);
                        }
                    }

                    int i = CharacterObject.TotalAttributes
                            - CalculateAttributePriorityPoints(CharacterObject.AttributeSection.AttributeList);
                    // Check if the character has gone over on Primary Attributes
                    if (i < 0)
                    {
                        //TODO: ATTACH TO ATTRIBUTE SECTION
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidAttributeExcess"), -i);
                    }

                    i = CharacterObject.TotalSpecial
                        - CalculateAttributePriorityPoints(CharacterObject.AttributeSection.SpecialAttributeList);
                    // Check if the character has gone over on Special Attributes
                    if (i < 0)
                    {
                        //TODO: ATTACH TO ATTRIBUTE SECTION
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidSpecialExcess"), -i);
                    }

                    // Check if the character has gone over on Skill Groups
                    if (CharacterObject.SkillsSection.SkillGroupPoints < 0)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidSkillGroupExcess"),
                                                                          -CharacterObject.SkillsSection
                                                                              .SkillGroupPoints);
                    }

                    // Check if the character has gone over on Active Skills
                    if (CharacterObject.SkillsSection.SkillPoints < 0)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidActiveSkillExcess"),
                                                                          -CharacterObject.SkillsSection.SkillPoints);
                    }

                    // Check if the character has gone over on Knowledge Skills
                    if (CharacterObject.SkillsSection.KnowledgeSkillPointsRemain < 0)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidKnowledgeSkillExcess"),
                                                                          -CharacterObject.SkillsSection
                                                                              .KnowledgeSkillPointsRemain);
                    }

                    if (CharacterObject.SkillsSection.Skills.Any(s => s.Specializations.Count > 1))
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidActiveSkillExcessSpecializations"),
                                                                          -CharacterObject.SkillsSection
                                                                              .KnowledgeSkillPointsRemain);
                        foreach (Skill objSkill in CharacterObject.SkillsSection.Skills.Where(
                                     s => s.Specializations.Count > 1))
                        {
                            sbdMessage.AppendLine().Append(objSkill.CurrentDisplayName)
                                      .Append(await LanguageManager.GetStringAsync("String_Space")).Append('(')
                                      .AppendJoin(',' + await LanguageManager.GetStringAsync("String_Space"),
                                                  objSkill.Specializations.Select(x => x.CurrentDisplayName))
                                      .Append(')');
                        }
                    }

                    // Check if the character has gone over the Nuyen limit.
                    decimal decNuyen = await CalculateNuyen(token);
                    if (decNuyen < 0)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .AppendFormat(GlobalSettings.CultureInfo,
                                                await LanguageManager.GetStringAsync("Message_InvalidNuyenExcess"),
                                                (-decNuyen).ToString(CharacterObjectSettings.NuyenFormat,
                                                                     GlobalSettings.CultureInfo)).Append(await LanguageManager.GetStringAsync("String_NuyenSymbol"));
                    }

                    if (CharacterObject.StolenNuyen < 0)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidStolenNuyenExcess"),
                                                                          (-CharacterObject.StolenNuyen).ToString(
                                                                              CharacterObjectSettings.NuyenFormat,
                                                                              GlobalSettings.CultureInfo)).Append(await LanguageManager.GetStringAsync("String_NuyenSymbol"));
                    }

                    // Check if the character's Essence is above 0.
                    if (CharacterObject.ESS.MetatypeMaximum > 0)
                    {
                        decimal decEss = await CharacterObject.EssenceAsync();
                        decimal decExcessEss = 0.0m;
                        // Need to split things up this way because without internal rounding, Essence can be as small as the player wants as long as it is positive
                        // And getting the smallest positive number supported by the decimal type is way trickier than just checking if it's zero or negative
                        if (CharacterObjectSettings.DontRoundEssenceInternally)
                        {
                            if (decEss < 0)
                                decExcessEss = -decEss;
                            else if (decEss == 0)
                                decExcessEss
                                    = 10.0m.RaiseToPower(-CharacterObjectSettings
                                                             .EssenceDecimals); // Hacky, but necessary so that the player knows they need to increase their ESS
                        }
                        else
                        {
                            decimal decMinEss = 10.0m.RaiseToPower(-CharacterObjectSettings.EssenceDecimals);
                            if (decEss < decMinEss)
                                decExcessEss = decMinEss - decEss;
                        }

                        if (decExcessEss > 0)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_InvalidEssenceExcess"),
                                decExcessEss);
                        }
                    }

                    // If the character has the Spells & Spirits Tab enabled, make sure a Tradition has been selected.
                    if ((CharacterObject.MagicianEnabled || CharacterObject.AdeptEnabled)
                        && CharacterObject.MagicTradition.Type != TraditionType.MAG)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .Append(await LanguageManager.GetStringAsync("Message_InvalidNoTradition"));
                    }

                    // If the character has the Spells & Spirits Tab enabled, make sure a Tradition has been selected.
                    if (CharacterObject.AdeptEnabled
                        && CharacterObject.PowerPointsUsed > CharacterObject.PowerPointsTotal)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidPowerPoints"),
                                                                          CharacterObject.PowerPointsUsed
                                                                          - CharacterObject.PowerPointsTotal,
                                                                          CharacterObject.PowerPointsTotal);
                    }

                    // If the character has the Technomancer Tab enabled, make sure a Stream has been selected.
                    if (CharacterObject.TechnomancerEnabled && CharacterObject.MagicTradition.Type != TraditionType.RES)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .Append(await LanguageManager.GetStringAsync("Message_InvalidNoStream"));
                    }

                    // Check if the character has more than the permitted amount of native languages.
                    int intLanguages
                        = CharacterObject.SkillsSection.KnowledgeSkills.Count(objSkill => objSkill.IsNativeLanguage);

                    int intLanguageLimit = 1 + (await ImprovementManager
                            .ValueOfAsync(CharacterObject,
                                          Improvement.ImprovementType.NativeLanguageLimit))
                                               .StandardRound();

                    if (intLanguages != intLanguageLimit)
                    {
                        if (intLanguages > intLanguageLimit)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                              await LanguageManager.GetStringAsync(
                                                                                  "Message_OverLanguageLimit"),
                                                                              intLanguages, intLanguageLimit);
                        }
                        else if (Program.ShowMessageBox(this,
                                                        string.Format(
                                                            GlobalSettings.CultureInfo,
                                                            await LanguageManager.GetStringAsync(
                                                                "Message_ExtraNativeLanguages")
                                                            , (intLanguageLimit - intLanguages).ToString(
                                                                GlobalSettings.CultureInfo)),
                                                        await LanguageManager.GetStringAsync(
                                                            "MessageTitle_ExtraNativeLanguages"),
                                                        MessageBoxButtons.YesNo,
                                                        MessageBoxIcon.Warning) == DialogResult.No)
                        {
                            blnValid = false;
                        }
                    }

                    // Check the character's equipment and make sure nothing goes over their set Maximum Availability.
                    // Number of items over the specified Availability the character is allowed to have (typically from the Restricted Gear Quality).
                    Dictionary<int, int> dicRestrictedGearLimits = new Dictionary<int, int>(1);
                    List<Improvement> lstUsedImprovements
                        = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                            CharacterObject, Improvement.ImprovementType.RestrictedGear);
                    bool blnHasRestrictedGearAvailable = lstUsedImprovements.Count != 0;
                    if (blnHasRestrictedGearAvailable)
                    {
                        foreach (Improvement objImprovement in lstUsedImprovements)
                        {
                            int intLoopAvailability = objImprovement.Value.StandardRound();
                            if (dicRestrictedGearLimits.TryGetValue(intLoopAvailability, out int intExistingValue))
                                dicRestrictedGearLimits[intLoopAvailability] = intExistingValue + objImprovement.Rating;
                            else
                                dicRestrictedGearLimits.Add(intLoopAvailability, objImprovement.Rating);
                        }
                    }

                    // Remove all Restricted Gear availabilities with non-positive counts
                    foreach (int intLoopAvailability in dicRestrictedGearLimits.Keys.ToList())
                    {
                        if (dicRestrictedGearLimits.TryGetValue(intLoopAvailability, out int intLoopCount)
                            && intLoopCount <= 0)
                            dicRestrictedGearLimits.Remove(intLoopAvailability);
                    }

                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdAvailItems))
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdRestrictedItems))
                    {
                        int intRestrictedCount = 0;

                        // Gear Availability.
                        foreach (Gear objGear in CharacterObject.Gear)
                        {
                            objGear.CheckRestrictedGear(dicRestrictedGearLimits, sbdAvailItems, sbdRestrictedItems,
                                                        ref intRestrictedCount);
                        }

                        // Cyberware Availability.
                        foreach (Cyberware objCyberware in CharacterObject.Cyberware)
                        {
                            objCyberware.CheckRestrictedGear(dicRestrictedGearLimits, sbdAvailItems, sbdRestrictedItems,
                                                             ref intRestrictedCount);
                        }

                        // Armor Availability.
                        foreach (Armor objArmor in CharacterObject.Armor)
                        {
                            objArmor.CheckRestrictedGear(dicRestrictedGearLimits, sbdAvailItems, sbdRestrictedItems,
                                                         ref intRestrictedCount);
                        }

                        // Weapon Availability.
                        foreach (Weapon objWeapon in CharacterObject.Weapons)
                        {
                            objWeapon.CheckRestrictedGear(dicRestrictedGearLimits, sbdAvailItems, sbdRestrictedItems,
                                                          ref intRestrictedCount);
                        }

                        // Vehicle Availability.
                        foreach (Vehicle objVehicle in CharacterObject.Vehicles)
                        {
                            objVehicle.CheckRestrictedGear(dicRestrictedGearLimits, sbdAvailItems, sbdRestrictedItems,
                                                           ref intRestrictedCount);
                        }

                        // Make sure the character is not carrying more items over the allowed Avail than they are allowed.
                        if (intRestrictedCount > 0)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                              await LanguageManager.GetStringAsync(
                                                                                  "Message_InvalidAvail"),
                                                                              intRestrictedCount,
                                                                              CharacterObjectSettings
                                                                                  .MaximumAvailability);
                            sbdMessage.Append(sbdAvailItems);
                            if (blnHasRestrictedGearAvailable)
                            {
                                sbdMessage.AppendLine().AppendFormat(GlobalSettings.CultureInfo,
                                                                     await LanguageManager.GetStringAsync(
                                                                         "Message_RestrictedGearUsed"),
                                                                     sbdRestrictedItems.ToString());
                            }
                        }
                    }

                    // Check for any illegal cyberware grades
                    using (new FetchSafelyFromPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdIllegalCyberwareFromGrade))
                    {
                        foreach (Cyberware objCyberware in CharacterObject.Cyberware)
                        {
                            objCyberware.CheckBannedGrades(sbdIllegalCyberwareFromGrade);
                        }

                        foreach (Vehicle objVehicle in CharacterObject.Vehicles)
                        {
                            foreach (Cyberware objCyberware in objVehicle.Mods.SelectMany(objMod => objMod.Cyberware))
                            {
                                objCyberware.CheckBannedGrades(sbdIllegalCyberwareFromGrade);
                            }

                            foreach (Cyberware objCyberware in objVehicle.WeaponMounts.SelectMany(
                                         objMount => objMount.Mods.SelectMany(objMod => objMod.Cyberware)))
                            {
                                objCyberware.CheckBannedGrades(sbdIllegalCyberwareFromGrade);
                            }
                        }

                        if (sbdIllegalCyberwareFromGrade.Length > 0)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t')
                                      .Append(await LanguageManager.GetStringAsync("Message_InvalidCyberwareGrades"))
                                      .Append(sbdIllegalCyberwareFromGrade);
                        }
                    }

                    // Cyberware: Prototype Transhuman
                    decimal decPrototypeTranshumanEssenceMax = CharacterObject.PrototypeTranshuman;
                    if (decPrototypeTranshumanEssenceMax > 0)
                    {
                        decimal decPrototypeTranshumanEssenceUsed = CharacterObject.PrototypeTranshumanEssenceUsed;
                        if (decPrototypeTranshumanEssenceMax < decPrototypeTranshumanEssenceUsed)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_OverPrototypeLimit"),
                                decPrototypeTranshumanEssenceUsed.ToString(CharacterObjectSettings.EssenceFormat,
                                                                           GlobalSettings.CultureInfo),
                                decPrototypeTranshumanEssenceMax.ToString(CharacterObjectSettings.EssenceFormat,
                                                                          GlobalSettings.CultureInfo));
                        }
                    }

                    // Check item Capacities if the option is enabled.
                    if (CharacterObjectSettings.EnforceCapacity)
                    {
                        List<string> lstOverCapacity = new List<string>(1);
                        bool blnOverCapacity = false;
                        int intCapacityOver = 0;
                        // Armor Capacity.
                        foreach (Armor objArmor in CharacterObject.Armor.Where(
                                     objArmor => objArmor.CapacityRemaining < 0))
                        {
                            blnOverCapacity = true;
                            lstOverCapacity.Add(objArmor.Name);
                            intCapacityOver++;
                        }

                        // Gear Capacity.
                        foreach (Gear objGear in CharacterObject.Gear)
                        {
                            if (objGear.CapacityRemaining < 0)
                            {
                                blnOverCapacity = true;
                                lstOverCapacity.Add(objGear.Name);
                                intCapacityOver++;
                            }

                            // Child Gear.
                            foreach (Gear objChild in
                                     objGear.Children.Where(objChild => objChild.CapacityRemaining < 0))
                            {
                                blnOverCapacity = true;
                                lstOverCapacity.Add(objChild.Name);
                                intCapacityOver++;
                            }
                        }

                        // Cyberware Capacity.
                        foreach (Cyberware objCyberware in CharacterObject.Cyberware)
                        {
                            if (objCyberware.CapacityRemaining < 0)
                            {
                                blnOverCapacity = true;
                                lstOverCapacity.Add(objCyberware.Name);
                                intCapacityOver++;
                            }

                            // Check plugins.
                            foreach (Cyberware objChild in objCyberware.Children.Where(
                                         objChild => objChild.CapacityRemaining < 0))
                            {
                                blnOverCapacity = true;
                                lstOverCapacity.Add(objChild.Name);
                                intCapacityOver++;
                            }
                        }

                        // Vehicle Capacity.
                        foreach (Vehicle objVehicle in CharacterObject.Vehicles)
                        {
                            if (CharacterObjectSettings.BookEnabled("R5"))
                            {
                                if (objVehicle.IsDrone && CharacterObjectSettings.DroneMods)
                                {
                                    if (objVehicle.DroneModSlotsUsed > objVehicle.DroneModSlots)
                                    {
                                        blnOverCapacity = true;
                                        lstOverCapacity.Add(objVehicle.Name);
                                        intCapacityOver++;
                                    }
                                }
                                else
                                {
                                    if (objVehicle.OverR5Capacity())
                                    {
                                        blnOverCapacity = true;
                                        lstOverCapacity.Add(objVehicle.Name);
                                        intCapacityOver++;
                                    }
                                }
                            }
                            else if (objVehicle.Slots < objVehicle.SlotsUsed)
                            {
                                blnOverCapacity = true;
                                lstOverCapacity.Add(objVehicle.Name);
                                intCapacityOver++;
                            }

                            // Check Vehicle Gear.
                            foreach (Gear objGear in objVehicle.GearChildren)
                            {
                                if (objGear.CapacityRemaining < 0)
                                {
                                    blnOverCapacity = true;
                                    lstOverCapacity.Add(objGear.Name);
                                    intCapacityOver++;
                                }

                                // Check Child Gear.
                                foreach (Gear objChild in objGear.Children.Where(
                                             objChild => objChild.CapacityRemaining < 0))
                                {
                                    blnOverCapacity = true;
                                    lstOverCapacity.Add(objChild.Name);
                                    intCapacityOver++;
                                }
                            }
                        }

                        if (blnOverCapacity)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_CapacityReachedValidate"),
                                intCapacityOver);
                            foreach (string strItem in lstOverCapacity)
                            {
                                sbdMessage.AppendLine().Append("\t- ").Append(strItem);
                            }
                        }
                    }

                    //Check Drone mods for illegalities
                    if (CharacterObjectSettings.BookEnabled("R5"))
                    {
                        List<string> lstDronesIllegalDowngrades = new List<string>(1);
                        bool blnIllegalDowngrades = false;
                        int intIllegalDowngrades = 0;
                        foreach (Vehicle objVehicle in CharacterObject.Vehicles)
                        {
                            if (!objVehicle.IsDrone || !CharacterObjectSettings.DroneMods)
                                continue;
                            foreach (string strModCategory in objVehicle.Mods
                                                                        .Where(objMod => !objMod.IncludedInVehicle
                                                                                   && objMod.Equipped
                                                                                   && objMod.Downgrade)
                                                                        .Select(x => x.Category))
                            {
                                //Downgrades can't reduce a attribute to less than 1 (except Speed which can go to 0)
                                if (strModCategory == "Handling"
                                    && Convert.ToInt32(objVehicle.TotalHandling, GlobalSettings.InvariantCultureInfo)
                                    < 1 ||
                                    strModCategory == "Speed"
                                    && Convert.ToInt32(objVehicle.TotalSpeed, GlobalSettings.InvariantCultureInfo) < 0
                                    ||
                                    strModCategory == "Acceleration"
                                    && Convert.ToInt32(objVehicle.TotalAccel, GlobalSettings.InvariantCultureInfo) < 1
                                    ||
                                    strModCategory == "Body" && objVehicle.TotalBody < 1 ||
                                    strModCategory == "Armor" && objVehicle.TotalArmor < 1 ||
                                    strModCategory == "Sensor" && objVehicle.CalculatedSensor < 1)
                                {
                                    blnIllegalDowngrades = true;
                                    intIllegalDowngrades++;
                                    lstDronesIllegalDowngrades.Add(objVehicle.Name);
                                    break;
                                }
                            }
                        }

                        if (blnIllegalDowngrades)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_DroneIllegalDowngrade"),
                                intIllegalDowngrades);
                            foreach (string strItem in lstDronesIllegalDowngrades)
                            {
                                sbdMessage.AppendLine().Append("\t- ").Append(strItem);
                            }
                        }
                    }

                    i = CharacterObject.Attributes
                        - CalculateAttributePriorityPoints(CharacterObject.AttributeSection.AttributeList);
                    // Check if the character has gone over on Primary Attributes
                    if (blnValid && i > 0 && Program.ShowMessageBox(this,
                                                                    string.Format(
                                                                        GlobalSettings.CultureInfo,
                                                                        await LanguageManager.GetStringAsync(
                                                                            "Message_ExtraPoints")
                                                                        , i.ToString(
                                                                            GlobalSettings.CultureInfo)
                                                                        , await LanguageManager.GetStringAsync("Label_SummaryPrimaryAttributes")),
                                                                    await LanguageManager.GetStringAsync(
                                                                        "MessageTitle_ExtraPoints"),
                                                                    MessageBoxButtons.YesNo,
                                                                    MessageBoxIcon.Warning) == DialogResult.No)
                    {
                        blnValid = false;
                    }

                    i = CharacterObject.Special
                        - CalculateAttributePriorityPoints(CharacterObject.AttributeSection.SpecialAttributeList);
                    // Check if the character has gone over on Special Attributes
                    if (blnValid && i > 0 && Program.ShowMessageBox(this,
                                                                    string.Format(
                                                                        GlobalSettings.CultureInfo,
                                                                        await LanguageManager.GetStringAsync(
                                                                            "Message_ExtraPoints")
                                                                        , i.ToString(
                                                                            GlobalSettings.CultureInfo)
                                                                        , await LanguageManager.GetStringAsync("Label_SummarySpecialAttributes")),
                                                                    await LanguageManager.GetStringAsync(
                                                                        "MessageTitle_ExtraPoints"),
                                                                    MessageBoxButtons.YesNo,
                                                                    MessageBoxIcon.Warning) == DialogResult.No)
                    {
                        blnValid = false;
                    }

                    // Check if the character has gone over on Skill Groups
                    if (blnValid && CharacterObject.SkillsSection.SkillGroupPoints > 0
                                 && Program.ShowMessageBox(this,
                                                           string.Format(
                                                               GlobalSettings.CultureInfo,
                                                               await LanguageManager.GetStringAsync(
                                                                   "Message_ExtraPoints")
                                                               , CharacterObject.SkillsSection.SkillGroupPoints
                                                                   .ToString(GlobalSettings.CultureInfo)
                                                               , await LanguageManager.GetStringAsync("Label_SummarySkillGroups")),
                                                           await LanguageManager.GetStringAsync(
                                                               "MessageTitle_ExtraPoints"),
                                                           MessageBoxButtons.YesNo,
                                                           MessageBoxIcon.Warning) == DialogResult.No)
                    {
                        blnValid = false;
                    }

                    // Check if the character has gone over on Active Skills
                    if (blnValid && CharacterObject.SkillsSection.SkillPoints > 0 && Program.ShowMessageBox(
                            this,
                            string.Format(GlobalSettings.CultureInfo,
                                          await LanguageManager.GetStringAsync("Message_ExtraPoints")
                                          , CharacterObject.SkillsSection.SkillPoints.ToString(
                                              GlobalSettings.CultureInfo)
                                          , await LanguageManager.GetStringAsync("Label_SummaryActiveSkills")),
                            await LanguageManager.GetStringAsync("MessageTitle_ExtraPoints"), MessageBoxButtons.YesNo,
                            MessageBoxIcon.Warning) == DialogResult.No)
                    {
                        blnValid = false;
                    }

                    // Check if the character has gone over on Knowledge Skills
                    if (blnValid && CharacterObject.SkillsSection.KnowledgeSkillPointsRemain > 0
                                 && Program.ShowMessageBox(this,
                                                           string.Format(
                                                               GlobalSettings.CultureInfo,
                                                               await LanguageManager.GetStringAsync(
                                                                   "Message_ExtraPoints")
                                                               , CharacterObject.SkillsSection
                                                                   .KnowledgeSkillPointsRemain
                                                                   .ToString(GlobalSettings.CultureInfo)
                                                               , await LanguageManager.GetStringAsync("Label_SummaryKnowledgeSkills")),
                                                           await LanguageManager.GetStringAsync(
                                                               "MessageTitle_ExtraPoints"),
                                                           MessageBoxButtons.YesNo,
                                                           MessageBoxIcon.Warning) == DialogResult.No)
                    {
                        blnValid = false;
                    }
                }

                if (!blnValid && sbdMessage.Length > (await LanguageManager.GetStringAsync("Message_InvalidBeginning")).Length)
                    Program.ShowMessageBox(this, sbdMessage.ToString(),
                                                    await LanguageManager.GetStringAsync("MessageTitle_Invalid"),
                                                    MessageBoxButtons.OK, MessageBoxIcon.Error);
            }

            return blnValid;
        }

        /// <summary>
        /// Confirm that the character can move to career mode and perform final actions for karma carryover and such.
        /// </summary>
        public async ValueTask<bool> ValidateCharacter(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();

            int intBuildPoints = await CalculateBP(false, token);

            if (await CheckCharacterValidity(true, intBuildPoints, token))
            {
                // See if the character has any Karma remaining.
                if (intBuildPoints > CharacterObjectSettings.KarmaCarryover)
                {
                    if (!CharacterObject.EffectiveBuildMethodUsesPriorityTables)
                    {
                        if (Program.ShowMessageBox(this, string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_NoExtraKarma"), intBuildPoints.ToString(GlobalSettings.CultureInfo)),
                                await LanguageManager.GetStringAsync("MessageTitle_ExtraKarma"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning) == DialogResult.No)
                            return false;
                    }
                    else if (Program.ShowMessageBox(this, string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ExtraKarma")
                            , intBuildPoints.ToString(GlobalSettings.CultureInfo)
                            , CharacterObjectSettings.KarmaCarryover.ToString(GlobalSettings.CultureInfo)),
                        await LanguageManager.GetStringAsync("MessageTitle_ExtraKarma"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning) == DialogResult.No)
                    {
                        return false;
                    }
                }
                if (CharacterObject.Nuyen > 5000 && Program.ShowMessageBox(this, string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Message_ExtraNuyen")
                        , CharacterObject.Nuyen.ToString(CharacterObjectSettings.NuyenFormat, GlobalSettings.CultureInfo)
                        , 5000.ToString(CharacterObjectSettings.NuyenFormat, GlobalSettings.CultureInfo)),
                    await LanguageManager.GetStringAsync("MessageTitle_ExtraNuyen"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning) == DialogResult.No)
                    return false;
                if (GlobalSettings.CreateBackupOnCareer && chkCharacterCreated.Checked)
                {
                    // Create a pre-Career Mode backup of the character.
                    // Make sure the backup directory exists.
                    if (!Directory.Exists(Path.Combine(Utils.GetStartupPath, "saves", "backup")))
                    {
                        try
                        {
                            Directory.CreateDirectory(Path.Combine(Utils.GetStartupPath, "saves", "backup"));
                        }
                        catch (UnauthorizedAccessException)
                        {
                            Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_Insufficient_Permissions_Warning"));
                            return false;
                        }
                    }

                    string strNewName = Path.GetFileNameWithoutExtension(CharacterObject.FileName);
                    if (string.IsNullOrEmpty(strNewName))
                    {
                        strNewName = CharacterObject.Alias;
                        if (string.IsNullOrEmpty(strNewName))
                        {
                            strNewName = CharacterObject.Name;
                            if (string.IsNullOrEmpty(strNewName))
                                strNewName = Guid.NewGuid().ToString("N", GlobalSettings.InvariantCultureInfo);
                        }
                    }
                    strNewName += await LanguageManager.GetStringAsync("String_Space") + '(' + await LanguageManager.GetStringAsync("Title_CreateMode") + ").chum5";

                    strNewName = Path.Combine(Utils.GetStartupPath, "saves", "backup", strNewName);

                    using (await CursorWait.NewAsync(this, token: token))
                    {
                        using (LoadingBar frmLoadingBar = await Program.CreateAndShowProgressBarAsync())
                        {
                            await frmLoadingBar.PerformStepAsync(CharacterObject.CharacterName,
                                                                LoadingBar.ProgressBarTextPatterns.Saving, token);
                            if (!await CharacterObject.SaveAsync(strNewName, token: token))
                                return false;
                        }
                    }
                }

                SkipUpdate = true;
                try
                {
                    // If the character does not have any Lifestyles, give them the Street Lifestyle.
                    if (CharacterObject.Lifestyles.Count == 0)
                    {
                        Lifestyle objLifestyle = new Lifestyle(CharacterObject);
                        XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("lifestyles.xml", token: token);
                        XmlNode objXmlLifestyle
                            = objXmlDocument.SelectSingleNode("/chummer/lifestyles/lifestyle[name = \"Street\"]");

                        objLifestyle.Create(objXmlLifestyle);

                        await CharacterObject.Lifestyles.AddAsync(objLifestyle);
                    }

                    decimal decStartingNuyen;
                    using (ThreadSafeForm<SelectLifestyleStartingNuyen> frmStartingNuyen
                           = await ThreadSafeForm<SelectLifestyleStartingNuyen>.GetAsync(
                               () => new SelectLifestyleStartingNuyen(CharacterObject), token))
                    {
                        if (await frmStartingNuyen.ShowDialogSafeAsync(this, token) != DialogResult.OK)
                            return false;
                        decStartingNuyen = frmStartingNuyen.MyForm.StartingNuyen;
                    }

                    // Assign starting values and overflows.
                    if (decStartingNuyen < 0)
                        decStartingNuyen = 0;
                    if (CharacterObject.Nuyen > 5000)
                        CharacterObject.Nuyen = 5000;
                    CharacterObject.Nuyen += decStartingNuyen;
                    // See if the character has any Karma remaining.
                    if (intBuildPoints > CharacterObjectSettings.KarmaCarryover)
                        CharacterObject.Karma = CharacterObject.EffectiveBuildMethodUsesPriorityTables
                            ? CharacterObjectSettings.KarmaCarryover
                            : 0;
                    else
                        CharacterObject.Karma = intBuildPoints;

                    return true;
                }
                finally
                {
                    SkipUpdate = false;
                }
            }

            return false;
        }

        /// <summary>
        /// Verify that the user wants to save this character as Created.
        /// </summary>
        public override async Task<bool> ConfirmSaveCreatedCharacter(CancellationToken token = default)
        {
            return Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ConfirmCreate"),
                await LanguageManager.GetStringAsync("MessageTitle_ConfirmCreate"), MessageBoxButtons.YesNo,
                MessageBoxIcon.Question) != DialogResult.No && await ValidateCharacter(token);
        }

        /// <summary>
        /// Create Cyberware from a Cyberware Suite.
        /// </summary>
        /// <param name="xmlSuiteNode">XmlNode for the cyberware suite to add.</param>
        /// <param name="xmlCyberwareNode">XmlNode for the Cyberware to add.</param>
        /// <param name="objGrade">CyberwareGrade to add the item as.</param>
        /// <param name="intRating">Rating of the Cyberware.</param>
        /// <param name="eSource">Source representing whether the suite is cyberware or bioware.</param>
        private Cyberware CreateSuiteCyberware(XmlNode xmlSuiteNode, XmlNode xmlCyberwareNode, Grade objGrade, int intRating, Improvement.ImprovementSource eSource)
        {
            // Create the Cyberware object.
            List<Weapon> lstWeapons = new List<Weapon>(1);
            List<Vehicle> lstVehicles = new List<Vehicle>(1);
            Cyberware objCyberware = new Cyberware(CharacterObject);
            string strForced = xmlSuiteNode.SelectSingleNode("name/@select")?.InnerText ?? string.Empty;

            objCyberware.Create(xmlCyberwareNode, objGrade, eSource, intRating, lstWeapons, lstVehicles, true, true, strForced);
            objCyberware.Suite = true;

            foreach (Weapon objWeapon in lstWeapons)
            {
                CharacterObject.Weapons.Add(objWeapon);
            }

            foreach (Vehicle objVehicle in lstVehicles)
            {
                CharacterObject.Vehicles.Add(objVehicle);
            }

            string strType = eSource == Improvement.ImprovementSource.Cyberware ? "cyberware" : "bioware";
            using (XmlNodeList xmlChildrenList = xmlSuiteNode.SelectNodes(strType + "s/" + strType))
            {
                if (xmlChildrenList?.Count > 0)
                {
                    XmlDocument objXmlDocument = CharacterObject.LoadData(strType + ".xml");
                    foreach (XmlNode objXmlChild in xmlChildrenList)
                    {
                        string strName = objXmlChild["name"]?.InnerText;
                        if (string.IsNullOrEmpty(strName))
                            continue;
                        XmlNode objXmlChildCyberware = objXmlDocument.SelectSingleNode("/chummer/" + strType + "s/" + strType + "[name = " + strName.CleanXPath() + ']');
                        int intChildRating = Convert.ToInt32(objXmlChild["rating"]?.InnerText, GlobalSettings.InvariantCultureInfo);

                        objCyberware.Children.Add(CreateSuiteCyberware(objXmlChild, objXmlChildCyberware, objGrade, intChildRating, eSource));
                    }
                }
            }

            return objCyberware;
        }

        /// <summary>
        /// Add a PACKS Kit to the character.
        /// </summary>
        public async ValueTask<bool> AddPACKSKit()
        {
            XmlNode objXmlKit;
            bool blnAddAgain;
            using (ThreadSafeForm<SelectPACKSKit> frmPickPACKSKit = await ThreadSafeForm<SelectPACKSKit>.GetAsync(() => new SelectPACKSKit(CharacterObject)))
            {
                // If the form was canceled, don't do anything.
                if (await frmPickPACKSKit.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return false;

                // Do not create child items for Gear if the chosen Kit is in the Custom category since these items will contain the exact plugins desired.
                //if (frmPickPACKSKit.SelectedCategory == "Custom")
                //blnCreateChildren = false;

                objXmlKit = (await CharacterObject.LoadDataAsync("packs.xml")).SelectSingleNode("/chummer/packs/pack[name = " + frmPickPACKSKit.MyForm.SelectedKit.CleanXPath() + " and category = " + SelectPACKSKit.SelectedCategory.CleanXPath() + ']');
                blnAddAgain = frmPickPACKSKit.MyForm.AddAgain;
            }

            if (objXmlKit == null)
                return false;
            const bool blnCreateChildren = true;
            // Update Qualities.
            XmlNode xmlQualities = objXmlKit["qualities"];
            if (xmlQualities != null)
            {
                XmlDocument xmlQualityDocument = await CharacterObject.LoadDataAsync("qualities.xml");

                // Positive and Negative Qualities.
                using (XmlNodeList xmlQualityList = xmlQualities.SelectNodes("*/quality"))
                {
                    if (xmlQualityList?.Count > 0)
                    {
                        foreach (XmlNode objXmlQuality in xmlQualityList)
                        {
                            XmlNode objXmlQualityNode = xmlQualityDocument.SelectSingleNode("/chummer/qualities/quality[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlQuality.InnerText.CleanXPath() + ']');

                            if (objXmlQualityNode == null)
                                continue;
                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            Quality objQuality = new Quality(CharacterObject);
                            string strForceValue = objXmlQuality.Attributes?["select"]?.InnerText ?? string.Empty;

                            objQuality.Create(objXmlQualityNode, QualitySource.Selected, lstWeapons, strForceValue);

                            await CharacterObject.Qualities.AddAsync(objQuality);

                            // Add any created Weapons to the character.
                            foreach (Weapon objWeapon in lstWeapons)
                            {
                                await CharacterObject.Weapons.AddAsync(objWeapon);
                            }
                        }
                    }
                }
            }

            //TODO: PACKS SKILLS?

            // Select a Martial Art.
            XmlNode xmlSelectMartialArt = objXmlKit["selectmartialart"];
            if (xmlSelectMartialArt != null)
            {
                string strForcedValue = xmlSelectMartialArt.Attributes?["select"]?.InnerText ?? string.Empty;

                using (ThreadSafeForm<SelectMartialArt> frmPickMartialArt = await ThreadSafeForm<SelectMartialArt>.GetAsync(() => new SelectMartialArt(CharacterObject)
                       {
                           ForcedValue = strForcedValue
                       }))
                {
                    if (await frmPickMartialArt.ShowDialogSafeAsync(this) != DialogResult.Cancel)
                    {
                        // Open the Martial Arts XML file and locate the selected piece.
                        XmlDocument objXmlMartialArtDocument = await CharacterObject.LoadDataAsync("martialarts.xml");

                        XmlNode objXmlArt = objXmlMartialArtDocument.SelectSingleNode("/chummer/martialarts/martialart[id = " + frmPickMartialArt.MyForm.SelectedMartialArt.CleanXPath() + ']');

                        MartialArt objMartialArt = new MartialArt(CharacterObject);
                        objMartialArt.Create(objXmlArt);
                        await CharacterObject.MartialArts.AddAsync(objMartialArt);
                    }
                }
            }

            // Update Martial Arts.
            XmlNode xmlMartialArts = objXmlKit["martialarts"];
            if (xmlMartialArts != null)
            {
                // Open the Martial Arts XML file and locate the selected art.
                XmlDocument objXmlMartialArtDocument = await CharacterObject.LoadDataAsync("martialarts.xml");

                using (XmlNodeList xmlMartialArtsList = xmlMartialArts.SelectNodes("martialart"))
                {
                    if (xmlMartialArtsList?.Count > 0)
                    {
                        foreach (XmlNode objXmlArt in xmlMartialArtsList)
                        {
                            MartialArt objArt = new MartialArt(CharacterObject);
                            XmlNode objXmlArtNode = objXmlMartialArtDocument.SelectSingleNode(
                                "/chummer/martialarts/martialart[(" + CharacterObjectSettings.BookXPath() +
                                ") and name = " + objXmlArt["name"]?.InnerText.CleanXPath() + ']');
                            if (objXmlArtNode == null)
                                continue;
                            objArt.Create(objXmlArtNode);
                            await CharacterObject.MartialArts.AddAsync(objArt);

                            // Check for Techniques.
                            using (XmlNodeList xmlTechniquesList = objXmlArt.SelectNodes("techniques/technique"))
                            {
                                if (xmlTechniquesList?.Count > 0)
                                {
                                    foreach (XmlNode xmlTechnique in xmlTechniquesList)
                                    {
                                        MartialArtTechnique objTechnique = new MartialArtTechnique(CharacterObject);
                                        XmlNode xmlTechniqueNode = objXmlMartialArtDocument.SelectSingleNode(
                                            "/chummer/techniques/technique[(" + CharacterObjectSettings.BookXPath() +
                                            ") and name = " + xmlTechnique["name"]?.InnerText.CleanXPath() + ']');
                                        objTechnique.Create(xmlTechniqueNode);
                                        await objArt.Techniques.AddAsync(objTechnique);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            /*
            // Update Adept Powers.
            if (objXmlKit["powers"] != null)
            {
                // Open the Powers XML file and locate the selected power.
                XmlDocument objXmlPowerDocument = XmlManager.Load("powers.xml");

                foreach (XmlNode objXmlPower in objXmlKit.SelectNodes("powers/power"))
                {
                    //TODO: Fix
                }
            }
            */

            // Update Complex Forms.
            XmlNode xmlComplexForms = objXmlKit["complexforms"];
            if (xmlComplexForms != null)
            {
                // Open the Programs XML file and locate the selected program.
                XmlDocument objXmlComplexFormDocument = await CharacterObject.LoadDataAsync("complexforms.xml");
                using (XmlNodeList xmlComplexFormsList = xmlComplexForms.SelectNodes("complexform"))
                {
                    if (xmlComplexFormsList?.Count > 0)
                    {
                        foreach (XmlNode objXmlComplexForm in xmlComplexFormsList)
                        {
                            XmlNode objXmlComplexFormNode =
                                objXmlComplexFormDocument.SelectSingleNode("/chummer/complexforms/complexform[(" +
                                                                           CharacterObjectSettings.BookXPath() +
                                                                           ") and name = " +
                                                                           objXmlComplexForm["name"]?.InnerText.CleanXPath() + ']');
                            if (objXmlComplexFormNode != null)
                            {
                                ComplexForm objComplexForm = new ComplexForm(CharacterObject);
                                objComplexForm.Create(objXmlComplexFormNode);

                                await CharacterObject.ComplexForms.AddAsync(objComplexForm);
                            }
                        }
                    }
                }
            }

            // Update AI Programs.
            XmlNode xmlPrograms = objXmlKit["programs"];
            if (xmlPrograms != null)
            {
                // Open the Programs XML file and locate the selected program.
                XmlDocument objXmlProgramDocument = await CharacterObject.LoadDataAsync("programs.xml");
                using (XmlNodeList xmlProgramsList = xmlPrograms.SelectNodes("program"))
                {
                    if (xmlProgramsList?.Count > 0)
                    {
                        foreach (XmlNode objXmlProgram in xmlProgramsList)
                        {
                            XmlNode objXmlProgramNode = objXmlProgramDocument.SelectSingleNode(
                                "/chummer/programs/program[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlProgram["name"]?.InnerText.CleanXPath() + ']');
                            if (objXmlProgramNode != null)
                            {
                                AIProgram objProgram = new AIProgram(CharacterObject);
                                objProgram.Create(objXmlProgramNode);

                                await CharacterObject.AIPrograms.AddAsync(objProgram);
                            }
                        }
                    }
                }
            }

            // Update Spells.
            XmlNode xmlSpells = objXmlKit["spells"];
            if (xmlSpells != null)
            {
                XmlDocument objXmlSpellDocument = await CharacterObject.LoadDataAsync("spells.xml");
                using (XmlNodeList xmlSpellsList = xmlSpells.SelectNodes("spell"))
                {
                    if (xmlSpellsList?.Count > 0)
                    {
                        foreach (XmlNode objXmlSpell in xmlSpellsList)
                        {
                            string strCategory = objXmlSpell["category"]?.InnerText;
                            string strName = objXmlSpell["name"].InnerText;
                            // Make sure the Spell has not already been added to the character.
                            if (CharacterObject.Spells.Any(x => x.Name == strName && x.Category == strCategory))
                                continue;
                            XmlNode objXmlSpellNode = objXmlSpellDocument.SelectSingleNode(
                                "/chummer/spells/spell[(" +
                                CharacterObjectSettings.BookXPath() + ") and name = " + strName.CleanXPath() + ']');

                            if (objXmlSpellNode == null)
                                continue;

                            Spell objSpell = new Spell(CharacterObject);
                            string strForceValue = objXmlSpell.Attributes?["select"]?.InnerText ?? string.Empty;
                            objSpell.Create(objXmlSpellNode, strForceValue);
                            await CharacterObject.Spells.AddAsync(objSpell);
                        }
                    }
                }
            }

            // Update Spirits.
            XmlNode xmlSpirits = objXmlKit["spirits"];
            if (xmlSpirits != null)
            {
                using (XmlNodeList xmlSpiritsList = xmlSpirits.SelectNodes("spirit"))
                {
                    if (xmlSpiritsList?.Count > 0)
                    {
                        foreach (XmlNode objXmlSpirit in xmlSpiritsList)
                        {
                            Spirit objSpirit = new Spirit(CharacterObject)
                            {
                                EntityType = SpiritType.Spirit,
                                Name = objXmlSpirit["name"].InnerText,
                                Force =
                                    Convert.ToInt32(objXmlSpirit["force"].InnerText,
                                        GlobalSettings.InvariantCultureInfo),
                                ServicesOwed = Convert.ToInt32(objXmlSpirit["services"].InnerText,
                                    GlobalSettings.InvariantCultureInfo)
                            };
                            await CharacterObject.Spirits.AddAsync(objSpirit);
                        }
                    }
                }
            }

            // Update Lifestyles.
            XmlNode xmlLifestyles = objXmlKit["lifestyles"];
            if (xmlLifestyles != null)
            {
                XmlDocument objXmlLifestyleDocument = await CharacterObject.LoadDataAsync("lifestyles.xml");

                foreach (XmlNode objXmlLifestyle in xmlLifestyles.SelectNodes("lifestyle"))
                {
                    // Create the Lifestyle.
                    XmlNode objXmlLifestyleNode = objXmlLifestyleDocument.SelectSingleNode("/chummer/lifestyles/lifestyle[name = " + objXmlLifestyle["baselifestyle"].InnerText.CleanXPath() + ']');
                    if (objXmlLifestyleNode == null)
                        continue;
                    Lifestyle objLifestyle = new Lifestyle(CharacterObject);
                    objLifestyle.Create(objXmlLifestyleNode);
                    // This is an Advanced Lifestyle, so build it manually.
                    objLifestyle.CustomName = objXmlLifestyle["name"]?.InnerText ?? string.Empty;
                    objLifestyle.Comforts = Convert.ToInt32(objXmlLifestyle["comforts"]?.InnerText, GlobalSettings.InvariantCultureInfo);
                    objLifestyle.Security = Convert.ToInt32(objXmlLifestyle["security"]?.InnerText, GlobalSettings.InvariantCultureInfo);
                    objLifestyle.Area = Convert.ToInt32(objXmlLifestyle["area"]?.InnerText, GlobalSettings.InvariantCultureInfo);

                    foreach (XmlNode objXmlQuality in objXmlLifestyle.SelectNodes("qualities/quality"))
                    {
                        LifestyleQuality lq = new LifestyleQuality(CharacterObject);
                        lq.Create(objXmlQuality, objLifestyle, CharacterObject, QualitySource.Selected);
                        await objLifestyle.LifestyleQualities.AddAsync(lq);
                    }

                    // Add the Lifestyle to the character and Lifestyle Tree.
                    await CharacterObject.Lifestyles.AddAsync(objLifestyle);
                }
            }

            // Update NuyenBP.
            string strNuyenBP = objXmlKit["nuyenbp"]?.InnerText;
            if (!string.IsNullOrEmpty(strNuyenBP) && decimal.TryParse(strNuyenBP, NumberStyles.Any, GlobalSettings.InvariantCultureInfo, out decimal decAmount))
            {
                //if (_objCharacter.BuildMethod == CharacterBuildMethod.Karma)
                //decAmount *= 2;

                CharacterObject.NuyenBP += decAmount;
            }

            XmlDocument objXmlGearDocument = await CharacterObject.LoadDataAsync("gear.xml");

            // Update Armor.
            XmlNode xmlArmors = objXmlKit["armors"];
            if (xmlArmors != null)
            {
                XmlDocument objXmlArmorDocument = await CharacterObject.LoadDataAsync("armor.xml");
                foreach (XmlNode objXmlArmor in xmlArmors.SelectNodes("armor"))
                {
                    XmlNode objXmlArmorNode = objXmlArmorDocument.SelectSingleNode("/chummer/armors/armor[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlArmor["name"].InnerText.CleanXPath() + ']');
                    if (objXmlArmorNode == null)
                        continue;
                    Armor objArmor = new Armor(CharacterObject);
                    List<Weapon> lstWeapons = new List<Weapon>(1);

                    objArmor.Create(objXmlArmorNode, Convert.ToInt32(objXmlArmor["rating"]?.InnerText, GlobalSettings.InvariantCultureInfo), lstWeapons, false, blnCreateChildren);
                    await CharacterObject.Armor.AddAsync(objArmor);

                    // Look for Armor Mods.
                    foreach (XmlNode objXmlMod in objXmlArmor.SelectNodes("mods/mod"))
                    {
                        XmlNode objXmlModNode = objXmlArmorDocument.SelectSingleNode("/chummer/mods/mod[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlMod["name"].InnerText.CleanXPath() + ']');
                        if (objXmlModNode != null)
                        {
                            ArmorMod objMod = new ArmorMod(CharacterObject);
                            int intRating = 0;
                            if (objXmlMod["rating"] != null)
                                intRating = Convert.ToInt32(objXmlMod["rating"].InnerText, GlobalSettings.InvariantCultureInfo);
                            objMod.Create(objXmlModNode, intRating, lstWeapons);

                            foreach (XmlNode objXmlGear in objXmlArmor.SelectNodes("gears/gear"))
                                AddPACKSGear(objXmlGearDocument, objXmlGear, objMod, blnCreateChildren);

                            await objArmor.ArmorMods.AddAsync(objMod);
                        }
                    }

                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objWeapon);
                    }

                    foreach (XmlNode objXmlGear in objXmlArmor.SelectNodes("gears/gear"))
                        AddPACKSGear(objXmlGearDocument, objXmlGear, objArmor, blnCreateChildren);
                }
            }

            // Update Weapons.
            XmlNode xmlWeapons = objXmlKit["weapons"];
            if (xmlWeapons != null)
            {
                XmlDocument objXmlWeaponDocument = await CharacterObject.LoadDataAsync("weapons.xml");

                XmlNodeList xmlWeaponsList = xmlWeapons.SelectNodes("weapon");
                await tsMain.DoThreadSafeAsync(() =>
                {
                    pgbProgress.Visible = true;
                    pgbProgress.Value = 0;
                    pgbProgress.Maximum = xmlWeaponsList.Count;
                });
                int i = 0;
                foreach (XmlNode objXmlWeapon in xmlWeaponsList)
                {
                    i++;
                    await tsMain.DoThreadSafeAsync(() => pgbProgress.Value = i);
                    Utils.DoEventsSafe();

                    XmlNode objXmlWeaponNode = objXmlWeaponDocument.SelectSingleNode("/chummer/weapons/weapon[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlWeapon["name"].InnerText.CleanXPath() + ']');
                    if (objXmlWeaponNode != null)
                    {
                        Weapon objWeapon = new Weapon(CharacterObject);
                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        objWeapon.Create(objXmlWeaponNode, lstWeapons, blnCreateChildren);
                        await CharacterObject.Weapons.AddAsync(objWeapon);

                        // Look for Weapon Accessories.
                        foreach (XmlNode objXmlAccessory in objXmlWeapon.SelectNodes("accessories/accessory"))
                        {
                            XmlNode objXmlAccessoryNode = objXmlWeaponDocument.SelectSingleNode("/chummer/accessories/accessory[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlAccessory["name"].InnerText.CleanXPath() + ']');
                            if (objXmlAccessoryNode == null)
                                continue;
                            WeaponAccessory objMod = new WeaponAccessory(CharacterObject);
                            string strMount = objXmlAccessory["mount"]?.InnerText ?? "Internal";
                            string strExtraMount = objXmlAccessory["extramount"]?.InnerText ?? "None";
                            objMod.Create(objXmlAccessoryNode, new Tuple<string, string>(strMount, strExtraMount), 0, false, blnCreateChildren);
                            objMod.Parent = objWeapon;

                            await objWeapon.WeaponAccessories.AddAsync(objMod);

                            foreach (XmlNode objXmlGear in objXmlAccessory.SelectNodes("gears/gear"))
                                AddPACKSGear(objXmlGearDocument, objXmlGear, objMod, blnCreateChildren);
                        }

                        // Look for an Underbarrel Weapon.
                        XmlNode xmlUnderbarrelNode = objXmlWeapon["underbarrel"];
                        if (xmlUnderbarrelNode != null)
                        {
                            XmlNode objXmlUnderbarrelNode = objXmlWeaponDocument.SelectSingleNode("/chummer/weapons/weapon[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlWeapon["underbarrel"].InnerText.CleanXPath() + ']');
                            if (objXmlUnderbarrelNode == null)
                            {
                                List<Weapon> lstLoopWeapons = new List<Weapon>(1);
                                Weapon objUnderbarrelWeapon = new Weapon(CharacterObject);
                                objUnderbarrelWeapon.Create(objXmlUnderbarrelNode, lstLoopWeapons, blnCreateChildren);
                                await objWeapon.UnderbarrelWeapons.AddAsync(objUnderbarrelWeapon);
                                if (!objWeapon.AllowAccessory)
                                    objUnderbarrelWeapon.AllowAccessory = false;

                                foreach (Weapon objLoopWeapon in lstLoopWeapons)
                                {
                                    if (!objWeapon.AllowAccessory)
                                        objLoopWeapon.AllowAccessory = false;
                                    await objWeapon.UnderbarrelWeapons.AddAsync(objLoopWeapon);
                                }

                                foreach (XmlNode objXmlAccessory in xmlUnderbarrelNode.SelectNodes("accessories/accessory"))
                                {
                                    XmlNode objXmlAccessoryNode =
                                        objXmlWeaponDocument.SelectSingleNode("/chummer/accessories/accessory[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlAccessory["name"].InnerText.CleanXPath() + ']');
                                    if (objXmlAccessoryNode == null)
                                        continue;
                                    WeaponAccessory objMod = new WeaponAccessory(CharacterObject);
                                    string strMount = objXmlAccessory["mount"]?.InnerText ?? "Internal";
                                    string strExtraMount = objXmlAccessory["extramount"]?.InnerText ?? "None";
                                    objMod.Create(objXmlAccessoryNode, new Tuple<string, string>(strMount, strExtraMount), 0, false, blnCreateChildren);
                                    objMod.Parent = objWeapon;

                                    await objUnderbarrelWeapon.WeaponAccessories.AddAsync(objMod);

                                    foreach (XmlNode objXmlGear in objXmlAccessory.SelectNodes("gears/gear"))
                                        AddPACKSGear(objXmlGearDocument, objXmlGear, objMod, blnCreateChildren);
                                }
                            }
                        }

                        foreach (Weapon objLoopWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objLoopWeapon);
                        }
                    }

                    Utils.DoEventsSafe();
                }
            }

            XmlDocument objXmlCyberwareDocument = await CharacterObject.LoadDataAsync("cyberware.xml");
            XmlDocument objXmlBiowareDocument = await CharacterObject.LoadDataAsync("bioware.xml");

            // Update Cyberware.
            XmlNode xmlCyberwares = objXmlKit["cyberwares"];
            if (xmlCyberwares != null)
            {
                XmlNodeList xmlCyberwaresList = xmlCyberwares.SelectNodes("cyberware");
                await tsMain.DoThreadSafeAsync(() =>
                {
                    pgbProgress.Visible = true;
                    pgbProgress.Value = 0;
                    pgbProgress.Maximum = xmlCyberwaresList.Count;
                });
                int i = 0;
                foreach (XmlNode objXmlCyberware in xmlCyberwaresList)
                {
                    i++;
                    await tsMain.DoThreadSafeAsync(() => pgbProgress.Value = i);
                    Utils.DoEventsSafe();

                    AddPACKSCyberware(objXmlCyberwareDocument, objXmlBiowareDocument, objXmlGearDocument, objXmlCyberware, CharacterObject, blnCreateChildren);

                    Utils.DoEventsSafe();
                }
            }

            // Update Bioware.
            XmlNode xmlBiowares = objXmlKit["biowares"];
            if (xmlBiowares != null)
            {
                XmlNodeList xmlBiowaresList = xmlBiowares.SelectNodes("bioware");
                await tsMain.DoThreadSafeAsync(() =>
                {
                    pgbProgress.Visible = true;
                    pgbProgress.Value = 0;
                    pgbProgress.Maximum = xmlBiowaresList.Count;
                });
                int i = 0;
                foreach (XmlNode objXmlBioware in xmlBiowaresList)
                {
                    i++;
                    await tsMain.DoThreadSafeAsync(() => pgbProgress.Value = i);
                    Utils.DoEventsSafe();

                    AddPACKSCyberware(objXmlCyberwareDocument, objXmlBiowareDocument, objXmlGearDocument, objXmlBioware, CharacterObject, blnCreateChildren);

                    Utils.DoEventsSafe();
                }
            }

            // Update Gear.
            XmlNode xmlGears = objXmlKit["gears"];
            if (xmlGears != null)
            {
                XmlNodeList xmlGearsList = xmlGears.SelectNodes("gear");
                await tsMain.DoThreadSafeAsync(() =>
                {
                    pgbProgress.Visible = true;
                    pgbProgress.Value = 0;
                    pgbProgress.Maximum = xmlGearsList.Count;
                });
                int i = 0;
                foreach (XmlNode objXmlGear in xmlGearsList)
                {
                    i++;
                    await tsMain.DoThreadSafeAsync(() => pgbProgress.Value = i);
                    Utils.DoEventsSafe();

                    AddPACKSGear(objXmlGearDocument, objXmlGear, CharacterObject, blnCreateChildren);

                    Utils.DoEventsSafe();
                }
            }

            // Update Vehicles.
            XmlNode xmlVehicles = objXmlKit["vehicles"];
            if (xmlVehicles != null)
            {
                XmlDocument objXmlVehicleDocument = await CharacterObject.LoadDataAsync("vehicles.xml");
                XmlNodeList xmlVehiclesList = xmlVehicles.SelectNodes("vehicle");
                await tsMain.DoThreadSafeAsync(() =>
                {
                    pgbProgress.Visible = true;
                    pgbProgress.Value = 0;
                    pgbProgress.Maximum = xmlVehiclesList.Count;
                });
                int i = 0;
                foreach (XmlNode objXmlVehicle in xmlVehiclesList)
                {
                    i++;
                    await tsMain.DoThreadSafeAsync(() => pgbProgress.Value = i);
                    Utils.DoEventsSafe();

                    Gear objDefaultSensor = null;

                    XmlNode objXmlVehicleNode = objXmlVehicleDocument.SelectSingleNode("/chummer/vehicles/vehicle[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlVehicle["name"].InnerText.CleanXPath() + ']');
                    if (objXmlVehicleNode == null)
                        continue;
                    Vehicle objVehicle = new Vehicle(CharacterObject);
                    objVehicle.Create(objXmlVehicleNode, blnCreateChildren: blnCreateChildren);
                    await CharacterObject.Vehicles.AddAsync(objVehicle);

                    // Grab the default Sensor that comes with the Vehicle.
                    foreach (Gear objSensorGear in objVehicle.GearChildren)
                    {
                        if (objSensorGear.Category == "Sensors" && objSensorGear.Cost == "0" && objSensorGear.Rating == 0)
                        {
                            objDefaultSensor = objSensorGear;
                            break;
                        }
                    }

                    // Add any Vehicle Mods.
                    foreach (XmlNode objXmlMod in objXmlVehicle.SelectNodes("mods/mod"))
                    {
                        XmlNode objXmlModNode = objXmlVehicleDocument.SelectSingleNode("/chummer/mods/mod[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlMod["name"].InnerText.CleanXPath() + ']');
                        if (objXmlModNode == null)
                            continue;
                        int intRating = 0;
                        objXmlMod.TryGetInt32FieldQuickly("rating", ref intRating);
                        int intMarkup = 0;
                        objXmlMod.TryGetInt32FieldQuickly("markup", ref intMarkup);
                        VehicleMod objMod = new VehicleMod(CharacterObject);
                        objMod.Create(objXmlModNode, intRating, objVehicle, intMarkup);
                        await objVehicle.Mods.AddAsync(objMod);

                        foreach (XmlNode objXmlCyberware in objXmlMod.SelectNodes("cyberwares/cyberware"))
                            AddPACKSCyberware(objXmlCyberwareDocument, objXmlBiowareDocument, objXmlGearDocument, objXmlCyberware, objMod, blnCreateChildren);
                    }

                    // Add any Vehicle Gear.
                    foreach (XmlNode objXmlGear in objXmlVehicle.SelectNodes("gears/gear"))
                    {
                        Gear objGear = AddPACKSGear(objXmlGearDocument, objXmlGear, objVehicle, blnCreateChildren);
                        // If this is a Sensor, it will replace the Vehicle's base sensor, so remove it.
                        if (objGear?.Category == "Sensors" && objGear.Cost == "0" && objGear.Rating == 0)
                        {
                            await objVehicle.GearChildren.RemoveAsync(objDefaultSensor);
                        }
                    }

                    // Add any Vehicle Weapons.
                    if (objXmlVehicle["weapons"] != null)
                    {
                        XmlDocument objXmlWeaponDocument = await CharacterObject.LoadDataAsync("weapons.xml");

                        foreach (XmlNode objXmlWeapon in objXmlVehicle.SelectNodes("weapons/weapon"))
                        {
                            Weapon objWeapon = new Weapon(CharacterObject);

                            List<Weapon> lstSubWeapons = new List<Weapon>(1);
                            XmlNode objXmlWeaponNode = objXmlWeaponDocument.SelectSingleNode("/chummer/weapons/weapon[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlWeapon["name"].InnerText.CleanXPath() + ']');
                            if (objXmlWeaponNode == null)
                                continue;
                            objWeapon.ParentVehicle = objVehicle;
                            objWeapon.Create(objXmlWeaponNode, lstSubWeapons, blnCreateChildren);

                            // Find the first Weapon Mount in the Vehicle.
                            foreach (VehicleMod objMod in objVehicle.Mods)
                            {
                                if (objMod.Name.Contains("Weapon Mount") || !string.IsNullOrEmpty(objMod.WeaponMountCategories) && objMod.WeaponMountCategories.Contains(objWeapon.Category))
                                {
                                    await objMod.Weapons.AddAsync(objWeapon);
                                    foreach (Weapon objSubWeapon in lstSubWeapons)
                                        await objMod.Weapons.AddAsync(objSubWeapon);
                                    break;
                                }
                            }

                            // Look for Weapon Accessories.
                            foreach (XmlNode objXmlAccessory in objXmlWeapon.SelectNodes("accessories/accessory"))
                            {
                                XmlNode objXmlAccessoryNode =
                                    objXmlWeaponDocument.SelectSingleNode("/chummer/accessories/accessory[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlAccessory["name"].InnerText.CleanXPath() + ']');
                                if (objXmlAccessoryNode == null)
                                    continue;
                                WeaponAccessory objMod = new WeaponAccessory(CharacterObject);
                                string strMount = objXmlAccessory["mount"]?.InnerText ?? "Internal";
                                string strExtraMount = objXmlAccessory["extramount"]?.InnerText ?? "None";
                                objMod.Create(objXmlAccessoryNode, new Tuple<string, string>(strMount, strExtraMount), 0, false, blnCreateChildren);
                                objMod.Parent = objWeapon;

                                await objWeapon.WeaponAccessories.AddAsync(objMod);
                            }

                            // Look for an Underbarrel Weapon.
                            XmlNode xmlUnderbarrelNode = objXmlWeapon["underbarrel"];
                            if (xmlUnderbarrelNode != null)
                            {
                                XmlNode objXmlUnderbarrelNode =
                                    objXmlWeaponDocument.SelectSingleNode("/chummer/weapons/weapon[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlWeapon["underbarrel"].InnerText.CleanXPath() + ']');
                                if (objXmlUnderbarrelNode != null)
                                {
                                    List<Weapon> lstLoopWeapons = new List<Weapon>(1);
                                    Weapon objUnderbarrelWeapon = new Weapon(CharacterObject);
                                    objUnderbarrelWeapon.Create(objXmlUnderbarrelNode, lstLoopWeapons, blnCreateChildren);
                                    await objWeapon.UnderbarrelWeapons.AddAsync(objUnderbarrelWeapon);
                                    if (!objWeapon.AllowAccessory)
                                        objUnderbarrelWeapon.AllowAccessory = false;

                                    foreach (Weapon objLoopWeapon in lstLoopWeapons)
                                    {
                                        if (!objWeapon.AllowAccessory)
                                            objLoopWeapon.AllowAccessory = false;
                                        await objWeapon.UnderbarrelWeapons.AddAsync(objLoopWeapon);
                                    }

                                    foreach (XmlNode objXmlAccessory in xmlUnderbarrelNode.SelectNodes("accessories/accessory"))
                                    {
                                        XmlNode objXmlAccessoryNode =
                                            objXmlWeaponDocument.SelectSingleNode("/chummer/accessories/accessory[(" + CharacterObjectSettings.BookXPath() + ") and name = " + objXmlAccessory["name"].InnerText.CleanXPath() + ']');
                                        if (objXmlAccessoryNode == null)
                                            continue;
                                        WeaponAccessory objMod = new WeaponAccessory(CharacterObject);
                                        string strMount = objXmlAccessory["mount"]?.InnerText ?? "Internal";
                                        string strExtraMount = objXmlAccessory["extramount"]?.InnerText ?? "None";
                                        objMod.Create(objXmlAccessoryNode, new Tuple<string, string>(strMount, strExtraMount), 0, false, blnCreateChildren);
                                        objMod.Parent = objWeapon;

                                        await objUnderbarrelWeapon.WeaponAccessories.AddAsync(objMod);

                                        foreach (XmlNode objXmlGear in objXmlAccessory.SelectNodes("gears/gear"))
                                            AddPACKSGear(objXmlGearDocument, objXmlGear, objMod, blnCreateChildren);
                                    }
                                }
                            }
                        }
                    }

                    Utils.DoEventsSafe();
                }
            }

            await tsMain.DoThreadSafeAsync(() => pgbProgress.Visible = false);

            return blnAddAgain;
        }

        /// <summary>
        /// Create a PACKS Kit from the character.
        /// </summary>
        public async ValueTask CreatePACKSKit()
        {
            using (ThreadSafeForm<CreatePACKSKit> frmBuildPACKSKit = await ThreadSafeForm<CreatePACKSKit>.GetAsync(() => new CreatePACKSKit(CharacterObject)))
                await frmBuildPACKSKit.ShowDialogSafeAsync(this);
        }

        /// <summary>
        /// Update the karma cost tooltip for Initiation/Submersion.
        /// </summary>
        private async Task UpdateInitiationCost(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            decimal decMultiplier = 1.0m;
            int intAmount;
            string strInitTip;
            if (CharacterObject.MAGEnabled)
            {
                if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaMAGInitiationGroupPercent;
                if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaMAGInitiationOrdealPercent;
                if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaMAGInitiationSchoolingPercent;
                intAmount = ((CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.InitiateGrade + 1) * CharacterObjectSettings.KarmaInitiation) * decMultiplier).StandardRound();
                token.ThrowIfCancellationRequested();
                strInitTip = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_ImproveInitiateGrade")
                    , (CharacterObject.InitiateGrade + 1).ToString(GlobalSettings.CultureInfo)
                    , intAmount.ToString(GlobalSettings.CultureInfo));
            }
            else
            {
                if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaRESInitiationGroupPercent;
                if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaRESInitiationOrdealPercent;
                if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, token))
                    decMultiplier -= CharacterObjectSettings.KarmaRESInitiationSchoolingPercent;
                intAmount = ((CharacterObjectSettings.KarmaInitiationFlat + (CharacterObject.SubmersionGrade + 1) * CharacterObjectSettings.KarmaInitiation) * decMultiplier).StandardRound();
                token.ThrowIfCancellationRequested();
                strInitTip = string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_ImproveSubmersionGrade")
                    , (CharacterObject.SubmersionGrade + 1).ToString(GlobalSettings.CultureInfo)
                    , intAmount.ToString(GlobalSettings.CultureInfo));
            }
            token.ThrowIfCancellationRequested();
            await cmdAddMetamagic.SetToolTipAsync(strInitTip, token);
        }

        /// <summary>
        /// Change the character's Metatype or priority selection.
        /// </summary>
        public async ValueTask ChangeMetatype()
        {
            if (CharacterObject.EffectiveBuildMethodUsesPriorityTables)
            {
                using (ThreadSafeForm<SelectMetatypePriority> frmSelectMetatype = await ThreadSafeForm<SelectMetatypePriority>.GetAsync(() => new SelectMetatypePriority(CharacterObject)))
                {
                    if (await frmSelectMetatype.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return;
                }
            }
            else
            {
                using (ThreadSafeForm<SelectMetatypeKarma> frmSelectMetatype = await ThreadSafeForm<SelectMetatypeKarma>.GetAsync(() => new SelectMetatypeKarma(CharacterObject)))
                {
                    if (await frmSelectMetatype.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                        return;
                }
            }

            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        /// <summary>
        /// Create a Cyberware Suite from the Cyberware the character currently has.
        /// </summary>
        private async ValueTask CreateCyberwareSuite(Improvement.ImprovementSource objSource)
        {
            // Make sure all of the Cyberware the character has is of the same grade.
            string strGrade = string.Empty;
            foreach (Cyberware objCyberware in CharacterObject.Cyberware)
            {
                if (objCyberware.SourceType == objSource)
                {
                    if (string.IsNullOrEmpty(strGrade))
                        strGrade = objCyberware.Grade.ToString();
                    else if (strGrade != objCyberware.Grade.ToString())
                    {
                        Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_CyberwareGradeMismatch"), await LanguageManager.GetStringAsync("MessageTitle_CyberwareGradeMismatch"), MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }
                }
            }
            // The character has no Cyberware!
            if (string.IsNullOrEmpty(strGrade))
            {
                Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_NoCyberware"), await LanguageManager.GetStringAsync("MessageTitle_NoCyberware"), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                return;
            }

            using (ThreadSafeForm<CreateCyberwareSuite> frmBuildCyberwareSuite = await ThreadSafeForm<CreateCyberwareSuite>.GetAsync(() => new CreateCyberwareSuite(CharacterObject, objSource)))
                await frmBuildCyberwareSuite.ShowDialogSafeAsync(this);
        }

        /// <summary>
        /// Set the ToolTips from the Language file.
        /// </summary>
        private async ValueTask SetTooltips(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            // Common Tab.
            await lblAttributes.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_CommonAttributes"), token);
            await lblAttributesBase.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_CommonAttributesBase"), token);
            await lblAttributesAug.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_CommonAttributesAug"), token);
            await lblAttributesMetatype.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_CommonAttributesMetatypeLimits"), token);
            await lblNuyen.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_CommonNuyen"),
                                                         CharacterObjectSettings.ChargenKarmaToNuyenExpression
                                                             .Replace("{Karma}", await LanguageManager.GetStringAsync("String_Karma"))
                                                             .Replace("{PriorityNuyen}", await LanguageManager.GetStringAsync("Checkbox_CreatePACKSKit_StartingNuyen"))), token);
            // Armor Tab.
            await chkArmorEquipped.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_ArmorEquipped"), token);
            // Gear Tab.
            await chkGearActiveCommlink.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_ActiveCommlink"), token);
            await chkCyberwareActiveCommlink.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_ActiveCommlink"), token);
            // Vehicles Tab.
            await chkVehicleWeaponAccessoryInstalled.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_WeaponInstalled"), token);
            await chkVehicleActiveCommlink.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_ActiveCommlink"), token);
            await lblVehiclePowertrainLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity"), token);
            await lblVehicleCosmeticLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity"), token);
            await lblVehicleElectromagneticLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity"), token);
            await lblVehicleBodymodLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity"), token);
            await lblVehicleWeaponsmodLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity"), token);
            await lblVehicleProtectionLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity"), token);
            // Character Info Tab.
            await chkCharacterCreated.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_CharacterCreated"), token);
            // Build Point Summary Tab.
            await lblBuildPrimaryAttributes.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_CommonAttributes"), token);
            await lblBuildPositiveQualities.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_BuildPositiveQualities"), token);
            await lblBuildNegativeQualities.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_BuildNegativeQualities"), token);
            await lblBuildContacts.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo,
                                                                 await LanguageManager.GetStringAsync("Tip_CommonContacts"),
                                                                 CharacterObjectSettings.KarmaContact.ToString(GlobalSettings.CultureInfo)), token);
            await lblBuildEnemies.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_CommonEnemies"), token);
            await lblBuildNuyen.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo,
                                                              await LanguageManager.GetStringAsync("Tip_CommonNuyen"),
                                                              CharacterObjectSettings.ChargenKarmaToNuyenExpression
                                                                  .Replace("{Karma}", await LanguageManager.GetStringAsync("String_Karma"))
                                                                  .Replace("{PriorityNuyen}", await LanguageManager.GetStringAsync("Checkbox_CreatePACKSKit_StartingNuyen"))), token);
            await lblBuildSkillGroups.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_SkillsSkillGroups"), CharacterObjectSettings.KarmaImproveSkillGroup.ToString(GlobalSettings.CultureInfo)), token);
            await lblBuildActiveSkills.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_SkillsActiveSkills"), CharacterObjectSettings.KarmaImproveActiveSkill.ToString(GlobalSettings.CultureInfo), CharacterObjectSettings.KarmaSpecialization.ToString(GlobalSettings.CultureInfo)), token);
            await lblBuildKnowledgeSkills.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_SkillsKnowledgeSkills"), CharacterObjectSettings.KarmaImproveKnowledgeSkill.ToString(GlobalSettings.CultureInfo), CharacterObjectSettings.KarmaKnowledgeSpecialization.ToString(GlobalSettings.CultureInfo)), token);
            await lblBuildSpells.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_SpellsSelectedSpells"), CharacterObjectSettings.KarmaSpell.ToString(GlobalSettings.CultureInfo)), token);
            await lblBuildSpirits.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_SpellsSpirits"), CharacterObjectSettings.KarmaSpirit.ToString(GlobalSettings.CultureInfo)), token);
            await lblBuildSprites.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_TechnomancerSprites"), CharacterObjectSettings.KarmaSpirit.ToString(GlobalSettings.CultureInfo)), token);
            await lblBuildComplexForms.SetToolTipAsync(string.Format(GlobalSettings.CultureInfo, await LanguageManager.GetStringAsync("Tip_TechnomancerComplexForms"), CharacterObjectSettings.KarmaNewComplexForm.ToString(GlobalSettings.CultureInfo)), token);
            // Other Info Tab.
            await lblCMPhysicalLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherCMPhysical"), token);
            await lblCMStunLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherCMStun"), token);
            await lblINILabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherInitiative"), token);
            await lblMatrixINILabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherMatrixInitiative"), token);
            await lblAstralINILabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherAstralInitiative"), token);
            await lblArmorLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherArmor"), token);
            await lblESS.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherEssence"), token);
            await lblRemainingNuyenLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherNuyen"), token);
            await lblMovementLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherMovement"), token);
            await lblSwimLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherSwim"), token);
            await lblFlyLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherFly"), token);
            await lblLiftCarryLimitsLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherLiftAndCarryLimits"), token);
            await lblComposureLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherComposure"), token);
            await lblSurpriseLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherSurprise"), token);
            await lblJudgeIntentionsLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherJudgeIntentions"), token);
            await lblLiftCarryLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherLiftAndCarry"), token);
            await lblMemoryLabel.SetToolTipAsync(await LanguageManager.GetStringAsync("Tip_OtherMemory"), token);
        }

        /// <summary>
        /// Recheck all mods to see if Sensor has changed.
        /// </summary>
        private async ValueTask UpdateSensor(Vehicle objVehicle, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            foreach (Gear objGear in objVehicle.GearChildren)
            {
                if (objGear.Category != "Sensors" || objGear.Name != "Sensor Array" || !objGear.IncludedInParent)
                    continue;
                token.ThrowIfCancellationRequested();
                // Update the name of the item in the TreeView.
                TreeNode objNode = treVehicles.FindNode(objGear.InternalId);
                if (objNode != null)
                {
                    await treVehicles.DoThreadSafeAsync(() => objNode.Text = objGear.CurrentDisplayName, token);
                    token.ThrowIfCancellationRequested();
                }
            }
        }

        /// <summary>
        /// Enable/Disable the Paste Menu and ToolStrip items as appropriate.
        /// </summary>
        private async void RefreshPasteStatus(object sender, EventArgs e)
        {
            try
            {
                await DoRefreshPasteStatus(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async ValueTask DoRefreshPasteStatus(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();

            bool blnPasteEnabled = false;
            bool blnCopyEnabled = false;

            TabPage objSelectedCharacterTab = await tabCharacterTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token);
            if (objSelectedCharacterTab == tabStreetGear)
            {
                TabPage objSelectedGearTabPage
                    = await tabStreetGearTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token);
                // Lifestyle Tab.
                if (objSelectedGearTabPage == tabLifestyle)
                {
                    blnPasteEnabled = GlobalSettings.ClipboardContentType == ClipboardContentType.Lifestyle;
                    blnCopyEnabled = await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is Lifestyle;
                }
                // Armor Tab.
                else if (objSelectedGearTabPage == tabArmor)
                {
                    if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is IHasInternalId
                        strSelectedId)
                    {
                        blnPasteEnabled = GlobalSettings.ClipboardContentType == ClipboardContentType.Armor ||
                                          GlobalSettings.ClipboardContentType == ClipboardContentType.Gear
                                          && (CharacterObject.Armor.Any(x => x.InternalId == strSelectedId.InternalId)
                                              ||
                                              CharacterObject.Armor.FindArmorMod(strSelectedId.InternalId) != null ||
                                              CharacterObject.Armor.FindArmorGear(strSelectedId.InternalId) != null);
                        blnCopyEnabled = CharacterObject.Armor.Any(x => x.InternalId == strSelectedId.InternalId)
                                         || CharacterObject.Armor.FindArmorGear(strSelectedId.InternalId) != null;
                    }
                }
                // Weapons Tab.
                else if (objSelectedGearTabPage == tabWeapons)
                {
                    if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is IHasInternalId objSelected)
                    {
                        switch (GlobalSettings.ClipboardContentType)
                        {
                            case ClipboardContentType.Weapon:
                                blnPasteEnabled = true;
                                break;

                            case ClipboardContentType.Gear:
                            case ClipboardContentType.WeaponAccessory:
                                blnPasteEnabled = objSelected is ICanPaste objCanPaste && objCanPaste.AllowPasteXml;
                                break;
                        }

                        //TODO: ICanCopy interface? If weapon comes from something else == false, etc.
                        blnCopyEnabled = objSelected is Weapon || objSelected is Gear;
                    }
                }
                // Gear Tab.
                else if (objSelectedGearTabPage == tabGear)
                {
                    if (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is IHasInternalId
                        objSelected)
                    {
                        blnPasteEnabled = GlobalSettings.ClipboardContentType == ClipboardContentType.Gear;
                        blnCopyEnabled = objSelected is Gear;
                    }
                }
            }
            // Cyberware Tab.
            else if (objSelectedCharacterTab == tabCyberware)
            {
                if (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is IHasInternalId
                    objSelected)
                {
                    blnPasteEnabled = objSelected is ICanPaste selected && selected.AllowPasteXml
                                      || GlobalSettings.ClipboardContentType == ClipboardContentType.Cyberware;
                    blnCopyEnabled = objSelected is Gear || objSelected is Cyberware;
                }
            }
            // Vehicles Tab.
            else if (objSelectedCharacterTab == tabVehicles)
            {
                if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token) is IHasInternalId
                    objSelected)
                {
                    switch (GlobalSettings.ClipboardContentType)
                    {
                        case ClipboardContentType.Vehicle:
                            blnPasteEnabled = true;
                            break;

                        case ClipboardContentType.Gear:
                        case ClipboardContentType.Weapon:
                        case ClipboardContentType.WeaponAccessory:
                        {
                            blnPasteEnabled = objSelected is ICanPaste selected && selected.AllowPasteXml;
                        }
                            break;
                    }

                    // In theory any object that's not a generic string node is valid to copy here. Locations might go screwy?
                    blnCopyEnabled = true;
                }
            }

            await mnuCreateMenu.DoThreadSafeAsync(() =>
            {
                mnuEditPaste.Enabled = blnPasteEnabled;
                mnuEditCopy.Enabled = blnCopyEnabled;
            }, token);
            await tsMain.DoThreadSafeAsync(() =>
            {
                tsbPaste.Enabled = blnPasteEnabled;
                tsbCopy.Enabled = blnCopyEnabled;
            }, token);
        }

        private async ValueTask AddCyberwareSuite(Improvement.ImprovementSource objSource)
        {
            using (ThreadSafeForm<SelectCyberwareSuite> frmPickCyberwareSuite = await ThreadSafeForm<SelectCyberwareSuite>.GetAsync(() => new SelectCyberwareSuite(CharacterObject, objSource)))
            {
                if (await frmPickCyberwareSuite.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                string strType = objSource == Improvement.ImprovementSource.Cyberware ? "cyberware" : "bioware";
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync(strType + ".xml", string.Empty, true);
                XmlNode xmlSuite = frmPickCyberwareSuite.MyForm.SelectedSuite.IsGuid()
                    ? objXmlDocument.SelectSingleNode("/chummer/suites/suite[id = " + frmPickCyberwareSuite.MyForm.SelectedSuite.CleanXPath() + ']')
                    : objXmlDocument.SelectSingleNode("/chummer/suites/suite[name = " + frmPickCyberwareSuite.MyForm.SelectedSuite.CleanXPath() + ']');
                if (xmlSuite == null)
                    return;
                Grade objGrade = Grade.ConvertToCyberwareGrade(xmlSuite["grade"]?.InnerText, objSource, CharacterObject);

                string strXPathPrefix = strType + "s/" + strType;
                // Run through each of the items in the Suite and add them to the character.
                using (XmlNodeList xmlItemList = xmlSuite.SelectNodes(strXPathPrefix))
                {
                    if (xmlItemList?.Count > 0)
                    {
                        foreach (XmlNode xmlItem in xmlItemList)
                        {
                            string strName = xmlItem["name"]?.InnerText;
                            if (string.IsNullOrEmpty(strName))
                                continue;
                            XmlNode objXmlCyberware = objXmlDocument.SelectSingleNode("/chummer/" + strXPathPrefix + "[name = " + strName.CleanXPath() + ']');
                            int intRating = Convert.ToInt32(xmlItem["rating"]?.InnerText, GlobalSettings.InvariantCultureInfo);

                            Cyberware objCyberware = CreateSuiteCyberware(xmlItem, objXmlCyberware, objGrade, intRating, objSource);
                            await CharacterObject.Cyberware.AddAsync(objCyberware);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Add a piece of Gear that was found in a PACKS Kit.
        /// </summary>
        /// <param name="objXmlGearDocument">XmlDocument that contains the Gear.</param>
        /// <param name="objXmlGear">XmlNode of the Gear to add.</param>
        /// <param name="objParentObject">Object to associate the newly-created items with.</param>
        /// <param name="blnCreateChildren">Whether or not the default plugins for the Gear should be created.</param>
        private Gear AddPACKSGear(XmlDocument objXmlGearDocument, XmlNode objXmlGear, object objParentObject, bool blnCreateChildren)
        {
            XmlNode objXmlGearNode = null;
            string strName = objXmlGear["name"]?.InnerText;
            if (!string.IsNullOrEmpty(strName))
            {
                string strCategory = objXmlGear["category"]?.InnerText;
                if (!string.IsNullOrEmpty(strCategory))
                    objXmlGearNode = objXmlGearDocument.SelectSingleNode(
                        "/chummer/gears/gear[(" + CharacterObjectSettings.BookXPath() + ") and name = " + strName.CleanXPath() +
                        " and category = " + strCategory.CleanXPath() + ']');
                else
                    objXmlGearNode = objXmlGearDocument.SelectSingleNode(
                        "/chummer/gears/gear[(" + CharacterObjectSettings.BookXPath() + ") and name = " + strName.CleanXPath() + ']');
            }

            if (objXmlGearNode == null)
                return null;

            int intRating = Convert.ToInt32(objXmlGear["rating"]?.InnerText, GlobalSettings.InvariantCultureInfo);
            decimal decQty = 1;
            string strQty = objXmlGear["qty"]?.InnerText;
            if (!string.IsNullOrEmpty(strQty))
                decQty = Convert.ToDecimal(strQty, GlobalSettings.InvariantCultureInfo);

            List<Weapon> lstWeapons = new List<Weapon>(1);
            string strForceValue = objXmlGear.SelectSingleNode("name/@select")?.InnerText ?? string.Empty;

            Gear objNewGear = new Gear(CharacterObject);
            objNewGear.Create(objXmlGearNode, intRating, lstWeapons, strForceValue, true, blnCreateChildren);
            objNewGear.Quantity = decQty;

            switch (objParentObject)
            {
                case Character objParentCharacter:
                    objParentCharacter.Gear.Add(objNewGear);
                    break;

                case Gear objParentGear:
                    objParentGear.Children.Add(objNewGear);
                    break;

                case Armor objParentArmor:
                    objParentArmor.GearChildren.Add(objNewGear);
                    break;

                case ArmorMod objParentArmorMod:
                    objParentArmorMod.GearChildren.Add(objNewGear);
                    break;

                case WeaponAccessory objParentWeaponAccessory:
                    objParentWeaponAccessory.GearChildren.Add(objNewGear);
                    break;

                case Cyberware objParentCyberware:
                    objParentCyberware.GearChildren.Add(objNewGear);
                    break;

                case Vehicle objParentVehicle:
                    objNewGear.Parent = objParentVehicle;
                    objParentVehicle.GearChildren.Add(objNewGear);
                    break;
            }

            // Look for child components.
            using (XmlNodeList xmlChildrenList = objXmlGear.SelectNodes("gears/gear"))
            {
                if (xmlChildrenList?.Count > 0)
                {
                    foreach (XmlNode xmlChild in xmlChildrenList)
                    {
                        AddPACKSGear(objXmlGearDocument, xmlChild, objNewGear, blnCreateChildren);
                    }
                }
            }

            // Add any Weapons created by the Gear.
            if (lstWeapons.Count > 0)
            {
                foreach (Weapon objWeapon in lstWeapons)
                {
                    CharacterObject.Weapons.Add(objWeapon);
                }
            }

            return objNewGear;
        }

        private void AddPACKSCyberware(XmlDocument xmlCyberwareDocument, XmlDocument xmlBiowareDocument, XmlDocument xmlGearDocument, XmlNode xmlCyberware, object objParentObject, bool blnCreateChildren)
        {
            Grade objGrade = Grade.ConvertToCyberwareGrade(xmlCyberware["grade"]?.InnerText, Improvement.ImprovementSource.Cyberware, CharacterObject);

            int intRating = Convert.ToInt32(xmlCyberware["rating"]?.InnerText, GlobalSettings.InvariantCultureInfo);

            Improvement.ImprovementSource eSource = Improvement.ImprovementSource.Cyberware;
            string strName = xmlCyberware["name"]?.InnerText;
            if (string.IsNullOrEmpty(strName))
                return;

            XmlNode objXmlCyberwareNode = xmlCyberwareDocument.SelectSingleNode("/chummer/cyberwares/cyberware[(" + CharacterObjectSettings.BookXPath() + ") and name = " + strName.CleanXPath() + ']');
            if (objXmlCyberwareNode == null)
            {
                eSource = Improvement.ImprovementSource.Bioware;
                objXmlCyberwareNode = xmlBiowareDocument.SelectSingleNode("/chummer/biowares/bioware[(" + CharacterObjectSettings.BookXPath() + ") and name = " + strName.CleanXPath() + ']');
                if (objXmlCyberwareNode == null)
                {
                    return;
                }
            }
            List<Weapon> lstWeapons = new List<Weapon>(1);
            List<Vehicle> lstVehicles = new List<Vehicle>(1);
            Cyberware objCyberware = new Cyberware(CharacterObject);
            objCyberware.Create(objXmlCyberwareNode, objGrade, eSource, intRating, lstWeapons, lstVehicles, true, blnCreateChildren);

            switch (objParentObject)
            {
                case Character objParentCharacter:
                    objParentCharacter.Cyberware.Add(objCyberware);
                    break;

                case Cyberware objParentCyberware:
                    objParentCyberware.Children.Add(objCyberware);
                    break;

                case VehicleMod objParentVehicleMod:
                    objParentVehicleMod.Cyberware.Add(objCyberware);
                    break;
            }

            // Add any children.
            using (XmlNodeList xmlCyberwareList = xmlCyberware.SelectNodes("cyberwares/cyberware"))
            {
                if (xmlCyberwareList?.Count > 0)
                {
                    foreach (XmlNode objXmlChild in xmlCyberwareList)
                        AddPACKSCyberware(xmlCyberwareDocument, xmlBiowareDocument, xmlGearDocument, objXmlChild, objCyberware, blnCreateChildren);
                }
            }

            using (XmlNodeList xmlGearList = xmlCyberware.SelectNodes("gears/gear"))
            {
                if (xmlGearList?.Count > 0)
                {
                    foreach (XmlNode objXmlGear in xmlGearList)
                        AddPACKSGear(xmlGearDocument, objXmlGear, objCyberware, blnCreateChildren);
                }
            }

            if (lstWeapons.Count > 0)
            {
                foreach (Weapon objWeapon in lstWeapons)
                {
                    CharacterObject.Weapons.Add(objWeapon);
                }
            }

            if (lstVehicles.Count > 0)
            {
                foreach (Vehicle objVehicle in lstVehicles)
                {
                    CharacterObject.Vehicles.Add(objVehicle);
                }
            }
        }

        #endregion Custom Methods

        private async void tsMetamagicAddMetamagic_Click(object sender, EventArgs e)
        {
            if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is InitiationGrade objGrade))
                return;

            using (ThreadSafeForm<SelectMetamagic> frmPickMetamagic = await ThreadSafeForm<SelectMetamagic>.GetAsync(() => new SelectMetamagic(CharacterObject, objGrade)))
            {
                // Make sure a value was selected.
                if (await frmPickMetamagic.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                Metamagic objNewMetamagic = new Metamagic(CharacterObject);

                XmlNode objXmlMetamagic;
                Improvement.ImprovementSource objSource;
                if (CharacterObject.RESEnabled)
                {
                    objXmlMetamagic = (await CharacterObject.LoadDataAsync("echoes.xml")).SelectSingleNode("/chummer/echoes/echo[id = " + frmPickMetamagic.MyForm.SelectedMetamagic.CleanXPath() + ']');
                    objSource = Improvement.ImprovementSource.Echo;
                }
                else
                {
                    objXmlMetamagic = (await CharacterObject.LoadDataAsync("metamagic.xml")).SelectSingleNode("/chummer/metamagics/metamagic[id = " + frmPickMetamagic.MyForm.SelectedMetamagic.CleanXPath() + ']');
                    objSource = Improvement.ImprovementSource.Metamagic;
                }

                objNewMetamagic.Create(objXmlMetamagic, objSource);
                objNewMetamagic.Grade = objGrade.Grade;
                if (objNewMetamagic.InternalId.IsEmptyGuid())
                    return;

                await CharacterObject.Metamagics.AddAsync(objNewMetamagic);
            }
        }

        private async void tsMetamagicAddArt_Click(object sender, EventArgs e)
        {
            if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is InitiationGrade objGrade))
                return;

            using (ThreadSafeForm<SelectArt> frmPickArt
                   = await ThreadSafeForm<SelectArt>.GetAsync(
                       () => new SelectArt(CharacterObject, SelectArt.Mode.Art)))
            {
                // Make sure a value was selected.
                if (await frmPickArt.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                XmlNode objXmlArt = (await CharacterObject.LoadDataAsync("metamagic.xml")).SelectSingleNode("/chummer/arts/art[id = " + frmPickArt.MyForm.SelectedItem.CleanXPath() + ']');

                Art objArt = new Art(CharacterObject);

                objArt.Create(objXmlArt, Improvement.ImprovementSource.Metamagic);
                objArt.Grade = objGrade.Grade;
                if (objArt.InternalId.IsEmptyGuid())
                    return;

                await CharacterObject.Arts.AddAsync(objArt);
            }
        }

        private async void tsMetamagicAddEnchantment_Click(object sender, EventArgs e)
        {
            if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is InitiationGrade objGrade))
                return;

            using (ThreadSafeForm<SelectArt> frmPickArt
                   = await ThreadSafeForm<SelectArt>.GetAsync(
                       () => new SelectArt(CharacterObject, SelectArt.Mode.Enchantment)))
            {
                // Make sure a value was selected.
                if (await frmPickArt.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                XmlNode objXmlArt = (await CharacterObject.LoadDataAsync("spells.xml")).SelectSingleNode("/chummer/spells/spell[id = " + frmPickArt.MyForm.SelectedItem.CleanXPath() + ']');

                Spell objNewSpell = new Spell(CharacterObject);

                objNewSpell.Create(objXmlArt, string.Empty, false, false, false, Improvement.ImprovementSource.Initiation);
                objNewSpell.Grade = objGrade.Grade;
                if (objNewSpell.InternalId.IsEmptyGuid())
                {
                    objNewSpell.Dispose();
                    return;
                }

                await CharacterObject.Spells.AddAsync(objNewSpell);
            }
        }

        private async void tsMetamagicAddRitual_Click(object sender, EventArgs e)
        {
            if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is InitiationGrade objGrade))
                return;

            using (ThreadSafeForm<SelectArt> frmPickArt
                   = await ThreadSafeForm<SelectArt>.GetAsync(
                       () => new SelectArt(CharacterObject, SelectArt.Mode.Ritual)))
            {
                // Make sure a value was selected.
                if (await frmPickArt.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                XmlNode objXmlArt = (await CharacterObject.LoadDataAsync("spells.xml")).SelectSingleNode("/chummer/spells/spell[id = " + frmPickArt.MyForm.SelectedItem.CleanXPath() + ']');

                Spell objNewSpell = new Spell(CharacterObject);

                objNewSpell.Create(objXmlArt, string.Empty, false, false, false, Improvement.ImprovementSource.Initiation);
                objNewSpell.Grade = objGrade.Grade;
                if (objNewSpell.InternalId.IsEmptyGuid())
                {
                    objNewSpell.Dispose();
                    return;
                }

                await CharacterObject.Spells.AddAsync(objNewSpell);
            }
        }

        private async void tsInitiationNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicAddEnhancement_Click(object sender, EventArgs e)
        {
            if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is InitiationGrade objGrade))
                return;

            using (ThreadSafeForm<SelectArt> frmPickArt
                   = await ThreadSafeForm<SelectArt>.GetAsync(
                       () => new SelectArt(CharacterObject, SelectArt.Mode.Enhancement)))
            {
                // Make sure a value was selected.
                if (await frmPickArt.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                XmlNode objXmlArt = (await CharacterObject.LoadDataAsync("powers.xml")).SelectSingleNode("/chummer/enhancements/enhancement[id = " + frmPickArt.MyForm.SelectedItem.CleanXPath() + ']');
                if (objXmlArt == null)
                    return;

                Enhancement objEnhancement = new Enhancement(CharacterObject);
                objEnhancement.Create(objXmlArt, Improvement.ImprovementSource.Initiation);
                objEnhancement.Grade = objGrade.Grade;
                if (objEnhancement.InternalId.IsEmptyGuid())
                    return;

                // Find the associated Power
                string strPower = objXmlArt["power"]?.InnerText;
                bool blnPowerFound = false;
                foreach (Power objPower in CharacterObject.Powers)
                {
                    if (objPower.Name == strPower)
                    {
                        await objPower.Enhancements.AddAsync(objEnhancement);
                        blnPowerFound = true;
                        break;
                    }
                }

                if (!blnPowerFound)
                {
                    // Add it to the character instead
                    await CharacterObject.Enhancements.AddAsync(objEnhancement);
                }
            }
        }

        private void panContacts_Click(object sender, EventArgs e)
        {
            panContacts.Focus();
        }

        private void panContacts_DragDrop(object sender, DragEventArgs e)
        {
            Point mousePosition = panContacts.PointToClient(new Point(e.X, e.Y));
            Control destination = panContacts.GetChildAtPoint(mousePosition);

            if (destination != null)
            {
                TransportWrapper wrapper = (TransportWrapper)e.Data.GetData(typeof(TransportWrapper));
                Control source = wrapper.Control;

                int indexDestination = panContacts.Controls.IndexOf(destination);
                if (panContacts.Controls.IndexOf(source) < indexDestination)
                    indexDestination--;

                panContacts.Controls.SetChildIndex(source, indexDestination);
            }

            foreach (ContactControl objControl in panContacts.Controls)
            {
                objControl.BackColor = ColorManager.Control;
            }
        }

        private void panContacts_DragOver(object sender, DragEventArgs e)
        {
            Point mousePosition = panContacts.PointToClient(new Point(e.X, e.Y));
            Control destination = panContacts.GetChildAtPoint(mousePosition);

            if (destination == null)
                return;

            destination.BackColor = ColorManager.ControlDarker;
            foreach (ContactControl objControl in panContacts.Controls)
            {
                if (objControl != destination as ContactControl)
                {
                    objControl.BackColor = ColorManager.Control;
                }
            }
            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
        }

        private void panContacts_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private void panEnemies_Click(object sender, EventArgs e)
        {
            panEnemies.Focus();
        }

        private async void tsAddTechniqueNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken), GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void btnCreateBackstory_Click(object sender, EventArgs e)
        {
            using (await CursorWait.NewAsync(this))
            {
                if (_objStoryBuilder == null)
                {
                    _objStoryBuilder = new StoryBuilder(CharacterObject);
                    await btnCreateBackstory.DoThreadSafeAsync(x => x.Enabled = false);
                }

                CharacterObject.Background = await _objStoryBuilder.GetStory(GlobalSettings.Language);
            }
        }

        private async void mnuSpecialConfirmValidity_Click(object sender, EventArgs e)
        {
            try
            {
                if (await CheckCharacterValidity(token: GenericToken))
                {
                    Program.ShowMessageBox(this, await LanguageManager.GetStringAsync("Message_ValidCharacter"),
                                           await LanguageManager.GetStringAsync("MessageTitle_ValidCharacter"),
                                           MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboPrimaryArm_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing || CharacterObject.Ambidextrous)
                return;
            CharacterObject.PrimaryArm = await cboPrimaryArm.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString());

            await SetDirty(true);
        }

        private async void AttributeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshAttributes(pnlAttributes, e, lblAttributes,
                                        await lblKarma.DoThreadSafeFuncAsync(x => x.PreferredWidth, GenericToken),
                                        await lblAttributesAug.DoThreadSafeFuncAsync(x => x.PreferredWidth, GenericToken),
                                        await lblAttributesMetatype.DoThreadSafeFuncAsync(x => x.PreferredWidth, GenericToken));
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void PowersBeforeRemove(object sender, RemovingOldEventArgs e)
        {
            await RefreshPowerCollectionBeforeRemove(treMetamagic, e);
        }

        private async void PowersListChanged(object sender, ListChangedEventArgs e)
        {
            try
            {
                await RefreshPowerCollectionListChanged(treMetamagic, cmsMetamagic, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void SpellCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ComplexFormCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ArtCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshArtCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void EnhancementCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshEnhancementCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void MetamagicCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshMetamagicCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void InitiationGradeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void AIProgramCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void CritterPowerCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshCritterPowers(treCritterPowers, cmsCritterPowers, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void QualityCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshQualities(treQualities, cmsQuality, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void MartialArtCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void LifestyleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ContactCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshContacts(panContacts, panEnemies, panPets, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void SpiritCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshSpirits(panSpirits, panSprites, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ArmorCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod, cmsArmorGear, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void ArmorLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshArmorLocations(treArmor, cmsArmorLocation, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void WeaponCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon, cmsWeaponAccessory, cmsWeaponAccessoryGear, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void WeaponLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshWeaponLocations(treWeapons, cmsWeaponLocation, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void DrugCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshDrugs(treCustomDrugs, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void GearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshGears(treGear, cmsGearLocation, cmsGear, await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, GenericToken), e);
                await RefreshFociFromGear(treFoci, null, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void GearLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshGearLocations(treGear, cmsGearLocation, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void CyberwareCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void VehicleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle, cmsVehicleWeapon,
                                      cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear, cmsVehicleGear,
                                      cmsWeaponMount, cmsVehicleCyberware, cmsVehicleCyberwareGear, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void VehicleLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            try
            {
                await RefreshVehicleLocations(treVehicles, cmsVehicleLocation, e);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void picMugshot_SizeChanged(object sender, EventArgs e)
        {
            try
            {
                await ProcessMugshot(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async ValueTask ProcessMugshot(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (await this.DoThreadSafeFuncAsync(x => x.IsNullOrDisposed(), token))
                return;
            await picMugshot.DoThreadSafeAsync(x =>
            {
                try
                {
                    x.SizeMode = x.Image != null && x.Height >= x.Image.Height
                                                 && x.Width >= x.Image.Width
                        ? PictureBoxSizeMode.CenterImage
                        : PictureBoxSizeMode.Zoom;
                }
                catch (ArgumentException) // No other way to catch when the Image is not null, but is disposed
                {
                    x.SizeMode = PictureBoxSizeMode.Zoom;
                }
            }, token);
        }

        private void mnuSpecialKarmaValue_Click(object sender, EventArgs e)
        {
            Program.ShowMessageBox(this, CharacterObject.CalculateKarmaValue(GlobalSettings.Language, out int _),
                LanguageManager.GetString("MessageTitle_KarmaValue"),
                MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        private async void cmdCyberwareChangeMount_Click(object sender, EventArgs e)
        {
            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objModularCyberware))
                return;
            string strSelectedParentID;
            using (new FetchSafelyFromPool<List<ListItem>>(
                       Utils.ListItemListPool, out List<ListItem> lstModularMounts))
            {
                lstModularMounts.AddRange(CharacterObject.ConstructModularCyberlimbList(objModularCyberware));
                //Mounted cyberware should always be allowed to be dismounted.
                //Unmounted cyberware requires that a valid mount be present.
                if (!objModularCyberware.IsModularCurrentlyEquipped
                    && lstModularMounts.All(x => !string.Equals(x.Value.ToString(), "None", StringComparison.Ordinal)))
                {
                    Program.ShowMessageBox(this,
                                                    await LanguageManager.GetStringAsync("Message_NoValidModularMount"),
                                                    await LanguageManager.GetStringAsync("MessageTitle_NoValidModularMount"),
                                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                string strDescription = await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware");
                using (ThreadSafeForm<SelectItem> frmPickMount = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem
                       {
                           Description = strDescription
                       }))
                {
                    frmPickMount.MyForm.SetGeneralItemsMode(lstModularMounts);

                    // Make sure the dialogue window was not canceled.
                    if (await frmPickMount.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    {
                        return;
                    }

                    strSelectedParentID = frmPickMount.MyForm.SelectedItem;
                }
            }

            Cyberware objOldParent = objModularCyberware.Parent;
            if (objOldParent != null)
                objModularCyberware.ChangeModularEquip(false);

            if (strSelectedParentID == "None")
            {
                if (objOldParent != null)
                {
                    await objOldParent.Children.RemoveAsync(objModularCyberware);

                    await CharacterObject.Cyberware.AddAsync(objModularCyberware);
                }
            }
            else
            {
                Cyberware objNewParent = CharacterObject.Cyberware.DeepFindById(strSelectedParentID);
                if (objNewParent != null)
                {
                    if (objOldParent != null)
                        await objOldParent.Children.RemoveAsync(objModularCyberware);
                    else
                        await CharacterObject.Cyberware.RemoveAsync(objModularCyberware);

                    await objNewParent.Children.AddAsync(objModularCyberware);

                    objModularCyberware.ChangeModularEquip(true);
                }
                else
                {
                    VehicleMod objNewVehicleModParent = CharacterObject.Vehicles.FindVehicleMod(x => x.InternalId == strSelectedParentID);
                    if (objNewVehicleModParent == null)
                        objNewParent = CharacterObject.Vehicles.FindVehicleCyberware(x => x.InternalId == strSelectedParentID, out objNewVehicleModParent);

                    if (objNewVehicleModParent != null || objNewParent != null)
                    {
                        if (objOldParent != null)
                            await objOldParent.Children.RemoveAsync(objModularCyberware);
                        else
                            await CharacterObject.Cyberware.RemoveAsync(objModularCyberware);

                        if (objNewParent != null)
                            await objNewParent.Children.AddAsync(objModularCyberware);
                        else
                            await objNewVehicleModParent.Cyberware.AddAsync(objModularCyberware);
                    }
                    else
                    {
                        if (objOldParent != null)
                        {
                            await objOldParent.Children.RemoveAsync(objModularCyberware);

                            await CharacterObject.Cyberware.AddAsync(objModularCyberware);
                        }
                    }
                }
            }
        }

        private async void cmdVehicleCyberwareChangeMount_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Cyberware objModularCyberware))
                return;
            string strSelectedParentID;
            using (new FetchSafelyFromPool<List<ListItem>>(
                       Utils.ListItemListPool, out List<ListItem> lstModularMounts))
            {
                lstModularMounts.AddRange(CharacterObject.ConstructModularCyberlimbList(objModularCyberware));
                //Mounted cyberware should always be allowed to be dismounted.
                //Unmounted cyberware requires that a valid mount be present.
                if (!objModularCyberware.IsModularCurrentlyEquipped
                    && lstModularMounts.All(
                        x => !string.Equals(x.Value.ToString(), "None", StringComparison.OrdinalIgnoreCase)))
                {
                    Program.ShowMessageBox(this,
                                                    await LanguageManager.GetStringAsync("Message_NoValidModularMount"),
                                                    await LanguageManager.GetStringAsync("MessageTitle_NoValidModularMount"),
                                                    MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                string strDescription = await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware");
                using (ThreadSafeForm<SelectItem> frmPickMount = await ThreadSafeForm<SelectItem>.GetAsync(() => new SelectItem
                       {
                           Description = strDescription
                       }))
                {
                    frmPickMount.MyForm.SetGeneralItemsMode(lstModularMounts);

                    // Make sure the dialogue window was not canceled.
                    if (await frmPickMount.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    {
                        return;
                    }

                    strSelectedParentID = frmPickMount.MyForm.SelectedItem;
                }
            }

            CharacterObject.Vehicles.FindVehicleCyberware(x => x.InternalId == objModularCyberware.InternalId,
                                                          out VehicleMod objOldParentVehicleMod);
            Cyberware objOldParent = objModularCyberware.Parent;
            if (objOldParent != null)
                objModularCyberware.ChangeModularEquip(false);
            if (strSelectedParentID == "None")
            {
                if (objOldParent != null)
                    await objOldParent.Children.RemoveAsync(objModularCyberware);
                else
                    await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware);

                await CharacterObject.Cyberware.AddAsync(objModularCyberware);
            }
            else
            {
                Cyberware objNewParent = CharacterObject.Cyberware.DeepFindById(strSelectedParentID);
                if (objNewParent != null)
                {
                    if (objOldParent != null)
                        await objOldParent.Children.RemoveAsync(objModularCyberware);
                    else
                        await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware);

                    await objNewParent.Children.AddAsync(objModularCyberware);

                    objModularCyberware.ChangeModularEquip(true);
                }
                else
                {
                    VehicleMod objNewVehicleModParent = CharacterObject.Vehicles.FindVehicleMod(x => x.InternalId == strSelectedParentID);
                    if (objNewVehicleModParent == null)
                        objNewParent = CharacterObject.Vehicles.FindVehicleCyberware(x => x.InternalId == strSelectedParentID, out objNewVehicleModParent);

                    if (objNewVehicleModParent != null || objNewParent != null)
                    {
                        if (objOldParent != null)
                            await objOldParent.Children.RemoveAsync(objModularCyberware);
                        else
                            await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware);

                        if (objNewParent != null)
                            await objNewParent.Children.AddAsync(objModularCyberware);
                        else
                            await objNewVehicleModParent.Cyberware.AddAsync(objModularCyberware);
                    }
                    else
                    {
                        if (objOldParent != null)
                            await objOldParent.Children.RemoveAsync(objModularCyberware);
                        else
                            await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware);

                        await CharacterObject.Cyberware.AddAsync(objModularCyberware);
                    }
                }
            }
        }

        private void cmdContactsExpansionToggle_Click(object sender, EventArgs e)
        {
            if (panContacts.Controls.Count <= 0)
                return;
            panContacts.SuspendLayout();
            try
            {
                bool toggle = ((ContactControl) panContacts.Controls[0]).Expanded;

                foreach (ContactControl c in panContacts.Controls)
                {
                    c.Expanded = !toggle;
                }
            }
            finally
            {
                panContacts.ResumeLayout();
            }
        }

        private void cmdSwapContactOrder_Click(object sender, EventArgs e)
        {
            panContacts.FlowDirection = panContacts.FlowDirection == FlowDirection.LeftToRight
                ? FlowDirection.TopDown
                : FlowDirection.LeftToRight;
        }

        private async void tsWeaponLocationAddWeapon_Click(object sender, EventArgs e)
        {
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Location objLocation))
                return;
            bool blnAddAgain;
            do
            {
                blnAddAgain = await AddWeapon(objLocation);
            }
            while (blnAddAgain);
        }

        private async void tsVehicleLocationAddVehicle_Click(object sender, EventArgs e)
        {
            bool blnAddAgain;
            do
            {
                blnAddAgain = await AddVehicle(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) as Location);
            }
            while (blnAddAgain);
        }

        private async void tsEditWeaponMount_Click(object sender, EventArgs e)
        {
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is WeaponMount objWeaponMount))
                return;
            using (ThreadSafeForm<CreateWeaponMount> frmCreateWeaponMount
                   = await ThreadSafeForm<CreateWeaponMount>.GetAsync(
                       () => new CreateWeaponMount(objWeaponMount.Parent, CharacterObject, objWeaponMount)))
            {
                if (await frmCreateWeaponMount.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;
            }

            await RequestCharacterUpdate();

            await SetDirty(true);
        }

        private async void btnCreateCustomDrug_Click_1(object sender, EventArgs e)
        {
            using (ThreadSafeForm<CreateCustomDrug> form = await ThreadSafeForm<CreateCustomDrug>.GetAsync(() => new CreateCustomDrug(CharacterObject)))
            {
                if (await form.ShowDialogSafeAsync(this) == DialogResult.Cancel)
                    return;

                Drug objCustomDrug = form.MyForm.CustomDrug;
                await CharacterObject.Drugs.AddAsync(objCustomDrug);
            }
        }

        private async void OpenSourceFromLabel(object sender, EventArgs e)
        {
            await CommonFunctions.OpenPdfFromControl(sender);
        }

        private void pnlAttributes_Layout(object sender, LayoutEventArgs e)
        {
            pnlAttributes.SuspendLayout();
            try
            {
                foreach (Control objAttributeControl in pnlAttributes.Controls)
                {
                    if (pnlAttributes.ClientSize.Width < objAttributeControl.MinimumSize.Height)
                        objAttributeControl.MinimumSize
                            = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MinimumSize.Height);
                    if (pnlAttributes.ClientSize.Width != objAttributeControl.MaximumSize.Height)
                        objAttributeControl.MaximumSize
                            = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MaximumSize.Height);
                    if (pnlAttributes.ClientSize.Width > objAttributeControl.MinimumSize.Height)
                        objAttributeControl.MinimumSize
                            = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MinimumSize.Height);
                }
            }
            finally
            {
                pnlAttributes.ResumeLayout();
            }
        }

        #region Stolen Property Changes

        private async void chkDrugStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasStolenProperty loot))
                return;
            await ProcessStolenChanged(loot, await chkDrugStolen.DoThreadSafeFuncAsync(x => x.Checked));
        }

        private async void chkCyberwareStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasStolenProperty loot))
                return;
            await ProcessStolenChanged(loot, await chkCyberwareStolen.DoThreadSafeFuncAsync(x => x.Checked));
        }

        private async void chkGearStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasStolenProperty loot))
                return;
            await ProcessStolenChanged(loot, await chkGearStolen.DoThreadSafeFuncAsync(x => x.Checked));
        }

        private async void chkArmorStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasStolenProperty loot))
                return;
            await ProcessStolenChanged(loot, await chkArmorStolen.DoThreadSafeFuncAsync(x => x.Checked));
        }

        private async void chkWeaponStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasStolenProperty loot))
                return;
            await ProcessStolenChanged(loot, await chkWeaponStolen.DoThreadSafeFuncAsync(x => x.Checked));
        }

        private async void chkVehicleStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is IHasStolenProperty loot))
                return;
            await ProcessStolenChanged(loot, await chkVehicleStolen.DoThreadSafeFuncAsync(x => x.Checked));
        }

        private async ValueTask ProcessStolenChanged(IHasStolenProperty loot, bool state)
        {
            loot.Stolen = state;
            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        #endregion Stolen Property Changes

        private void btnDeleteCustomDrug_Click(object sender, EventArgs e)
        {
            if (!(treCustomDrugs.SelectedNode?.Tag is ICanRemove selectedObject))
                return;
            selectedObject.Remove();
        }

        private async void cboVehicleWeaponFiringMode_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;

            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is Weapon objWeapon))
                return;
            objWeapon.FireMode = await cboVehicleWeaponFiringMode.DoThreadSafeFuncAsync(x => x.SelectedIndex >= 0
                ? (Weapon.FiringMode) x.SelectedValue
                : Weapon.FiringMode.DogBrain);
            await RefreshSelectedVehicle();

            await SetDirty(true);
        }

        private async void chkCyberwareBlackMarketDiscount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is ICanBlackMarketDiscount objItem))
                return;
            objItem.DiscountCost = chkCyberwareBlackMarketDiscount.Checked;
            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkGearBlackMarketDiscount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is ICanBlackMarketDiscount objItem))
                return;
            objItem.DiscountCost = await chkGearBlackMarketDiscount.DoThreadSafeFuncAsync(x => x.Checked);
            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkArmorBlackMarketDiscount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is ICanBlackMarketDiscount objItem))
                return;
            objItem.DiscountCost = await chkArmorBlackMarketDiscount.DoThreadSafeFuncAsync(x => x.Checked);
            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkWeaponBlackMarketDiscount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is ICanBlackMarketDiscount objItem))
                return;
            objItem.DiscountCost = await chkWeaponBlackMarketDiscount.DoThreadSafeFuncAsync(x => x.Checked);
            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void chkVehicleBlackMarketDiscount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing)
                return;
            if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag) is ICanBlackMarketDiscount objItem))
                return;
            objItem.DiscountCost = await chkVehicleBlackMarketDiscount.DoThreadSafeFuncAsync(x => x.Checked);
            await RequestCharacterUpdate();
            await SetDirty(true);
        }

        private async void mnuFileExport_Click(object sender, EventArgs e)
        {
            try
            {
                await DoExport(GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }
    }
}
