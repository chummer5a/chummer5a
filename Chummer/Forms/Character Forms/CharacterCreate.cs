/*  This file is part of Chummer5a.
 *
 *  Chummer5a is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Chummer5a is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Chummer5a.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  You can obtain the full source code for Chummer5a at
 *  https://github.com/chummer5a/chummer5a
 */

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Xml;
using System.Xml.XPath;
using Chummer.Backend.Attributes;
using Chummer.Backend.Enums;
using Chummer.Backend.Equipment;
using Chummer.Backend.Skills;
using Chummer.Backend.Uniques;
using NLog;

namespace Chummer
{
    [DesignerCategory("Form")]
    public partial class CharacterCreate : CharacterShared
    {
        private static readonly Lazy<Logger> s_ObjLogger = new Lazy<Logger>(LogManager.GetCurrentClassLogger);
        private static Logger Log => s_ObjLogger.Value;

        private bool _blnReapplyImprovements;
        private bool _blnFreestyle;
        public bool IsReopenQueued { get; private set; }
        private int _intDragLevel;
        private StoryBuilder _objStoryBuilder;

        public TabControl TabCharacterTabs => tabCharacterTabs;

        private readonly Font _fntNormal;
        private readonly Font _fntStrikeout;

        #region Form Events

        private void ConstructorCommon()
        {
            InitializeComponent();
            tabSkillsUc.MyToken = GenericToken;
            tabPowerUc.MyToken = GenericToken;
        }

        [Obsolete("This constructor is for use by form designers only.", true)]
        public CharacterCreate()
        {
            ConstructorCommon();
            _fntNormal = new Font(treQualities.Font, FontStyle.Regular);
            _fntStrikeout = new Font(treQualities.Font, FontStyle.Strikeout);
        }

        public CharacterCreate(Character objCharacter) : base(objCharacter)
        {
            ConstructorCommon();
            _fntNormal = new Font(treQualities.Font, FontStyle.Regular);
            _fntStrikeout = new Font(treQualities.Font, FontStyle.Strikeout);
            tabSkillsUc.CachedCharacter = objCharacter;
            tabPowerUc.CachedCharacter = objCharacter;
            this.UpdateLightDarkMode();
            this.TranslateWinForm();
            this.UpdateParentForToolTipControls();

            ContextMenuStrip[] lstCMSToTranslate =
            {
                cmsAdvancedLifestyle,
                cmsAdvancedProgram,
                cmsArmor,
                cmsArmorGear,
                cmsArmorLocation,
                cmsArmorMod,
                cmsBioware,
                cmsComplexForm,
                cmsCritterPowers,
                cmsCyberware,
                cmsCyberwareGear,
                cmsVehicleCyberware,
                cmsVehicleCyberwareGear,
                cmsGear,
                cmsGearAllowRename,
                cmsGearButton,
                cmsGearLocation,
                cmsInitiationNotes,
                cmsLifestyle,
                cmsLifestyleNotes,
                cmsMartialArts,
                cmsMetamagic,
                cmsQuality,
                cmsSpell,
                cmsSpellButton,
                cmsTechnique,
                cmsVehicle,
                cmsVehicleGear,
                cmsVehicleLocation,
                cmsVehicleWeapon,
                cmsVehicleWeaponAccessory,
                cmsVehicleWeaponAccessoryGear,
                cmsWeapon,
                cmsWeaponAccessory,
                cmsWeaponAccessoryGear,
                cmsWeaponLocation,
                cmsWeaponMount
            };

            // Update the text in the Menus so they can be merged with frmMain properly.
            foreach (ToolStripMenuItem tssItem in mnuCreateMenu.Items.OfType<ToolStripMenuItem>())
            {
                tssItem.UpdateLightDarkMode();
                tssItem.TranslateToolStripItemsRecursively();
            }

            foreach (ContextMenuStrip objCMS in lstCMSToTranslate)
            {
                if (objCMS != null)
                {
                    foreach (ToolStripMenuItem tssItem in objCMS.Items.OfType<ToolStripMenuItem>())
                    {
                        tssItem.UpdateLightDarkMode();
                        tssItem.TranslateToolStripItemsRecursively();
                    }
                }
            }

            tabCharacterTabs.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabInfo.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabLongTexts.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabPeople.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabStreetGearTabs.MouseWheel += CommonFunctions.ShiftTabsOnMouseScroll;
            tabSkillsUc.MakeDirtyWithCharacterUpdate += MakeDirtyWithCharacterUpdate;
            lmtControl.MakeDirty += MakeDirty;
        }

        private async void TreeView_KeyDown(object sender, KeyEventArgs e)
        {
            if (sender is TreeView treView && e.KeyCode == Keys.Delete)
            {
                try
                {
                    object objSelected = await treView.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false);
                    await RemoveSelectedObject(objSelected, GenericToken).ConfigureAwait(false);
                }
                catch (OperationCanceledException)
                {
                    //swallow this
                }
            }
        }

        private void TreeView_ItemDrag(object sender, ItemDragEventArgs e)
        {
            if (!(sender is TreeView treView))
                return;
            TreeNode nodSelected = treView.SelectedNode;
            object objTag = nodSelected?.Tag;
            if (objTag == null || (objTag is string strTag && (string.IsNullOrEmpty(strTag) || strTag.StartsWith("Node_"))))
                return;
            int intDragLevel = nodSelected.Level;
            if (treView == treGear)
            {
                switch (e.Button)
                {
                    case MouseButtons.Left:
                        if (intDragLevel < 0 || intDragLevel > 1)
                            return;
                        break;
                    case MouseButtons.Right:
                        if (intDragLevel == 0)
                            return;
                        break;
                    default:
                        return;
                }
            }
            else if (treView == treVehicles)
            {
                DraggingGear = objTag is Gear;
            }
            else if (intDragLevel != 1)
                return;
            _intDragLevel = intDragLevel;
            DragButton = e.Button;
            DoDragDrop(e.Item, DragDropEffects.Move);
        }

        private async void TreeView_DragDrop(object sender, DragEventArgs e)
        {
            if (!(sender is TreeView treView))
                return;
            ItemTreeViewTypes eType = ItemTreeViewTypes.Misc;
            if (treView == treWeapons)
                eType = ItemTreeViewTypes.Weapons;
            else if (treView == treArmor)
                eType = ItemTreeViewTypes.Armor;
            else if (treView == treGear)
                eType = ItemTreeViewTypes.Gear;
            else if (treView == treVehicles)
                eType = ItemTreeViewTypes.Vehicles;
            try
            {
                await DoTreeDragDrop(sender, e, eType, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void TreeView_MouseDown(object sender, MouseEventArgs e)
        {
            // Generic event for all TreeViews to allow right-clicking to select a TreeNode so the proper ContextMenu is shown.
            //if (e.Button == System.Windows.Forms.MouseButtons.Right)
            //{
            if (!(sender is TreeView treView))
                return;
            TreeNode nodSelected = treView.SelectedNode = treView.HitTest(e.X, e.Y).Node;
            //}
            if (ModifierKeys != Keys.Control)
                return;
            if (nodSelected != null)
            {
                if (!nodSelected.IsExpanded)
                {
                    foreach (TreeNode objNode in nodSelected.Nodes)
                    {
                        objNode.ExpandAll();
                    }
                }
                else
                {
                    foreach (TreeNode objNode in nodSelected.Nodes)
                    {
                        objNode.Collapse();
                    }
                }
            }
        }

        private void TreeView_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private void TreeView_DragOver(object sender, DragEventArgs e)
        {
            if (!(sender is TreeView treView))
                return;
            Point pt = treView.PointToClient(new Point(e.X, e.Y));
            TreeNode objNode = treView.GetNodeAt(pt);

            if (objNode == null)
                return;

            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
            if (DragButton == MouseButtons.Left)
            {
                if (objNode.Level <= _intDragLevel)
                    objNode.BackColor = ColorManager.ControlDarker;
            }
            else
                objNode.BackColor = ColorManager.ControlDarker;

            // Clear the background color for all other Nodes.
            treView.ClearNodeBackground(objNode);
        }

        private async void CharacterCreate_Load(object sender, EventArgs e)
        {
            try
            {
                try
                {
                    CursorWait objCursorWait =
                        await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                    try
                    {
                        Task tskAutosave = Task.CompletedTask; // Separate out the autosave task so that we can work on it while the UI is drawing
                        using (CustomActivity op_load_frm_create = Timekeeper.StartSyncron(
                                   "load_frm_create", null, CustomActivity.OperationType.RequestOperation,
                                   CharacterObject != null ? await CharacterObject.GetFileNameAsync(GenericToken).ConfigureAwait(false) : string.Empty))
                        {
                            await this.DoThreadSafeAsync(x => x.SuspendLayout(), GenericToken).ConfigureAwait(false);
                            try
                            {
                                try
                                {
                                    if (CharacterObject == null)
                                    {
                                        // Stupid hack to get the MDI icon to show up properly.
                                        await this.DoThreadSafeFuncAsync(x => x.Icon = x.Icon.Clone() as Icon,
                                            GenericToken).ConfigureAwait(false);
                                        return;
                                    }

                                    if (!await CharacterObject.GetIsCritterAsync(GenericToken).ConfigureAwait(false)
                                        && !await CharacterObject.GetEffectiveBuildMethodIsLifeModuleAsync(GenericToken).ConfigureAwait(false)
                                        && await CharacterObjectSettings.GetBuildKarmaAsync(GenericToken).ConfigureAwait(false) == 0)
                                    {
                                        _blnFreestyle = true;
                                        await tsMain.DoThreadSafeAsync(() =>
                                        {
                                            tslKarmaRemaining.Visible = false;
                                            tslKarmaRemainingLabel.Visible = false;
                                        }, GenericToken).ConfigureAwait(false);
                                    }

                                    using (Timekeeper.StartSyncron(
                                               "load_frm_create_BuildMethod", op_load_frm_create))
                                    {
                                        // Initialize elements if we're using Priority to build.
                                        if (CharacterObject.EffectiveBuildMethodUsesPriorityTables)
                                        {
                                            string strText
                                                = await LanguageManager.GetStringAsync("Menu_SpecialChangePriorities",
                                                    token: GenericToken).ConfigureAwait(false);
                                            await mnuCreateMenu.DoThreadSafeAsync(() =>
                                            {
                                                mnuSpecialChangeMetatype.Tag = "Menu_SpecialChangePriorities";
                                                mnuSpecialChangeMetatype.Text = strText;
                                            }, GenericToken).ConfigureAwait(false);
                                        }
                                    }

                                    using (Timekeeper.StartSyncron(
                                               "load_frm_create_databinding", op_load_frm_create))
                                    {
                                        await lblNuyenTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayTotalStartingNuyen),
                                                x => x.GetDisplayTotalStartingNuyenAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblStolenNuyenLabel.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.HasStolenNuyen),
                                                x => x.GetHasStolenNuyenAsync(GenericToken),
                                                GenericToken)
                                            .ConfigureAwait(false);
                                        await lblStolenNuyen.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.HasStolenNuyen),
                                                x => x.GetHasStolenNuyenAsync(GenericToken),
                                                GenericToken)
                                            .ConfigureAwait(false);
                                        await lblAttributesBase.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.EffectiveBuildMethodUsesPriorityTables),
                                                x => x.GetEffectiveBuildMethodUsesPriorityTablesAsync(GenericToken),
                                                GenericToken)
                                            .ConfigureAwait(false);

                                        await txtGroupName.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.GroupName),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetGroupNameAsync(GenericToken),
                                            (x, y) => x.SetGroupNameAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtGroupNotes.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.GroupNotes),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetGroupNotesAsync(GenericToken),
                                            (x, y) => x.SetGroupNotesAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);

                                        await txtCharacterName.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Name),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetNameAsync(GenericToken),
                                            (x, y) => x.SetNameAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtGender.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Gender),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetGenderAsync(GenericToken),
                                            (x, y) => x.SetGenderAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtAge.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Age),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetAgeAsync(GenericToken),
                                            (x, y) => x.SetAgeAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtEyes.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Eyes),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetEyesAsync(GenericToken),
                                            (x, y) => x.SetEyesAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtHeight.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Height),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetHeightAsync(GenericToken),
                                            (x, y) => x.SetHeightAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtWeight.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Weight),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetWeightAsync(GenericToken),
                                            (x, y) => x.SetWeightAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtSkin.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Skin),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetSkinAsync(GenericToken),
                                            (x, y) => x.SetSkinAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtHair.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Hair),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetHairAsync(GenericToken),
                                            (x, y) => x.SetHairAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await rtfDescription.RegisterAsyncDataBindingWithDelayAsync(x => x.Rtf, (x, y) => x.Rtf = y,
                                            CharacterObject,
                                            nameof(Character.Description),
                                            (x, y) => x.RtfContentChanged += y,
                                            x => x.GetDescriptionAsync(GenericToken),
                                            (x, y) => x.SetDescriptionAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await rtfBackground.RegisterAsyncDataBindingWithDelayAsync(x => x.Rtf, (x, y) => x.Rtf = y,
                                            CharacterObject,
                                            nameof(Character.Background),
                                            (x, y) => x.RtfContentChanged += y,
                                            x => x.GetBackgroundAsync(GenericToken),
                                            (x, y) => x.SetBackgroundAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await rtfConcept.RegisterAsyncDataBindingWithDelayAsync(x => x.Rtf, (x, y) => x.Rtf = y,
                                            CharacterObject,
                                            nameof(Character.Concept),
                                            (x, y) => x.RtfContentChanged += y,
                                            x => x.GetConceptAsync(GenericToken),
                                            (x, y) => x.SetConceptAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await rtfNotes.RegisterAsyncDataBindingWithDelayAsync(x => x.Rtf, (x, y) => x.Rtf = y,
                                            CharacterObject,
                                            nameof(Character.Notes),
                                            (x, y) => x.RtfContentChanged += y,
                                            x => x.GetNotesAsync(GenericToken),
                                            (x, y) => x.SetNotesAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtAlias.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.Alias),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetAliasAsync(GenericToken),
                                            (x, y) => x.SetAliasAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                        await txtPlayerName.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            CharacterObject,
                                            nameof(Character.PlayerName),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetPlayerNameAsync(GenericToken),
                                            (x, y) => x.SetPlayerNameAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);

                                        await lblPositiveQualitiesBP.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayPositiveQualityKarma),
                                                x => x.GetDisplayPositiveQualityKarmaAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblNegativeQualitiesBP.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayNegativeQualityKarma),
                                                x => x.GetDisplayNegativeQualityKarmaAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMetagenicQualities.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayMetagenicQualityKarma),
                                                x => x.GetDisplayMetagenicQualityKarmaAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMetagenicQualities.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.IsChangeling),
                                                x => x.GetIsChangelingAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMetagenicQualitiesLabel.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.IsChangeling),
                                                x => x.GetIsChangelingAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblEnemiesBP.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayEnemyKarma),
                                                x => x.GetDisplayEnemyKarmaAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        string strKarma = await LanguageManager
                                            .GetStringAsync("Label_Karma", token: GenericToken)
                                            .ConfigureAwait(false);
                                        string strKarmaRemaining
                                            = await LanguageManager.GetStringAsync("Label_KarmaRemaining",
                                                    token: GenericToken)
                                                .ConfigureAwait(false);
                                        string strBPSummaryKarma
                                            = await LanguageManager.GetStringAsync("Tab_BPSummary_Karma",
                                                    token: GenericToken)
                                                .ConfigureAwait(false);
                                        await tsMain.DoThreadSafeAsync(() =>
                                        {
                                            tslKarmaLabel.Text = strKarma;
                                            tslKarmaRemainingLabel.Text = strKarmaRemaining;
                                        }, GenericToken).ConfigureAwait(false);
                                        await tabBPSummary.DoThreadSafeAsync(x => x.Text = strBPSummaryKarma,
                                                GenericToken)
                                            .ConfigureAwait(false);
                                        await lblQualityBPLabel.DoThreadSafeAsync(x => x.Text = strKarma, GenericToken)
                                            .ConfigureAwait(false);

                                        await lblMetatype.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.FormattedMetatype),
                                                x => x.GetFormattedMetatypeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        // Set the visibility of the Bioware Suites menu options.
                                        await mnuCreateMenu.DoThreadSafeAsync(() =>
                                        {
                                            mnuSpecialAddBiowareSuite.Visible =
                                                CharacterObjectSettings.AllowBiowareSuites;
                                            mnuSpecialCreateBiowareSuite.Visible
                                                = CharacterObjectSettings.AllowBiowareSuites;
                                        }, GenericToken).ConfigureAwait(false);

                                        await chkJoinGroup.RegisterAsyncDataBindingAsync(x => x.Checked, (x, y) => x.Checked = y,
                                            CharacterObject,
                                            nameof(Character.GroupMember),
                                            (x, y) => x.CheckedChanged += y,
                                            x => x.GetGroupMemberAsync(GenericToken),
                                            (x, y) => x.SetGroupMemberAsync(y, GenericToken),
                                            GenericToken,
                                            GenericToken).ConfigureAwait(false);
                                        await chkInitiationGroup.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Enabled = y, CharacterObject,
                                                nameof(Character.GroupMember),
                                                x => x.GetGroupMemberAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await chkCyberwareBlackMarketDiscount.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.BlackMarketDiscount),
                                                x => x.GetBlackMarketDiscountAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await chkGearBlackMarketDiscount.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.BlackMarketDiscount),
                                                x => x.GetBlackMarketDiscountAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await chkWeaponBlackMarketDiscount.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.BlackMarketDiscount),
                                                x => x.GetBlackMarketDiscountAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await chkArmorBlackMarketDiscount.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.BlackMarketDiscount),
                                                x => x.GetBlackMarketDiscountAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await chkVehicleBlackMarketDiscount.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.BlackMarketDiscount),
                                                x => x.GetBlackMarketDiscountAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        // If the character has a mugshot, decode it and put it in the PictureBox.
                                        int intMugshotCount =
                                            await (await CharacterObject.GetMugshotsAsync(GenericToken).ConfigureAwait(false)).GetCountAsync(GenericToken).ConfigureAwait(false);
                                        if (intMugshotCount > 0)
                                        {
                                            int intMainMugshotIndex =
                                                await CharacterObject.GetMainMugshotIndexAsync(GenericToken).ConfigureAwait(false);
                                            await nudMugshotIndex.DoThreadSafeAsync(x =>
                                            {
                                                x.Minimum = 1;
                                                x.Maximum = intMugshotCount;
                                                x.Value = Math.Max(intMainMugshotIndex, 0) + 1;
                                            }, GenericToken).ConfigureAwait(false);
                                        }
                                        else
                                        {
                                            await nudMugshotIndex.DoThreadSafeAsync(x =>
                                            {
                                                x.Minimum = 0;
                                                x.Maximum = 0;
                                                x.Value = 0;
                                            }, GenericToken).ConfigureAwait(false);
                                        }

                                        string strNumMugshots =
                                            await LanguageManager.GetStringAsync("String_Of", token: GenericToken)
                                                .ConfigureAwait(false) +
                                            intMugshotCount.ToString(GlobalSettings.CultureInfo);
                                        await lblNumMugshots
                                            .DoThreadSafeAsync(x => x.Text = strNumMugshots, GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    if (!await CharacterObjectSettings.BookEnabledAsync("RF", GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await cmdAddLifestyle
                                            .DoThreadSafeAsync(x => x.SplitMenuStrip = null, GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    if (!await CharacterObjectSettings.BookEnabledAsync("FA", GenericToken)
                                            .ConfigureAwait(false))
                                    {
                                        await lblWildReputation.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                            .ConfigureAwait(false);
                                        await lblWildReputationTotal.DoThreadSafeAsync(
                                            x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                        if (!await CharacterObjectSettings.BookEnabledAsync("SG", GenericToken)
                                                .ConfigureAwait(false))
                                        {
                                            await lblAstralReputation.DoThreadSafeAsync(
                                                x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                            await lblAstralReputationTotal.DoThreadSafeAsync(
                                                x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                        }
                                    }

                                    if (!await CharacterObjectSettings.GetEnableEnemyTrackingAsync(GenericToken).ConfigureAwait(false))
                                    {
                                        await tabPeople.DoThreadSafeAsync(x => x.TabPages.Remove(tabEnemies),
                                                GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    await splitMagician.DoThreadSafeAsync(x => x.SplitterDistance
                                        = Math.Max(x.SplitterDistance,
                                            ((x.Height - x.SplitterWidth) * 2).DivAwayFromZero(3)), GenericToken).ConfigureAwait(false);
                                    await splitTechnomancer.DoThreadSafeAsync(
                                        x => x.SplitterDistance
                                            = Math.Max(x.SplitterDistance, ((x.Height - x.SplitterWidth) * 2).DivAwayFromZero(3)),
                                        GenericToken).ConfigureAwait(false);

                                    Tradition objTradition = await CharacterObject
                                        .GetMagicTraditionAsync(GenericToken).ConfigureAwait(false);

                                    using (Timekeeper.StartSyncron(
                                               "load_frm_create_tradition", op_load_frm_create))
                                    {
                                        // Populate the Magician Traditions list.
                                        XPathNavigator xmlTraditionsBaseChummerNode =
                                            (await CharacterObject.LoadDataXPathAsync(
                                                "traditions.xml", token: GenericToken).ConfigureAwait(false))
                                            .SelectSingleNodeAndCacheExpression("/chummer", GenericToken);
                                        using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(Utils.ListItemListPool,
                                                   out List<ListItem> lstTraditions))
                                        {
                                            if (xmlTraditionsBaseChummerNode != null)
                                            {
                                                foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode
                                                             .Select(
                                                                 "traditions/tradition["
                                                                 + await CharacterObjectSettings
                                                                     .BookXPathAsync(token: GenericToken)
                                                                     .ConfigureAwait(false)
                                                                 + "]"))
                                                {
                                                    string strName
                                                        = xmlTradition.SelectSingleNodeAndCacheExpression(
                                                                "name", GenericToken)
                                                            ?.Value;
                                                    if (!string.IsNullOrEmpty(strName))
                                                        lstTraditions.Add(new ListItem(
                                                            xmlTradition
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "id", GenericToken)
                                                                ?.Value ?? strName,
                                                            xmlTradition
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "translate", GenericToken)
                                                                ?.Value ?? strName));
                                                }
                                            }

                                            if (lstTraditions.Count > 1)
                                            {
                                                lstTraditions.Sort(CompareListItems.CompareNames);
                                                lstTraditions.Insert(0,
                                                    new ListItem(
                                                        "None",
                                                        await LanguageManager
                                                            .GetStringAsync("String_None", token: GenericToken)
                                                            .ConfigureAwait(false)));
                                                await cboTradition
                                                    .PopulateWithListItemsAsync(lstTraditions, GenericToken)
                                                    .ConfigureAwait(false);
                                            }
                                            else
                                            {
                                                await this.DoThreadSafeAsync(() =>
                                                {
                                                    cboTradition.Visible = false;
                                                    lblTraditionLabel.Visible = false;
                                                }, GenericToken).ConfigureAwait(false);
                                            }
                                        }

                                        // Populate the Magician Custom Drain Options list.
                                        using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(Utils.ListItemListPool,
                                                   out List<ListItem> lstDrainAttributes))
                                        {
                                            if (xmlTraditionsBaseChummerNode != null)
                                            {
                                                foreach (XPathNavigator xmlDrain in xmlTraditionsBaseChummerNode.Select(
                                                             "drainattributes/drainattribute"))
                                                {
                                                    string strName
                                                        = xmlDrain.SelectSingleNodeAndCacheExpression("name",
                                                                GenericToken)
                                                            ?.Value;
                                                    if (!string.IsNullOrEmpty(strName)
                                                        && (lstDrainAttributes.Count == 0 || lstDrainAttributes.TrueForAll(x =>
                                                            x.Value?.ToString() != strName)))
                                                    {
                                                        string strTranslatedName = xmlDrain
                                                            .SelectSingleNodeAndCacheExpression(
                                                                "translate", GenericToken)?.Value ?? strName;
                                                        lstDrainAttributes.Add(new ListItem(strName,
                                                            strTranslatedName));
                                                    }
                                                }
                                            }

                                            lstDrainAttributes.Sort(CompareListItems.CompareNames);
                                            lstDrainAttributes.Insert(0, ListItem.Blank);
                                            await cboDrain.PopulateWithListItemsAsync(lstDrainAttributes, GenericToken)
                                                .ConfigureAwait(false);
                                            await cboDrain.RegisterAsyncDataBindingWithDelayAsync(
                                                x => x.SelectedValue?.ToString() ?? string.Empty,
                                                (x, y) =>
                                                {
                                                    if (!string.IsNullOrEmpty(y))
                                                        x.SelectedValue = y;
                                                    else
                                                        x.SelectedIndex = -1;
                                                }, objTradition,
                                                nameof(Tradition.DrainExpression),
                                                (x, y) => x.SelectedValueChanged += y,
                                                x => x.GetDrainExpressionAsync(GenericToken),
                                                (x, y) => x.SetDrainExpressionAsync(y, GenericToken),
                                                1000,
                                                GenericToken,
                                                GenericToken).ConfigureAwait(false);
                                        }

                                        await lblDrainAttributes.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y,
                                                objTradition,
                                                nameof(Tradition.DisplayDrainExpression),
                                                x => x.GetDisplayDrainExpressionAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblDrainAttributesValue.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                objTradition,
                                                nameof(Tradition.DrainValue),
                                                x => x.GetDrainValueAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblDrainAttributesValue.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y,
                                                objTradition,
                                                nameof(Tradition.DrainValueToolTip),
                                                x => x.GetDrainValueToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await objTradition.SetSourceDetailAsync(
                                            lblTraditionSource, GenericToken).ConfigureAwait(false);

                                        await lblFadingAttributes.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y,
                                                objTradition,
                                                nameof(Tradition.DisplayDrainExpression),
                                                x => x.GetDisplayDrainExpressionAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblFadingAttributesValue.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                objTradition,
                                                nameof(Tradition.DrainValue),
                                                x => x.GetDrainValueAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblFadingAttributesValue.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y,
                                                objTradition,
                                                nameof(Tradition.DrainValueToolTip),
                                                x => x.GetDrainValueToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                                   out HashSet<string> limit))
                                        {
                                            foreach (Improvement improvement in await ImprovementManager
                                                         .GetCachedImprovementListForValueOfAsync(
                                                             CharacterObject,
                                                             Improvement.ImprovementType.LimitSpiritCategory,
                                                             token: GenericToken)
                                                         .ConfigureAwait(false))
                                            {
                                                limit.Add(improvement.ImprovedName);
                                            }

                                            /* Populate drugs. //TODO: fix
                                            foreach (Drug objDrug in CharacterObj.Drugs)
                                            {
                                                treCustomDrugs.Add(objDrug);
                                            }
                                            */

                                            // Populate the Magician Custom Spirits lists - Combat.
                                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(Utils.ListItemListPool,
                                                       out List<ListItem> lstSpirit))
                                            {
                                                if (xmlTraditionsBaseChummerNode != null)
                                                {
                                                    foreach (XPathNavigator xmlSpirit in xmlTraditionsBaseChummerNode
                                                                 .SelectAndCacheExpression("spirits/spirit",
                                                                     GenericToken))
                                                    {
                                                        string strSpiritName
                                                            = xmlSpirit.SelectSingleNodeAndCacheExpression(
                                                                    "name", GenericToken)
                                                                ?.Value;
                                                        if (!string.IsNullOrEmpty(strSpiritName)
                                                            && (limit.Count == 0 || limit.Contains(strSpiritName)))
                                                        {
                                                            lstSpirit.Add(new ListItem(strSpiritName,
                                                                xmlSpirit
                                                                    .SelectSingleNodeAndCacheExpression(
                                                                        "translate", GenericToken)
                                                                    ?.Value
                                                                ?? strSpiritName));
                                                        }
                                                    }
                                                }

                                                lstSpirit.Sort(CompareListItems.CompareNames);
                                                lstSpirit.Insert(0, ListItem.Blank);

                                                async ValueTask BindSpiritVisibility(ElasticComboBox cboBox,
                                                    Label lblName,
                                                    string strSpirit, Func<Tradition, Task<string>> funcSpiritGetter, Func<Tradition, string, Task> funcSpiritSetter)
                                                {
                                                    await cboBox.PopulateWithListItemsAsync(lstSpirit, GenericToken)
                                                        .ConfigureAwait(false);
                                                    await cboBox.RegisterAsyncDataBindingWithDelayAsync(
                                                        x => x.SelectedValue?.ToString() ?? string.Empty,
                                                        (x, y) =>
                                                        {
                                                            if (!string.IsNullOrEmpty(y))
                                                                x.SelectedValue = y;
                                                            else
                                                                x.SelectedIndex = -1;
                                                        }, objTradition,
                                                        strSpirit,
                                                        (x, y) => x.SelectedValueChanged += y,
                                                        funcSpiritGetter,
                                                        funcSpiritSetter,
                                                        1000,
                                                        GenericToken,
                                                        GenericToken).ConfigureAwait(false);
                                                    bool blnIsMag =
                                                        await objTradition.GetTypeAsync(GenericToken)
                                                            .ConfigureAwait(false) == TraditionType.MAG;
                                                    bool blnCustomTradition = await objTradition
                                                        .GetIsCustomTraditionAsync(GenericToken).ConfigureAwait(false);
                                                    await lblName
                                                        .DoThreadSafeAsync(x => x.Visible = blnIsMag, GenericToken)
                                                        .ConfigureAwait(false);
                                                    await cboBox.DoThreadSafeAsync(x =>
                                                    {
                                                        x.Visible = blnIsMag;
                                                        x.Enabled = blnCustomTradition;
                                                    }, GenericToken).ConfigureAwait(false);
                                                }

                                                await BindSpiritVisibility(cboSpiritCombat, lblSpiritCombat,
                                                        nameof(Tradition.SpiritCombat),
                                                        x => x.GetSpiritCombatAsync(GenericToken),
                                                        (x, y) => x.SetSpiritCombatAsync(y, GenericToken))
                                                    .ConfigureAwait(false);
                                                await BindSpiritVisibility(cboSpiritDetection, lblSpiritDetection,
                                                        nameof(Tradition.SpiritDetection),
                                                        x => x.GetSpiritDetectionAsync(GenericToken),
                                                        (x, y) => x.SetSpiritDetectionAsync(y, GenericToken))
                                                    .ConfigureAwait(false);
                                                await BindSpiritVisibility(cboSpiritHealth, lblSpiritHealth,
                                                        nameof(Tradition.SpiritHealth),
                                                        x => x.GetSpiritHealthAsync(GenericToken),
                                                        (x, y) => x.SetSpiritHealthAsync(y, GenericToken))
                                                    .ConfigureAwait(false);
                                                await BindSpiritVisibility(cboSpiritIllusion, lblSpiritIllusion,
                                                        nameof(Tradition.SpiritIllusion),
                                                        x => x.GetSpiritIllusionAsync(GenericToken),
                                                        (x, y) => x.SetSpiritIllusionAsync(y, GenericToken))
                                                    .ConfigureAwait(false);
                                                await BindSpiritVisibility(cboSpiritManipulation, lblSpiritManipulation,
                                                        nameof(Tradition.SpiritManipulation),
                                                        x => x.GetSpiritManipulationAsync(GenericToken),
                                                        (x, y) => x.SetSpiritManipulationAsync(y, GenericToken))
                                                    .ConfigureAwait(false);
                                            }
                                        }

                                        // Populate the Technomancer Streams list.
                                        xmlTraditionsBaseChummerNode =
                                            (await CharacterObject.LoadDataXPathAsync(
                                                "streams.xml", token: GenericToken).ConfigureAwait(false))
                                            .SelectSingleNodeAndCacheExpression("/chummer", GenericToken);
                                        using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(Utils.ListItemListPool,
                                                   out List<ListItem> lstStreams))
                                        {
                                            if (xmlTraditionsBaseChummerNode != null)
                                            {
                                                foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode
                                                             .Select(
                                                                 "traditions/tradition["
                                                                 + await CharacterObjectSettings
                                                                     .BookXPathAsync(token: GenericToken)
                                                                     .ConfigureAwait(false)
                                                                 + "]"))
                                                {
                                                    string strName
                                                        = xmlTradition.SelectSingleNodeAndCacheExpression(
                                                                "name", GenericToken)
                                                            ?.Value;
                                                    if (!string.IsNullOrEmpty(strName))
                                                        lstStreams.Add(new ListItem(
                                                            xmlTradition
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "id", GenericToken)
                                                                ?.Value
                                                            ?? strName,
                                                            xmlTradition
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "translate", GenericToken)
                                                                ?.Value ?? strName));
                                                }
                                            }

                                            if (lstStreams.Count > 1)
                                            {
                                                lstStreams.Sort(CompareListItems.CompareNames);
                                                lstStreams.Insert(0,
                                                    new ListItem(
                                                        "None",
                                                        await LanguageManager.GetStringAsync("String_None",
                                                                token: GenericToken)
                                                            .ConfigureAwait(false)));
                                                await cboStream.PopulateWithListItemsAsync(lstStreams, GenericToken)
                                                    .ConfigureAwait(false);
                                            }
                                            else
                                            {
                                                await cboStream.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                                    .ConfigureAwait(false);
                                                await lblStreamLabel.DoThreadSafeAsync(
                                                    x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                            }
                                        }

                                        await nudMysticAdeptMAGMagician.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Maximum = y, await CharacterObject.GetAttributeAsync("MAG", token: GenericToken).ConfigureAwait(false),
                                                nameof(CharacterAttrib.TotalValue),
                                                x => x.GetTotalValueAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await nudMysticAdeptMAGMagician.RegisterAsyncDataBindingWithDelayAsync(x => x.ValueAsInt,
                                            (x, y) => x.ValueAsInt = y,
                                            CharacterObject,
                                            nameof(Character.MysticAdeptPowerPoints),
                                            (x, y) => x.ValueChanged += y,
                                            x => x.GetMysticAdeptPowerPointsAsync(GenericToken),
                                            (x, y) => x.SetMysticAdeptPowerPointsAsync(y, GenericToken), 250, GenericToken,
                                            GenericToken).ConfigureAwait(false);

                                        TraditionType eTraditionType = await objTradition.GetTypeAsync(GenericToken)
                                            .ConfigureAwait(false);
                                        string strTraditionSourceIdString =
                                            await objTradition.GetSourceIDStringAsync(GenericToken)
                                                .ConfigureAwait(false);
                                        await cboTradition.DoThreadSafeAsync(x =>
                                        {
                                            if (eTraditionType == TraditionType.MAG && !string.IsNullOrEmpty(strTraditionSourceIdString))
                                                x.SelectedValue = strTraditionSourceIdString;
                                            if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                x.SelectedIndex = 0;
                                        }, GenericToken).ConfigureAwait(false);
                                        await cboStream.DoThreadSafeAsync(x =>
                                        {
                                            if (eTraditionType == TraditionType.RES && !string.IsNullOrEmpty(strTraditionSourceIdString))
                                                x.SelectedValue = strTraditionSourceIdString;
                                            if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                x.SelectedIndex = 0;
                                        }, GenericToken).ConfigureAwait(false);
                                        await txtTraditionName.RegisterAsyncDataBindingWithDelayAsync(x => x.Text, (x, y) => x.Text = y,
                                            objTradition,
                                            nameof(Tradition.Name),
                                            (x, y) => x.TextChanged += y,
                                            x => x.GetNameAsync(GenericToken),
                                            (x, y) => x.SetNameAsync(y, GenericToken),
                                            1000, GenericToken, GenericToken).ConfigureAwait(false);
                                    }

                                    using (Timekeeper.StartSyncron(
                                               "load_frm_create_databinding2", op_load_frm_create))
                                    {
                                        await nudNuyen.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Maximum = y, CharacterObject,
                                                nameof(Character.TotalNuyenMaximumBP),
                                                x => x.GetTotalNuyenMaximumBPAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await nudNuyen.RegisterAsyncDataBindingWithDelayAsync(x => x.Value,
                                            (x, y) => x.Value = y,
                                            CharacterObject,
                                            nameof(Character.NuyenBP),
                                            (x, y) => x.ValueChanged += y,
                                            x => x.GetNuyenBPAsync(GenericToken),
                                            (x, y) => x.SetNuyenBPAsync(y, GenericToken), 250, GenericToken,
                                            GenericToken).ConfigureAwait(false);

                                        await lblCMPhysical.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y,
                                                CharacterObject,
                                                nameof(Character.PhysicalCMToolTip),
                                                x => x.GetPhysicalCMToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMPhysical.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.PhysicalCM),
                                                x => x.GetPhysicalCMAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMPhysicalLabel.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y,
                                                CharacterObject,
                                                nameof(Character.PhysicalCMLabelText),
                                                x => x.GetPhysicalCMLabelTextAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMStun.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y,
                                                CharacterObject,
                                                nameof(Character.DisplayStunCM),
                                                x => x.GetDisplayStunCMAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMStun.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.StunCMToolTip),
                                                x => x.GetStunCMToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCMStunLabel.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.StunCMLabelText),
                                                x => x.GetStunCMLabelTextAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblESSMax.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayEssence),
                                                x => x.GetDisplayEssenceAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblCyberwareESS.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayCyberwareEssence),
                                                x => x.GetDisplayCyberwareEssenceAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblBiowareESS.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayBiowareEssence),
                                                x => x.GetDisplayBiowareEssenceAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblEssenceHoleESS.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayEssenceHole),
                                                x => x.GetDisplayEssenceHoleAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblPrototypeTranshumanESS.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayPrototypeTranshumanEssenceUsed),
                                                x => x.GetDisplayPrototypeTranshumanEssenceUsedAsync(GenericToken),
                                                GenericToken)
                                            .ConfigureAwait(false);

                                        await lblArmor.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.TotalArmorRating),
                                                x => x.GetTotalArmorRatingAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblArmor.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.TotalArmorRatingToolTip),
                                                x => x.GetTotalArmorRatingToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblDodge.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayDodge),
                                                x => x.GetDisplayDodgeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblDodge.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.DodgeToolTip),
                                                x => x.GetDodgeToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblSpellDefenseIndirectDodge.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseIndirectDodge),
                                            x => x.GetDisplaySpellDefenseIndirectDodgeAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIndirectDodge.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseIndirectDodgeToolTip),
                                            x => x.GetSpellDefenseIndirectDodgeToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIndirectSoak.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseIndirectSoak),
                                            x => x.GetDisplaySpellDefenseIndirectSoakAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIndirectSoak.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseIndirectSoakToolTip),
                                            x => x.GetSpellDefenseIndirectSoakToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDirectSoakMana.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDirectSoakMana),
                                            x => x.GetDisplaySpellDefenseDirectSoakManaAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDirectSoakMana.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDirectSoakManaToolTip),
                                            x => x.GetSpellDefenseDirectSoakManaToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDirectSoakPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDirectSoakPhysical),
                                            x => x.GetDisplaySpellDefenseDirectSoakPhysicalAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDirectSoakPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDirectSoakPhysicalToolTip),
                                            x => x.GetSpellDefenseDirectSoakPhysicalToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDetection.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDetection),
                                            x => x.GetDisplaySpellDefenseDetectionAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDetection.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDetectionToolTip),
                                            x => x.GetSpellDefenseDetectionToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttBOD.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseBOD),
                                            x => x.GetDisplaySpellDefenseDecreaseBODAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttBOD.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseBODToolTip),
                                            x => x.GetSpellDefenseDecreaseBODToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttAGI.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseAGI),
                                            x => x.GetDisplaySpellDefenseDecreaseAGIAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttAGI.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseAGIToolTip),
                                            x => x.GetSpellDefenseDecreaseAGIToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttREA.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseREA),
                                            x => x.GetDisplaySpellDefenseDecreaseREAAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttREA.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseREAToolTip),
                                            x => x.GetSpellDefenseDecreaseREAToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttSTR.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseSTR),
                                            x => x.GetDisplaySpellDefenseDecreaseSTRAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttSTR.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseSTRToolTip),
                                            x => x.GetSpellDefenseDecreaseSTRToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttCHA.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseCHA),
                                            x => x.GetDisplaySpellDefenseDecreaseCHAAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttCHA.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseCHAToolTip),
                                            x => x.GetSpellDefenseDecreaseCHAToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttINT.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseINT),
                                            x => x.GetDisplaySpellDefenseDecreaseINTAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttINT.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseINTToolTip),
                                            x => x.GetSpellDefenseDecreaseINTToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttLOG.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseLOG),
                                            x => x.GetDisplaySpellDefenseDecreaseLOGAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttLOG.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseLOGToolTip),
                                            x => x.GetSpellDefenseDecreaseLOGToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttWIL.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseDecreaseWIL),
                                            x => x.GetDisplaySpellDefenseDecreaseWILAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseDecAttWIL.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseDecreaseWILToolTip),
                                            x => x.GetSpellDefenseDecreaseWILToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIllusionMana.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseIllusionMana),
                                            x => x.GetDisplaySpellDefenseIllusionManaAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIllusionMana.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseIllusionManaToolTip),
                                            x => x.GetSpellDefenseIllusionManaToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIllusionPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseIllusionPhysical),
                                            x => x.GetDisplaySpellDefenseIllusionPhysicalAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseIllusionPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseIllusionPhysicalToolTip),
                                            x => x.GetSpellDefenseIllusionPhysicalToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseManipMental.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseManipulationMental),
                                            x => x.GetDisplaySpellDefenseManipulationMentalAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseManipMental.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseManipulationMentalToolTip),
                                            x => x.GetSpellDefenseManipulationMentalToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseManipPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.DisplaySpellDefenseManipulationPhysical),
                                            x => x.GetDisplaySpellDefenseManipulationPhysicalAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblSpellDefenseManipPhysical.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.ToolTipText = y, CharacterObject,
                                            nameof(Character.SpellDefenseManipulationPhysicalToolTip),
                                            x => x.GetSpellDefenseManipulationPhysicalToolTipAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await nudCounterspellingDice.RegisterAsyncDataBindingWithDelayAsync(x => x.ValueAsInt,
                                            (x, y) => x.ValueAsInt = y,
                                            CharacterObject,
                                            nameof(Character.CurrentCounterspellingDice),
                                            (x, y) => x.ValueChanged += y,
                                            x => x.GetCurrentCounterspellingDiceAsync(GenericToken),
                                            (x, y) => x.SetCurrentCounterspellingDiceAsync(y, GenericToken), 250, GenericToken,
                                            GenericToken).ConfigureAwait(false);

                                        await nudLiftCarryHits.RegisterAsyncDataBindingWithDelayAsync(x => x.ValueAsInt,
                                            (x, y) => x.ValueAsInt = y,
                                            CharacterObject,
                                            nameof(Character.CurrentLiftCarryHits),
                                            (x, y) => x.ValueChanged += y,
                                            x => x.GetCurrentLiftCarryHitsAsync(GenericToken),
                                            (x, y) => x.SetCurrentLiftCarryHitsAsync(y, GenericToken), 250, GenericToken,
                                            GenericToken).ConfigureAwait(false);

                                        await lblMovement.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayMovement),
                                                x => x.GetDisplayMovementAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblSwim.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplaySwim),
                                                x => x.GetDisplaySwimAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblFly.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.DisplayFly),
                                                x => x.GetDisplayFlyAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblStreetCredTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                                nameof(Character.TotalStreetCred),
                                                x => x.GetTotalStreetCredAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblStreetCredTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.StreetCredTooltip),
                                                x => x.GetStreetCredTooltipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblNotorietyTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                                nameof(Character.TotalNotoriety),
                                                x => x.GetTotalNotorietyAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblNotorietyTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.NotorietyTooltip),
                                                x => x.GetNotorietyTooltipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblPublicAwareTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                                nameof(Character.TotalPublicAwareness),
                                                x => x.GetTotalPublicAwarenessAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblPublicAwareTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.PublicAwarenessTooltip),
                                                x => x.GetPublicAwarenessTooltipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblAstralReputationTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.TotalAstralReputation),
                                                x => x.GetTotalAstralReputationAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblAstralReputationTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.AstralReputationTooltip),
                                                x => x.GetAstralReputationTooltipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblWildReputationTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.TotalWildReputation),
                                                x => x.GetTotalWildReputationAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblWildReputationTotal.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.WildReputationTooltip),
                                                x => x.GetWildReputationTooltipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblMentorSpirit.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.FirstMentorSpiritDisplayName),
                                                x => x.GetFirstMentorSpiritDisplayNameAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMentorSpiritInformation.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.FirstMentorSpiritDisplayInformation),
                                            x => x.GetFirstMentorSpiritDisplayInformationAsync(GenericToken),
                                            GenericToken).ConfigureAwait(false);
                                        await lblParagon.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.FirstMentorSpiritDisplayName),
                                                x => x.GetFirstMentorSpiritDisplayNameAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblParagonInformation.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y, CharacterObject,
                                            nameof(Character.FirstMentorSpiritDisplayInformation),
                                            x => x.GetFirstMentorSpiritDisplayInformationAsync(GenericToken),
                                            GenericToken).ConfigureAwait(false);

                                        await lblSurprise.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.SurpriseToolTip),
                                                x => x.GetSurpriseToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblSurprise.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                            nameof(Character.Surprise),
                                            x => x.GetSurpriseAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblComposure.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.ComposureToolTip),
                                                x => x.GetComposureToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblComposure.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                            nameof(Character.Composure),
                                            x => x.GetComposureAsync(GenericToken), GenericToken).ConfigureAwait(false);
                                        await lblJudgeIntentions.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.JudgeIntentionsToolTip),
                                                x => x.GetJudgeIntentionsToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblJudgeIntentions.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.JudgeIntentions),
                                                x => x.GetJudgeIntentionsAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblLiftCarry.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.LiftAndCarryToolTip),
                                                x => x.GetLiftAndCarryToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblLiftCarry.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo),
                                                CharacterObject,
                                                nameof(Character.LiftAndCarry),
                                                x => x.GetLiftAndCarryAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMemory.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.MemoryToolTip),
                                                x => x.GetMemoryToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMemory.RegisterOneWayAsyncDataBindingAsync(
                                            (x, y) => x.Text = y.ToString(GlobalSettings.CultureInfo), CharacterObject,
                                            nameof(Character.Memory),
                                            x => x.GetMemoryAsync(GenericToken), GenericToken).ConfigureAwait(false);

                                        await lblLiftCarryLimits.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.LiftAndCarryLimits),
                                                x => x.GetLiftAndCarryLimitsAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await lblINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.InitiativeToolTip),
                                                x => x.GetInitiativeToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.Initiative),
                                                x => x.GetInitiativeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblAstralINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.AstralInitiativeToolTip),
                                                x => x.GetAstralInitiativeToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblAstralINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.AstralInitiative),
                                                x => x.GetAstralInitiativeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.MatrixInitiativeToolTip),
                                                x => x.GetMatrixInitiativeToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.MatrixInitiative),
                                                x => x.GetMatrixInitiativeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINICold.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.MatrixInitiativeColdToolTip),
                                                x => x.GetMatrixInitiativeColdToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINICold.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.MatrixInitiativeCold),
                                                x => x.GetMatrixInitiativeColdAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINIHot.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.MatrixInitiativeHotToolTip),
                                                x => x.GetMatrixInitiativeHotToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblMatrixINIHot.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.MatrixInitiativeHot),
                                                x => x.GetMatrixInitiativeHotAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblRiggingINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.ToolTipText = y, CharacterObject,
                                                nameof(Character.InitiativeToolTip),
                                                x => x.GetInitiativeToolTipAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                        await lblRiggingINI.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Text = y, CharacterObject,
                                                nameof(Character.Initiative),
                                                x => x.GetInitiativeAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    using (Timekeeper.StartSyncron(
                                               "load_frm_create_vehicle", op_load_frm_create))
                                    {
                                        // Populate vehicle weapon fire mode list.
                                        using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(Utils.ListItemListPool,
                                                   out List<ListItem> lstFireModes))
                                        {
                                            foreach (FiringMode mode in
                                                     Enum.GetValues(typeof(FiringMode)))
                                            {
                                                if (mode == FiringMode.NumFiringModes)
                                                    continue;
                                                lstFireModes.Add(new ListItem(mode,
                                                    await LanguageManager
                                                        .GetStringAsync("Enum_" + mode, token: GenericToken)
                                                        .ConfigureAwait(false)));
                                            }

                                            await cboVehicleWeaponFiringMode.PopulateWithListItemsAsync(
                                                lstFireModes, GenericToken).ConfigureAwait(false);
                                        }
                                    }

                                    using (Timekeeper.StartSyncron("load_frm_create_miscstuff",
                                               op_load_frm_create))
                                    {
                                        await SetTooltips(GenericToken).ConfigureAwait(false);
                                        await RefreshAttributes(pnlAttributes, null, lblAttributes,
                                            await lblAttributesBase
                                                .DoThreadSafeFuncAsync(x => x.PreferredWidth, GenericToken)
                                                .ConfigureAwait(false),
                                            await lblAttributesKarma.DoThreadSafeFuncAsync(x =>
                                                    x.PreferredWidth, GenericToken)
                                                .ConfigureAwait(false),
                                            await lblAttributesAug.DoThreadSafeFuncAsync(
                                                    x => x.PreferredWidth, GenericToken)
                                                .ConfigureAwait(false),
                                            await lblAttributesMetatype.DoThreadSafeFuncAsync(
                                                    x => x.PreferredWidth, GenericToken)
                                                .ConfigureAwait(false),
                                            GenericToken).ConfigureAwait(false);

                                        CharacterObject.AttributeSection.Attributes.BeforeClearCollectionChangedAsync
                                            += AttributeBeforeClearCollectionChanged;
                                        CharacterObject.AttributeSection.Attributes.CollectionChangedAsync
                                            += AttributeCollectionChanged;

                                        await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
                                        await ProcessMugshot(GenericToken).ConfigureAwait(false);

                                        // Stupid hack to get the MDI icon to show up properly.
                                        await this.DoThreadSafeFuncAsync(x => x.Icon = x.Icon.Clone() as Icon,
                                                GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    using (CustomActivity op_load_frm_create_longloads
                                           = Timekeeper.StartSyncron("load_frm_create_longloads",
                                               op_load_frm_create))
                                    {
                                        using (Timekeeper.StartSyncron(
                                                   "load_frm_create_Run through all appropriate property changers",
                                                   op_load_frm_create_longloads))
                                        {
                                            // Run through all appropriate property changers
                                            await OnCharacterPropertyChanged(this,
                                                new MultiplePropertiesChangedEventArgs(typeof(Character).GetProperties()
                                                    .Select(x => x.Name)), GenericToken).ConfigureAwait(false);
                                        }

                                        using (Timekeeper.StartSyncron(
                                                   "load_frm_create_tabPowerUc.RealLoad()",
                                                   op_load_frm_create_longloads))
                                        {
                                            await tabPowerUc.RealLoad(GenericToken, GenericToken).ConfigureAwait(false);
                                        }

                                        using (Timekeeper.StartSyncron(
                                                   "load_frm_create_tabSkillsUc.RealLoad()",
                                                   op_load_frm_create_longloads))
                                        {
                                            await tabSkillsUc.RealLoad(GenericToken, GenericToken)
                                                .ConfigureAwait(false);
                                        }
                                    }

                                    using (Timekeeper.StartSyncron(
                                               "load_frm_create_refresh", op_load_frm_create))
                                    {
                                        await cmdAddMetamagic.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Enabled = y, CharacterObject,
                                                nameof(Character.AddInitiationsAllowed),
                                                x => x.GetAddInitiationsAllowedAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        await cmdLifeModule.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.EffectiveBuildMethodIsLifeModule),
                                                x => x.GetEffectiveBuildMethodIsLifeModuleAsync(GenericToken),
                                                GenericToken)
                                            .ConfigureAwait(false);
                                        await btnCreateBackstory.RegisterOneWayAsyncDataBindingAsync(
                                                (x, y) => x.Visible = y, CharacterObject,
                                                nameof(Character.EnableAutomaticStoryButton),
                                                x => x.GetEnableAutomaticStoryButtonAsync(GenericToken), GenericToken)
                                            .ConfigureAwait(false);

                                        if (!await CharacterObjectSettings.BookEnabledAsync("RF", GenericToken)
                                                .ConfigureAwait(false))
                                        {
                                            await cmdAddLifestyle.DoThreadSafeAsync(
                                                x => x.SplitMenuStrip = null, GenericToken).ConfigureAwait(false);
                                        }

                                        if (!await CharacterObjectSettings.BookEnabledAsync("FA", GenericToken)
                                                .ConfigureAwait(false))
                                        {
                                            await lblWildReputation
                                                .DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                                .ConfigureAwait(false);
                                            await lblWildReputationTotal.DoThreadSafeAsync(
                                                x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                            if (!await CharacterObjectSettings.BookEnabledAsync("SG", GenericToken)
                                                    .ConfigureAwait(false))
                                            {
                                                await lblAstralReputation.DoThreadSafeAsync(
                                                    x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                                await lblAstralReputationTotal.DoThreadSafeAsync(
                                                    x => x.Visible = false, GenericToken).ConfigureAwait(false);
                                            }
                                        }

                                        if (!await CharacterObjectSettings.GetEnableEnemyTrackingAsync(GenericToken).ConfigureAwait(false))
                                        {
                                            await tabPeople.DoThreadSafeAsync(
                                                x => x.TabPages.Remove(tabEnemies), GenericToken).ConfigureAwait(false);
                                            await lblEnemiesBP.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                                .ConfigureAwait(false);
                                            await lblBuildEnemies
                                                .DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                                .ConfigureAwait(false);
                                        }

                                        await RefreshQualities(treQualities, cmsQuality, _fntNormal, _fntStrikeout,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshSpirits(panSpirits, panSprites, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm,
                                                cmsInitiationNotes, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshPowerCollectionListChanged(
                                                treMetamagic, cmsMetamagic, cmsInitiationNotes, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshCritterPowers(treCritterPowers, cmsCritterPowers,
                                                token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshContacts(panContacts, panEnemies, panPets, token: GenericToken)
                                            .ConfigureAwait(false);

                                        await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod,
                                            cmsArmorGear,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshGears(treGear, cmsGearLocation, cmsGear, cmsGearAllowRename,
                                            await chkCommlinks.DoThreadSafeFuncAsync(
                                                x => x.Checked, GenericToken).ConfigureAwait(false), false,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshFociFromGear(treFoci, null, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon,
                                                cmsWeaponAccessory,
                                                cmsWeaponAccessoryGear, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle,
                                            cmsVehicleWeapon,
                                            cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear,
                                            cmsVehicleGear,
                                            cmsWeaponMount,
                                            cmsVehicleCyberware, cmsVehicleCyberwareGear,
                                            token: GenericToken).ConfigureAwait(false);
                                        await RefreshDrugs(treCustomDrugs, token: GenericToken).ConfigureAwait(false);
                                    }

                                    using (Timekeeper.StartSyncron(
                                               "load_frm_create_sortAndCallback", op_load_frm_create))
                                    {
                                        await treWeapons.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treArmor.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treGear.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treLifestyles.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treCustomDrugs.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treCyberware.DoThreadSafeAsync(x => x.SortCustomOrder(true), GenericToken)
                                            .ConfigureAwait(false);
                                        await treVehicles.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);
                                        await treCritterPowers.DoThreadSafeAsync(x => x.SortCustomOrder(), GenericToken)
                                            .ConfigureAwait(false);

                                        // Set up events linked to character changes
                                        GlobalSettings.ClipboardChangedAsync += DoRefreshPasteStatus;
                                        CharacterObject.MultiplePropertiesChangedAsync += OnCharacterPropertyChanged;
                                        CharacterObject.SettingsMultiplePropertiesChangedAsync += OnCharacterSettingsPropertyChanged;
                                        CharacterObject.AttributeSection.PropertyChangedAsync += MakeDirtyWithCharacterUpdate;
                                        CharacterObject.Spells.CollectionChangedAsync += SpellCollectionChanged;
                                        CharacterObject.ComplexForms.CollectionChangedAsync +=
                                            ComplexFormCollectionChanged;
                                        CharacterObject.Arts.CollectionChangedAsync += ArtCollectionChanged;
                                        CharacterObject.Enhancements.CollectionChangedAsync +=
                                            EnhancementCollectionChanged;
                                        CharacterObject.Metamagics.CollectionChangedAsync += MetamagicCollectionChanged;
                                        CharacterObject.InitiationGrades.CollectionChangedAsync
                                            += InitiationGradeCollectionChanged;
                                        CharacterObject.Powers.ListChangedAsync += PowersListChanged;
                                        CharacterObject.Powers.BeforeRemoveAsync += PowersBeforeRemove;
                                        CharacterObject.AIPrograms.CollectionChangedAsync += AIProgramCollectionChanged;
                                        CharacterObject.CritterPowers.CollectionChangedAsync +=
                                            CritterPowerCollectionChanged;
                                        CharacterObject.Qualities.CollectionChangedAsync += QualityCollectionChanged;
                                        CharacterObject.MartialArts.BeforeClearCollectionChangedAsync +=
                                            MartialArtBeforeClearCollectionChanged;
                                        CharacterObject.MartialArts.CollectionChangedAsync +=
                                            MartialArtCollectionChanged;
                                        CharacterObject.Lifestyles.CollectionChangedAsync +=
                                            LifestylesCollectionChanged;
                                        CharacterObject.Contacts.BeforeClearCollectionChangedAsync +=
                                            ContactBeforeClearCollectionChanged;
                                        CharacterObject.Contacts.CollectionChangedAsync += ContactCollectionChanged;
                                        CharacterObject.Spirits.BeforeClearCollectionChangedAsync +=
                                            SpiritBeforeClearCollectionChanged;
                                        CharacterObject.Spirits.CollectionChangedAsync += SpiritCollectionChanged;
                                        CharacterObject.Armor.BeforeClearCollectionChangedAsync +=
                                            ArmorBeforeClearCollectionChanged;
                                        CharacterObject.Armor.CollectionChangedAsync += ArmorCollectionChanged;
                                        CharacterObject.ArmorLocations.CollectionChangedAsync +=
                                            ArmorLocationCollectionChanged;
                                        CharacterObject.Weapons.BeforeClearCollectionChangedAsync +=
                                            WeaponBeforeClearCollectionChanged;
                                        CharacterObject.Weapons.CollectionChangedAsync += WeaponCollectionChanged;
                                        CharacterObject.WeaponLocations.CollectionChangedAsync
                                            += WeaponLocationCollectionChanged;
                                        CharacterObject.Gear.BeforeClearCollectionChangedAsync +=
                                            GearBeforeClearCollectionChanged;
                                        CharacterObject.Gear.CollectionChangedAsync += GearCollectionChanged;
                                        CharacterObject.GearLocations.CollectionChangedAsync +=
                                            GearLocationCollectionChanged;
                                        CharacterObject.Drugs.CollectionChangedAsync += DrugCollectionChanged;
                                        CharacterObject.Cyberware.BeforeClearCollectionChangedAsync +=
                                            CyberwareBeforeClearCollectionChanged;
                                        CharacterObject.Cyberware.CollectionChangedAsync += CyberwareCollectionChanged;
                                        CharacterObject.Vehicles.BeforeClearCollectionChangedAsync +=
                                            VehicleBeforeClearCollectionChanged;
                                        CharacterObject.Vehicles.CollectionChangedAsync += VehicleCollectionChanged;
                                        CharacterObject.VehicleLocations.CollectionChangedAsync
                                            += VehicleLocationCollectionChanged;

                                        SetupCommonCollectionDatabindings(true);
                                    }
                                }
                                finally
                                {
                                    IsLoading = false;
                                }

                                using (Timekeeper.StartSyncron("load_frm_create_finish", op_load_frm_create))
                                {
                                    // Directly awaiting here so that we can properly unset the dirty flag after the update
                                    await RequestAndProcessCharacterUpdate(GenericToken).ConfigureAwait(false);
                                    
                                    // Update tradition UI after character loading is complete
                                    Tradition objTradition = await CharacterObject.GetMagicTraditionAsync(GenericToken).ConfigureAwait(false);
                                    if (objTradition != null && objTradition.IsCustomTradition)
                                    {
                                        // Just update UI visibility without recreating the tradition
                                        await lblTraditionName.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await txtTraditionName.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                                        await cboSpiritCombat.DoThreadSafeAsync(x => { x.Enabled = true; x.Visible = true; }, GenericToken).ConfigureAwait(false);
                                        await cboSpiritDetection.DoThreadSafeAsync(x => { x.Enabled = true; x.Visible = true; }, GenericToken).ConfigureAwait(false);
                                        await cboSpiritHealth.DoThreadSafeAsync(x => { x.Enabled = true; x.Visible = true; }, GenericToken).ConfigureAwait(false);
                                        await cboSpiritIllusion.DoThreadSafeAsync(x => { x.Enabled = true; x.Visible = true; }, GenericToken).ConfigureAwait(false);
                                        await cboSpiritManipulation.DoThreadSafeAsync(x => { x.Enabled = true; x.Visible = true; }, GenericToken).ConfigureAwait(false);
                                    }
                                    
                                    // Clear the Dirty flag which gets set when creating a new Character.
                                    if (!await CharacterObject.GetLoadAsDirtyAsync(GenericToken).ConfigureAwait(false))
                                        IsDirty = false;

                                    await Program.PluginLoader.CallPlugins(this, op_load_frm_create, GenericToken)
                                        .ConfigureAwait(false);
                                }

                                ConcurrentBag<string> lstInternalIdsNeedingReapplyImprovements
                                    = await CharacterObject.TakeInternalIdsNeedingReapplyImprovementsAsync(GenericToken)
                                        .ConfigureAwait(false);
                                if (lstInternalIdsNeedingReapplyImprovements?.Count > 0 && !Utils.IsUnitTest)
                                {
                                    string strListFriendlyNames;
                                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdListFriendlyNames))
                                    {
                                        foreach (IHasInternalId objSource in await CharacterObject.GetItemsByInternalIdsAsync(lstInternalIdsNeedingReapplyImprovements, true, GenericToken).ConfigureAwait(false))
                                        {
                                            string strToAdd;
                                            if (objSource is IHasCustomName objCustomNameItem)
                                                strToAdd = objCustomNameItem.CustomName;
                                            else if (objSource is Improvement objImprovement)
                                                strToAdd = await CharacterObject.GetObjectNameAsync(objImprovement, token: GenericToken).ConfigureAwait(false);
                                            else if (objSource is IHasName objNamedItem)
                                                strToAdd = await objNamedItem.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                                            else
                                                strToAdd = objSource.InternalId;
                                            sbdListFriendlyNames.AppendLine(strToAdd);
                                        }
                                        strListFriendlyNames = sbdListFriendlyNames.ToString();
                                    }
                                    string strDescription = await LanguageManager.GetStringAsync("Message_ImprovementLoadError", token: GenericToken).ConfigureAwait(false);
                                    if (!string.IsNullOrEmpty(strListFriendlyNames))
                                    {
                                        strDescription += await LanguageManager.GetStringAsync("Message_ImprovementLoadErrorPart2", token: GenericToken).ConfigureAwait(false) + strListFriendlyNames;
                                    }
                                    if (await Program.ShowScrollableMessageBoxAsync(
                                        this, strDescription,
                                        await LanguageManager.GetStringAsync("MessageTitle_ImprovementLoadError", token: GenericToken).ConfigureAwait(false),
                                        MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false) == DialogResult.Yes)
                                    {
                                        await DoReapplyImprovements(lstInternalIdsNeedingReapplyImprovements,
                                            GenericToken).ConfigureAwait(false);
                                    }
                                }

                                // If we end up with a character who is flagged as dirty after loading, immediately autosave them
                                if (IsDirty)
                                    tskAutosave = AutoSaveCharacter(GenericToken);

                                op_load_frm_create.SetSuccess(true);
                            }
                            catch (OperationCanceledException)
                            {
                                //swallow this
                                op_load_frm_create?.SetSuccess(false);
                            }
                            catch (Exception ex)
                            {
                                ex = ex.Demystify();
                                if (op_load_frm_create != null)
                                {
                                    op_load_frm_create.SetSuccess(false);
                                    op_load_frm_create.MyTelemetryClient.TrackException(ex);
                                }

                                Log.Error(ex);
                                throw;
                            }
                            finally
                            {
                                await this.DoThreadSafeAsync(x => x.ResumeLayout(true), GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }

                        await tskAutosave.ConfigureAwait(false);
                    }
                    finally
                    {
                        await objCursorWait.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsFinishedInitializing = true;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private DebuggableSemaphoreSlim _objFormClosingSemaphore = new DebuggableSemaphoreSlim();

        private async void CharacterCreate_FormClosing(object sender, FormClosingEventArgs e)
        {
            try
            {
                DebuggableSemaphoreSlim objSemaphore = _objFormClosingSemaphore;
                if (objSemaphore?.IsDisposed != false)
                    return;
                await objSemaphore.WaitAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    Form frmSender = sender as Form;
                    if (frmSender != null)
                    {
                        e.Cancel = true; // Always have to cancel because of issues with async FormClosing events
                        await frmSender.DoThreadSafeAsync(x => x.Enabled = false, GenericToken).ConfigureAwait(false); // Disable the form to make sure we can't interract with it anymore
                    }

                    try
                    {
                        CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                        try
                        {
                            bool blnDoClose = false;
                            IsLoading = true;
                            try
                            {
                                // Caller returns and form stays open (weird async FormClosing event issue workaround)
                                await Task.Yield();

                                // If there are unsaved changes to the character, as the user if they would like to save their changes.
                                if (IsDirty && !Utils.IsUnitTest)
                                {
                                    string strCharacterName = await CharacterObject.GetCharacterNameAsync(GenericToken)
                                        .ConfigureAwait(false);
                                    DialogResult eResult = await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            string.Format(GlobalSettings.CultureInfo,
                                                await LanguageManager
                                                    .GetStringAsync("Message_UnsavedChanges", token: GenericToken)
                                                    .ConfigureAwait(false),
                                                strCharacterName),
                                            await LanguageManager.GetStringAsync("MessageTitle_UnsavedChanges",
                                                    token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.YesNoCancel, MessageBoxIcon.Question, token: GenericToken)
                                        .ConfigureAwait(false);
                                    switch (eResult)
                                    {
                                        case DialogResult.Yes:
                                            {
                                                // Attempt to save the Character. If the user cancels the Save As dialogue that may open, cancel the closing event so that changes are not lost.
                                                bool blnResult = await SaveCharacter(token: GenericToken).ConfigureAwait(false);
                                                if (!blnResult)
                                                    return;
                                                break;
                                            }
                                        case DialogResult.Cancel:
                                            return;
                                    }
                                }

                                await this.DoThreadSafeAsync(x => x.UseWaitCursor = true, GenericToken).ConfigureAwait(false);
                                CancelGenericToken();

                                // Unsubscribe from events.
                                GlobalSettings.ClipboardChangedAsync -= DoRefreshPasteStatus;
                                CharacterObject.MultiplePropertiesChangedAsync -= OnCharacterPropertyChanged;
                                CharacterObject.SettingsMultiplePropertiesChangedAsync -= OnCharacterSettingsPropertyChanged;
                                CharacterObject.AttributeSection.PropertyChangedAsync -= MakeDirtyWithCharacterUpdate;
                                CharacterObject.AttributeSection.Attributes.BeforeClearCollectionChangedAsync
                                    -= AttributeBeforeClearCollectionChanged;
                                CharacterObject.AttributeSection.Attributes.CollectionChangedAsync -=
                                    AttributeCollectionChanged;
                                CharacterObject.Spells.CollectionChangedAsync -= SpellCollectionChanged;
                                CharacterObject.ComplexForms.CollectionChangedAsync -= ComplexFormCollectionChanged;
                                CharacterObject.Arts.CollectionChangedAsync -= ArtCollectionChanged;
                                CharacterObject.Enhancements.CollectionChangedAsync -= EnhancementCollectionChanged;
                                CharacterObject.Metamagics.CollectionChangedAsync -= MetamagicCollectionChanged;
                                CharacterObject.InitiationGrades.CollectionChangedAsync -= InitiationGradeCollectionChanged;
                                CharacterObject.Powers.ListChangedAsync -= PowersListChanged;
                                CharacterObject.Powers.BeforeRemoveAsync -= PowersBeforeRemove;
                                CharacterObject.AIPrograms.CollectionChangedAsync -= AIProgramCollectionChanged;
                                CharacterObject.CritterPowers.CollectionChangedAsync -= CritterPowerCollectionChanged;
                                CharacterObject.Qualities.CollectionChangedAsync -= QualityCollectionChanged;
                                CharacterObject.MartialArts.BeforeClearCollectionChangedAsync -=
                                    MartialArtBeforeClearCollectionChanged;
                                CharacterObject.MartialArts.CollectionChangedAsync -= MartialArtCollectionChanged;
                                CharacterObject.Lifestyles.CollectionChangedAsync -= LifestylesCollectionChanged;
                                CharacterObject.Contacts.BeforeClearCollectionChangedAsync -=
                                    ContactBeforeClearCollectionChanged;
                                CharacterObject.Contacts.CollectionChangedAsync -= ContactCollectionChanged;
                                CharacterObject.Spirits.BeforeClearCollectionChangedAsync -= SpiritBeforeClearCollectionChanged;
                                CharacterObject.Spirits.CollectionChangedAsync -= SpiritCollectionChanged;
                                CharacterObject.Armor.BeforeClearCollectionChangedAsync -=
                                    ArmorBeforeClearCollectionChanged;
                                CharacterObject.Armor.CollectionChangedAsync -= ArmorCollectionChanged;
                                CharacterObject.ArmorLocations.CollectionChangedAsync -= ArmorLocationCollectionChanged;
                                CharacterObject.Weapons.BeforeClearCollectionChangedAsync -=
                                    WeaponBeforeClearCollectionChanged;
                                CharacterObject.Weapons.CollectionChangedAsync -= WeaponCollectionChanged;
                                CharacterObject.Drugs.CollectionChangedAsync -= DrugCollectionChanged;
                                CharacterObject.WeaponLocations.CollectionChangedAsync -= WeaponLocationCollectionChanged;
                                CharacterObject.Gear.BeforeClearCollectionChangedAsync -=
                                    GearBeforeClearCollectionChanged;
                                CharacterObject.Gear.CollectionChangedAsync -= GearCollectionChanged;
                                CharacterObject.GearLocations.CollectionChangedAsync -= GearLocationCollectionChanged;
                                CharacterObject.Cyberware.BeforeClearCollectionChangedAsync -=
                                    CyberwareBeforeClearCollectionChanged;
                                CharacterObject.Cyberware.CollectionChangedAsync -= CyberwareCollectionChanged;
                                CharacterObject.Vehicles.BeforeClearCollectionChangedAsync -=
                                    VehicleBeforeClearCollectionChanged;
                                CharacterObject.Vehicles.CollectionChangedAsync -= VehicleCollectionChanged;
                                CharacterObject.VehicleLocations.CollectionChangedAsync -= VehicleLocationCollectionChanged;

                                SetupCommonCollectionDatabindings(false);

                                // Clear the mugshot image so that we don't get crashes from disposal ordering (image can get disposed before its picturebox does)
                                await picMugshot.DoThreadSafeAsync(x => x.Image = null, CancellationToken.None).ConfigureAwait(false);

                                await Task.WhenAll(RefreshAttributesClearBindings(pnlAttributes, CancellationToken.None),
                                    RefreshMartialArtsClearBindings(treMartialArts, CancellationToken.None),
                                    RefreshArmorClearBindings(treArmor, CancellationToken.None),
                                    RefreshWeaponsClearBindings(treWeapons, CancellationToken.None),
                                    RefreshGearsClearBindings(treGear, CancellationToken.None),
                                    RefreshCyberwareClearBindings(treCyberware, CancellationToken.None),
                                    RefreshVehiclesClearBindings(treVehicles, CancellationToken.None),
                                    RefreshContactsClearBindings(panContacts, panEnemies, panPets,
                                        CancellationToken.None),
                                    RefreshSpiritsClearBindings(panSpirits, panSprites,
                                        CancellationToken.None)).ConfigureAwait(false);
                                try
                                {
                                    await UpdateCharacterInfoTask.ConfigureAwait(false);
                                }
                                catch (OperationCanceledException)
                                {
                                    //swallow this
                                }

                                blnDoClose = true;
                            }
                            finally
                            {
                                if (!blnDoClose)
                                    IsLoading = false;
                            }
                        }
                        finally
                        {
                            await objCursorWait.DisposeAsync().ConfigureAwait(false);
                        }

                        // Now we close the original caller (weird async FormClosing event issue workaround)
                        if (frmSender != null)
                        {
                            await frmSender.DoThreadSafeAsync(x =>
                            {
                                x.FormClosing -= CharacterCreate_FormClosing;
                                try
                                {
                                    x.Close();
                                }
                                catch
                                {
                                    // Ignore disposal errors if we are quitting the program anyway
                                    if (Program.MainForm.IsNullOrDisposed() || Program.MainForm.IsClosing)
                                        return;
                                    throw;
                                }
                            }, CancellationToken.None).ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        if (frmSender != null)
                            await frmSender.DoThreadSafeAsync(x => x.Enabled = true, CancellationToken.None).ConfigureAwait(false); // Doesn't matter if we're closed
                    }
                }
                finally
                {
                    if (!objSemaphore.IsDisposed)
                        objSemaphore.Release();
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private void CharacterCreate_Activated(object sender, EventArgs e)
        {
            ToolStripManager.Merge(tsMain, Program.MainForm.MainToolStrip);
        }

        private void CharacterCreate_Deactivate(object sender, EventArgs e)
        {
            ToolStripManager.RevertMerge(Program.MainForm.MainToolStrip, tsMain);
        }

        #endregion Form Events

        #region Character Events

        private async Task RefreshNuyenDisplays(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            (decimal decNuyen, decimal decStolenNuyen) = await CharacterObject.CalculateNuyenCreateModeAsync(token).ConfigureAwait(false);
            string strDisplayNuyen =
                decNuyen.ToString(await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false), GlobalSettings.CultureInfo) +
                await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
            await StatusStrip.DoThreadSafeAsync(() => tslNuyenRemaining.Text = strDisplayNuyen,
                token).ConfigureAwait(false);
            await lblRemainingNuyen.DoThreadSafeAsync(x => x.Text = strDisplayNuyen,
                token).ConfigureAwait(false);
            if (await CharacterObject.GetHasStolenNuyenAsync(token).ConfigureAwait(false))
            {
                string strDisplayStolenNuyen =
                    decStolenNuyen.ToString(await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false), GlobalSettings.CultureInfo) +
                    await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                await lblStolenNuyen.DoThreadSafeAsync(x => x.Text = strDisplayStolenNuyen, token: token).ConfigureAwait(false);
            }
        }

        private async Task OnCharacterPropertyChanged(object sender, MultiplePropertiesChangedEventArgs e,
            CancellationToken token = default)
        {
            if (_blnReapplyImprovements)
                return;
            try
            {
                token.ThrowIfCancellationRequested();
                bool blnDoRefresh = false;
                await SetDirty(true, token).ConfigureAwait(false);
                if (e.PropertyNames.Contains(nameof(Character.CharacterName)))
                {
                    await UpdateWindowTitleAsync(false, token).ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.DisplayEssence)))
                {
                    string strDisplayEssence =
                        await CharacterObject.GetDisplayEssenceAsync(token).ConfigureAwait(false);
                    await StatusStrip.DoThreadSafeAsync(() => tslEssence.Text = strDisplayEssence,
                        token).ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.DisplayTotalCarriedWeight)))
                {
                    string strDisplayTotalCarriedWeight = await CharacterObject.GetDisplayTotalCarriedWeightAsync(token)
                        .ConfigureAwait(false);
                    await StatusStrip.DoThreadSafeAsync(
                            () => tslCarriedWeight.Text = strDisplayTotalCarriedWeight,
                            token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.Encumbrance)))
                {
                    bool blnHasEncumbrance = await CharacterObject.GetEncumbranceAsync(token).ConfigureAwait(false) > 0;
                    await StatusStrip.DoThreadSafeAsync(() => tslCarriedWeight.ForeColor
                            = blnHasEncumbrance
                                ? ColorManager.ErrorColor
                                : ColorManager.ControlText, token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.Source)) ||
                    e.PropertyNames.Contains(nameof(Character.Page)))
                {
                    await CharacterObject.SetSourceDetailAsync(lblMetatypeSource, token)
                        .ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.MAGEnabled)))
                {
                    if (await CharacterObject.GetMAGEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabInitiation))
                                x.TabPages.Insert(3, tabInitiation);
                        }, token).ConfigureAwait(false);

                        await UpdateInitiationCost(token).ConfigureAwait(false);

                        string strTemp = await LanguageManager.GetStringAsync("Tab_Initiation", token: token)
                            .ConfigureAwait(false);
                        await tabInitiation.DoThreadSafeAsync(x => x.Text = strTemp, token)
                            .ConfigureAwait(false);
                        string strTemp2 = await LanguageManager
                            .GetStringAsync("Button_AddMetamagic", token: token)
                            .ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(() => tsMetamagicAddMetamagic.Text = strTemp2,
                            token).ConfigureAwait(false);
                        string strTemp3 = await LanguageManager
                            .GetStringAsync("Button_AddInitiateGrade", token: token)
                            .ConfigureAwait(false);
                        await cmdAddMetamagic.DoThreadSafeAsync(x => x.Text = strTemp3, token)
                            .ConfigureAwait(false);
                        string strTemp4 = await LanguageManager
                            .GetStringAsync("Button_RemoveInitiateGrade", token: token)
                            .ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x => x.Text = strTemp4, token)
                            .ConfigureAwait(false);
                        string strTemp5 = await LanguageManager
                            .GetStringAsync("String_InitiationType", token: token)
                            .ConfigureAwait(false);
                        await gpbInitiationType.DoThreadSafeAsync(x => x.Text = strTemp5, token)
                            .ConfigureAwait(false);
                        string strTemp6 = await LanguageManager
                            .GetStringAsync("String_InitiationGroup", token: token)
                            .ConfigureAwait(false);
                        await gpbInitiationGroup.DoThreadSafeAsync(x => x.Text = strTemp6, token)
                            .ConfigureAwait(false);
                        string strText1 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_InitiationOrdeal", token: token).ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaMAGInitiationOrdealPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        await chkInitiationOrdeal.DoThreadSafeAsync(x => x.Text = strText1, token)
                            .ConfigureAwait(false);
                        string strText2 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_InitiationGroup", token: token).ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaMAGInitiationGroupPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        await chkInitiationGroup.DoThreadSafeAsync(x => x.Text = strText2, token)
                            .ConfigureAwait(false);
                        string strText3 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_InitiationSchooling", token: token)
                                .ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaMAGInitiationSchoolingPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        await chkInitiationSchooling.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText3;
                            x.Enabled = true;
                        }, token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(() =>
                        {
                            tsMetamagicAddArt.Visible = true;
                            tsMetamagicAddEnchantment.Visible = true;
                            tsMetamagicAddEnhancement.Visible = true;
                            tsMetamagicAddRitual.Visible = true;
                        }, token).ConfigureAwait(false);
                        int intGrade = await CharacterObject.GetInitiateGradeAsync(token).ConfigureAwait(false);
                        string strInitTip = string.Format(GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Tip_ImproveInitiateGrade", token: token).ConfigureAwait(false),
                            intGrade + 1,
                            await CharacterObjectSettings.GetKarmaInitiationFlatAsync(token).ConfigureAwait(false) + (intGrade + 1) *
                            await CharacterObjectSettings.GetKarmaInitiationAsync(token).ConfigureAwait(false));
                        await cmdAddMetamagic.SetToolTipTextAsync(strInitTip, token).ConfigureAwait(false);
                        string strTemp7 = await LanguageManager
                            .GetStringAsync("Checkbox_JoinedGroup", token: token)
                            .ConfigureAwait(false);
                        await chkJoinGroup.DoThreadSafeAsync(x => x.Text = strTemp7, token)
                            .ConfigureAwait(false);

                        await gpbGearBondedFoci
                            .DoThreadSafeAsync(x => x.Visible = true, token)
                            .ConfigureAwait(false);
                        await lblAstralINI.DoThreadSafeAsync(x => x.Visible = true, token)
                            .ConfigureAwait(false);
                    }
                    else
                    {
                        if (!await CharacterObject.GetRESEnabledAsync(token).ConfigureAwait(false))
                            await tabCharacterTabs
                                .DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation), token)
                                .ConfigureAwait(false);

                        await gpbGearBondedFoci
                            .DoThreadSafeAsync(x => x.Visible = false, token)
                            .ConfigureAwait(false);
                        await lblAstralINI.DoThreadSafeAsync(x => x.Visible = false, token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.RESEnabled)))
                {
                    // Change to the status of RES being enabled.
                    if (await CharacterObject.GetRESEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabInitiation))
                                x.TabPages.Insert(3, tabInitiation);
                        }, token).ConfigureAwait(false);

                        /*
                        int intEssenceLoss = 0;
                        if (!CharacterObjectSettings.ESSLossReducesMaximumOnly)
                            intEssenceLoss = _objCharacter.EssencePenalty;
                        // If the character options permit submersion in create mode, show the Initiation page.
                        */
                        await UpdateInitiationCost(token).ConfigureAwait(false);

                        string strTemp1 = await LanguageManager
                            .GetStringAsync("Tab_Submersion", token: token)
                            .ConfigureAwait(false);
                        await tabInitiation.DoThreadSafeAsync(x => x.Text = strTemp1, token)
                            .ConfigureAwait(false);
                        string strTemp2 = await LanguageManager
                            .GetStringAsync("Button_AddEcho", token: token)
                            .ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(() => tsMetamagicAddMetamagic.Text = strTemp2,
                            token).ConfigureAwait(false);
                        string strTemp3 = await LanguageManager
                            .GetStringAsync("Button_AddSubmersionGrade", token: token)
                            .ConfigureAwait(false);
                        await cmdAddMetamagic.DoThreadSafeAsync(x => x.Text = strTemp3, token)
                            .ConfigureAwait(false);
                        string strTemp4 = await LanguageManager
                            .GetStringAsync("Button_RemoveSubmersionGrade", token: token)
                            .ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x => x.Text = strTemp4, token)
                            .ConfigureAwait(false);
                        string strTemp5 = await LanguageManager
                            .GetStringAsync("String_SubmersionType", token: token)
                            .ConfigureAwait(false);
                        await gpbInitiationType.DoThreadSafeAsync(x => x.Text = strTemp5, token)
                            .ConfigureAwait(false);
                        string strTemp6 = await LanguageManager
                            .GetStringAsync("String_SubmersionNetwork", token: token)
                            .ConfigureAwait(false);
                        await gpbInitiationGroup.DoThreadSafeAsync(x => x.Text = strTemp6, token)
                            .ConfigureAwait(false);
                        string strText1 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_SubmersionTask", token: token).ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaRESInitiationOrdealPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        await chkInitiationOrdeal.DoThreadSafeAsync(x => x.Text = strText1, token)
                            .ConfigureAwait(false);
                        string strText2 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_NetworkSubmersion", token: token).ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaRESInitiationGroupPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        await chkInitiationGroup.DoThreadSafeAsync(x => x.Text = strText2, token)
                            .ConfigureAwait(false);
                        string strText3 = string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                .GetStringAsync(
                                    "Checkbox_InitiationSchooling", token: token)
                                .ConfigureAwait(false),
                            (await CharacterObjectSettings.GetKarmaRESInitiationSchoolingPercentAsync(token).ConfigureAwait(false))
                                .ToString(
                                    "P", GlobalSettings.CultureInfo));
                        bool blnEnabled = await CharacterObjectSettings.GetAllowTechnomancerSchoolingAsync(token).ConfigureAwait(false);
                        await chkInitiationSchooling.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText3;
                            x.Enabled = blnEnabled;
                        }, token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(() =>
                        {
                            tsMetamagicAddArt.Visible = false;
                            tsMetamagicAddEnchantment.Visible = false;
                            tsMetamagicAddEnhancement.Visible = false;
                            tsMetamagicAddRitual.Visible = false;
                        }, token).ConfigureAwait(false);
                        int intGrade = await CharacterObject.GetSubmersionGradeAsync(token).ConfigureAwait(false);
                        string strInitTip = string.Format(GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Tip_ImproveSubmersionGrade", token: token).ConfigureAwait(false),
                            intGrade + 1,
                            await CharacterObjectSettings.GetKarmaInitiationFlatAsync(token).ConfigureAwait(false) + (intGrade + 1) *
                            await CharacterObjectSettings.GetKarmaInitiationAsync(token).ConfigureAwait(false));
                        await cmdAddMetamagic.SetToolTipTextAsync(strInitTip, token).ConfigureAwait(false);
                        string strTemp7 = await LanguageManager
                            .GetStringAsync("Checkbox_JoinedNetwork", token: token)
                            .ConfigureAwait(false);
                        await chkJoinGroup.DoThreadSafeAsync(x => x.Text = strTemp7, token)
                            .ConfigureAwait(false);
                    }
                    else
                    {
                        if (!await CharacterObject.GetMAGEnabledAsync(token).ConfigureAwait(false))
                            await tabCharacterTabs
                                .DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation), token)
                                .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.Ambidextrous)))
                {
                    using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(Utils.ListItemListPool,
                               out List<ListItem> lstPrimaryArm))
                    {
                        if (await CharacterObject.GetAmbidextrousAsync(token).ConfigureAwait(false))
                        {
                            lstPrimaryArm.Add(new ListItem("Ambidextrous",
                                await LanguageManager.GetStringAsync(
                                    "String_Ambidextrous", token: token).ConfigureAwait(false)));
                            await cboPrimaryArm.DoThreadSafeAsync(x => x.Enabled = false, token)
                                .ConfigureAwait(false);
                        }
                        else
                        {
                            //Create the dropdown for the character's primary arm.
                            lstPrimaryArm.Add(new ListItem(
                                "Left",
                                await LanguageManager.GetStringAsync(
                                    "String_Improvement_SideLeft", token: token).ConfigureAwait(false)));
                            lstPrimaryArm.Add(new ListItem(
                                "Right",
                                await LanguageManager.GetStringAsync(
                                    "String_Improvement_SideRight", token: token).ConfigureAwait(false)));
                            lstPrimaryArm.Sort(CompareListItems.CompareNames);
                            await cboPrimaryArm.DoThreadSafeAsync(x => x.Enabled = true, token)
                                .ConfigureAwait(false);
                        }

                        string strPrimaryArm = await CharacterObject.GetPrimaryArmAsync(token).ConfigureAwait(false);

                        await cboPrimaryArm.PopulateWithListItemsAsync(lstPrimaryArm, token)
                            .ConfigureAwait(false);
                        await cboPrimaryArm.DoThreadSafeAsync(x =>
                        {
                            if (!string.IsNullOrEmpty(strPrimaryArm))
                                x.SelectedValue = strPrimaryArm;
                            if (x.SelectedIndex == -1)
                                x.SelectedIndex = 0;
                        }, token).ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.MagicianEnabled)))
                {
                    // Change to the status of Magician being enabled.
                    bool blnMagicianEnabled =
                        await CharacterObject.GetMagicianEnabledAsync(token).ConfigureAwait(false);
                    if (blnMagicianEnabled || await CharacterObject.GetAdeptEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabMagician))
                                x.TabPages.Insert(3, tabMagician);
                        }, token).ConfigureAwait(false);
                        await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, token)
                            .ConfigureAwait(false);
                    }
                    else
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabMagician), token)
                            .ConfigureAwait(false);
                        await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = false, token)
                            .ConfigureAwait(false);
                    }

                    await cmdAddSpirit.DoThreadSafeAsync(x => x.Visible = blnMagicianEnabled,
                        token).ConfigureAwait(false);
                    await panSpirits.DoThreadSafeAsync(x => x.Visible = blnMagicianEnabled,
                        token).ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.AdeptEnabled)))
                {
                    // Change to the status of Adept being enabled.
                    if (await CharacterObject.GetAdeptEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabMagician))
                                x.TabPages.Insert(3, tabMagician);
                        }, token).ConfigureAwait(false);
                        await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, token)
                            .ConfigureAwait(false);

                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabAdept))
                                x.TabPages.Insert(3, tabAdept);
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        if (!await CharacterObject.GetMagicianEnabledAsync(token).ConfigureAwait(false))
                        {
                            await tabCharacterTabs
                                .DoThreadSafeAsync(x => x.TabPages.Remove(tabMagician), token)
                                .ConfigureAwait(false);
                            await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = false, token)
                                .ConfigureAwait(false);
                        }
                        else
                            await cmdAddSpell.DoThreadSafeAsync(x => x.Enabled = true, token)
                                .ConfigureAwait(false);

                        await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabAdept), token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.TechnomancerEnabled)))
                {
                    // Change to the status of Technomancer being enabled.
                    if (await CharacterObject.GetTechnomancerEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabTechnomancer))
                                x.TabPages.Insert(3, tabTechnomancer);
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await tabCharacterTabs
                            .DoThreadSafeAsync(x => x.TabPages.Remove(tabTechnomancer), token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.AdvancedProgramsEnabled)))
                {
                    // Change to the status of Advanced Programs being enabled.
                    if (await CharacterObject.GetAdvancedProgramsEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabAdvancedPrograms))
                                x.TabPages.Insert(3, tabAdvancedPrograms);
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await tabCharacterTabs
                            .DoThreadSafeAsync(x => x.TabPages.Remove(tabAdvancedPrograms), token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.CritterEnabled)))
                {
                    // Change the status of Critter being enabled.
                    if (await CharacterObject.GetCritterEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabCritter))
                                x.TabPages.Insert(3, tabCritter);
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x => x.TabPages.Remove(tabCritter), token)
                            .ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.AddBiowareEnabled)) && !await CharacterObject.GetAddBiowareEnabledAsync(token).ConfigureAwait(false))
                {
                    foreach (Cyberware objCyberware in await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).DeepWhereAsync(
                                 x => x.GetChildrenAsync(token), async x =>
                                 {
                                     if (x.SourceType != Improvement.ImprovementSource.Bioware)
                                         return false;
                                     Guid guidSourceId = await x.GetSourceIDAsync(token).ConfigureAwait(false);
                                     return guidSourceId != Cyberware.EssenceHoleGUID
                                            && guidSourceId != Cyberware.EssenceAntiHoleGUID
                                            && await x.GetIsModularCurrentlyEquippedAsync(token).ConfigureAwait(false)
                                            && (!string.IsNullOrEmpty(await x.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false))
                                                || x.CanRemoveThroughImprovements);
                                 }, token).ConfigureAwait(false))
                    {
                        if (!string.IsNullOrEmpty(await objCyberware.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false)))
                        {
                            Cyberware objParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false);
                            if (objParent != null)
                                await (await objParent.GetChildrenAsync(token).ConfigureAwait(false)).RemoveAsync(objCyberware, token)
                                    .ConfigureAwait(false);
                            await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).AddAsync(objCyberware, token)
                                .ConfigureAwait(false);
                            await objCyberware.ChangeModularEquipAsync(false, token: token)
                                .ConfigureAwait(false);
                        }
                        else
                        {
                            await objCyberware.DeleteCyberwareAsync(token: token).ConfigureAwait(false);
                            blnDoRefresh = true;
                        }
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.AddCyberwareEnabled)) &&
                    !await CharacterObject.GetAddCyberwareEnabledAsync(token).ConfigureAwait(false))
                {
                    foreach (Cyberware objCyberware in await CharacterObject.Cyberware.DeepWhereAsync(
                                     x => x.GetChildrenAsync(GenericToken), async x =>
                                     {
                                         if (x.SourceType != Improvement.ImprovementSource.Cyberware)
                                             return false;
                                         Guid guidSourceId = await x.GetSourceIDAsync(token).ConfigureAwait(false);
                                         return guidSourceId != Cyberware.EssenceHoleGUID
                                                && guidSourceId != Cyberware.EssenceAntiHoleGUID
                                                && await x.GetIsModularCurrentlyEquippedAsync(token)
                                                    .ConfigureAwait(false)
                                                && (!string.IsNullOrEmpty(await x.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false))
                                                    || await x.GetCanRemoveThroughImprovementsAsync(token)
                                                        .ConfigureAwait(false));
                                     }, token)
                                 .ConfigureAwait(false))
                    {
                        if (!string.IsNullOrEmpty(await objCyberware.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false)))
                        {
                            await objCyberware.ChangeModularEquipAsync(false, token: token)
                                .ConfigureAwait(false);
                            Cyberware objParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false);
                            if (objParent != null)
                                await (await objParent.GetChildrenAsync(token).ConfigureAwait(false)).RemoveAsync(objCyberware, token)
                                    .ConfigureAwait(false);
                            await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).AddAsync(objCyberware, token)
                                .ConfigureAwait(false);
                        }
                        else
                        {
                            await objCyberware.DeleteCyberwareAsync(token: token).ConfigureAwait(false);
                            blnDoRefresh = true;
                        }
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.ExCon)) && await CharacterObject.GetExConAsync(token).ConfigureAwait(false))
                {
                    foreach (Cyberware objCyberware in await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).DeepWhereAsync(
                                     x => x.GetChildrenAsync(token), async x =>
                                     {
                                         Guid guidSourceId = await x.GetSourceIDAsync(token).ConfigureAwait(false);
                                         return guidSourceId != Cyberware.EssenceHoleGUID
                                                && guidSourceId != Cyberware.EssenceAntiHoleGUID
                                                && (await x.GetGradeAsync(token).ConfigureAwait(false)).Name != "None"
                                                && await x.GetIsModularCurrentlyEquippedAsync(token)
                                                    .ConfigureAwait(false)
                                                && (!string.IsNullOrEmpty(await x.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false))
                                                    || await x.GetCanRemoveThroughImprovementsAsync(token)
                                                        .ConfigureAwait(false));
                                     }, token)
                                 .ConfigureAwait(false))
                    {
                        char chrAvail = (await objCyberware.TotalAvailTupleAsync(false, token)
                            .ConfigureAwait(false)).Suffix;
                        if (chrAvail != 'R' && chrAvail != 'F')
                            continue;
                        if (!string.IsNullOrEmpty(await objCyberware.GetPlugsIntoModularMountAsync(token)
                                .ConfigureAwait(false)))
                        {
                            Cyberware objParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false);
                            if (objParent != null)
                                await (await objParent.GetChildrenAsync(token).ConfigureAwait(false)).RemoveAsync(objCyberware, token)
                                    .ConfigureAwait(false);
                            await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).AddAsync(objCyberware, token)
                                .ConfigureAwait(false);
                            await objCyberware.ChangeModularEquipAsync(false, token: token)
                                .ConfigureAwait(false);
                        }
                        else
                        {
                            await objCyberware.DeleteCyberwareAsync(token: token).ConfigureAwait(false);
                        }
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.InitiationEnabled)))
                {
                    // Change the status of the Initiation tab being show.
                    if (await CharacterObject.GetInitiationEnabledAsync(token).ConfigureAwait(false))
                    {
                        await tabCharacterTabs.DoThreadSafeAsync(x =>
                        {
                            if (!x.TabPages.Contains(tabInitiation))
                                x.TabPages.Insert(3, tabInitiation);
                        }, token).ConfigureAwait(false);
                        await gpbInitiationType.DoThreadSafeAsync(x => x.Visible = true,
                            token).ConfigureAwait(false);
                        await gpbInitiationGroup.DoThreadSafeAsync(x => x.Visible = true,
                            token).ConfigureAwait(false);
                    }
                    else
                    {
                        await tabCharacterTabs
                            .DoThreadSafeAsync(x => x.TabPages.Remove(tabInitiation), token)
                            .ConfigureAwait(false);
                        await gpbInitiationType.DoThreadSafeAsync(x => x.Visible = false,
                            token).ConfigureAwait(false);
                        await gpbInitiationGroup.DoThreadSafeAsync(x => x.Visible = false,
                            token).ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.FirstMentorSpiritDisplayName)))
                {
                    MentorSpirit objMentor = await CharacterObject.MentorSpirits.FirstOrDefaultAsync(token)
                        .ConfigureAwait(false);
                    if (objMentor != null)
                    {
                        await objMentor.SetSourceDetailAsync(lblMentorSpiritSource, token)
                            .ConfigureAwait(false);
                        await objMentor.SetSourceDetailAsync(lblParagonSource, token).ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.HasMentorSpirit)))
                {
                    bool blnHasMentorSpirit = await CharacterObject.GetHasMentorSpiritAsync(token).ConfigureAwait(false);
                    await gpbMagicianMentorSpirit.DoThreadSafeAsync(
                        x => x.Visible = blnHasMentorSpirit, token).ConfigureAwait(false);
                    await gpbTechnomancerParagon.DoThreadSafeAsync(x => x.Visible = blnHasMentorSpirit,
                        token).ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.UseMysticAdeptPPs)))
                {
                    bool blnUseMysticAdeptPPs =
                        await CharacterObject.GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false);
                    await lblMysticAdeptAssignment.DoThreadSafeAsync(
                        x => x.Visible = blnUseMysticAdeptPPs, token).ConfigureAwait(false);
                    await nudMysticAdeptMAGMagician.DoThreadSafeAsync(
                        x => x.Visible = blnUseMysticAdeptPPs, token).ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.IsPrototypeTranshuman)))
                {
                    bool blnIsPrototypeTranshuman =
                        await CharacterObject.GetIsPrototypeTranshumanAsync(token).ConfigureAwait(false);
                    await lblPrototypeTranshumanESS.DoThreadSafeAsync(
                        x => x.Visible = blnIsPrototypeTranshuman, token).ConfigureAwait(false);
                    await lblPrototypeTranshumanESSLabel.DoThreadSafeAsync(
                        x => x.Visible = blnIsPrototypeTranshuman, token).ConfigureAwait(false);
                }

                if (e.PropertyNames.Contains(nameof(Character.MetatypeCategory)))
                {
                    bool blnIsCyberzombie =
                        await CharacterObject.GetMetatypeCategoryAsync(token).ConfigureAwait(false) == "Cyberzombie";
                    if (e.PropertyNames.Contains(nameof(Character.IsSprite)))
                    {
                        await mnuCreateMenu.DoThreadSafeAsync(
                                () =>
                                {
                                    mnuSpecialCyberzombie.Visible = !blnIsCyberzombie;
                                    mnuSpecialConvertToFreeSprite.Visible = CharacterObject.IsSprite;
                                },
                                token)
                            .ConfigureAwait(false);
                    }
                    else
                        await mnuCreateMenu.DoThreadSafeAsync(
                            () => mnuSpecialCyberzombie.Visible = !blnIsCyberzombie,
                            token).ConfigureAwait(false);
                }
                else if (e.PropertyNames.Contains(nameof(Character.IsSprite)))
                {
                    await mnuCreateMenu.DoThreadSafeAsync(
                            () => mnuSpecialConvertToFreeSprite.Visible = CharacterObject.IsSprite,
                            token)
                        .ConfigureAwait(false);
                }

                if (blnDoRefresh
                    || e.PropertyNames.Contains(nameof(Character.NuyenBP))
                    || e.PropertyNames.Contains(nameof(Character.MetatypeBP))
                    || e.PropertyNames.Contains(nameof(Character.ContactPoints))
                    || e.PropertyNames.Contains(nameof(Character.FreeSpells))
                    || e.PropertyNames.Contains(nameof(Character.CFPLimit))
                    || e.PropertyNames.Contains(nameof(Character.AIAdvancedProgramLimit))
                    || e.PropertyNames.Contains(nameof(Character.SpellKarmaCost))
                    || e.PropertyNames.Contains(nameof(Character.ComplexFormKarmaCost))
                    || e.PropertyNames.Contains(nameof(Character.AIProgramKarmaCost))
                    || e.PropertyNames.Contains(nameof(Character.AIAdvancedProgramKarmaCost))
                    || e.PropertyNames.Contains(nameof(Character.MysticAdeptPowerPoints))
                    || e.PropertyNames.Contains(nameof(Character.MagicTradition))
                    || e.PropertyNames.Contains(nameof(Character.HomeNode))
                    || e.PropertyNames.Contains(nameof(Character.ActiveCommlink))
                    || e.PropertyNames.Contains(nameof(Character.Nuyen))
                    || e.PropertyNames.Contains(nameof(Character.Karma))
                    || e.PropertyNames.Contains(nameof(Character.MAGEnabled))
                    || e.PropertyNames.Contains(nameof(Character.RESEnabled))
                    || e.PropertyNames.Contains(nameof(Character.DEPEnabled))
                    || e.PropertyNames.Contains(nameof(Character.MetatypeCategory))
                    || e.PropertyNames.Contains(nameof(Character.IsSprite))
                    || e.PropertyNames.Contains(nameof(Character.IsPrototypeTranshuman)))
                {
                    RequestCharacterUpdate(token);
                }
                else
                {
                    if (e.PropertyNames.Contains(nameof(Character.DisplayNuyen)))
                    {
                        await RefreshNuyenDisplays(token).ConfigureAwait(false);
                    }

                    if (e.PropertyNames.Contains(nameof(Character.BlackMarketDiscount)))
                    {
                        await Task.WhenAll(RefreshSelectedCyberware(token),
                            RefreshSelectedArmor(token),
                            RefreshSelectedGear(token),
                            RefreshSelectedVehicle(token),
                            RefreshSelectedWeapon(token)).ConfigureAwait(false);
                    }
                }

                if (e.PropertyNames.Contains(nameof(Character.Settings)) && !IsLoading)
                {
                    await OnCharacterSettingsPropertyChanged(this,
                        new MultiplePropertiesChangedEventArgs(typeof(CharacterSettings).GetProperties()
                            .Select(x => x.Name)), token).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task OnCharacterSettingsPropertyChanged(object sender, MultiplePropertiesChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                token.ThrowIfCancellationRequested();
                CursorWait objCursorWait
                    = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
                try
                {
                    if (e.PropertyNames.Contains(nameof(CharacterSettings.Books)) && !IsLoading)
                    {
                        await this.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                        try
                        {
                            if (await CharacterObjectSettings.BookEnabledAsync("RF", token)
                                    .ConfigureAwait(false))
                                await cmdAddLifestyle
                                    .DoThreadSafeAsync(x => x.SplitMenuStrip = cmsAdvancedLifestyle, token)
                                    .ConfigureAwait(false);
                            else
                                await cmdAddLifestyle.DoThreadSafeAsync(x => x.SplitMenuStrip = null, token)
                                    .ConfigureAwait(false);
                            if (!await CharacterObjectSettings.BookEnabledAsync("FA", token)
                                    .ConfigureAwait(false))
                            {
                                await this.DoThreadSafeAsync(() =>
                                {
                                    lblWildReputation.Visible = false;
                                    lblWildReputationTotal.Visible = false;
                                }, token).ConfigureAwait(false);
                                if (!await CharacterObjectSettings.BookEnabledAsync("SG", token)
                                        .ConfigureAwait(false))
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        lblAstralReputation.Visible = false;
                                        lblAstralReputationTotal.Visible = false;
                                    }, token).ConfigureAwait(false);
                                }
                                else
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        lblAstralReputation.Visible = true;
                                        lblAstralReputationTotal.Visible = true;
                                    }, token).ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                await this.DoThreadSafeAsync(() =>
                                {
                                    lblWildReputation.Visible = true;
                                    lblWildReputationTotal.Visible = true;
                                    lblAstralReputation.Visible = true;
                                    lblAstralReputationTotal.Visible = true;
                                }, token).ConfigureAwait(false);
                            }

                            // Refresh all trees because enabled sources can change the nodes that are visible
                            await RefreshQualities(treQualities, cmsQuality, _fntNormal, _fntStrikeout,
                                token: token).ConfigureAwait(false);
                            await RefreshSpirits(panSpirits, panSprites, token: token).ConfigureAwait(false);
                            await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes,
                                token: token).ConfigureAwait(false);
                            await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm,
                                    cmsInitiationNotes, token: token)
                                .ConfigureAwait(false);
                            await RefreshPowerCollectionListChanged(treMetamagic, cmsMetamagic,
                                cmsInitiationNotes,
                                token: token).ConfigureAwait(false);
                            await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes,
                                token: token).ConfigureAwait(false);
                            await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram, token: token)
                                .ConfigureAwait(false);
                            await RefreshCritterPowers(treCritterPowers, cmsCritterPowers, token: token)
                                .ConfigureAwait(false);
                            await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique,
                                token: token).ConfigureAwait(false);
                            await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle,
                                token: token).ConfigureAwait(false);
                            await RefreshContacts(panContacts, panEnemies, panPets, token: token)
                                .ConfigureAwait(false);

                            await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod, cmsArmorGear,
                                token: token).ConfigureAwait(false);
                            await RefreshGears(treGear, cmsGearLocation, cmsGear, cmsGearAllowRename,
                                await chkCommlinks.DoThreadSafeFuncAsync(
                                    x => x.Checked, token).ConfigureAwait(false), false,
                                token: token).ConfigureAwait(false);
                            await RefreshFociFromGear(treFoci, null, token: token).ConfigureAwait(false);
                            await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear,
                                token: token).ConfigureAwait(false);
                            await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon, cmsWeaponAccessory,
                                cmsWeaponAccessoryGear, token: token).ConfigureAwait(false);
                            await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle, cmsVehicleWeapon,
                                    cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear,
                                    cmsVehicleGear,
                                    cmsWeaponMount,
                                    cmsVehicleCyberware, cmsVehicleCyberwareGear, token: token)
                                .ConfigureAwait(false);
                            await RefreshDrugs(treCustomDrugs, token: token).ConfigureAwait(false);
                            await this.DoThreadSafeAsync(() =>
                            {
                                treWeapons.SortCustomOrder();
                                treArmor.SortCustomOrder();
                                treGear.SortCustomOrder();
                                treLifestyles.SortCustomOrder();
                                treCustomDrugs.SortCustomOrder();
                                treCyberware.SortCustomOrder(true);
                                treVehicles.SortCustomOrder();
                                treCritterPowers.SortCustomOrder();
                            }, token).ConfigureAwait(false);

                            XPathNavigator xmlTraditionsBaseChummerNode =
                                (await CharacterObject.LoadDataXPathAsync(
                                    "traditions.xml", token: token).ConfigureAwait(false))
                                .SelectSingleNodeAndCacheExpression("/chummer", token);
                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstTraditions))
                            {
                                if (xmlTraditionsBaseChummerNode != null)
                                {
                                    foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                 "traditions/tradition["
                                                 + await CharacterObjectSettings.BookXPathAsync(token: token)
                                                     .ConfigureAwait(false)
                                                 + "]"))
                                    {
                                        string strName
                                            = xmlTradition
                                                .SelectSingleNodeAndCacheExpression("name", token)
                                                ?.Value;
                                        if (!string.IsNullOrEmpty(strName))
                                            lstTraditions.Add(new ListItem(
                                                xmlTradition
                                                    .SelectSingleNodeAndCacheExpression(
                                                        "id", token)
                                                    ?.Value ?? strName,
                                                xmlTradition
                                                    .SelectSingleNodeAndCacheExpression(
                                                        "translate", token)
                                                    ?.Value ?? strName));
                                    }
                                }

                                if (lstTraditions.Count > 1)
                                {
                                    lstTraditions.Sort(CompareListItems.CompareNames);
                                    lstTraditions.Insert(
                                        0,
                                        new ListItem(
                                            "None",
                                            await LanguageManager.GetStringAsync("String_None", token: token)
                                                .ConfigureAwait(false)));
                                    if (!lstTraditions.SequenceEqual(
                                            await cboTradition.DoThreadSafeFuncAsync(
                                                x => x.Items.Cast<ListItem>(), token).ConfigureAwait(false)))
                                    {
                                        await cboTradition.PopulateWithListItemsAsync(lstTraditions, token)
                                            .ConfigureAwait(false);
                                        Tradition objTradition =
                                            await CharacterObject.GetMagicTraditionAsync(token)
                                                .ConfigureAwait(false);
                                        TraditionType eTraditionType = await objTradition.GetTypeAsync(token)
                                            .ConfigureAwait(false);
                                        string strTraditionSourceIdString =
                                            await objTradition.GetSourceIDStringAsync(token)
                                                .ConfigureAwait(false);
                                        await cboTradition.DoThreadSafeAsync(x =>
                                        {
                                            if (eTraditionType == TraditionType.MAG && !string.IsNullOrEmpty(strTraditionSourceIdString))
                                                x.SelectedValue = strTraditionSourceIdString;
                                            if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                x.SelectedIndex = 0;
                                        }, token).ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        cboTradition.Visible = false;
                                        lblTraditionLabel.Visible = false;
                                    }, token).ConfigureAwait(false);
                                }
                            }

                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstDrainAttributes))
                            {
                                if (xmlTraditionsBaseChummerNode != null)
                                {
                                    foreach (XPathNavigator xmlDrain in xmlTraditionsBaseChummerNode
                                                 .SelectAndCacheExpression(
                                                     "drainattributes/drainattribute", token))
                                    {
                                        string strName
                                            = xmlDrain
                                                .SelectSingleNodeAndCacheExpression("name", token)
                                                ?.Value;
                                        if (!string.IsNullOrEmpty(strName)
                                            && (lstDrainAttributes.Count == 0 || lstDrainAttributes.TrueForAll(x =>
                                                            x.Value?.ToString() != strName)))
                                        {
                                            string strTranslatedName = xmlDrain
                                                .SelectSingleNodeAndCacheExpression(
                                                    "translate",
                                                    token)?.Value ?? strName;
                                            lstDrainAttributes.Add(new ListItem(strName, strTranslatedName));
                                        }
                                    }
                                }

                                lstDrainAttributes.Sort(CompareListItems.CompareNames);
                                lstDrainAttributes.Insert(0, ListItem.Blank);
                                await cboDrain.PopulateWithListItemsAsync(lstDrainAttributes, token)
                                    .ConfigureAwait(false);
                            }

                            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                       out HashSet<string> limit))
                            {
                                foreach (Improvement improvement in await ImprovementManager
                                             .GetCachedImprovementListForValueOfAsync(
                                                 CharacterObject,
                                                 Improvement.ImprovementType
                                                     .LimitSpiritCategory, token: token)
                                             .ConfigureAwait(false))
                                {
                                    limit.Add(improvement.ImprovedName);
                                }

                                using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                           Utils.ListItemListPool, out List<ListItem> lstSpirit))
                                {
                                    if (xmlTraditionsBaseChummerNode != null)
                                    {
                                        foreach (XPathNavigator xmlSpirit in xmlTraditionsBaseChummerNode
                                                     .SelectAndCacheExpression("spirits/spirit", token))
                                        {
                                            string strSpiritName
                                                = xmlSpirit
                                                    .SelectSingleNodeAndCacheExpression("name", token)
                                                    ?.Value;
                                            if (!string.IsNullOrEmpty(strSpiritName)
                                                && (limit.Count == 0 || limit.Contains(strSpiritName)))
                                            {
                                                lstSpirit.Add(new ListItem(strSpiritName,
                                                    xmlSpirit
                                                        .SelectSingleNodeAndCacheExpression(
                                                            "translate", token)?.Value
                                                    ?? strSpiritName));
                                            }
                                        }
                                    }

                                    lstSpirit.Sort(CompareListItems.CompareNames);
                                    lstSpirit.Insert(0, ListItem.Blank);
                                    await cboSpiritCombat.PopulateWithListItemsAsync(lstSpirit, token)
                                        .ConfigureAwait(false);
                                    await cboSpiritDetection.PopulateWithListItemsAsync(lstSpirit, token)
                                        .ConfigureAwait(false);
                                    await cboSpiritHealth.PopulateWithListItemsAsync(lstSpirit, token)
                                        .ConfigureAwait(false);
                                    await cboSpiritIllusion.PopulateWithListItemsAsync(lstSpirit, token)
                                        .ConfigureAwait(false);
                                    await cboSpiritManipulation.PopulateWithListItemsAsync(lstSpirit, token)
                                        .ConfigureAwait(false);
                                }
                            }

                            // Populate the Technomancer Streams list.
                            xmlTraditionsBaseChummerNode =
                                (await CharacterObject.LoadDataXPathAsync("streams.xml", token: token)
                                    .ConfigureAwait(false))
                                .SelectSingleNodeAndCacheExpression("/chummer", token);
                            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                                       Utils.ListItemListPool, out List<ListItem> lstStreams))
                            {
                                if (xmlTraditionsBaseChummerNode != null)
                                {
                                    foreach (XPathNavigator xmlTradition in xmlTraditionsBaseChummerNode.Select(
                                                 "traditions/tradition["
                                                 + await CharacterObjectSettings.BookXPathAsync(token: token)
                                                     .ConfigureAwait(false)
                                                 + "]"))
                                    {
                                        string strName
                                            = xmlTradition
                                                .SelectSingleNodeAndCacheExpression("name", token)
                                                ?.Value;
                                        if (!string.IsNullOrEmpty(strName))
                                            lstStreams.Add(new ListItem(
                                                xmlTradition
                                                    .SelectSingleNodeAndCacheExpression(
                                                        "id", token)
                                                    ?.Value ?? strName,
                                                xmlTradition
                                                    .SelectSingleNodeAndCacheExpression(
                                                        "translate", token)
                                                    ?.Value ?? strName));
                                    }
                                }

                                if (lstStreams.Count > 1)
                                {
                                    lstStreams.Sort(CompareListItems.CompareNames);
                                    lstStreams.Insert(
                                        0,
                                        new ListItem(
                                            "None",
                                            await LanguageManager.GetStringAsync("String_None", token: token)
                                                .ConfigureAwait(false)));
                                    if (!lstStreams.SequenceEqual(
                                            await cboStream.DoThreadSafeFuncAsync(
                                                x => x.Items.Cast<ListItem>(), token).ConfigureAwait(false)))
                                    {
                                        await cboStream.PopulateWithListItemsAsync(lstStreams, token)
                                            .ConfigureAwait(false);
                                        Tradition objTradition =
                                            await CharacterObject.GetMagicTraditionAsync(token)
                                                .ConfigureAwait(false);
                                        TraditionType eTraditionType = await objTradition.GetTypeAsync(token)
                                            .ConfigureAwait(false);
                                        string strTraditionSourceIdString =
                                            await objTradition.GetSourceIDStringAsync(token)
                                                .ConfigureAwait(false);
                                        await cboStream.DoThreadSafeAsync(x =>
                                        {
                                            if (eTraditionType == TraditionType.RES && !string.IsNullOrEmpty(strTraditionSourceIdString))
                                                x.SelectedValue = strTraditionSourceIdString;
                                            if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                                x.SelectedIndex = 0;
                                        }, token).ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    await this.DoThreadSafeAsync(() =>
                                    {
                                        cboStream.Visible = false;
                                        lblStreamLabel.Visible = false;
                                    }, token).ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await this.DoThreadSafeAsync(x => x.ResumeLayout(), token).ConfigureAwait(false);
                        }
                    }

                    if (e.PropertyNames.Contains(nameof(CharacterSettings.AllowFreeGrids)) && !await CharacterObjectSettings.BookEnabledAsync("HT", token).ConfigureAwait(false))
                    {
                        await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle,
                                token: token)
                            .ConfigureAwait(false);
                        await treLifestyles.DoThreadSafeAsync(x => x.SortCustomOrder(), token)
                            .ConfigureAwait(false);
                    }

                    if (e.PropertyNames.Contains(nameof(CharacterSettings.EnableEnemyTracking)))
                    {
                        bool blnTracking = await CharacterObjectSettings.GetEnableEnemyTrackingAsync(token).ConfigureAwait(false);
                        await this.DoThreadSafeAsync(x =>
                        {
                            x.SuspendLayout();
                            try
                            {
                                if (blnTracking)
                                {
                                    lblEnemiesBP.Visible = true;
                                    lblBuildEnemies.Visible = true;
                                    if (!tabPeople.TabPages.Contains(tabEnemies))
                                        tabPeople.TabPages.Insert(
                                            tabPeople.TabPages.IndexOf(tabContacts) + 1,
                                            tabEnemies);
                                }
                                else
                                {
                                    tabPeople.TabPages.Remove(tabEnemies);
                                    lblEnemiesBP.Visible = false;
                                    lblBuildEnemies.Visible = false;
                                }
                            }
                            finally
                            {
                                x.ResumeLayout();
                            }
                        }, token).ConfigureAwait(false);
                        await RefreshContacts(panContacts, panEnemies, panPets, token: token)
                            .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }

                RequestCharacterUpdate(token);
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        #endregion Character Events

        #region Menu Events

        private async void mnuFileSave_Click(object sender, EventArgs e)
        {
            try
            {
                if (await SaveCharacter(token: GenericToken).ConfigureAwait(false) && IsReopenQueued)
                    await this.DoThreadSafeAsync(x => x.Close(), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuFileSaveAs_Click(object sender, EventArgs e)
        {
            try
            {
                if (await SaveCharacterAs(token: GenericToken).ConfigureAwait(false) && IsReopenQueued)
                    await this.DoThreadSafeAsync(x => x.Close(), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuFileSaveAsCreated_Click(object sender, EventArgs e)
        {
            try
            {
                if (await SaveCharacterAs(true, GenericToken).ConfigureAwait(false) && IsReopenQueued)
                    await this.DoThreadSafeAsync(x => x.Close(), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuFilePrint_Click(object sender, EventArgs e)
        {
            try
            {
                await DoPrint(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void mnuFileClose_Click(object sender, EventArgs e)
        {
            Close();
        }

        private async void mnuSpecialAddPACKSKit_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddPACKSKit(GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialCreatePACKSKit_Click(object sender, EventArgs e)
        {
            try
            {
                await CreatePACKSKit(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialChangeMetatype_Click(object sender, EventArgs e)
        {
            try
            {
                await ChangeMetatype(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialChangeOptions_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    using (ThreadSafeForm<SelectBuildMethod> frmPickBP
                           = await ThreadSafeForm<SelectBuildMethod>.GetAsync(
                               () => new SelectBuildMethod(CharacterObject, true), GenericToken).ConfigureAwait(false))
                    {
                        await frmPickBP.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialCyberzombie_Click(object sender, EventArgs e)
        {
            try
            {
                await CharacterObject.ConvertCyberzombie(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialAddCyberwareSuite_Click(object sender, EventArgs e)
        {
            try
            {
                await AddCyberwareSuite(Improvement.ImprovementSource.Cyberware, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialAddBiowareSuite_Click(object sender, EventArgs e)
        {
            try
            {
                await AddCyberwareSuite(Improvement.ImprovementSource.Bioware, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialCreateCyberwareSuite_Click(object sender, EventArgs e)
        {
            try
            {
                await CreateCyberwareSuite(Improvement.ImprovementSource.Cyberware, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialCreateBiowareSuite_Click(object sender, EventArgs e)
        {
            try
            {
                await CreateCyberwareSuite(Improvement.ImprovementSource.Bioware, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                // This only re-applies the Improvements for everything the character has. If a match is not found in the data files, the current Improvement information is left as-is.
                // Verify that the user wants to go through with it.
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_ConfirmReapplyImprovements", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager
                            .GetStringAsync("MessageTitle_ConfirmReapplyImprovements", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) == DialogResult.No)
                    return;
                await DoReapplyImprovements(token: GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsQualityReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                    .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                      .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                   .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMartialArtsReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                          .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsSpellReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                     .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsComplexFormReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                           .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAIProgramReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                         .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCritterPowersReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicReapplyImprovements_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = (await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false))?.Tag;
                await ReapplySpecificImprovements((objSelected as IHasInternalId)?.InternalId,
                                                  objSelected is IHasName objHasName
                                                      ? await objHasName.GetCurrentDisplayNameAsync(GenericToken)
                                                                        .ConfigureAwait(false)
                                                      : string.Empty, GenericToken)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        internal async Task ReapplySpecificImprovements(string strSelectedId, string strSelectedName,
                                                             CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (string.IsNullOrEmpty(strSelectedId))
                return;
            string strName = !string.IsNullOrEmpty(strSelectedName)
                ? strSelectedName
                : await LanguageManager.GetStringAsync("String_SelectedItem", token: token).ConfigureAwait(false);
            // This only re-applies the Improvements for everything the character has. If a match is not found in the data files, the current Improvement information is left as-is.
            // Verify that the user wants to go through with it.
            if (await Program.ShowScrollableMessageBoxAsync(
                    this,
                    string.Format(GlobalSettings.CultureInfo,
                        await LanguageManager
                            .GetStringAsync("Message_ConfirmReapplySpecificImprovements", token: token)
                            .ConfigureAwait(false), strName),
                    await LanguageManager
                        .GetStringAsync("MessageTitle_ConfirmReapplySpecificImprovements", token: token)
                        .ConfigureAwait(false),
                    MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: token).ConfigureAwait(false) == DialogResult.No)
                return;
            using (TemporaryStringArray eParam = strSelectedId.YieldAsPooled())
                await DoReapplyImprovements(eParam, token: token).ConfigureAwait(false);
        }

        private async Task DoReapplyImprovements(IReadOnlyCollection<string> lstInternalIdFilter = null,
                                                      CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker
                    = await CharacterObject.LockObject.EnterWriteLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdOutdatedItems))
                    {
                        // Record the status of any flags that normally trigger character events.
                        bool blnMAGEnabled = await CharacterObject.GetMAGEnabledAsync(token).ConfigureAwait(false);
                        bool blnRESEnabled = await CharacterObject.GetRESEnabledAsync(token).ConfigureAwait(false);
                        bool blnDEPEnabled = await CharacterObject.GetDEPEnabledAsync(token).ConfigureAwait(false);

                        bool blnOldReapplyImprovements = _blnReapplyImprovements;
                        _blnReapplyImprovements = true;

                        try
                        {
                            // Wipe all improvements that we will reapply, this is mainly to eliminate orphaned improvements caused by certain bugs and also for a performance increase
                            if (lstInternalIdFilter == null)
                                await ImprovementManager.RemoveImprovementsAsync(
                                    CharacterObject,
                                    await (await CharacterObject.GetImprovementsAsync(token).ConfigureAwait(false))
                                          .ToListAsync(
                                              x => x.ImproveSource == Improvement.ImprovementSource.AIProgram
                                                   || x.ImproveSource == Improvement.ImprovementSource.Armor
                                                   || x.ImproveSource == Improvement.ImprovementSource.ArmorMod
                                                   || x.ImproveSource == Improvement.ImprovementSource.Bioware
                                                   || x.ImproveSource == Improvement.ImprovementSource.ComplexForm
                                                   || x.ImproveSource == Improvement.ImprovementSource.CritterPower
                                                   || x.ImproveSource == Improvement.ImprovementSource.Cyberware
                                                   || x.ImproveSource == Improvement.ImprovementSource.Echo
                                                   || x.ImproveSource == Improvement.ImprovementSource.Gear
                                                   || x.ImproveSource == Improvement.ImprovementSource.MartialArt
                                                   || x.ImproveSource == Improvement.ImprovementSource
                                                       .MartialArtTechnique
                                                   || x.ImproveSource == Improvement.ImprovementSource.Metamagic
                                                   || x.ImproveSource == Improvement.ImprovementSource.Power
                                                   || x.ImproveSource == Improvement.ImprovementSource.Quality
                                                   || x.ImproveSource == Improvement.ImprovementSource.Spell
                                                   || x.ImproveSource == Improvement.ImprovementSource.StackedFocus,
                                              token)
                                          .ConfigureAwait(false),
                                    true, token: token).ConfigureAwait(false);
                            else
                                await ImprovementManager.RemoveImprovementsAsync(
                                    CharacterObject,
                                    await (await CharacterObject.GetImprovementsAsync(token).ConfigureAwait(false))
                                          .ToListAsync(
                                              x => lstInternalIdFilter.Contains(x.SourceName) &&
                                                   (x.ImproveSource == Improvement.ImprovementSource.AIProgram
                                                    || x.ImproveSource == Improvement.ImprovementSource.Armor
                                                    || x.ImproveSource == Improvement.ImprovementSource.ArmorMod
                                                    || x.ImproveSource == Improvement.ImprovementSource.Bioware
                                                    || x.ImproveSource == Improvement.ImprovementSource.ComplexForm
                                                    || x.ImproveSource == Improvement.ImprovementSource.CritterPower
                                                    || x.ImproveSource == Improvement.ImprovementSource.Cyberware
                                                    || x.ImproveSource == Improvement.ImprovementSource.Echo
                                                    || x.ImproveSource == Improvement.ImprovementSource.Gear
                                                    || x.ImproveSource == Improvement.ImprovementSource.MartialArt
                                                    || x.ImproveSource == Improvement.ImprovementSource
                                                        .MartialArtTechnique
                                                    || x.ImproveSource == Improvement.ImprovementSource.Metamagic
                                                    || x.ImproveSource == Improvement.ImprovementSource.Power
                                                    || x.ImproveSource == Improvement.ImprovementSource.Quality
                                                    || x.ImproveSource == Improvement.ImprovementSource.Spell
                                                    || x.ImproveSource == Improvement.ImprovementSource.StackedFocus),
                                              token).ConfigureAwait(false),
                                    true, token: token).ConfigureAwait(false);

                            // Refresh Qualities.
                            // We cannot use foreach because qualities can add more qualities
                            for (int j = 0;
                                 j < await CharacterObject.Qualities.GetCountAsync(token).ConfigureAwait(false);
                                 j++)
                            {
                                Quality objQuality = await CharacterObject.Qualities.GetValueAtAsync(j, token)
                                                                          .ConfigureAwait(false);
                                QualitySource eOriginSource = await objQuality.GetOriginSourceAsync(token).ConfigureAwait(false);
                                if (eOriginSource == QualitySource.Improvement
                                    || eOriginSource == QualitySource.MetatypeRemovedAtChargen)
                                    continue;
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objQuality.InternalId) == false)
                                    continue;

                                XmlNode objNode = await objQuality.GetNodeAsync(token: token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    string strSelected = objQuality.Extra;

                                    objQuality.Bonus = objNode["bonus"];
                                    if (objQuality.Bonus != null)
                                    {
                                        ImprovementManager.SetForcedValue(strSelected, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                            Improvement.ImprovementSource.Quality,
                                            objQuality.InternalId, objQuality.Bonus, 1,
                                            await objQuality.GetCurrentDisplayNameShortAsync(token)
                                                            .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objQuality.Extra = strSelectedValue;
                                            string strName = await objQuality.GetCurrentDisplayNameAsync(token)
                                                                             .ConfigureAwait(false);
                                            await treQualities.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                                if (objTreeNode != null)
                                                    objTreeNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }

                                    objQuality.FirstLevelBonus = objNode["firstlevelbonus"];
                                    if (objQuality.FirstLevelBonus?.HasChildNodes == true)
                                    {
                                        string strCheckExtra = await objQuality.GetExtraAsync(token).ConfigureAwait(false);
                                        string strCheckSourceName = await objQuality.GetSourceNameAsync(token).ConfigureAwait(false);
                                        bool blnDoFirstLevel = true;
                                        for (int k = 0; k < await CharacterObject.Qualities.GetCountAsync(token).ConfigureAwait(false); ++k)
                                        {
                                            Quality objCheckQuality = await CharacterObject.Qualities.GetValueAtAsync(k, token).ConfigureAwait(false);
                                            if (j != k
                                                && objCheckQuality.SourceID == objQuality.SourceID
                                                && await objCheckQuality.GetExtraAsync(token).ConfigureAwait(false) == strCheckExtra
                                                && await objCheckQuality.GetSourceNameAsync(token).ConfigureAwait(false) == strCheckSourceName
                                                && (k < j
                                                    || await objCheckQuality.GetOriginSourceAsync(token).ConfigureAwait(false) == QualitySource.Improvement
                                                    || lstInternalIdFilter?.Contains(objCheckQuality.InternalId)
                                                    == false))
                                            {
                                                blnDoFirstLevel = false;
                                                break;
                                            }
                                        }

                                        if (blnDoFirstLevel)
                                        {
                                            ImprovementManager.SetForcedValue(strSelected, CharacterObject);
                                            await ImprovementManager.CreateImprovementsAsync(
                                                                        CharacterObject,
                                                                        Improvement.ImprovementSource.Quality,
                                                                        objQuality.InternalId,
                                                                        objQuality.FirstLevelBonus, 1,
                                                                        await objQuality
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                            string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                            if (!string.IsNullOrEmpty(strSelectedValue))
                                            {
                                                objQuality.Extra = strSelectedValue;
                                                string strName = await objQuality.GetCurrentDisplayNameAsync(token)
                                                    .ConfigureAwait(false);
                                                await treQualities.DoThreadSafeAsync(x =>
                                                {
                                                    TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                                    if (objTreeNode != null)
                                                        objTreeNode.Text = strName;
                                                }, token).ConfigureAwait(false);
                                            }
                                        }
                                    }

                                    objQuality.NaturalWeaponsNode = objNode["naturalweapons"];
                                    if (objQuality.NaturalWeaponsNode != null)
                                    {
                                        ImprovementManager.SetForcedValue(strSelected, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.Quality,
                                            objQuality.InternalId,
                                            objQuality.NaturalWeaponsNode, 1,
                                            await objQuality.GetCurrentDisplayNameShortAsync(token)
                                                            .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objQuality.Extra = strSelectedValue;
                                            string strName = await objQuality.GetCurrentDisplayNameAsync(token)
                                                                             .ConfigureAwait(false);
                                            await treQualities.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objTreeNode = x.FindNodeByTag(objQuality);
                                                if (objTreeNode != null)
                                                    objTreeNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objQuality.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }

                            // Refresh Martial Art Techniques.
                            await CharacterObject.MartialArts.ForEachWithSideEffectsAsync(async objMartialArt =>
                            {
                                XmlNode objMartialArtNode
                                    = await objMartialArt.GetNodeAsync(token: token).ConfigureAwait(false);
                                if (objMartialArtNode != null)
                                {
                                    // We're only re-apply improvements a list of items, not all of them
                                    if (lstInternalIdFilter?.Contains(objMartialArt.InternalId) != false
                                        && objMartialArtNode["bonus"] != null)
                                    {
                                        await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                                                    Improvement.ImprovementSource.MartialArt,
                                                                    objMartialArt.InternalId,
                                                                    objMartialArtNode["bonus"], 1,
                                                                    await objMartialArt
                                                                          .GetCurrentDisplayNameShortAsync(token)
                                                                          .ConfigureAwait(false), token: token)
                                                                .ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(await objMartialArt
                                                                      .GetCurrentDisplayNameShortAsync(token)
                                                                      .ConfigureAwait(false));
                                }

                                await objMartialArt.Techniques.ForEachWithSideEffectsAsync(async objTechnique =>
                                {
                                    if (lstInternalIdFilter?.Contains(objTechnique.InternalId) == false)
                                        return;
                                    XmlNode objNode = await objTechnique.GetNodeAsync(token: token)
                                                                        .ConfigureAwait(false);
                                    if (objNode != null)
                                    {
                                        if (objNode["bonus"] != null)
                                            await ImprovementManager.CreateImprovementsAsync(
                                                CharacterObject, Improvement.ImprovementSource.MartialArtTechnique,
                                                objTechnique.InternalId, objNode["bonus"], 1,
                                                await objTechnique.GetCurrentDisplayNameAsync(token)
                                                                  .ConfigureAwait(false),
                                                token: token).ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        sbdOutdatedItems.AppendLine(
                                            await objTechnique.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                    }
                                }, token).ConfigureAwait(false);
                            }, token).ConfigureAwait(false);

                            // Refresh Spells.
                            await CharacterObject.Spells.ForEachWithSideEffectsAsync(async objSpell =>
                            {
                                if (lstInternalIdFilter?.Contains(objSpell.InternalId) == false)
                                    return;
                                XmlNode objNode = await objSpell.GetNodeAsync(token: token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    if (objNode["bonus"] != null)
                                    {
                                        ImprovementManager.SetForcedValue(objSpell.Extra, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                            Improvement.ImprovementSource.Spell,
                                            objSpell.InternalId, objNode["bonus"], 1,
                                            await objSpell.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objSpell.Extra = strSelectedValue;
                                            string strName = await objSpell.GetCurrentDisplayNameAsync(token)
                                                                           .ConfigureAwait(false);
                                            await treSpells.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objSpellNode = x.FindNode(objSpell.InternalId);
                                                if (objSpellNode != null)
                                                    objSpellNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objSpell.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }, token).ConfigureAwait(false);

                            // Refresh Adept Powers.
                            await CharacterObject.Powers.ForEachWithSideEffectsAsync(async objPower =>
                            {
                                if (lstInternalIdFilter?.Contains(objPower.InternalId) == false)
                                    return;
                                XmlNode objNode = await objPower.GetNodeAsync(token: token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    objPower.Bonus = objNode["bonus"];
                                    if (objPower.Bonus != null)
                                    {
                                        ImprovementManager.SetForcedValue(objPower.Extra, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                            Improvement.ImprovementSource.Power,
                                            objPower.InternalId, objPower.Bonus,
                                            await objPower.GetTotalRatingAsync(token).ConfigureAwait(false),
                                            await objPower.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objPower.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }, GenericToken).ConfigureAwait(false);

                            // Refresh Complex Forms.
                            await CharacterObject.ComplexForms.ForEachWithSideEffectsAsync(async objComplexForm =>
                            {
                                if (lstInternalIdFilter?.Contains(objComplexForm.InternalId) == false)
                                    return;
                                XmlNode objNode = await objComplexForm.GetNodeAsync(token: token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    if (objNode["bonus"] != null)
                                    {
                                        ImprovementManager.SetForcedValue(objComplexForm.Extra, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                                                    Improvement.ImprovementSource.ComplexForm,
                                                                    objComplexForm.InternalId, objNode["bonus"],
                                                                    1,
                                                                    await objComplexForm
                                                                          .GetCurrentDisplayNameShortAsync(token)
                                                                          .ConfigureAwait(false), token: token)
                                                                .ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objComplexForm.Extra = strSelectedValue;
                                            string strName = await objComplexForm.GetCurrentDisplayNameAsync(token)
                                                .ConfigureAwait(false);
                                            await treComplexForms.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objCFNode = x.FindNode(objComplexForm.InternalId);
                                                if (objCFNode != null)
                                                    objCFNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objComplexForm.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }, token).ConfigureAwait(false);

                            // Refresh AI Programs and Advanced Programs
                            await CharacterObject.AIPrograms.ForEachWithSideEffectsAsync(async objProgram =>
                            {
                                if (lstInternalIdFilter?.Contains(objProgram.InternalId) == false)
                                    return;
                                XmlNode objNode = await objProgram.GetNodeAsync(token: token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    if (objNode["bonus"] != null)
                                    {
                                        ImprovementManager.SetForcedValue(objProgram.Extra, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                            Improvement.ImprovementSource.AIProgram,
                                            objProgram.InternalId, objNode["bonus"], 1,
                                            await objProgram.GetCurrentDisplayNameShortAsync(token)
                                                            .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objProgram.Extra = strSelectedValue;
                                            string strName = await objProgram.GetCurrentDisplayNameShortAsync(token)
                                                                             .ConfigureAwait(false);
                                            await treAIPrograms.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objProgramNode = x.FindNode(objProgram.InternalId);
                                                if (objProgramNode != null)
                                                    objProgramNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objProgram.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false));
                                }
                            }, token).ConfigureAwait(false);

                            // Refresh Critter Powers.
                            await CharacterObject.CritterPowers.ForEachWithSideEffectsAsync(async objPower =>
                            {
                                if (lstInternalIdFilter?.Contains(objPower.InternalId) == false)
                                    return;
                                XmlNode objNode = await objPower.GetNodeAsync(token: token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    objPower.Bonus = objNode["bonus"];
                                    if (objPower.Bonus != null)
                                    {
                                        string strSelected = objPower.Extra;
                                        if (!int.TryParse(strSelected, out int intRating))
                                        {
                                            intRating = 1;
                                            ImprovementManager.SetForcedValue(strSelected, CharacterObject);
                                        }

                                        await ImprovementManager.CreateImprovementsAsync(CharacterObject,
                                            Improvement.ImprovementSource.CritterPower,
                                            objPower.InternalId, objPower.Bonus,
                                            intRating,
                                            await objPower.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue))
                                        {
                                            objPower.Extra = strSelectedValue;
                                            string strName = await objPower.GetCurrentDisplayNameAsync(token)
                                                                           .ConfigureAwait(false);
                                            await treCritterPowers.DoThreadSafeAsync(x =>
                                            {
                                                TreeNode objPowerNode = x.FindNode(objPower.InternalId);
                                                if (objPowerNode != null)
                                                    objPowerNode.Text = strName;
                                            }, token).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objPower.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }, token).ConfigureAwait(false);

                            // Refresh Metamagics and Echoes.
                            // We cannot use foreach because metamagics/echoes can add more metamagics/echoes
                            // ReSharper disable once ForCanBeConvertedToForeach
                            for (int j = 0;
                                 j < await CharacterObject.Metamagics.GetCountAsync(token).ConfigureAwait(false);
                                 j++)
                            {
                                Metamagic objMetamagic = await CharacterObject.Metamagics.GetValueAtAsync(j, token)
                                                                              .ConfigureAwait(false);
                                if (objMetamagic.Grade < 0)
                                    continue;
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objMetamagic.InternalId) == false)
                                    continue;
                                XmlNode objNode = await objMetamagic.GetNodeAsync(token: token).ConfigureAwait(false);
                                if (objNode != null)
                                {
                                    objMetamagic.Bonus = objNode["bonus"];
                                    if (objMetamagic.Bonus != null)
                                    {
                                        await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, objMetamagic.SourceType,
                                            objMetamagic.InternalId, objMetamagic.Bonus,
                                            1,
                                            await objMetamagic.GetCurrentDisplayNameShortAsync(token)
                                                              .ConfigureAwait(false),
                                            token: token).ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    sbdOutdatedItems.AppendLine(
                                        await objMetamagic.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                }
                            }

                            // Refresh Cyberware and Bioware.
                            Dictionary<Cyberware, int> dicPairableCyberwares
                                = new Dictionary<Cyberware, int>(await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).GetCountAsync(token).ConfigureAwait(false));
                            foreach (Cyberware objCyberware in await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).GetAllDescendantsAsync(
                                         x => x.GetChildrenAsync(GenericToken), token).ConfigureAwait(false))
                            {
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objCyberware.InternalId) != false)
                                {
                                    XmlNode objNode = await objCyberware.GetNodeAsync(token: token)
                                                                        .ConfigureAwait(false);
                                    if (objNode != null)
                                    {
                                        objCyberware.Bonus = objNode["bonus"];
                                        objCyberware.WirelessBonus = objNode["wirelessbonus"];
                                        objCyberware.PairBonus = objNode["pairbonus"];
                                        if (!string.IsNullOrEmpty(objCyberware.Forced) && objCyberware.Forced != "Right"
                                            && objCyberware.Forced != "Left")
                                            ImprovementManager.SetForcedValue(objCyberware.Forced, CharacterObject);
                                        if (objCyberware.Bonus != null)
                                        {
                                            await ImprovementManager.CreateImprovementsAsync(
                                                                        CharacterObject, objCyberware.SourceType,
                                                                        objCyberware.InternalId,
                                                                        objCyberware.Bonus,
                                                                        await objCyberware.GetRatingAsync(token)
                                                                            .ConfigureAwait(false),
                                                                        await objCyberware
                                                                              .GetCurrentDisplayNameShortAsync(token)
                                                                              .ConfigureAwait(false), token: token)
                                                                    .ConfigureAwait(false);
                                            string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                            if (!string.IsNullOrEmpty(strSelectedValue))
                                                objCyberware.Extra = strSelectedValue;
                                        }

                                        if (!await objCyberware.GetIsModularCurrentlyEquippedAsync(token).ConfigureAwait(false))
                                            await objCyberware.ChangeModularEquipAsync(false, token: token)
                                                              .ConfigureAwait(false);
                                        else
                                        {
                                            await objCyberware.RefreshWirelessBonusesAsync(token).ConfigureAwait(false);
                                            if (objCyberware.PairBonus != null)
                                            {
                                                Cyberware objMatchingCyberware
                                                    = dicPairableCyberwares.Keys.FirstOrDefault(
                                                        x => objCyberware.IncludePair.Contains(x.Name)
                                                             && x.Extra == objCyberware.Extra);
                                                if (objMatchingCyberware != null)
                                                    ++dicPairableCyberwares[objMatchingCyberware];
                                                else
                                                    dicPairableCyberwares.Add(objCyberware, 1);
                                            }
                                        }

                                        Guid guidSourceId = await objCyberware.GetSourceIDAsync(token).ConfigureAwait(false);
                                        TreeNode objWareNode = guidSourceId == Cyberware.EssenceHoleGUID
                                                               || guidSourceId == Cyberware.EssenceAntiHoleGUID
                                            ? await treCyberware.DoThreadSafeFuncAsync(
                                                                    x => x.FindNode(guidSourceId.ToString("D", GlobalSettings.InvariantCultureInfo)), token)
                                                                .ConfigureAwait(false)
                                            : await treCyberware.DoThreadSafeFuncAsync(
                                                x => x.FindNode(objCyberware.InternalId), token).ConfigureAwait(false);
                                        if (objWareNode != null)
                                        {
                                            string strName = await objCyberware.GetCurrentDisplayNameAsync(token)
                                                                               .ConfigureAwait(false);
                                            await treCyberware.DoThreadSafeAsync(
                                                () => objWareNode.Text = strName, token).ConfigureAwait(false);
                                        }
                                    }
                                    else
                                    {
                                        sbdOutdatedItems.AppendLine(
                                            await objCyberware.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                    }
                                }

                                foreach (Gear objGear in objCyberware.GearChildren)
                                {
                                    await objGear
                                          .ReaddImprovements(treCyberware, sbdOutdatedItems, lstInternalIdFilter,
                                                             token: token)
                                          .ConfigureAwait(false);
                                }
                            }

                            // Separate Pass for PairBonuses
                            foreach (KeyValuePair<Cyberware, int> objItem in dicPairableCyberwares)
                            {
                                Cyberware objCyberware = objItem.Key;
                                int intCyberwaresCount = objItem.Value;
                                List<Cyberware> lstPairableCyberwares = await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false))
                                    .DeepWhereAsync(x => x.GetChildrenAsync(token),
                                                    async x => objCyberware.IncludePair
                                                                           .Contains(x.Name)
                                                               && x.Extra == objCyberware.Extra
                                                               && await x.GetIsModularCurrentlyEquippedAsync(token)
                                                                         .ConfigureAwait(false), token)
                                    .ConfigureAwait(false);
                                // Need to use slightly different logic if this cyberware has a location (Left or Right) and only pairs with itself because Lefts can only be paired with Rights and Rights only with Lefts
                                if (!string.IsNullOrEmpty(objCyberware.Location)
                                    && objCyberware.IncludePair.All(x => x == objCyberware.Name))
                                {
                                    int intMatchLocationCount = 0;
                                    int intNotMatchLocationCount = 0;
                                    foreach (Cyberware objPairableCyberware in lstPairableCyberwares)
                                    {
                                        if (objPairableCyberware.Location != objCyberware.Location)
                                            ++intNotMatchLocationCount;
                                        else
                                            ++intMatchLocationCount;
                                    }

                                    // Set the count to the total number of cyberwares in matching pairs, which would mean 2x the number of whichever location contains the fewest members (since every single one of theirs would have a pair)
                                    intCyberwaresCount = Math.Min(intNotMatchLocationCount, intMatchLocationCount) * 2;
                                }

                                if (intCyberwaresCount <= 0)
                                    continue;
                                foreach (Cyberware objLoopCyberware in lstPairableCyberwares)
                                {
                                    if ((intCyberwaresCount & 1) == 0)
                                    {
                                        if (!string.IsNullOrEmpty(objCyberware.Forced) && objCyberware.Forced != "Right"
                                            && objCyberware.Forced != "Left")
                                            ImprovementManager.SetForcedValue(objCyberware.Forced, CharacterObject);
                                        await ImprovementManager.CreateImprovementsAsync(
                                                                    CharacterObject, objLoopCyberware.SourceType,
                                                                    objLoopCyberware.InternalId + "Pair",
                                                                    objLoopCyberware.PairBonus,
                                                                    await objLoopCyberware.GetRatingAsync(token)
                                                                        .ConfigureAwait(false),
                                                                    await objLoopCyberware
                                                                          .GetCurrentDisplayNameShortAsync(token)
                                                                          .ConfigureAwait(false), token: token)
                                                                .ConfigureAwait(false);
                                        string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                        if (!string.IsNullOrEmpty(strSelectedValue) && string.IsNullOrEmpty(objCyberware.Extra))
                                            objCyberware.Extra = strSelectedValue;
                                        TreeNode objNode = await objLoopCyberware.GetSourceIDAsync(token).ConfigureAwait(false) == Cyberware.EssenceHoleGUID
                                                           || await objCyberware.GetSourceIDAsync(token).ConfigureAwait(false) == Cyberware.EssenceAntiHoleGUID
                                            ? await treCyberware.DoThreadSafeFuncAsync(
                                                                    x => x.FindNode(objCyberware.SourceIDString), token)
                                                                .ConfigureAwait(false)
                                            : await treCyberware.DoThreadSafeFuncAsync(
                                                                    x => x.FindNode(objLoopCyberware.InternalId), token)
                                                                .ConfigureAwait(false);
                                        if (objNode != null)
                                        {
                                            string strName = await objCyberware.GetCurrentDisplayNameAsync(token)
                                                                               .ConfigureAwait(false);
                                            await treCyberware.DoThreadSafeAsync(() => objNode.Text = strName, token)
                                                              .ConfigureAwait(false);
                                        }
                                    }

                                    --intCyberwaresCount;
                                    if (intCyberwaresCount <= 0)
                                        break;
                                }
                            }

                            // Refresh Armors.
                            await CharacterObject.Armor.ForEachWithSideEffectsAsync(async objArmor =>
                            {
                                // We're only re-apply improvements a list of items, not all of them
                                if (lstInternalIdFilter?.Contains(objArmor.InternalId) != false)
                                {
                                    XmlNode objNode = await objArmor.GetNodeAsync(token: token).ConfigureAwait(false);
                                    if (objNode != null)
                                    {
                                        objArmor.Bonus = objNode["bonus"];
                                        if (objArmor.Bonus != null && objArmor.Equipped)
                                        {
                                            ImprovementManager.SetForcedValue(objArmor.Extra, CharacterObject);
                                            await ImprovementManager.CreateImprovementsAsync(
                                                CharacterObject, Improvement.ImprovementSource.Armor,
                                                objArmor.InternalId,
                                                objArmor.Bonus, await objArmor.GetRatingAsync(token).ConfigureAwait(false),
                                                await objArmor.GetCurrentDisplayNameShortAsync(token)
                                                              .ConfigureAwait(false),
                                                token: token).ConfigureAwait(false);
                                            string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                            if (!string.IsNullOrEmpty(strSelectedValue))
                                            {
                                                objArmor.Extra = strSelectedValue;
                                                string strName = await objArmor.GetCurrentDisplayNameAsync(token)
                                                                               .ConfigureAwait(false);
                                                await treArmor.DoThreadSafeAsync(x =>
                                                {
                                                    TreeNode objArmorNode = x.FindNode(objArmor.InternalId);
                                                    if (objArmorNode != null)
                                                        objArmorNode.Text = strName;
                                                }, token).ConfigureAwait(false);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        sbdOutdatedItems.AppendLine(
                                            await objArmor.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                    }
                                }

                                await objArmor.ArmorMods.ForEachWithSideEffectsAsync(async objMod =>
                                {
                                    // We're only re-apply improvements a list of items, not all of them
                                    if (lstInternalIdFilter?.Contains(objMod.InternalId) != false)
                                    {
                                        XmlNode objChild
                                            = await objMod.GetNodeAsync(token: token).ConfigureAwait(false);

                                        if (objChild != null)
                                        {
                                            objMod.Bonus = objChild["bonus"];
                                            if (objMod.Bonus != null && objMod.Equipped)
                                            {
                                                ImprovementManager.SetForcedValue(objMod.Extra, CharacterObject);
                                                await ImprovementManager.CreateImprovementsAsync(
                                                                            CharacterObject,
                                                                            Improvement.ImprovementSource.ArmorMod,
                                                                            objMod.InternalId,
                                                                            objMod.Bonus, await objMod.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                                            await objMod
                                                                                .GetCurrentDisplayNameShortAsync(token)
                                                                                .ConfigureAwait(false), token: token)
                                                                        .ConfigureAwait(false);
                                                string strSelectedValue = ImprovementManager.GetSelectedValue(CharacterObject);
                                                if (!string.IsNullOrEmpty(strSelectedValue))
                                                {
                                                    objMod.Extra = strSelectedValue;
                                                    string strName = await objMod.GetCurrentDisplayNameAsync(token)
                                                        .ConfigureAwait(false);
                                                    await treArmor.DoThreadSafeAsync(x =>
                                                    {
                                                        TreeNode objPluginNode = x.FindNode(objMod.InternalId);
                                                        if (objPluginNode != null)
                                                            objPluginNode.Text = strName;
                                                    }, token).ConfigureAwait(false);
                                                }
                                            }
                                        }
                                        else
                                        {
                                            sbdOutdatedItems.AppendLine(
                                                await objMod.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                                        }
                                    }

                                    await objMod.GearChildren.ForEachWithSideEffectsAsync(objGear => objGear
                                                                               .ReaddImprovements(
                                                                                   treArmor, sbdOutdatedItems,
                                                                                   lstInternalIdFilter, token: token),
                                                                           token).ConfigureAwait(false);
                                }, token).ConfigureAwait(false);

                                await objArmor.GearChildren.ForEachWithSideEffectsAsync(objGear => objGear
                                                                             .ReaddImprovements(
                                                                                 treArmor, sbdOutdatedItems,
                                                                                 lstInternalIdFilter, token: token),
                                                                         token).ConfigureAwait(false);

                                await objArmor.RefreshWirelessBonusesAsync(token).ConfigureAwait(false);
                            }, token).ConfigureAwait(false);

                            // Refresh Gear.
                            await CharacterObject.Gear.ForEachWithSideEffectsAsync(async objGear =>
                            {
                                await objGear
                                      .ReaddImprovements(treGear, sbdOutdatedItems, lstInternalIdFilter, token: token)
                                      .ConfigureAwait(false);
                                await objGear.RefreshWirelessBonusesAsync(token).ConfigureAwait(false);
                            }, token).ConfigureAwait(false);

                            // Refresh Weapons Gear
                            await CharacterObject.Weapons.ForEachWithSideEffectsAsync(async objWeapon =>
                            {
                                await objWeapon.WeaponAccessories.ForEachWithSideEffectsAsync(
                                                   objAccessory => objAccessory.GearChildren.ForEachWithSideEffectsAsync(objGear =>
                                                           objGear
                                                               .ReaddImprovements(
                                                                   treWeapons, sbdOutdatedItems, lstInternalIdFilter,
                                                                   token: token), token), token)
                                               .ConfigureAwait(false);

                                await objWeapon.RefreshWirelessBonusesAsync(token).ConfigureAwait(false);
                            }, token).ConfigureAwait(false);
                        }
                        finally
                        {
                            _blnReapplyImprovements = blnOldReapplyImprovements;
                        }

                        // If the status of any Character Event flags has changed, manually trigger those events.
                        List<string> lstTemp = new List<string>(3);
                        if (blnMAGEnabled != await CharacterObject.GetMAGEnabledAsync(token).ConfigureAwait(false))
                            lstTemp.Add(nameof(Character.MAGEnabled));
                        if (blnRESEnabled != await CharacterObject.GetRESEnabledAsync(token).ConfigureAwait(false))
                            lstTemp.Add(nameof(Character.RESEnabled));
                        if (blnDEPEnabled != await CharacterObject.GetDEPEnabledAsync(token).ConfigureAwait(false))
                            lstTemp.Add(nameof(Character.DEPEnabled));
                        if (lstTemp.Count > 0)
                            await OnCharacterPropertyChanged(this, new MultiplePropertiesChangedEventArgs(lstTemp),
                                token).ConfigureAwait(false);

                        // Immediately await character update because it re-applies essence loss improvements
                        try
                        {
                            await RequestAndProcessCharacterUpdate(token).ConfigureAwait(false);
                        }
                        catch (OperationCanceledException)
                        {
                            return;
                        }

                        if (sbdOutdatedItems.Length > 0 && !Utils.IsUnitTest)
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this, await LanguageManager.GetStringAsync(
                                              "Message_ReapplyImprovementsFoundOutdatedItems_Top",
                                              token: token)
                                          .ConfigureAwait(false) +
                                      sbdOutdatedItems.Append(
                                      await LanguageManager.GetStringAsync(
                                              "Message_ReapplyImprovementsFoundOutdatedItems_Bottom",
                                              token: token)
                                          .ConfigureAwait(false)).ToString(),
                                await LanguageManager
                                    .GetStringAsync("MessageTitle_ConfirmReapplyImprovements", token: token)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error, token: token).ConfigureAwait(false);
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }

            await SetDirty(true, token).ConfigureAwait(false);
        }

        private async void mnuEditCopy_Click(object sender, EventArgs e)
        {
            try
            {
                if (tabCharacterTabs != null)
                {
                    object objSelectedObject = await tabCharacterTabs.DoThreadSafeFuncAsync(x =>
                    {
                        if (x.SelectedTab == tabStreetGear && tabStreetGearTabs != null)
                        {
                            if (tabStreetGearTabs.SelectedTab == tabArmor)
                            {
                                return treArmor.SelectedNode?.Tag;
                            }

                            if (tabStreetGearTabs.SelectedTab == tabWeapons)
                            {
                                return treWeapons.SelectedNode?.Tag;
                            }

                            if (tabStreetGearTabs.SelectedTab == tabGear)
                            {
                                return treGear.SelectedNode?.Tag;
                            }

                            if (tabStreetGearTabs.SelectedTab == tabLifestyle)
                            {
                                return treLifestyles.SelectedNode?.Tag;
                            }

                            Utils.BreakIfDebug();
                            return null;
                        }

                        if (x.SelectedTab == tabVehicles)
                        {
                            return treVehicles.SelectedNode?.Tag;
                        }

                        if (x.SelectedTab == tabCyberware)
                        {
                            return treCyberware.SelectedNode?.Tag;
                        }

                        Utils.BreakIfDebug();
                        return null;
                    }, GenericToken).ConfigureAwait(false);

                    if (objSelectedObject != null)
                        await CopyObject(objSelectedObject, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuEditPaste_Click(object sender, EventArgs e)
        {
            object objSelectedObject = null;
            try
            {
                if (tabCharacterTabs != null)
                {
                    objSelectedObject = await tabCharacterTabs.DoThreadSafeFuncAsync(x =>
                    {
                        if (x.SelectedTab == tabStreetGear && tabStreetGearTabs != null)
                        {
                            if (tabStreetGearTabs.SelectedTab == tabArmor)
                            {
                                return treArmor.SelectedNode?.Tag;
                            }

                            if (tabStreetGearTabs.SelectedTab == tabWeapons)
                            {
                                return treWeapons.SelectedNode?.Tag;
                            }

                            if (tabStreetGearTabs.SelectedTab == tabGear)
                            {
                                return treGear.SelectedNode?.Tag;
                            }

                            if (tabStreetGearTabs.SelectedTab == tabLifestyle)
                            {
                                // Intentionally blank, lifestyles are always clones.
                                return null;
                            }

                            Utils.BreakIfDebug();
                            return null;
                        }

                        if (x.SelectedTab == tabVehicles)
                        {
                            return treVehicles.SelectedNode?.Tag;
                        }

                        if (x.SelectedTab == tabCyberware)
                        {
                            return treCyberware.SelectedNode?.Tag;
                        }

                        Utils.BreakIfDebug();
                        return null;
                    }, GenericToken).ConfigureAwait(false);
                }

                IAsyncDisposable objLocker = await GlobalSettings.EnterClipboardReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    switch (await GlobalSettings.GetClipboardContentTypeAsync(GenericToken).ConfigureAwait(false))
                    {
                        case ClipboardContentType.Armor:
                        {
                            // Paste Armor.
                            XmlNode objXmlNode = (await GlobalSettings.GetClipboardAsync(GenericToken).ConfigureAwait(false)).SelectSingleNode("/character/armor");
                            if (objXmlNode != null)
                            {
                                Armor objArmor = new Armor(CharacterObject);
                                try
                                {
                                    await objArmor.LoadAsync(objXmlNode, true, GenericToken).ConfigureAwait(false);
                                    await CharacterObject.Armor.AddAsync(objArmor, GenericToken).ConfigureAwait(false);

                                    await AddChildVehicles(objArmor.InternalId).ConfigureAwait(false);
                                    await AddChildWeapons(objArmor.InternalId).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await objArmor.DeleteArmorAsync(token: CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }

                            break;
                        }
                        case ClipboardContentType.ArmorMod:
                        {
                            if (!(objSelectedObject is Armor selectedArmor &&
                                  await selectedArmor.AllowPasteXml(GenericToken).ConfigureAwait(false)))
                                break;
                            // Paste Armor.
                            XmlNode objXmlNode = (await GlobalSettings.GetClipboardAsync(GenericToken).ConfigureAwait(false)).SelectSingleNode("/character/armormod");
                            if (objXmlNode != null)
                            {
                                ArmorMod objArmorMod = new ArmorMod(CharacterObject, selectedArmor);
                                try
                                {
                                    await objArmorMod.LoadAsync(objXmlNode, true, GenericToken).ConfigureAwait(false);
                                    await selectedArmor.ArmorMods.AddAsync(objArmorMod, GenericToken).ConfigureAwait(false);

                                    await AddChildVehicles(objArmorMod.InternalId).ConfigureAwait(false);
                                    await AddChildWeapons(objArmorMod.InternalId).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await objArmorMod.DeleteArmorModAsync(token: CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }

                            break;
                        }
                        case ClipboardContentType.Cyberware:
                        {
                            // Paste Cyberware.
                            XmlNode objXmlNode = (await GlobalSettings.GetClipboardAsync(GenericToken).ConfigureAwait(false)).SelectSingleNode("/character/cyberware");
                            if (objXmlNode != null)
                            {
                                Cyberware objCyberware = new Cyberware(CharacterObject);
                                try
                                {
                                    await objCyberware.LoadAsync(objXmlNode, true, GenericToken).ConfigureAwait(false);
                                    if (objSelectedObject is Cyberware objCyberwareParent)
                                    {
                                        if (!await objCyberwareParent.AllowPasteObject(objCyberware, GenericToken)
                                                .ConfigureAwait(false))
                                        {
                                            await objCyberware.DeleteCyberwareAsync(token: GenericToken)
                                                .ConfigureAwait(false);
                                            return;
                                        }

                                        await objCyberware.SetGradeAsync(await objCyberwareParent.GetGradeAsync(GenericToken).ConfigureAwait(false),
                                            token: GenericToken).ConfigureAwait(false);
                                        await (await objCyberwareParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).AddAsync(objCyberware, GenericToken)
                                            .ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        if (!string.IsNullOrEmpty(await objCyberware.GetLimbSlotAsync(GenericToken)
                                                .ConfigureAwait(false)) &&
                                            !await objCyberware.GetValidLimbSlotAsync(
                                                await objCyberware.GetNodeXPathAsync(GlobalSettings.Language, GenericToken)
                                                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false))
                                        {
                                            await objCyberware.DeleteCyberwareAsync(token: GenericToken)
                                                .ConfigureAwait(false);
                                            return;
                                        }

                                        await CharacterObject.Cyberware.AddAsync(objCyberware, GenericToken)
                                            .ConfigureAwait(false);
                                    }

                                    await AddChildVehicles(objCyberware.InternalId).ConfigureAwait(false);
                                    await AddChildWeapons(objCyberware.InternalId).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await objCyberware.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }

                            break;
                        }
                        case ClipboardContentType.Gear:
                        {
                            // Paste Gear.
                            XmlNode objXmlNode = (await GlobalSettings.GetClipboardAsync(GenericToken).ConfigureAwait(false)).SelectSingleNode("/character/gear");
                            if (objXmlNode == null)
                                break;
                            Gear objGear = new Gear(CharacterObject);
                            await objGear.LoadAsync(objXmlNode, true, GenericToken).ConfigureAwait(false);
                            if (objSelectedObject is ICanPaste selected &&
                                await selected.AllowPasteXml(GenericToken).ConfigureAwait(false) &&
                                objSelectedObject is IHasGear gear)
                            {
                                await gear.GearChildren.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                                if (gear is ICanEquip selectedEquip && !selectedEquip.Equipped)
                                    await objGear.ChangeEquippedStatusAsync(false, token: GenericToken)
                                        .ConfigureAwait(false);
                            }
                            else
                            {
                                await CharacterObject.Gear.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                            }

                            await AddChildVehicles(objGear.InternalId).ConfigureAwait(false);
                            await AddChildWeapons(objGear.InternalId).ConfigureAwait(false);
                            break;
                        }
                        case ClipboardContentType.Lifestyle:
                        {
                            // Lifestyle Tab.
                            if (await tabStreetGearTabs
                                    .DoThreadSafeFuncAsync(x => x.SelectedTab != tabLifestyle, GenericToken)
                                    .ConfigureAwait(false))
                                break;

                            // Paste Lifestyle.
                            XmlNode objXmlNode = (await GlobalSettings.GetClipboardAsync(GenericToken).ConfigureAwait(false)).SelectSingleNode("/character/lifestyle");
                            if (objXmlNode == null)
                                break;

                            Lifestyle objLifestyle = new Lifestyle(CharacterObject);
                            try
                            {
                                await objLifestyle.LoadAsync(objXmlNode, true, GenericToken).ConfigureAwait(false);
                                // Reset the number of months back to 1 since 0 isn't valid in Create Mode.
                                await objLifestyle.SetIncrementsAsync(1, GenericToken).ConfigureAwait(false);
                                await (await CharacterObject.GetLifestylesAsync(GenericToken).ConfigureAwait(false)).AddAsync(objLifestyle, GenericToken).ConfigureAwait(false);
                            }
                            catch
                            {
                                await objLifestyle.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                            break;
                        }
                        case ClipboardContentType.Vehicle:
                        {
                            // Paste Vehicle.
                            XmlNode objXmlNode = (await GlobalSettings.GetClipboardAsync(GenericToken).ConfigureAwait(false)).SelectSingleNode("/character/vehicle");
                            Vehicle objVehicle = new Vehicle(CharacterObject);
                            try
                            {
                                await objVehicle.LoadAsync(objXmlNode, true, GenericToken).ConfigureAwait(false);
                                await (await CharacterObject.GetVehiclesAsync(GenericToken).ConfigureAwait(false)).AddAsync(objVehicle, GenericToken).ConfigureAwait(false);
                            }
                            catch
                            {
                                await objVehicle.DeleteVehicleAsync(CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                            break;
                        }
                        case ClipboardContentType.Weapon:
                        {
                            // Paste Weapon.
                            XmlNode objXmlNode = (await GlobalSettings.GetClipboardAsync(GenericToken).ConfigureAwait(false)).SelectSingleNode("/character/weapon");
                            if (objXmlNode != null)
                            {
                                Weapon objWeapon = null;
                                try
                                {
                                    switch (objSelectedObject)
                                    {
                                        case Weapon objWeaponParent when !await objWeaponParent.AllowPasteXml(GenericToken)
                                            .ConfigureAwait(false):
                                            return;

                                        case Weapon objWeaponParent:
                                            objWeapon = new Weapon(CharacterObject);
                                            await objWeapon.LoadAsync(objXmlNode, true, GenericToken).ConfigureAwait(false);
                                            await objWeaponParent.Children.AddAsync(objWeapon, GenericToken)
                                                .ConfigureAwait(false);
                                            break;

                                        case WeaponMount objWeaponMount
                                            when !await objWeaponMount.AllowPasteXml(GenericToken).ConfigureAwait(false):
                                            return;

                                        case WeaponMount objWeaponMount:
                                            objWeapon = new Weapon(CharacterObject);
                                            await objWeapon.LoadAsync(objXmlNode, true, GenericToken).ConfigureAwait(false);
                                            await objWeaponMount.Weapons.AddAsync(objWeapon, GenericToken)
                                                .ConfigureAwait(false);
                                            break;

                                        case VehicleMod objMod
                                            when !await objMod.AllowPasteXml(GenericToken).ConfigureAwait(false):
                                            return;

                                        case VehicleMod objMod:
                                            objWeapon = new Weapon(CharacterObject);
                                            await objWeapon.LoadAsync(objXmlNode, true, GenericToken).ConfigureAwait(false);
                                            await objMod.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                                            break;

                                        default:
                                            objWeapon = new Weapon(CharacterObject);
                                            await objWeapon.LoadAsync(objXmlNode, true, GenericToken).ConfigureAwait(false);
                                            await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                                .ConfigureAwait(false);
                                            break;
                                    }

                                    await AddChildVehicles(objWeapon.InternalId).ConfigureAwait(false);
                                    await AddChildWeapons(objWeapon.InternalId).ConfigureAwait(false);
                                }
                                catch
                                {
                                    if (objWeapon != null)
                                        await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }

                            break;
                        }
                        case ClipboardContentType.WeaponAccessory:
                        {
                            if (!(objSelectedObject is Weapon selectedWeapon &&
                                  await selectedWeapon.AllowPasteXml(GenericToken).ConfigureAwait(false)))
                                break;
                            // Paste Armor.
                            XmlNode objXmlNode = (await GlobalSettings.GetClipboardAsync(GenericToken).ConfigureAwait(false)).SelectSingleNode("/character/accessory");
                            if (objXmlNode != null)
                            {
                                WeaponAccessory objMod = new WeaponAccessory(CharacterObject);
                                try
                                {
                                    await objMod.LoadAsync(objXmlNode, true, GenericToken).ConfigureAwait(false);
                                    await selectedWeapon.WeaponAccessories.AddAsync(objMod, GenericToken)
                                        .ConfigureAwait(false);

                                    await AddChildVehicles(objMod.InternalId).ConfigureAwait(false);
                                    await AddChildWeapons(objMod.InternalId).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await objMod.DeleteWeaponAccessoryAsync(token: CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }

                            break;
                        }
                        default:
                            Utils.BreakIfDebug();
                            break;
                    }

                    async Task AddChildWeapons(string parentId)
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        XmlNodeList objXmlNodeList = (await GlobalSettings.GetClipboardAsync(GenericToken).ConfigureAwait(false)).SelectNodes("/character/weapons/weapon");
                        if (!(objXmlNodeList?.Count > 0))
                            return;
                        foreach (XmlNode objLoopNode in objXmlNodeList)
                        {
                            Weapon objWeapon = new Weapon(CharacterObject);
                            try
                            {
                                await objWeapon.LoadAsync(objLoopNode, true, GenericToken).ConfigureAwait(false);
                                await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                                objWeapon.ParentID = parentId;
                            }
                            catch
                            {
                                await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    }

                    async Task AddChildVehicles(string parentId)
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        // Add any Vehicles that come with the Cyberware.
                        XmlNodeList objXmlNodeList =
                            (await GlobalSettings.GetClipboardAsync(GenericToken).ConfigureAwait(false)).SelectNodes("/character/vehicles/vehicle");
                        if (!(objXmlNodeList?.Count > 0))
                            return;
                        foreach (XmlNode objLoopNode in objXmlNodeList)
                        {
                            Vehicle objVehicle = new Vehicle(CharacterObject);
                            try
                            {
                                await objVehicle.LoadAsync(objLoopNode, true, GenericToken).ConfigureAwait(false);
                                await (await CharacterObject.GetVehiclesAsync(GenericToken).ConfigureAwait(false)).AddAsync(objVehicle, GenericToken).ConfigureAwait(false);
                                objVehicle.ParentID = parentId;
                            }
                            catch
                            {
                                await objVehicle.DeleteVehicleAsync(CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialConvertToFreeSprite_Click(object sender, EventArgs e)
        {
            try
            {
                XmlNode objXmlPower
                    = (await CharacterObject.LoadDataAsync("critterpowers.xml", token: GenericToken)
                                            .ConfigureAwait(false))
                    .SelectSingleNode("/chummer/powers/power[name = \"Denial\"]");
                CritterPower objPower = new CritterPower(CharacterObject);
                await objPower.CreateAsync(objXmlPower, token: GenericToken).ConfigureAwait(false);
                objPower.CountTowardsLimit = false;
                if (objPower.InternalId.IsEmptyGuid())
                    return;

                await CharacterObject.CritterPowers.AddAsync(objPower, GenericToken).ConfigureAwait(false);

                await CharacterObject.SetMetatypeCategoryAsync("Free Sprite", GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Menu Events

        #region Martial Tab Control Events

        private async void treMartialArts_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedMartialArt(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedMartialArt(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                object objSelectedNodeTag = await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token)
                                                                .ConfigureAwait(false);
                if (objSelectedNodeTag is IHasSource objSelected)
                {
                    await lblMartialArtSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                    await lblMartialArtSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    await objSelected.SetSourceDetailAsync(lblMartialArtSource, token).ConfigureAwait(false);
                }
                else
                {
                    await lblMartialArtSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                    await lblMartialArtSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                }

                switch (objSelectedNodeTag)
                {
                    case MartialArt objMartialArt:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = !objMartialArt.IsQuality, token)
                                                 .ConfigureAwait(false);
                        break;

                    case ICanRemove _:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        break;

                    default:
                        await cmdDeleteMartialArt.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                 .ConfigureAwait(false);
                        await SourceString.Blank.SetControlAsync(lblMartialArtSource, this, token).ConfigureAwait(false);
                        break;
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        #endregion Martial Tab Control Events

        #region Button Events

        private async void cmdAddSpell_Click(object sender, EventArgs e)
        {
            try
            {
                // Open the Spells XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("spells.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        using (ThreadSafeForm<SelectSpell> frmPickSpell
                               = await ThreadSafeForm<SelectSpell>.GetAsync(() => new SelectSpell(CharacterObject), GenericToken)
                                                                  .ConfigureAwait(false))
                        {
                            // Make sure the dialogue window was not canceled.
                            if (await frmPickSpell.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;

                            blnAddAgain = frmPickSpell.MyForm.AddAgain;

                            XmlNode objXmlSpell
                                = objXmlDocument.TryGetNodeByNameOrId("/chummer/spells/spell", frmPickSpell.MyForm.SelectedSpell);

                            Spell objSpell = new Spell(CharacterObject);
                            try
                            {
                                await objSpell.CreateAsync(objXmlSpell, string.Empty, frmPickSpell.MyForm.Limited,
                                    frmPickSpell.MyForm.Extended,
                                    frmPickSpell.MyForm.Alchemical, token: GenericToken).ConfigureAwait(false);
                                if (objSpell.InternalId.IsEmptyGuid())
                                {
                                    await objSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                    continue;
                                }

                                if (frmPickSpell.MyForm.FreeBonus)
                                {
                                    objSpell.FreeBonus = true;
                                    // Barehanded Adept
                                    if (await CharacterObject.GetAdeptEnabledAsync(GenericToken).ConfigureAwait(false)
                                        && !await CharacterObject.GetMagicianEnabledAsync(GenericToken).ConfigureAwait(false)
                                        && (objSpell.Range == "T" || objSpell.Range == "T (A)"))
                                    {
                                        objSpell.BarehandedAdept = true;
                                    }
                                }

                                await CharacterObject.Spells.AddAsync(objSpell, GenericToken).ConfigureAwait(false);
                            }
                            catch
                            {
                                await objSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteSpell_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddSpirit_Click(object sender, EventArgs e)
        {
            try
            {
                await AddSpirit(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddSprite_Click(object sender, EventArgs e)
        {
            try
            {
                await AddSprite(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddContact_Click(object sender, EventArgs e)
        {
            try
            {
                await AddContact(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddEnemy_Click(object sender, EventArgs e)
        {
            try
            {
                await AddEnemy(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddPet_Click(object sender, EventArgs e)
        {
            try
            {
                await AddPet(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAddFromFile_Click(object sender, EventArgs e)
        {
            try
            {
                await AddContactsFromFile(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddCyberware_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickCyberware(null, Improvement.ImprovementSource.Cyberware, GenericToken)
                        .ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteCyberware_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddComplexForm_Click(object sender, EventArgs e)
        {
            try
            {
                XmlDocument objXmlDocument
                    = await CharacterObject.LoadDataAsync("complexforms.xml", token: GenericToken)
                                           .ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        // The number of Complex Forms cannot exceed twice the character's RES.
                        if (await CharacterObject.ComplexForms.GetCountAsync(GenericToken).ConfigureAwait(false)
                            >= await (await CharacterObject.GetAttributeAsync("RES", token: GenericToken).ConfigureAwait(false)).GetTotalValueAsync(GenericToken).ConfigureAwait(false) * 2
                            + await ImprovementManager.ValueOfAsync(CharacterObject,
                                                                    Improvement.ImprovementType.ComplexFormLimit,
                                                                    token: GenericToken)
                                                      .ConfigureAwait(false)
                            && !await CharacterObject.GetIgnoreRulesAsync(GenericToken).ConfigureAwait(false))
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_ComplexFormLimit", token: GenericToken).ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_ComplexFormLimit", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            break;
                        }

                        XmlNode objXmlComplexForm;
                        // Let the user select a Program.
                        using (ThreadSafeForm<SelectComplexForm> frmPickComplexForm
                               = await ThreadSafeForm<SelectComplexForm>.GetAsync(
                                   () => new SelectComplexForm(CharacterObject), GenericToken).ConfigureAwait(false))
                        {
                            // Make sure the dialogue window was not canceled.
                            if (await frmPickComplexForm.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;

                            blnAddAgain = frmPickComplexForm.MyForm.AddAgain;

                            objXmlComplexForm = objXmlDocument.TryGetNodeByNameOrId("/chummer/complexforms/complexform", frmPickComplexForm.MyForm.SelectedComplexForm);
                        }

                        if (objXmlComplexForm == null)
                            continue;

                        ComplexForm objComplexForm = new ComplexForm(CharacterObject);
                        try
                        {
                            await objComplexForm.CreateAsync(objXmlComplexForm, token: GenericToken).ConfigureAwait(false);
                            if (objComplexForm.InternalId.IsEmptyGuid())
                            {
                                await objComplexForm.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                continue;
                            }

                            await CharacterObject.ComplexForms.AddAsync(objComplexForm, GenericToken).ConfigureAwait(false);
                        }
                        catch
                        {
                            await objComplexForm.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddAIProgram_Click(object sender, EventArgs e)
        {
            try
            {
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("programs.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        XmlNode objXmlProgram;
                        // Let the user select a Program.
                        using (ThreadSafeForm<SelectAIProgram> frmPickProgram
                               = await ThreadSafeForm<SelectAIProgram>.GetAsync(
                                   () => new SelectAIProgram(CharacterObject), GenericToken).ConfigureAwait(false))
                        {
                            // Make sure the dialogue window was not canceled.
                            if (await frmPickProgram.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                            {
                                break;
                            }

                            blnAddAgain = frmPickProgram.MyForm.AddAgain;

                            objXmlProgram = objXmlDocument.TryGetNodeByNameOrId("/chummer/programs/program", frmPickProgram.MyForm.SelectedProgram);
                        }

                        if (objXmlProgram == null)
                            continue;

                        // Check for SelectText.
                        string strExtra = string.Empty;
                        XPathNavigator xmlSelectText = objXmlProgram.SelectSingleNodeAndCacheExpressionAsNavigator("bonus/selecttext", GenericToken);
                        if (xmlSelectText != null)
                        {
                            string strDescription = string.Format(GlobalSettings.CultureInfo,
                                                                  await LanguageManager.GetStringAsync(
                                                                          "String_Improvement_SelectText", token: GenericToken)
                                                                      .ConfigureAwait(false),
                                                                  objXmlProgram["translate"]?.InnerTextViaPool(GenericToken)
                                                                  ?? objXmlProgram["name"]?.InnerTextViaPool(GenericToken));
                            using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                                       () => new SelectText
                                       {
                                           Description = strDescription
                                       }, GenericToken).ConfigureAwait(false))
                            {
                                if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    continue;
                                strExtra = frmPickText.MyForm.SelectedValue;
                            }
                        }

                        AIProgram objProgram = new AIProgram(CharacterObject);
                        await objProgram.CreateAsync(objXmlProgram, strExtra, token: GenericToken).ConfigureAwait(false);
                        if (objProgram.InternalId.IsEmptyGuid())
                            continue;

                        await CharacterObject.AIPrograms.AddAsync(objProgram, GenericToken).ConfigureAwait(false);
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteArmor_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddBioware_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickCyberware(null, Improvement.ImprovementSource.Bioware, GenericToken)
                        .ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                Location objLocation = null;
                if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is Location objSelectedLocation)
                {
                    objLocation = objSelectedLocation;
                }

                do
                {
                    blnAddAgain = await AddWeapon(objLocation, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task<bool> AddWeapon(Location objLocation = null, CancellationToken token = default)
        {
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    using (ThreadSafeForm<SelectWeapon> frmPickWeapon
                           = await ThreadSafeForm<SelectWeapon>.GetAsync(() => new SelectWeapon(CharacterObject), token)
                               .ConfigureAwait(false))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickWeapon.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return false;

                        // Open the Weapons XML file and locate the selected piece.
                        XmlNode objXmlWeapon
                            = (await CharacterObject.LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false))
                            .TryGetNodeByNameOrId(
                                "/chummer/weapons/weapon", frmPickWeapon.MyForm.SelectedWeapon);
                        if (objXmlWeapon == null)
                            return frmPickWeapon.MyForm.AddAgain;

                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        Weapon objWeapon = new Weapon(CharacterObject);
                        try
                        {
                            await objWeapon.CreateAsync(objXmlWeapon, lstWeapons, token: token).ConfigureAwait(false);
                            objWeapon.DiscountCost = frmPickWeapon.MyForm.BlackMarketDiscount;
                            if (frmPickWeapon.MyForm.FreeCost)
                            {
                                objWeapon.Cost = "0";
                            }

                            //objWeapon.Location = objLocation;
                            if (objLocation != null)
                                await objLocation.Children.AddAsync(objWeapon, token).ConfigureAwait(false);
                            await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);

                            foreach (Weapon objExtraWeapon in lstWeapons)
                            {
                                await CharacterObject.Weapons.AddAsync(objExtraWeapon, token).ConfigureAwait(false);
                            }

                            return frmPickWeapon.MyForm.AddAgain;
                        }
                        catch
                        {
                            foreach (Weapon objLoopWeapon in lstWeapons)
                                await objLoopWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                            await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async void cmdDeleteWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddLifestyle_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        Lifestyle objLifestyle = new Lifestyle(CharacterObject);
                        try
                        {
                            await objLifestyle.SetStyleTypeAsync(LifestyleType.Standard, GenericToken).ConfigureAwait(false);
                            using (ThreadSafeForm<SelectLifestyle> frmPickLifestyle
                                   = await ThreadSafeForm<SelectLifestyle>.GetAsync(
                                           () => new SelectLifestyle(
                                               CharacterObject, objLifestyle),
                                           GenericToken)
                                       .ConfigureAwait(false))
                            {
                                // Make sure the dialogue window was not canceled.
                                if (await frmPickLifestyle.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                {
                                    //And if it was, remove Improvements that was already added based on the lifestyle
                                    await objLifestyle.RemoveAsync(false, GenericToken).ConfigureAwait(false);
                                    return;
                                }

                                blnAddAgain = frmPickLifestyle.MyForm.AddAgain;

                                Lifestyle objNewLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;

                                await CharacterObject.Lifestyles.AddAsync(objNewLifestyle, GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }
                        catch
                        {
                            await objLifestyle.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteLifestyle_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                string strSelectedId = string.Empty;
                if (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    Location objNode)
                {
                    strSelectedId = objNode.InternalId;
                }

                do
                {
                    blnAddAgain = await PickGear(strSelectedId, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteGear_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task<bool> AddVehicle(Location objLocation = null, CancellationToken token = default)
        {
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                using (ThreadSafeForm<SelectVehicle> frmPickVehicle
                       = await ThreadSafeForm<SelectVehicle>.GetAsync(() => new SelectVehicle(CharacterObject), token)
                                                            .ConfigureAwait(false))
                {
                    // Make sure the dialogue window was not canceled.
                    if (await frmPickVehicle.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return false;

                    // Open the Vehicles XML file and locate the selected piece.
                    XmlNode objXmlVehicle
                        = (await CharacterObject.LoadDataAsync("vehicles.xml", token: token).ConfigureAwait(false))
                        .TryGetNodeByNameOrId(
                            "/chummer/vehicles/vehicle", frmPickVehicle.MyForm.SelectedVehicle);
                    if (objXmlVehicle == null)
                        return frmPickVehicle.MyForm.AddAgain;
                    Vehicle objVehicle = new Vehicle(CharacterObject);
                    try
                    {
                        await objVehicle.CreateAsync(objXmlVehicle, token: token).ConfigureAwait(false);
                        // Update the Used Vehicle information if applicable.
                        if (frmPickVehicle.MyForm.UsedVehicle)
                        {
                            objVehicle.Avail = frmPickVehicle.MyForm.UsedAvail;
                            objVehicle.Cost = frmPickVehicle.MyForm.UsedCost.ToString(GlobalSettings.InvariantCultureInfo);
                        }

                        objVehicle.DiscountCost = frmPickVehicle.MyForm.BlackMarketDiscount;
                        if (frmPickVehicle.MyForm.FreeCost)
                        {
                            objVehicle.Cost = "0";
                        }

                        //objVehicle.Location = objLocation;
                        if (objLocation != null)
                            await objLocation.Children.AddAsync(objVehicle, token).ConfigureAwait(false);

                        await CharacterObject.Vehicles.AddAsync(objVehicle, token).ConfigureAwait(false);

                        return frmPickVehicle.MyForm.AddAgain;
                    }
                    catch
                    {
                        await objVehicle.DeleteVehicleAsync(CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async void cmdAddVehicle_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddVehicle(
                        await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                         .ConfigureAwait(false) as Location, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteVehicle_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddMartialArt_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    await MartialArt.Purchase(CharacterObject, GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteMartialArt_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddMugshot_Click(object sender, EventArgs e)
        {
            try
            {
                if (!await AddMugshot(GenericToken).ConfigureAwait(false))
                    return;
                int intMugshotCount =
                    await (await CharacterObject.GetMugshotsAsync(GenericToken).ConfigureAwait(false)).GetCountAsync(GenericToken).ConfigureAwait(false);
                string strText = await LanguageManager.GetStringAsync("String_Of", token: GenericToken).ConfigureAwait(false)
                                 + intMugshotCount.ToString(GlobalSettings.CultureInfo);
                await lblNumMugshots.DoThreadSafeAsync(x => x.Text = strText, GenericToken).ConfigureAwait(false);
                await nudMugshotIndex.DoThreadSafeAsync(x =>
                {
                    ++x.Maximum;
                    x.Value = intMugshotCount;
                }, GenericToken).ConfigureAwait(false);
                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteMugshot_Click(object sender, EventArgs e)
        {
            try
            {
                int intMugshotCount =
                    await (await CharacterObject.GetMugshotsAsync(GenericToken).ConfigureAwait(false)).GetCountAsync(GenericToken).ConfigureAwait(false);
                if (intMugshotCount == 0)
                    return;
                await RemoveMugshot(await nudMugshotIndex.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken).ConfigureAwait(false) - 1, GenericToken).ConfigureAwait(false);
                --intMugshotCount;
                string strText = await LanguageManager.GetStringAsync("String_Of", token: GenericToken).ConfigureAwait(false)
                                 + intMugshotCount.ToString(GlobalSettings.CultureInfo);
                await lblNumMugshots.DoThreadSafeAsync(x => x.Text = strText, GenericToken).ConfigureAwait(false);
                (bool blnDoExtra, int intMugshotIndex) = await nudMugshotIndex.DoThreadSafeFuncAsync(x =>
                {
                    --x.Maximum;
                    if (x.Value <= x.Maximum)
                    {
                        return new ValueTuple<bool, int>(true, x.ValueAsInt);
                    }

                    x.Value = x.Maximum;
                    return new ValueTuple<bool, int>(false, x.ValueAsInt);
                }, GenericToken).ConfigureAwait(false);
                if (blnDoExtra)
                {
                    int intMainMugshotIndex = await CharacterObject.GetMainMugshotIndexAsync(GenericToken).ConfigureAwait(false);
                    await chkIsMainMugshot.DoThreadSafeAsync(y =>
                    {
                        if (intMugshotIndex - 1 == intMainMugshotIndex)
                            y.Checked = true;
                        else if (y.Checked)
                            y.Checked = false;
                    }, GenericToken).ConfigureAwait(false);

                    await UpdateMugshot(picMugshot, intMugshotIndex - 1, GenericToken).ConfigureAwait(false);
                }
                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudMugshotIndex_ValueChanged(object sender, EventArgs e)
        {
            try
            {
                if (await (await CharacterObject.GetMugshotsAsync(GenericToken).ConfigureAwait(false)).GetCountAsync(GenericToken).ConfigureAwait(false) == 0)
                {
                    await nudMugshotIndex.DoThreadSafeAsync(x =>
                    {
                        x.Minimum = 0;
                        x.Maximum = 0;
                        x.Value = 0;
                    }, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await nudMugshotIndex.DoThreadSafeAsync(x =>
                    {
                        x.Minimum = 1;
                        if (x.Value < x.Minimum)
                            x.Value = x.Maximum;
                        else if (x.Value > x.Maximum)
                            x.Value = x.Minimum;
                    }, GenericToken).ConfigureAwait(false);
                }

                int intMainMugshotIndex = await CharacterObject.GetMainMugshotIndexAsync(GenericToken).ConfigureAwait(false);
                int intCurrentMugshotIndex =
                    await nudMugshotIndex.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken).ConfigureAwait(false);
                if (intCurrentMugshotIndex - 1 == intMainMugshotIndex)
                    await chkIsMainMugshot.DoThreadSafeAsync(x => x.Checked = true, GenericToken).ConfigureAwait(false);
                else
                {
                    await chkIsMainMugshot.DoThreadSafeAsync(x =>
                    {
                        if (x.Checked)
                            x.Checked = false;
                    }, GenericToken).ConfigureAwait(false);
                }

                await UpdateMugshot(picMugshot, intCurrentMugshotIndex - 1, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkIsMainMugshot_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                bool blnStatusChanged = false;
                int intSelectedIndex = await nudMugshotIndex.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                            .ConfigureAwait(false);
                switch (await chkIsMainMugshot.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                              .ConfigureAwait(false))
                {
                    case true when CharacterObject.MainMugshotIndex != intSelectedIndex - 1:
                        CharacterObject.MainMugshotIndex = intSelectedIndex - 1;
                        blnStatusChanged = true;
                        break;

                    case false when intSelectedIndex - 1 == CharacterObject.MainMugshotIndex:
                        CharacterObject.MainMugshotIndex = -1;
                        blnStatusChanged = true;
                        break;
                }

                if (blnStatusChanged)
                {
                    await SetDirty(true).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddMetamagic_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker =
                        await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        if (await CharacterObject.GetMAGEnabledAsync(GenericToken).ConfigureAwait(false))
                        {
                            int intGrade = await CharacterObject.GetInitiateGradeAsync(GenericToken).ConfigureAwait(false);
                            // Make sure that the Initiate Grade is not attempting to go above the character's MAG CharacterAttribute.
                            if (intGrade + 1
                                > await (await CharacterObject.GetAttributeAsync("MAG", token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken).ConfigureAwait(false) ||
                                await CharacterObject.GetIsMysticAdeptAsync(GenericToken).ConfigureAwait(false) && await CharacterObjectSettings.GetMysAdeptSecondMAGAttributeAsync(GenericToken).ConfigureAwait(false)
                                && intGrade + 1
                                > await (await CharacterObject
                                        .GetAttributeAsync(
                                            "MAGAdept",
                                            token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken)
                                    .ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager.GetStringAsync("Message_CannotIncreaseInitiateGrade",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync("MessageTitle_CannotIncreaseInitiateGrade",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                return;
                            }

                            // Create the Initiate Grade object.
                            InitiationGrade objGrade = new InitiationGrade(CharacterObject);
                            await objGrade.CreateAsync(
                                await CharacterObject.GetInitiateGradeAsync(GenericToken).ConfigureAwait(false) + 1,
                                false,
                                await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false),
                                await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false),
                                await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                            await CharacterObject.InitiationGrades.AddWithSortAsync(objGrade, token: GenericToken)
                                .ConfigureAwait(false);
                        }
                        else if (await CharacterObject.GetRESEnabledAsync(GenericToken).ConfigureAwait(false))
                        {
                            string strText = await LanguageManager.GetStringAsync("Button_AddEcho", token: GenericToken)
                                .ConfigureAwait(false);
                            await cmsMetamagic.DoThreadSafeAsync(() =>
                            {
                                tsMetamagicAddArt.Visible = false;
                                tsMetamagicAddEnchantment.Visible = false;
                                tsMetamagicAddEnhancement.Visible = false;
                                tsMetamagicAddRitual.Visible = false;
                                tsMetamagicAddMetamagic.Text = strText;
                            }, GenericToken).ConfigureAwait(false);

                            // Make sure that the Initiate Grade is not attempting to go above the character's RES CharacterAttribute.
                            if (await CharacterObject.GetSubmersionGradeAsync(GenericToken).ConfigureAwait(false) + 1
                                > await (await CharacterObject.GetAttributeAsync("RES", token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken).ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager.GetStringAsync("Message_CannotIncreaseSubmersionGrade",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync("MessageTitle_CannotIncreaseSubmersionGrade",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK,
                                    MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                return;
                            }

                            // Create the Initiate Grade object.
                            InitiationGrade objGrade = new InitiationGrade(CharacterObject);
                            await objGrade.CreateAsync(
                                await CharacterObject.GetSubmersionGradeAsync(GenericToken).ConfigureAwait(false) + 1,
                                true,
                                await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false),
                                await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false),
                                await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                            await CharacterObject.InitiationGrades.AddWithSortAsync(objGrade, token: GenericToken)
                                .ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteMetamagic_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddCritterPower_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure the Critter is allowed to have Optional Powers.
                XmlDocument objXmlDocument
                    = await CharacterObject.LoadDataAsync("critterpowers.xml", token: GenericToken)
                                           .ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        using (ThreadSafeForm<SelectCritterPower> frmPickCritterPower
                               = await ThreadSafeForm<SelectCritterPower>.GetAsync(
                                   () => new SelectCritterPower(CharacterObject), GenericToken).ConfigureAwait(false))
                        {
                            if (await frmPickCritterPower.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;

                            blnAddAgain = frmPickCritterPower.MyForm.AddAgain;

                            XmlNode objXmlPower = objXmlDocument.TryGetNodeByNameOrId("/chummer/powers/power", frmPickCritterPower.MyForm.SelectedPower);
                            CritterPower objPower = new CritterPower(CharacterObject);
                            await objPower.CreateAsync(objXmlPower, frmPickCritterPower.MyForm.SelectedRating, token: GenericToken).ConfigureAwait(false);
                            objPower.PowerPoints = frmPickCritterPower.MyForm.PowerPoints;
                            if (objPower.InternalId.IsEmptyGuid())
                                continue;

                            await CharacterObject.CritterPowers.AddAsync(objPower, GenericToken).ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteCritterPower_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteComplexForm_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdDeleteAIProgram_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdLifeModule_Click(object sender, EventArgs e)
        {
            try
            {
                XPathNavigator xmlStagesParentNode
                    = (await CharacterObject.LoadDataXPathAsync("lifemodules.xml", token: GenericToken)
                                            .ConfigureAwait(false)).SelectSingleNode(
                        "chummer/stages");
                if (xmlStagesParentNode == null)
                    return;

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        //from 1 to second highest life module order possible (ye hardcoding is bad, but extra stage is a niche case)
                        int intStage;
                        for (intStage = 1; intStage < 5; ++intStage)
                        {
                            XPathNavigator xmlStageNode = xmlStagesParentNode
                                                                .SelectSingleNodeAndCacheExpression(
                                                                    "stage[@order = "
                                                                    + intStage.ToString(
                                                                                  GlobalSettings.InvariantCultureInfo)
                                                                              .CleanXPath()
                                                                    + "]", GenericToken);
                            if (xmlStageNode == null)
                            {
                                --intStage;
                                break;
                            }

                            if (!await CharacterObject.Qualities.AnyAsync(x => x.Type == QualityType.LifeModule
                                                                               && x.Stage == xmlStageNode.Value,
                                                                          GenericToken).ConfigureAwait(false))
                            {
                                break;
                            }
                        }

                        //i--; //Counter last increment
                        XmlNode objXmlLifeModule;
                        using (ThreadSafeForm<SelectLifeModule> frmSelectLifeModule
                               = await ThreadSafeForm<SelectLifeModule>.GetAsync(
                                                                           () => new SelectLifeModule(CharacterObject,
                                                                               intStage), GenericToken)
                                                                       .ConfigureAwait(false))
                        {
                            if (await frmSelectLifeModule.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;

                            blnAddAgain = frmSelectLifeModule.MyForm.AddAgain;
                            objXmlLifeModule = frmSelectLifeModule.MyForm.SelectedNode;
                        }

                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        Quality objLifeModule = new Quality(CharacterObject);
                        try
                        {
                            await objLifeModule.CreateAsync(objXmlLifeModule, QualitySource.LifeModule, lstWeapons, token: GenericToken).ConfigureAwait(false);
                            if (objLifeModule.InternalId.IsEmptyGuid())
                            {
                                await objLifeModule.DeleteQualityAsync(token: GenericToken).ConfigureAwait(false);
                                continue;
                            }

                            //Is there any reason not to add it?
                            if (true)
                            {
                                await CharacterObject.Qualities.AddAsync(objLifeModule, GenericToken).ConfigureAwait(false);

                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                                }
                            }
                        }
                        catch
                        {
                            await objLifeModule.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }

                        //Stupid hardcoding but no sane way
                        //To do group skills (not that anything else is sane)
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddQuality_Click(object sender, EventArgs e)
        {
            try
            {
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("qualities.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);

                CursorWait objCursorWait
                    = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        using (ThreadSafeForm<SelectQuality> frmPickQuality = await ThreadSafeForm<SelectQuality>
                                   .GetAsync(() => new SelectQuality(CharacterObject), GenericToken)
                                   .ConfigureAwait(false))
                        {
                            // Don't do anything else if the form was canceled.
                            if (await frmPickQuality.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;

                            blnAddAgain = frmPickQuality.MyForm.AddAgain;
                            int intRatingToAdd = frmPickQuality.MyForm.SelectedRating;
                            string strSelectedQuality = frmPickQuality.MyForm.SelectedQuality;
                            XmlNode objXmlQuality = objXmlDocument.TryGetNodeByNameOrId("/chummer/qualities/quality", strSelectedQuality);
                            int intDummy = 0;
                            if (objXmlQuality != null && objXmlQuality["nolevels"] == null
                                                      && objXmlQuality.TryGetInt32FieldQuickly(
                                                          "limit", ref intDummy))
                            {
                                intRatingToAdd -= await (await CharacterObject.GetQualitiesAsync(GenericToken).ConfigureAwait(false))
                                    .CountAsync(async x =>
                                        (await x.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false))
                                            .Equals(strSelectedQuality, StringComparison.OrdinalIgnoreCase)
                                        && string.IsNullOrEmpty(await x.GetSourceNameAsync(GenericToken).ConfigureAwait(false)), GenericToken).ConfigureAwait(false);
                            }

                            // Helps to capture a write lock here for performance purposes
                            IAsyncDisposable objLocker = await CharacterObject
                                                               .LockObject.EnterWriteLockAsync(GenericToken)
                                                               .ConfigureAwait(false);
                            try
                            {
                                GenericToken.ThrowIfCancellationRequested();
                                for (int i = 1; i <= intRatingToAdd; ++i)
                                {
                                    List<Weapon> lstWeapons = new List<Weapon>(1);
                                    Quality objQuality = new Quality(CharacterObject);
                                    try
                                    {
                                        await objQuality.CreateAsync(objXmlQuality, QualitySource.Selected, lstWeapons,
                                            token: GenericToken).ConfigureAwait(false);
                                        if (objQuality.InternalId.IsEmptyGuid())
                                        {
                                            // If the Quality could not be added, remove the Improvements that were added during the Quality Creation process.
                                            await objQuality.DeleteQualityAsync(token: GenericToken).ConfigureAwait(false);
                                            break;
                                        }

                                        if (frmPickQuality.MyForm.FreeCost)
                                            await objQuality.SetBPAsync(0, GenericToken).ConfigureAwait(false);

                                        // Make sure that adding the Quality would not cause the character to exceed their BP limits.
                                        bool blnAddItem = true;
                                        if (await objQuality.GetContributeToLimitAsync(GenericToken).ConfigureAwait(false) && !await CharacterObject.GetIgnoreRulesAsync(GenericToken).ConfigureAwait(false))
                                        {
                                            // If the item being checked would cause the limit of 25 BP spent on Positive Qualities to be exceed, do not let it be checked and display a message.
                                            int intMaxQualityAmount = await CharacterObjectSettings.GetQualityKarmaLimitAsync(GenericToken).ConfigureAwait(false);
                                            string strAmount =
                                                intMaxQualityAmount.ToString(
                                                    GlobalSettings.CultureInfo) +
                                                await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                                                     .ConfigureAwait(false) +
                                                await LanguageManager.GetStringAsync("String_Karma", token: GenericToken)
                                                                     .ConfigureAwait(false);

                                            // Add the cost of the Quality that is being added.
                                            int intBP = await objQuality.GetBPAsync(GenericToken).ConfigureAwait(false);

                                            if (await objQuality.GetTypeAsync(GenericToken).ConfigureAwait(false) == QualityType.Negative)
                                            {
                                                // Check if adding this Quality would put the character over their limit.
                                                if (!await CharacterObjectSettings.GetExceedNegativeQualitiesAsync(GenericToken).ConfigureAwait(false))
                                                {
                                                    intBP += await CharacterObject.GetNegativeQualityLimitKarmaAsync(GenericToken).ConfigureAwait(false);
                                                    if (intBP < intMaxQualityAmount * -1)
                                                    {
                                                        await Program.ShowScrollableMessageBoxAsync(this,
                                                            string.Format(GlobalSettings.CultureInfo,
                                                                await LanguageManager.GetStringAsync(
                                                                        "Message_NegativeQualityLimit", token: GenericToken)
                                                                    .ConfigureAwait(false),
                                                                strAmount),
                                                            await LanguageManager.GetStringAsync(
                                                                    "MessageTitle_NegativeQualityLimit", token: GenericToken)
                                                                .ConfigureAwait(false),
                                                            MessageBoxButtons.OK,
                                                            MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                                        blnAddItem = false;
                                                    }
                                                    else if (await CharacterObject.GetMetatypeBPAsync(GenericToken).ConfigureAwait(false) < 0
                                                             && intBP + await CharacterObject.GetMetatypeBPAsync(GenericToken).ConfigureAwait(false)
                                                             < intMaxQualityAmount * -1)
                                                    {
                                                        await Program.ShowScrollableMessageBoxAsync(this,
                                                            string.Format(GlobalSettings.CultureInfo,
                                                                await LanguageManager.GetStringAsync(
                                                                        "Message_NegativeQualityAndMetatypeLimit", token: GenericToken)
                                                                    .ConfigureAwait(false),
                                                                strAmount),
                                                            await LanguageManager.GetStringAsync(
                                                                    "MessageTitle_NegativeQualityLimit", token: GenericToken)
                                                                .ConfigureAwait(false),
                                                            MessageBoxButtons.OK,
                                                            MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                                        blnAddItem = false;
                                                    }
                                                }
                                            }
                                            // Check if adding this Quality would put the character over their limit.
                                            else if (!await CharacterObjectSettings.GetExceedPositiveQualitiesAsync(GenericToken).ConfigureAwait(false))
                                            {
                                                intBP += await CharacterObject.GetPositiveQualityLimitKarmaAsync(GenericToken).ConfigureAwait(false);
                                                if (intBP > intMaxQualityAmount)
                                                {
                                                    await Program.ShowScrollableMessageBoxAsync(this,
                                                        string.Format(GlobalSettings.CultureInfo,
                                                            await LanguageManager.GetStringAsync(
                                                                    "Message_PositiveQualityLimit", token: GenericToken)
                                                                .ConfigureAwait(false),
                                                            strAmount),
                                                        await LanguageManager.GetStringAsync(
                                                                "MessageTitle_PositiveQualityLimit", token: GenericToken)
                                                            .ConfigureAwait(false),
                                                        MessageBoxButtons.OK,
                                                        MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                                    blnAddItem = false;
                                                }
                                            }
                                        }

                                        if (blnAddItem)
                                        {
                                            await CharacterObject.Qualities.AddAsync(objQuality, GenericToken)
                                                                 .ConfigureAwait(false);

                                            // Add any created Weapons to the character.
                                            foreach (Weapon objWeapon in lstWeapons)
                                            {
                                                await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                                                     .ConfigureAwait(false);
                                            }
                                        }
                                        else
                                        {
                                            await objQuality.DeleteQualityAsync(token: GenericToken).ConfigureAwait(false);
                                            break;
                                        }
                                    }
                                    catch
                                    {
                                        await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }
                            }
                            finally
                            {
                                await objLocker.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task<bool> RemoveQuality(Quality objSelectedQuality, bool blnConfirmDelete = true,
                                                    bool blnCompleteDelete = true, CancellationToken token = default)
        {
            XmlNode objXmlDeleteQuality = await objSelectedQuality.GetNodeAsync(token: token).ConfigureAwait(false);
            switch (await objSelectedQuality.GetOriginSourceAsync(token).ConfigureAwait(false))
            {
                // Qualities that come from a Metatype cannot be removed.
                case QualitySource.Metatype:
                case QualitySource.Heritage:
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_MetavariantQuality", token: token)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_MetavariantQuality", token: token)
                            .ConfigureAwait(false), MessageBoxButtons.OK, MessageBoxIcon.Information, token: token).ConfigureAwait(false);
                    return false;

                case QualitySource.Improvement:
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        string.Format(GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync("Message_ImprovementQuality", token: token)
                                .ConfigureAwait(false),
                            await objSelectedQuality.DisplaySourceNameAsync(GlobalSettings.Language, token)
                                .ConfigureAwait(false)),
                        await LanguageManager.GetStringAsync("MessageTitle_MetavariantQuality", token: token)
                            .ConfigureAwait(false), MessageBoxButtons.OK, MessageBoxIcon.Information, token: token).ConfigureAwait(false);
                    return false;
            }

            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker = await objSelectedQuality.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    if (await objSelectedQuality.GetOriginSourceAsync(token).ConfigureAwait(false) == QualitySource.MetatypeRemovable)
                    {
                        int intBP = 0;
                        if (await objSelectedQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.Negative
                            && objXmlDeleteQuality?.TryGetInt32FieldQuickly("karma", ref intBP) == false)
                        {
                            intBP = -intBP;
                        }

                        intBP *= await CharacterObjectSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);
                        int intShowBP = intBP;
                        if (blnCompleteDelete)
                            intShowBP *= await objSelectedQuality.GetLevelsAsync(token).ConfigureAwait(false);
                        string strBP = intShowBP.ToString(GlobalSettings.CultureInfo)
                                       + await LanguageManager.GetStringAsync("String_Space", token: token)
                                           .ConfigureAwait(false)
                                       + await LanguageManager.GetStringAsync("String_Karma", token: token)
                                           .ConfigureAwait(false);

                        if (blnConfirmDelete &&
                            !await CommonFunctions.ConfirmDeleteAsync(string.Format(GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync(
                                    blnCompleteDelete
                                        ? "Message_DeleteMetatypeQuality"
                                        : "Message_LowerMetatypeQualityLevel",
                                    token: token).ConfigureAwait(false),
                                strBP), token).ConfigureAwait(false))
                            return false;

                        // Remove any Improvements that the Quality might have.
                        if (objXmlDeleteQuality != null)
                        {
                            XmlNode xmlDeleteQualityNoBonus = objXmlDeleteQuality.Clone();
                            if (xmlDeleteQualityNoBonus["bonus"] != null)
                                xmlDeleteQualityNoBonus["bonus"].InnerText = string.Empty;
                            if (xmlDeleteQualityNoBonus["firstlevelbonus"] != null)
                                xmlDeleteQualityNoBonus["firstlevelbonus"].InnerText = string.Empty;

                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            Quality objReplaceQuality = new Quality(CharacterObject);
                            try
                            {
                                await objReplaceQuality.CreateAsync(xmlDeleteQualityNoBonus,
                                    QualitySource.MetatypeRemovedAtChargen,
                                    lstWeapons, token: token).ConfigureAwait(false);
                                await objReplaceQuality.SetBPAsync(-await objReplaceQuality.GetBPAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                                // If a Negative Quality is being bought off, the replacement one is Positive.
                                if (await objSelectedQuality.GetTypeAsync(token).ConfigureAwait(false) ==
                                    QualityType.Positive)
                                {
                                    objReplaceQuality.Type = QualityType.Negative;
                                    if (!string.IsNullOrEmpty(objReplaceQuality.Extra))
                                        objReplaceQuality.Extra += "," + await LanguageManager
                                            .GetStringAsync("String_Space", token: token)
                                            .ConfigureAwait(false);
                                    objReplaceQuality.Extra
                                        += await LanguageManager
                                            .GetStringAsync("String_ExpenseRemovePositiveQuality", token: token)
                                            .ConfigureAwait(false);
                                }
                                else
                                {
                                    objReplaceQuality.Type = QualityType.Positive;
                                    if (!string.IsNullOrEmpty(objReplaceQuality.Extra))
                                        objReplaceQuality.Extra += "," + await LanguageManager
                                            .GetStringAsync("String_Space", token: token)
                                            .ConfigureAwait(false);
                                    objReplaceQuality.Extra
                                        += await LanguageManager
                                            .GetStringAsync("String_ExpenseRemoveNegativeQuality", token: token)
                                            .ConfigureAwait(false);
                                }

                                // The replacement Quality does not count towards the BP limit of the new type, nor should it be printed.
                                objReplaceQuality.AllowPrint = false;
                                await objReplaceQuality.SetContributeToLimitAsync(false, token).ConfigureAwait(false);
                                await CharacterObject.Qualities.AddAsync(objReplaceQuality, token)
                                    .ConfigureAwait(false);
                                // The replacement Quality no longer adds its weapons to the character
                            }
                            catch
                            {
                                await objReplaceQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    }
                    else
                    {
                        if (blnConfirmDelete && !await CommonFunctions.ConfirmDeleteAsync(
                                blnCompleteDelete
                                    ? await LanguageManager.GetStringAsync("Message_DeleteQuality", token: token)
                                        .ConfigureAwait(false)
                                    : await LanguageManager.GetStringAsync("Message_LowerQualityLevel", token: token)
                                        .ConfigureAwait(false), token).ConfigureAwait(false))
                            return false;

                        if (await objSelectedQuality.GetOriginSourceAsync(token).ConfigureAwait(false) == QualitySource.MetatypeRemovedAtChargen)
                        {
                            XPathNavigator xmlCharacterNode
                                = await CharacterObject.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                            if (xmlCharacterNode != null)
                            {
                                XmlDocument xmlQualitiesDoc
                                    = await CharacterObject.LoadDataAsync("qualities.xml", token: token)
                                        .ConfigureAwait(false);
                                // Create the Qualities that come with the Metatype.
                                foreach (XPathNavigator objXmlQualityItem in xmlCharacterNode.Select(
                                             "qualities/*/quality[. = " + (await objSelectedQuality.GetNameAsync(token).ConfigureAwait(false)).CleanXPath() + "]"))
                                {
                                    XmlNode objXmlQuality
                                        = xmlQualitiesDoc.TryGetNodeByNameOrId(
                                            "/chummer/qualities/quality", objXmlQualityItem.Value);
                                    string strForceValue = objXmlQualityItem.GetAttribute("select", string.Empty);
                                    QualitySource objSource
                                        = objXmlQualityItem.GetAttribute("removable", string.Empty)
                                          == bool.TrueString
                                            ? QualitySource.MetatypeRemovable
                                            : QualitySource.Metatype;
                                    Quality objQuality = new Quality(CharacterObject);
                                    try
                                    {
                                        await objQuality.CreateAsync(objXmlQuality, objSource, await CharacterObject.GetWeaponsAsync(token).ConfigureAwait(false),
                                            strForceValue, token: token).ConfigureAwait(false);
                                        await CharacterObject.Qualities.AddAsync(objQuality, token)
                                            .ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }
                            }
                        }
                    }

                    if (await objSelectedQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.LifeModule)
                    {
                        objXmlDeleteQuality
                            = Quality.GetNodeOverrideable(objSelectedQuality.SourceIDString,
                                await CharacterObject.LoadDataAsync(
                                    "lifemodules.xml", token: token).ConfigureAwait(false));
                    }

                    // Fix for legacy characters with old addqualities improvements.
                    if (objXmlDeleteQuality != null)
                        await RemoveAddedQualities(
                            objXmlDeleteQuality.SelectAndCacheExpressionAsNavigator("addqualities/addquality", token),
                            token: token).ConfigureAwait(false);
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                // Perform removal
                await objSelectedQuality.DeleteQualityAsync(blnCompleteDelete, token).ConfigureAwait(false);
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }

            return true;
        }

        private async void cmdDeleteQuality_Click(object sender, EventArgs e)
        {
            try
            {
                await DeleteQuality(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DeleteQuality(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            // Locate the selected Quality.
            if (!(await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                    Quality objSelectedQuality))
                return;
            string strInternalIDToRemove = objSelectedQuality.InternalId;
            // Can't do a foreach because we're removing items, this is the next best thing
            bool blnFirstRemoval = true;
            // Helps to capture a write lock here for performance purposes
            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterWriteLockAsync(token)
                                                              .ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                for (int i = await CharacterObject.Qualities.GetCountAsync(token).ConfigureAwait(false) - 1; i >= 0; --i)
                {
                    Quality objLoopQuality = await CharacterObject.Qualities.GetValueAtAsync(i, token).ConfigureAwait(false);
                    if (objLoopQuality.InternalId != strInternalIDToRemove)
                        continue;
                    if (!await RemoveQuality(objLoopQuality, blnFirstRemoval, token: token).ConfigureAwait(false))
                        break;
                    blnFirstRemoval = false;
                    int intCount = await CharacterObject.Qualities.GetCountAsync(token).ConfigureAwait(false);
                    if (i > intCount)
                    {
                        i = intCount;
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async void cmdAddLocation_Click(object sender, EventArgs e)
        {
            try
            {
                // Add a new location to the Armor Tree.
                string strDescription = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken)
                                                             .ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel
                        || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                        return;
                    Location objLocation = new Location(CharacterObject, CharacterObject.GearLocations,
                                                        frmPickText.MyForm.SelectedValue);
                    await CharacterObject.GearLocations.AddAsync(objLocation, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddWeaponLocation_Click(object sender, EventArgs e)
        {
            try
            {
                // Add a new location to the Armor Tree.
                string strDescription = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken)
                                                             .ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel
                        || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                        return;
                    Location objLocation = new Location(CharacterObject, CharacterObject.WeaponLocations,
                                                        frmPickText.MyForm.SelectedValue);
                    await CharacterObject.WeaponLocations.AddAsync(objLocation, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdCreateStackedFocus_Click(object sender, EventArgs e)
        {
            try
            {
                // Run through all the Foci the character has and count the un-Bonded ones.
                List<Gear> lstGear
                    = await CharacterObject.Gear.ToListAsync(x =>
                        (x.Category == "Foci" || x.Category == "Metamagic Foci") && !x.Bonded, GenericToken).ConfigureAwait(false);

                // If the character does not have at least 2 un-Bonded Foci, display an error and leave.
                if (lstGear.Count < 2)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CannotStackFoci", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                List<Gear> lstStack = new List<Gear>(lstGear.Count);
                string strDescription
                    = await LanguageManager.GetStringAsync("String_SelectItemFocus", token: GenericToken).ConfigureAwait(false);
                DialogResult eResult;
                // Let the character select the Foci they'd like to stack, stopping when they either click Cancel or there are no more items left in the list.
                do
                {
                    using (ThreadSafeForm<SelectItem> frmPickItem = await ThreadSafeForm<SelectItem>.GetAsync(
                               () => new SelectItem
                               {
                                   AllowAutoSelect = false
                               }, GenericToken).ConfigureAwait(false))
                    {
                        await frmPickItem.MyForm.DoThreadSafeAsync(x => x.Description = strDescription, GenericToken).ConfigureAwait(false);
                        frmPickItem.MyForm.SetGearMode(lstGear);
                        eResult = await frmPickItem.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false);
                        if (eResult != DialogResult.OK)
                            continue;
                        string strSelected = await frmPickItem.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, GenericToken).ConfigureAwait(false);
                        // Move the item from the Gear list to the Stack list.
                        foreach (Gear objGear in lstGear)
                        {
                            if (objGear.InternalId == strSelected)
                            {
                                objGear.Bonded = true;
                                lstStack.Add(objGear);
                                lstGear.Remove(objGear);
                                break;
                            }
                        }
                    }
                } while (lstGear.Count > 0 && eResult != DialogResult.Cancel);

                // Make sure at least 2 Foci were selected.
                if (lstStack.Count < 2)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_StackedFocusMinimum", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Make sure the combined Force of the Foci do not exceed 6.
                if (!CharacterObjectSettings.AllowHigherStackedFoci)
                {
                    int intCombined = await lstStack.SumAsync(objGear => objGear.GetRatingAsync(GenericToken), GenericToken).ConfigureAwait(false);
                    if (intCombined > 6)
                    {
                        foreach (Gear objGear in lstStack)
                            objGear.Bonded = false;
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_StackedFocusForce", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_CannotStackFoci", token: GenericToken).ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                    }
                }

                // Create the Stacked Focus.
                StackedFocus objStack = new StackedFocus(CharacterObject);
                foreach (Gear objGear in lstStack)
                    await objStack.Gear.AddAsync(objGear, GenericToken).ConfigureAwait(false);
                await CharacterObject.StackedFoci.AddAsync(objStack, GenericToken).ConfigureAwait(false);

                // Remove the Gear from the character and replace it with a Stacked Focus item.
                decimal decCost = 0;
                foreach (Gear objGear in lstStack)
                {
                    decCost += await objGear.GetTotalCostAsync(GenericToken).ConfigureAwait(false);
                    await CharacterObject.Gear.RemoveAsync(objGear, GenericToken).ConfigureAwait(false);
                }

                Gear objStackItem = new Gear(CharacterObject)
                {
                    Category = "Stacked Focus",
                    Name = "Stacked Focus: "
                           + await objStack.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false),
                    MinRating = string.Empty,
                    MaxRating = string.Empty,
                    Source = "SR5",
                    Page = "1",
                    Cost = decCost.ToString(GlobalSettings.CultureInfo),
                    Avail = "0"
                };

                await CharacterObject.Gear.AddAsync(objStackItem, GenericToken).ConfigureAwait(false);

                objStack.GearId = objStackItem.InternalId;
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddArmor_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddArmor(
                        await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                            .ConfigureAwait(false) as Location, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task<bool> AddArmor(Location objLocation = null, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    using (ThreadSafeForm<SelectArmor> frmPickArmor = await ThreadSafeForm<SelectArmor>
                               .GetAsync(() => new SelectArmor(CharacterObject),
                                   token).ConfigureAwait(false))
                    {
                        // Make sure the dialogue window was not canceled.
                        if (await frmPickArmor.ShowDialogSafeAsync(this, token).ConfigureAwait(false) ==
                            DialogResult.Cancel)
                            return false;

                        // Open the Armor XML file and locate the selected piece.
                        XmlNode objXmlArmor
                            = (await CharacterObject.LoadDataAsync("armor.xml", token: token).ConfigureAwait(false))
                            .TryGetNodeByNameOrId(
                                "/chummer/armors/armor", frmPickArmor.MyForm.SelectedArmor);

                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        Armor objArmor = new Armor(CharacterObject);
                        try
                        {
                            await objArmor.CreateAsync(objXmlArmor, frmPickArmor.MyForm.Rating, lstWeapons, token: token)
                                .ConfigureAwait(false);
                            objArmor.DiscountCost = frmPickArmor.MyForm.BlackMarketDiscount;
                            if (objArmor.InternalId.IsEmptyGuid())
                            {
                                foreach (Weapon objWeapon in lstWeapons)
                                    await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                await objArmor.DeleteArmorAsync(token: CancellationToken.None).ConfigureAwait(false);
                                return frmPickArmor.MyForm.AddAgain;
                            }
                            if (frmPickArmor.MyForm.FreeCost)
                            {
                                objArmor.Cost = "0";
                            }

                            //objArmor.Location = objLocation;
                            if (objLocation != null)
                                await objLocation.Children.AddAsync(objArmor, token).ConfigureAwait(false);
                            await CharacterObject.Armor.AddAsync(objArmor, token).ConfigureAwait(false);

                            foreach (Weapon objWeapon in lstWeapons)
                            {
                                await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                            }

                            return frmPickArmor.MyForm.AddAgain;
                        }
                        catch
                        {
                            foreach (Weapon objWeapon in lstWeapons)
                                await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                            await objArmor.DeleteArmorAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async void cmdAddArmorBundle_Click(object sender, EventArgs e)
        {
            try
            {
                // Add a new location to the Armor Tree.
                string strDescription = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken)
                                                             .ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel
                        || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                        return;
                    Location objLocation = new Location(CharacterObject, CharacterObject.ArmorLocations,
                                                        frmPickText.MyForm.SelectedValue);
                    await CharacterObject.ArmorLocations.AddAsync(objLocation, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdArmorEquipAll_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token: GenericToken)
                                                   .ConfigureAwait(false);
                if (objSelected is Location selectedLocation)
                {
                    // Equip all of the Armor in the Armor Bundle.
                    await selectedLocation.Children.ForEachWithSideEffectsAsync(async child =>
                    {
                        if (child is Armor objArmor && objArmor.Location == selectedLocation && !objArmor.Equipped)
                        {
                            await objArmor.SetEquippedAsync(true, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }
                else if (objSelected?.ToString() == "Node_SelectedArmor")
                {
                    await CharacterObject.Armor.ForEachWithSideEffectsAsync(async objArmor =>
                    {
                        if (!objArmor.Equipped && objArmor.Location == null)
                        {
                            await objArmor.SetEquippedAsync(true, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await CharacterObject.Armor.ForEachWithSideEffectsAsync(async objArmor =>
                    {
                        if (!objArmor.Equipped)
                        {
                            await objArmor.SetEquippedAsync(true, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdArmorUnEquipAll_Click(object sender, EventArgs e)
        {
            try
            {
                object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token: GenericToken)
                                                   .ConfigureAwait(false);
                if (objSelected is Location selectedLocation)
                {
                    // Equip all of the Armor in the Armor Bundle.
                    await selectedLocation.Children.ForEachWithSideEffectsAsync(async child =>
                    {
                        if (child is Armor objArmor && objArmor.Location == selectedLocation && objArmor.Equipped)
                        {
                            await objArmor.SetEquippedAsync(false, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }
                else if (objSelected?.ToString() == "Node_SelectedArmor")
                {
                    await CharacterObject.Armor.ForEachWithSideEffectsAsync(async objArmor =>
                    {
                        if (objArmor.Equipped && objArmor.Location == null)
                        {
                            await objArmor.SetEquippedAsync(false, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await CharacterObject.Armor.ForEachWithSideEffectsAsync(async objArmor =>
                    {
                        if (objArmor.Equipped)
                        {
                            await objArmor.SetEquippedAsync(false, GenericToken).ConfigureAwait(false);
                        }
                    }, GenericToken).ConfigureAwait(false);
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdAddVehicleLocation_Click(object sender, EventArgs e)
        {
            try
            {
                ThreadSafeObservableCollection<Location> destCollection;
                // Make sure a Vehicle is selected.
                object objSelected
                    = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token: GenericToken)
                                       .ConfigureAwait(false);
                if (objSelected is Vehicle objVehicle)
                {
                    destCollection = objVehicle.Locations;
                }
                else if (objSelected == null || objSelected.ToString() == "Node_SelectedVehicles")
                {
                    destCollection = CharacterObject.VehicleLocations;
                }
                else
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectVehicleLocation", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken)
                                                             .ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel
                        || string.IsNullOrEmpty(frmPickText.MyForm.SelectedValue))
                        return;
                    Location objLocation
                        = new Location(CharacterObject, destCollection, frmPickText.MyForm.SelectedValue);
                    await destCollection.AddAsync(objLocation, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Button Events

        #region ContextMenu Events

        private async void InitiationContextMenu_Opening(object sender, CancelEventArgs e)
        {
            try
            {
                // Enable and disable menu items
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is InitiationGrade objGrade))
                    return;
                int intGrade = objGrade.Grade;
                bool blnHasArt = await CharacterObject.Arts.AnyAsync(art => art.Grade == intGrade, GenericToken)
                    .ConfigureAwait(false);
                bool blnHasBonus = await CharacterObject.Metamagics
                                       .AnyAsync(bonus => bonus.Grade == intGrade, GenericToken)
                                       .ConfigureAwait(false)
                                   || await CharacterObject.Spells
                                       .AnyAsync(spell => spell.Grade == intGrade, GenericToken)
                                       .ConfigureAwait(false);
                await this.DoThreadSafeAsync(() =>
                {
                    tsMetamagicAddArt.Enabled = !blnHasArt;
                    tsMetamagicAddMetamagic.Enabled = !blnHasBonus;
                }, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Cyberware window.
                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is Cyberware
                        objCyberware && !string.IsNullOrWhiteSpace(objCyberware.AllowedSubsystems)))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectCyberware", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickCyberware(objCyberware, objCyberware.SourceType, token: GenericToken)
                        .ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleCyberwareAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Cyberware window.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Cyberware
                        objCyberware && !string.IsNullOrWhiteSpace(objCyberware.AllowedSubsystems)))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectCyberware", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickCyberware(objCyberware, objCyberware.SourceType, token: GenericToken)
                        .ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponAddAccessory_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag,
                                                             GenericToken).ConfigureAwait(false) is Weapon objWeapon))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectWeaponAccessory", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Accessories cannot be added to Cyberweapons.
                if (objWeapon.Cyberware)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_CyberweaponNoAccessory", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberweaponNoAccessory", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Weapons XML file and locate the selected Weapon.
                XmlNode objXmlWeapon = await objWeapon.GetNodeAsync(GenericToken).ConfigureAwait(false);
                if (objXmlWeapon == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CannotFindWeapon", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                XmlDocument xmlDocument = await CharacterObject.LoadDataAsync("weapons.xml", token: GenericToken).ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        // Make sure the Weapon allows Accessories to be added to it.
                        if (!objWeapon.AllowAccessory)
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_CannotModifyWeapon", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            break;
                        }

                        using (ThreadSafeForm<SelectWeaponAccessory> frmPickWeaponAccessory
                               = await ThreadSafeForm<SelectWeaponAccessory>.GetAsync(
                                   () => new SelectWeaponAccessory(CharacterObject), GenericToken).ConfigureAwait(false))
                        {
                            await frmPickWeaponAccessory.MyForm.SetWeapon(objWeapon, GenericToken).ConfigureAwait(false);
                            if (await frmPickWeaponAccessory.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;
                            blnAddAgain = frmPickWeaponAccessory.MyForm.AddAgain;

                            // Locate the selected piece.
                            objXmlWeapon = xmlDocument.TryGetNodeByNameOrId("/chummer/accessories/accessory", frmPickWeaponAccessory.MyForm.SelectedAccessory);

                            WeaponAccessory objAccessory = new WeaponAccessory(CharacterObject);
                            try
                            {
                                await objAccessory.CreateAsync(objXmlWeapon, frmPickWeaponAccessory.MyForm.SelectedMount,
                                    frmPickWeaponAccessory.MyForm.SelectedRating, token: GenericToken).ConfigureAwait(false);
                                await objAccessory.SetParentAsync(objWeapon, GenericToken).ConfigureAwait(false);
                                objAccessory.DiscountCost = frmPickWeaponAccessory.MyForm.BlackMarketDiscount;

                                if (frmPickWeaponAccessory.MyForm.FreeCost)
                                {
                                    objAccessory.Cost = "0";
                                }

                                await objWeapon.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                            }
                            catch
                            {
                                await objAccessory.DeleteWeaponAccessoryAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAddArmorMod_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent item is selected, then open the Select Accessory window.
                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is Armor objArmor))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Armor XML file and locate the selected Armor.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("armor.xml", token: GenericToken).ConfigureAwait(false);

                XmlNode objXmlArmor = await objArmor.GetNodeAsync(GenericToken).ConfigureAwait(false);

                string strAllowedCategories = objArmor.Category + "," + objArmor.Name;
                bool blnExcludeGeneralCategory = false;
                XmlElement xmlAddModCategory = objXmlArmor["forcemodcategory"];
                if (xmlAddModCategory != null)
                {
                    strAllowedCategories = xmlAddModCategory.InnerTextViaPool(GenericToken);
                    blnExcludeGeneralCategory = true;
                }
                else
                {
                    xmlAddModCategory = objXmlArmor["addmodcategory"];
                    if (xmlAddModCategory != null)
                    {
                        strAllowedCategories += "," + xmlAddModCategory.InnerTextViaPool(GenericToken);
                    }
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectArmorMod> frmPickArmorMod
                                   = await ThreadSafeForm<SelectArmorMod>.GetAsync(
                                       () => new SelectArmorMod(CharacterObject, objArmor)
                                       {
                                           AllowedCategories = strAllowedCategories,
                                           ExcludeGeneralCategory = blnExcludeGeneralCategory
                                       }, GenericToken).ConfigureAwait(false))
                            {
                                if (await frmPickArmorMod.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickArmorMod.MyForm.AddAgain;

                                // Locate the selected piece.
                                objXmlArmor = objXmlDocument.TryGetNodeByNameOrId("/chummer/mods/mod",
                                    frmPickArmorMod.MyForm.SelectedArmorMod);

                                List<Weapon> lstWeapons = new List<Weapon>(1);
                                int.TryParse(objXmlArmor["maxrating"]?.InnerTextViaPool(GenericToken), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intMaxRating);
                                int intRating
                                        = intMaxRating > 1
                                            ? frmPickArmorMod.MyForm.SelectedRating
                                            : 0;
                                ArmorMod objMod = new ArmorMod(CharacterObject, objArmor);
                                try
                                {
                                    await objMod.CreateAsync(objXmlArmor, intRating, lstWeapons, token: GenericToken)
                                        .ConfigureAwait(false);
                                    if (objMod.InternalId.IsEmptyGuid())
                                    {
                                        foreach (Weapon objWeapon in lstWeapons)
                                            await objWeapon.DeleteWeaponAsync(token: GenericToken).ConfigureAwait(false);
                                        await objMod.DeleteArmorModAsync(token: GenericToken).ConfigureAwait(false);
                                        continue;
                                    }

                                    if (frmPickArmorMod.MyForm.FreeCost)
                                    {
                                        objMod.Cost = "0";
                                    }

                                    await objArmor.ArmorMods.AddAsync(objMod, GenericToken).ConfigureAwait(false);

                                    // Add any Weapons created by the Mod.
                                    foreach (Weapon objWeapon in lstWeapons)
                                    {
                                        await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                            .ConfigureAwait(false);
                                    }
                                }
                                catch
                                {
                                    foreach (Weapon objWeapon in lstWeapons)
                                        await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                    await objMod.DeleteArmorModAsync(token: CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Cyberware window.
                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is Gear objGear))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectGear", token: GenericToken)
                            .ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickGear(objGear.InternalId, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleAddWeaponMount_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Vehicle
                        objVehicle))
                    return;
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    using (ThreadSafeForm<CreateWeaponMount> frmPickVehicleMod
                           = await ThreadSafeForm<CreateWeaponMount>.GetAsync(
                               () => new CreateWeaponMount(objVehicle, CharacterObject), GenericToken).ConfigureAwait(false))
                    {
                        if (await frmPickVehicleMod.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;
                        await objVehicle.WeaponMounts.AddAsync(frmPickVehicleMod.MyForm.WeaponMount, GenericToken)
                                        .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleAddMod_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x =>
                {
                    TreeNode objTemp = x.SelectedNode;
                    while (objTemp?.Level > 1)
                        objTemp = objTemp.Parent;
                    return objTemp;
                }, GenericToken).ConfigureAwait(false);

                // Make sure a parent items is selected, then open the Select Vehicle Mod window.
                if (!(objSelectedNode?.Tag is Vehicle objVehicle))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectVehicle", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Vehicles XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("vehicles.xml", token: GenericToken).ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        using (ThreadSafeForm<SelectVehicleMod> frmPickVehicleMod
                               = await ThreadSafeForm<SelectVehicleMod>.GetAsync(
                                                                           () => new SelectVehicleMod(CharacterObject,
                                                                               objVehicle), GenericToken)
                                                                       .ConfigureAwait(false))
                        {
                            // Make sure the dialogue window was not canceled.
                            if (await frmPickVehicleMod.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;
                            blnAddAgain = frmPickVehicleMod.MyForm.AddAgain;

                            XmlNode objXmlMod
                                = objXmlDocument.TryGetNodeByNameOrId("/chummer/mods/mod", frmPickVehicleMod.MyForm.SelectedMod);

                            VehicleMod objMod = new VehicleMod(CharacterObject);
                            try
                            {
                                objMod.DiscountCost = frmPickVehicleMod.MyForm.BlackMarketDiscount;
                                await objMod.CreateAsync(objXmlMod, frmPickVehicleMod.MyForm.SelectedRating, objVehicle, token: GenericToken).ConfigureAwait(false);

                                // Check the item's Cost and make sure the character can afford it.
                                if (frmPickVehicleMod.MyForm.FreeCost)
                                    objMod.Cost = "0";

                                await objVehicle.Mods.AddAsync(objMod, GenericToken).ConfigureAwait(false);
                            }
                            catch
                            {
                                await objMod.DeleteVehicleModAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleAddWeaponWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is IHasInternalId
                        selectedObject))
                    return;
                string strSelectedId = selectedObject.InternalId;
                // Make sure that a Weapon Mount has been selected.
                // Attempt to locate the selected VehicleMod.
                VehicleMod objMod = null;
                WeaponMount objWeaponMount = null;
                if (!string.IsNullOrEmpty(strSelectedId))
                {
                    (objWeaponMount, _) = await CharacterObject.Vehicles.FindVehicleWeaponMountAsync(strSelectedId, GenericToken).ConfigureAwait(false);
                    if (objWeaponMount == null)
                    {
                        (objMod, _, objWeaponMount) = await CharacterObject.Vehicles.FindVehicleModAsync(x => x.InternalId == strSelectedId, GenericToken).ConfigureAwait(false);
                        if (objMod?.Name.StartsWith("Mechanical Arm", StringComparison.Ordinal) == false
                            && !objMod.Name.Contains("Drone Arm"))
                        {
                            objMod = null;
                        }
                    }
                }

                if (objWeaponMount == null && objMod == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CannotAddWeapon", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotAddWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                if (objWeaponMount?.IsWeaponsFull == true)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_WeaponMountFull", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotAddWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddWeaponToWeaponMount(objWeaponMount, objMod, GenericToken)
                        .ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task<bool> AddWeaponToWeaponMount(WeaponMount objWeaponMount, VehicleMod objMod, CancellationToken token = default)
        {
            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(
                           () => new SelectWeapon(CharacterObject)
                           {
                               LimitToCategories = objMod == null
                                   ? objWeaponMount.AllowedWeaponCategories
                                   : objMod.WeaponMountCategories,
                               WeaponFilter = objMod == null
                                   ? objWeaponMount.WeaponFilter
                                   : string.Empty
                           }, token).ConfigureAwait(false))
                {
                    if (await frmPickWeapon.ShowDialogSafeAsync(this, token).ConfigureAwait(false) ==
                        DialogResult.Cancel)
                        return false;

                    // Open the Weapons XML file and locate the selected piece.
                    XmlDocument objXmlDocument
                        = await CharacterObject.LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false);

                    XmlNode objXmlWeapon = objXmlDocument.TryGetNodeByNameOrId("/chummer/weapons/weapon",
                        frmPickWeapon.MyForm.SelectedWeapon);

                    List<Weapon> lstWeapons = new List<Weapon>(1);
                    Weapon objWeapon = new Weapon(CharacterObject);
                    try
                    {
                        if (objMod != null)
                            await objWeapon.SetParentVehicleModAsync(objMod, GenericToken).ConfigureAwait(false);
                        else
                            await objWeapon.SetParentMountAsync(objWeaponMount, GenericToken).ConfigureAwait(false);
                        await objWeapon.CreateAsync(objXmlWeapon, lstWeapons, token: token).ConfigureAwait(false);

                        if (objMod != null)
                            await objMod.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                        else
                            await objWeaponMount.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);

                        foreach (Weapon objLoopWeapon in lstWeapons)
                        {
                            if (objMod != null)
                                await objMod.Weapons.AddAsync(objLoopWeapon, token).ConfigureAwait(false);
                            else
                                await objWeaponMount.Weapons.AddAsync(objLoopWeapon, token).ConfigureAwait(false);
                        }

                        return frmPickWeapon.MyForm.AddAgain && (objMod != null || !objWeaponMount.IsWeaponsFull);
                    }
                    catch
                    {
                        foreach (Weapon objLoopWeapon in lstWeapons)
                            await objLoopWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                        await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async void tsVehicleAddWeaponAccessory_Click(object sender, EventArgs e)
        {
            try
            {
                // Attempt to locate the selected VehicleWeapon.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Weapon
                        objWeapon))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_VehicleWeaponAccessories", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_VehicleWeaponAccessories", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Weapons XML file and locate the selected Weapon.
                XmlNode objXmlWeapon = await objWeapon.GetNodeAsync(GenericToken).ConfigureAwait(false);
                if (objXmlWeapon == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CannotFindWeapon", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("weapons.xml", token: GenericToken).ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        // Make sure the Weapon allows Accessories to be added to it.
                        if (!objWeapon.AllowAccessory)
                        {
                            await Program.ShowScrollableMessageBoxAsync(
                                this,
                                await LanguageManager.GetStringAsync("Message_CannotModifyWeapon", token: GenericToken)
                                    .ConfigureAwait(false),
                                await LanguageManager.GetStringAsync("MessageTitle_CannotModifyWeapon", token: GenericToken)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                            return;
                        }

                        using (ThreadSafeForm<SelectWeaponAccessory> frmPickWeaponAccessory
                               = await ThreadSafeForm<SelectWeaponAccessory>.GetAsync(
                                   () => new SelectWeaponAccessory(CharacterObject), GenericToken).ConfigureAwait(false))
                        {
                            await frmPickWeaponAccessory.MyForm.SetWeapon(objWeapon, GenericToken).ConfigureAwait(false);
                            if (await frmPickWeaponAccessory.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;
                            blnAddAgain = frmPickWeaponAccessory.MyForm.AddAgain;

                            // Locate the selected piece.
                            objXmlWeapon = objXmlDocument.TryGetNodeByNameOrId("/chummer/accessories/accessory", frmPickWeaponAccessory.MyForm.SelectedAccessory);

                            WeaponAccessory objAccessory = new WeaponAccessory(CharacterObject);
                            try
                            {
                                await objAccessory.CreateAsync(objXmlWeapon, frmPickWeaponAccessory.MyForm.SelectedMount,
                                    frmPickWeaponAccessory.MyForm.SelectedRating, token: GenericToken).ConfigureAwait(false);
                                await objAccessory.SetParentAsync(objWeapon, GenericToken).ConfigureAwait(false);
                                objAccessory.DiscountCost = frmPickWeaponAccessory.MyForm.BlackMarketDiscount;

                                if (frmPickWeaponAccessory.MyForm.FreeCost)
                                {
                                    objAccessory.Cost = "0";
                                }

                                await objWeapon.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                            }
                            catch
                            {
                                await objAccessory.DeleteWeaponAccessoryAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleAddUnderbarrelWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                // Attempt to locate the selected VehicleWeapon.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Weapon
                        objSelectedWeapon))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_VehicleWeaponUnderbarrel", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_VehicleWeaponUnderbarrel", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(
                                   () => new SelectWeapon(CharacterObject)
                                   {
                                       LimitToCategories = "Underbarrel Weapons",
                                       ParentWeapon = objSelectedWeapon
                                   }, GenericToken).ConfigureAwait(false))
                        {
                            frmPickWeapon.MyForm.Mounts.UnionWith(await objSelectedWeapon.GetAccessoryMountsAsync(token: GenericToken).ConfigureAwait(false));

                            // Make sure the dialogue window was not canceled.
                            if (await frmPickWeapon.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) ==
                                DialogResult.Cancel)
                                return;

                            // Open the Weapons XML file and locate the selected piece.
                            XmlNode objXmlWeapon
                                = (await CharacterObject.LoadDataAsync("weapons.xml", token: GenericToken)
                                    .ConfigureAwait(false))
                                .TryGetNodeByNameOrId(
                                    "/chummer/weapons/weapon", frmPickWeapon.MyForm.SelectedWeapon);

                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            Weapon objWeapon = new Weapon(CharacterObject);
                            try
                            {
                                await objWeapon.SetParentAsync(objSelectedWeapon, GenericToken).ConfigureAwait(false);
                                await objWeapon.CreateAsync(objXmlWeapon, lstWeapons, token: GenericToken)
                                    .ConfigureAwait(false);
                                objWeapon.DiscountCost = frmPickWeapon.MyForm.BlackMarketDiscount;

                                if (frmPickWeapon.MyForm.FreeCost)
                                {
                                    objWeapon.Cost = "0";
                                }

                                await objSelectedWeapon.UnderbarrelWeapons.AddAsync(objWeapon, GenericToken)
                                    .ConfigureAwait(false);
                                if (!objSelectedWeapon.AllowAccessory)
                                    objWeapon.AllowAccessory = false;

                                foreach (Weapon objLoopWeapon in lstWeapons)
                                {
                                    await objSelectedWeapon.UnderbarrelWeapons.AddAsync(objLoopWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                    if (!objSelectedWeapon.AllowAccessory)
                                        objLoopWeapon.AllowAccessory = false;
                                }
                            }
                            catch
                            {
                                foreach (Weapon objLoopWeapon in lstWeapons)
                                    await objLoopWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMartialArtsAddTechnique_Click(object sender, EventArgs e)
        {
            try
            {
                // Select the Martial Arts node if we're currently on a child.
                TreeNode objSelectedNode = await treMartialArts.DoThreadSafeFuncAsync(x =>
                {
                    TreeNode objReturn = x.SelectedNode;
                    while (objReturn?.Level > 1)
                        objReturn = objReturn.Parent;
                    return objReturn;
                }, GenericToken).ConfigureAwait(false);

                if (objSelectedNode == null || objSelectedNode.Level <= 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectMartialArtTechnique", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectMartialArtTechnique", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                if (!(objSelectedNode.Tag is MartialArt objMartialArt))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectMartialArtTechnique", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectMartialArtTechnique", token: GenericToken)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                XmlDocument xmlDocument = await CharacterObject.LoadDataAsync("martialarts.xml", token: GenericToken).ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        XmlNode xmlTechnique;
                        using (ThreadSafeForm<SelectMartialArtTechnique> frmPickMartialArtTechnique
                               = await ThreadSafeForm<SelectMartialArtTechnique>.GetAsync(
                                       () => new SelectMartialArtTechnique(CharacterObject, objMartialArt), GenericToken)
                                   .ConfigureAwait(false))
                        {
                            if (await frmPickMartialArtTechnique.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                return;

                            blnAddAgain = frmPickMartialArtTechnique.MyForm.AddAgain;

                            // Open the Martial Arts XML file and locate the selected piece.
                            xmlTechnique = xmlDocument.TryGetNodeByNameOrId("/chummer/techniques/technique", frmPickMartialArtTechnique.MyForm.SelectedTechnique);
                        }

                        // Create the Improvements for the Technique if there are any.
                        MartialArtTechnique objTechnique = new MartialArtTechnique(CharacterObject);
                        await objTechnique.CreateAsync(xmlTechnique, GenericToken).ConfigureAwait(false);
                        if (objTechnique.InternalId.IsEmptyGuid())
                            return;

                        await objMartialArt.Techniques.AddAsync(objTechnique, GenericToken).ConfigureAwait(false);
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                Vehicle objSelectedVehicle;
                Location objLocation = null;
                TreeNode objSelectedNode = await treVehicles
                                                 .DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                 .ConfigureAwait(false);
                switch (objSelectedNode?.Tag)
                {
                    case Vehicle vehicle:
                        objSelectedVehicle = vehicle;
                        break;

                    case Location location:
                        objLocation = location;
                        objSelectedVehicle = objSelectedNode.Parent.Tag as Vehicle;
                        break;

                    default:
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_SelectGearVehicle", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_SelectGearVehicle", token: GenericToken)
                                .ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;
                }

                await PurchaseVehicleGear(objSelectedVehicle, objLocation, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleSensorAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false);
                // Make sure a parent items is selected, then open the Select Gear window.
                if (objSelectedNode == null || objSelectedNode.Level < 2)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Make sure the Gear was found.
                if (!(objSelectedNode.Tag is Gear objSensor))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken).ConfigureAwait(false);
                string strCategories = string.Empty;
                XPathNavigator objSensorNode = await objSensor.GetNodeXPathAsync(GenericToken).ConfigureAwait(false);
                XPathNodeIterator xmlAddonCategoryList = objSensorNode?.SelectAndCacheExpression("addoncategory", GenericToken);
                if (xmlAddonCategoryList?.Count > 0)
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                            sbdCategories.Append(objXmlCategory.Value, ',');
                        // Remove the trailing comma.
                        --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }
                }

                List<Weapon> lstWeapons = new List<Weapon>(1);
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        lstWeapons.Clear();
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            Gear objGear;
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                           () => new SelectGear(CharacterObject, objGearParent: objSensor, strAllowedCategories: strCategories), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                         && (!objSensor.Capacity.Contains('[')
                                                                             || objSensor.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                // Open the Gear XML file and locate the selected piece.
                                XmlNode objXmlGear
                                    = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                        frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    false, token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;
                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";
                                // If the item was marked as free, change its cost.
                                if (frmPickGear.MyForm.FreeCost)
                                {
                                    objGear.Cost = "0";
                                }
                            }

                            IsRefreshing = true;
                            try
                            {
                                nudVehicleGearQty.Increment = objGear.CostFor;
                                //nudVehicleGearQty.Minimum = objGear.CostFor;
                            }
                            finally
                            {
                                IsRefreshing = false;
                            }

                            await objSensor.Children.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                            if (lstWeapons.Count > 0)
                            {
                                Vehicle objVehicle =
                                    (await CharacterObject.Vehicles.FindVehicleGearAsync(objSensor.InternalId,
                                        GenericToken).ConfigureAwait(false)).Item2;
                                if (objVehicle != null)
                                {
                                    foreach (Weapon objWeapon in lstWeapons)
                                    {
                                        await objVehicle.Weapons.AddAsync(objWeapon, GenericToken)
                                            .ConfigureAwait(false);
                                    }
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleGearNotes_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles
                                                 .DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                 .ConfigureAwait(false);
                switch (objSelectedNode?.Tag)
                {
                    case Gear objGear:
                    {
                        string strNotes = await objGear.GetNotesAsync(GenericToken).ConfigureAwait(false);
                        Color objColor = await objGear.GetNotesColorAsync(GenericToken).ConfigureAwait(false);
                        using (ThreadSafeForm<EditNotes> frmItemNotes
                               = await ThreadSafeForm<EditNotes>.GetAsync(
                                                                    () => new EditNotes(strNotes,
                                                                        objColor, GenericToken), GenericToken)
                                                                .ConfigureAwait(false))
                        {
                            if (await frmItemNotes.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                != DialogResult.OK)
                                return;
                            await objGear.SetNotesAsync(frmItemNotes.MyForm.Notes, GenericToken).ConfigureAwait(false);
                            await objGear.SetNotesColorAsync(frmItemNotes.MyForm.NotesColor, GenericToken).ConfigureAwait(false);
                        }
                        strNotes = (await objGear.GetNotesAsync(GenericToken).ConfigureAwait(false)).WordWrap();
                        objColor = await objGear.GetPreferredColorAsync(GenericToken).ConfigureAwait(false);
                        await treVehicles.DoThreadSafeAsync(() =>
                        {
                            objSelectedNode.ForeColor = objColor;
                            objSelectedNode.ToolTipText = strNotes;
                        }, GenericToken).ConfigureAwait(false);
                        await SetDirty(true).ConfigureAwait(false);

                        break;
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAdvancedLifestyle_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        Lifestyle objLifestyle = new Lifestyle(CharacterObject);
                        try
                        {
                            await objLifestyle.SetStyleTypeAsync(LifestyleType.Advanced, GenericToken).ConfigureAwait(false);
                            using (ThreadSafeForm<SelectLifestyle> frmPickLifestyle
                                   = await ThreadSafeForm<SelectLifestyle>.GetAsync(
                                           () => new SelectLifestyle(
                                               CharacterObject,
                                               objLifestyle), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                // Make sure the dialogue window was not canceled.
                                if (await frmPickLifestyle.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                {
                                    //And if it was, remove Improvements that was already added based on the lifestyle
                                    await objLifestyle.RemoveAsync(false, GenericToken).ConfigureAwait(false);
                                    return;
                                }

                                blnAddAgain = frmPickLifestyle.MyForm.AddAgain;

                                Lifestyle objNewLifestyle = frmPickLifestyle.MyForm.SelectedLifestyle;

                                await CharacterObject.Lifestyles.AddAsync(objNewLifestyle, GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }
                        catch
                        {
                            await objLifestyle.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponName_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x =>
                {
                    TreeNode objReturn = x.SelectedNode;
                    while (objReturn?.Level > 1)
                        objReturn = objReturn.Parent;
                    return objReturn;
                }, GenericToken).ConfigureAwait(false);

                // Make sure a parent item is selected, then open the Select Accessory window.
                if (objSelectedNode == null || objSelectedNode.Level <= 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectWeaponName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Get the information for the currently selected Weapon.
                if (!(objSelectedNode.Tag is Weapon objWeapon))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectWeaponName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription = await LanguageManager.GetStringAsync("String_WeaponName", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objWeapon.CustomName,
                               AllowEmptyString = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    objWeapon.CustomName = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objWeapon.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treWeapons.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearName_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false);
                if (objSelectedNode == null || objSelectedNode.Level <= 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectGearName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Get the information for the currently selected Gear.
                if (!(objSelectedNode.Tag is Gear objGear))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectGearName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription = await LanguageManager.GetStringAsync("String_GearName", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objGear.GearName,
                               AllowEmptyString = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    objGear.GearName = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                             .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponAddUnderbarrel_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                           .ConfigureAwait(false);
                // Locate the Weapon that is selected in the tree.
                if (!(objSelectedNode?.Tag is Weapon objSelectedWeapon))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_SelectWeaponUnderbarrel", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectWeapon", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                if (objSelectedWeapon.Cyberware)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_CyberwareUnderbarrel", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_WeaponUnderbarrel", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        using (ThreadSafeForm<SelectWeapon> frmPickWeapon = await ThreadSafeForm<SelectWeapon>.GetAsync(
                                   () => new SelectWeapon(CharacterObject)
                                   {
                                       LimitToCategories = "Underbarrel Weapons",
                                       ParentWeapon = objSelectedWeapon
                                   }, GenericToken).ConfigureAwait(false))
                        {
                            frmPickWeapon.MyForm.Mounts.UnionWith(await objSelectedWeapon.GetAccessoryMountsAsync(token: GenericToken).ConfigureAwait(false));

                            // Make sure the dialogue window was not canceled.
                            if (await frmPickWeapon.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) ==
                                DialogResult.Cancel)
                                return;

                            // Open the Weapons XML file and locate the selected piece.
                            XmlNode objXmlWeapon
                                = (await CharacterObject.LoadDataAsync("weapons.xml", token: GenericToken)
                                    .ConfigureAwait(false))
                                .TryGetNodeByNameOrId(
                                    "/chummer/weapons/weapon", frmPickWeapon.MyForm.SelectedWeapon);

                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            Weapon objWeapon = new Weapon(CharacterObject);
                            try
                            {
                                await objWeapon.CreateAsync(objXmlWeapon, lstWeapons, token: GenericToken)
                                    .ConfigureAwait(false);
                                objWeapon.DiscountCost = frmPickWeapon.MyForm.BlackMarketDiscount;
                                await objWeapon.SetParentAsync(objSelectedWeapon, GenericToken).ConfigureAwait(false);
                                objWeapon.AllowAccessory = objSelectedWeapon.AllowAccessory;

                                if (frmPickWeapon.MyForm.FreeCost)
                                {
                                    objWeapon.Cost = "0";
                                }

                                await objSelectedWeapon.UnderbarrelWeapons.AddAsync(objWeapon, GenericToken)
                                    .ConfigureAwait(false);
                            }
                            catch
                            {
                                foreach (Weapon objLoopWeapon in lstWeapons)
                                    await objLoopWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearRename_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Gear objGear))
                    return;
                using (ThreadSafeForm<SelectText> frmPickText
                       = await ThreadSafeForm<SelectText>.GetAsync(() => new SelectText
                                                         {
                                                             DefaultString = objGear.Extra,
                                                             AllowEmptyString = true
                                                         }, GenericToken)
                                                         .ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;
                    objGear.Extra = frmPickText.MyForm.SelectedValue;
                    string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                    await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = strText,
                                                    token: GenericToken).ConfigureAwait(false);
                    await SetDirty(true).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorLocationAddArmor_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddArmor(
                        await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token: GenericToken)
                                      .ConfigureAwait(false) as Location,
                        GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAddArmorGear_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Gear window.
                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token: GenericToken)
                                    .ConfigureAwait(false) is Armor
                        objArmor))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                bool blnAddAgain;
                do
                {
                    // Select the root Gear node then open the Select Gear window.
                    blnAddAgain = await PickArmorGear(objArmor.InternalId, true, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorGearAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                         .ConfigureAwait(false);
                // Make sure a parent items is selected, then open the Select Gear window.
                if (objSelectedNode == null || objSelectedNode.Level <= 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string selectedGuid = string.Empty;
                switch (objSelectedNode.Tag)
                {
                    // Make sure the selected item is another piece of Gear.
                    case ArmorMod objMod when string.IsNullOrEmpty(objMod.GearCapacity):
                        await Program.ShowScrollableMessageBoxAsync(
                            this, await LanguageManager.GetStringAsync("Message_SelectArmor", token: GenericToken).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_SelectArmor", token: GenericToken).ConfigureAwait(false),
                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                        return;

                    case ArmorMod objMod:
                        selectedGuid = objMod.InternalId;
                        break;

                    case Gear objGear:
                        selectedGuid = objGear.InternalId;
                        break;
                }

                bool blnAddAgain;
                do
                {
                    blnAddAgain = await PickArmorGear(selectedGuid, token: GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsQualityNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMartialArtsNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsSpellNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsComplexFormNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                         .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsAIProgramNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCritterPowersNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                          .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsLifestyleNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponMountLocation_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode
                    = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is WeaponMount objWeaponMount))
                    return;
                string strDescription
                    = await LanguageManager.GetStringAsync("String_VehicleName", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objWeaponMount.Location
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objWeaponMount.Location = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objWeaponMount.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treVehicles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                 .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleName_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x =>
                {
                    TreeNode objReturn = x.SelectedNode;
                    while (objReturn?.Level > 1)
                        objReturn = objReturn.Parent;
                    return objReturn;
                }, GenericToken).ConfigureAwait(false);

                // Make sure a parent item is selected.
                if (objSelectedNode == null || objSelectedNode.Level <= 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectVehicleName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Get the information for the currently selected Vehicle.
                if (!(objSelectedNode.Tag is Vehicle objVehicle))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectVehicleName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectVehicle", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription
                    = await LanguageManager.GetStringAsync("String_VehicleName", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objVehicle.CustomName,
                               AllowEmptyString = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    objVehicle.CustomName = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objVehicle.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treVehicles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                 .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleAddCyberware_Click(object sender, EventArgs e)
        {
            try
            {
                if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                     .ConfigureAwait(false) is string)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_VehicleCyberwarePlugin", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NoCyberware", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                Cyberware objCyberwareParent = null;
                string strNeedleId
                    = (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) as
                        IHasInternalId)?.InternalId;
                (VehicleMod objMod, Vehicle objVehicle, _)
                    = await CharacterObject.Vehicles.FindVehicleModAsync(x => x.InternalId == strNeedleId, GenericToken).ConfigureAwait(false);
                if (objMod == null)
                    (objCyberwareParent, objMod)
                        = await CharacterObject.Vehicles.FindVehicleCyberwareAsync(x => x.InternalId == strNeedleId, GenericToken).ConfigureAwait(false);

                if (objCyberwareParent == null && objMod?.AllowCyberware != true)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_VehicleCyberwarePlugin", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_NoCyberware", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Cyberware XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("cyberware.xml", token: GenericToken).ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        using (ThreadSafeForm<SelectCyberware> frmPickCyberware
                               = await ThreadSafeForm<SelectCyberware>.GetAsync(() => new SelectCyberware(
                                   CharacterObject,
                                   Improvement.ImprovementSource.Cyberware,
                                   objCyberwareParent ?? (object)objMod), GenericToken).ConfigureAwait(false))
                        {
                            if (objCyberwareParent == null)
                            {
                                //frmPickCyberware.SetGrade = "Standard";
                                await frmPickCyberware.MyForm.SetMaximumCapacityAsync(await objMod.GetCapacityRemainingAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                frmPickCyberware.MyForm.Subsystems = objMod.Subsystems;
                                using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                           out HashSet<string> setDisallowedMounts))
                                using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                           out HashSet<string> setHasMounts))
                                {
                                    foreach (Cyberware objLoopCyberware in await objMod.Cyberware.DeepWhereAsync(
                                                 x => x.GetChildrenAsync(GenericToken), async x => string.IsNullOrEmpty(await x.GetPlugsIntoModularMountAsync(GenericToken).ConfigureAwait(false)), GenericToken).ConfigureAwait(false))
                                    {
                                        foreach (string strLoop in (await objLoopCyberware.GetBlocksMountsAsync(GenericToken).ConfigureAwait(false)).SplitNoAlloc(
                                                     ',', StringSplitOptions.RemoveEmptyEntries))
                                        {
                                            setDisallowedMounts.Add(strLoop + await objLoopCyberware.GetLocationAsync(GenericToken).ConfigureAwait(false));
                                        }

                                        string strLoopHasModularMount = await objLoopCyberware.GetHasModularMountAsync(GenericToken).ConfigureAwait(false);
                                        if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                            setHasMounts.Add(strLoopHasModularMount);
                                    }

                                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                               out StringBuilder sbdDisallowedMounts))
                                    {
                                        foreach (string strLoop in setDisallowedMounts)
                                        {
                                            if (!strLoop.EndsWith("Right", StringComparison.Ordinal)
                                                && (!strLoop.EndsWith("Left", StringComparison.Ordinal)
                                                    || setDisallowedMounts.Contains(
                                                        strLoop.Substring(0, strLoop.Length - 4) + "Right")))
                                                sbdDisallowedMounts.Append(strLoop.TrimEndOnce("Left"), ',');
                                        }

                                        // Remove trailing ","
                                        if (sbdDisallowedMounts.Length > 0)
                                            --sbdDisallowedMounts.Length;
                                        frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                                    }

                                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                               out StringBuilder sbdHasMounts))
                                    {
                                        foreach (string strLoop in setHasMounts)
                                            sbdHasMounts.Append(strLoop, ',');
                                        // Remove trailing ","
                                        if (sbdHasMounts.Length > 0)
                                            --sbdHasMounts.Length;
                                        frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                                    }
                                }
                            }
                            else
                            {
                                frmPickCyberware.MyForm.ForcedGrade = await objCyberwareParent.GetGradeAsync(GenericToken).ConfigureAwait(false);
                                // If the Cyberware has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that conume Capacity).
                                if (!objCyberwareParent.Capacity.Contains('[')
                                    || objCyberwareParent.Capacity.Contains("/["))
                                {
                                    frmPickCyberware.MyForm.Subsystems = objCyberwareParent.AllowedSubsystems;
                                    await frmPickCyberware.MyForm.SetMaximumCapacityAsync(await objCyberwareParent.GetCapacityRemainingAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                                    // Do not allow the user to add a new piece of Cyberware if its Capacity has been reached.
                                    if (await CharacterObjectSettings.GetEnforceCapacityAsync(GenericToken).ConfigureAwait(false)
                                        && frmPickCyberware.MyForm.MaximumCapacity < 0)
                                    {
                                        await Program.ShowScrollableMessageBoxAsync(
                                            this,
                                            await LanguageManager.GetStringAsync("Message_CapacityReached", token: GenericToken)
                                                .ConfigureAwait(false),
                                            await LanguageManager.GetStringAsync("MessageTitle_CapacityReached", token: GenericToken)
                                                .ConfigureAwait(false),
                                            MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                        break;
                                    }
                                }

                                frmPickCyberware.MyForm.Subsystems = objCyberwareParent.AllowedSubsystems;
                                using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                           out HashSet<string> setDisallowedMounts))
                                using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                           out HashSet<string> setHasMounts))
                                {
                                    string strLoopHasModularMount = await objCyberwareParent.GetHasModularMountAsync(GenericToken).ConfigureAwait(false);
                                    if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                        setHasMounts.Add(strLoopHasModularMount);
                                    foreach (Cyberware objLoopCyberware in await (await objCyberwareParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).DeepWhereAsync(
                                                 x => x.GetChildrenAsync(GenericToken), async x => string.IsNullOrEmpty(await x.GetPlugsIntoModularMountAsync(GenericToken).ConfigureAwait(false)), GenericToken).ConfigureAwait(false))
                                    {
                                        foreach (string strLoop in objLoopCyberware.BlocksMounts.SplitNoAlloc(
                                                     ',', StringSplitOptions.RemoveEmptyEntries))
                                        {
                                            setDisallowedMounts.Add(strLoop + await objLoopCyberware.GetLocationAsync(GenericToken).ConfigureAwait(false));
                                        }

                                        strLoopHasModularMount = await objLoopCyberware.GetHasModularMountAsync(GenericToken).ConfigureAwait(false);
                                        if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                            setHasMounts.Add(strLoopHasModularMount);
                                    }

                                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                               out StringBuilder sbdDisallowedMounts))
                                    {
                                        foreach (string strLoop in setDisallowedMounts)
                                        {
                                            if (!strLoop.EndsWith("Right", StringComparison.Ordinal)
                                                && (!strLoop.EndsWith("Left", StringComparison.Ordinal)
                                                    || setDisallowedMounts.Contains(
                                                        strLoop.Substring(0, strLoop.Length - 4) + "Right")))
                                                sbdDisallowedMounts.Append(strLoop.TrimEndOnce("Left"), ',');
                                        }

                                        // Remove trailing ","
                                        if (sbdDisallowedMounts.Length > 0)
                                            --sbdDisallowedMounts.Length;
                                        frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                                    }

                                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                               out StringBuilder sbdHasMounts))
                                    {
                                        foreach (string strLoop in setHasMounts)
                                            sbdHasMounts.Append(strLoop, ',');
                                        // Remove trailing ","
                                        if (sbdHasMounts.Length > 0)
                                            --sbdHasMounts.Length;
                                        frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                                    }
                                }
                            }

                            frmPickCyberware.MyForm.LockGrade();
                            frmPickCyberware.MyForm.ParentVehicle = objVehicle ?? objMod.Parent;
                            frmPickCyberware.MyForm.ParentVehicleMod = objMod;

                            if (await frmPickCyberware.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;
                            blnAddAgain = frmPickCyberware.MyForm.AddAgain;

                            XmlNode objXmlCyberware = objXmlDocument.TryGetNodeByNameOrId("/chummer/cyberwares/cyberware", frmPickCyberware.MyForm.SelectedCyberware);
                            Cyberware objCyberware = new Cyberware(CharacterObject);
                            try
                            {
                                if (!await objCyberware.Purchase(objXmlCyberware, Improvement.ImprovementSource.Cyberware,
                                        frmPickCyberware.MyForm.SelectedGrade,
                                        frmPickCyberware.MyForm.SelectedRating,
                                        objVehicle, objMod.Cyberware, await CharacterObject.GetVehiclesAsync(GenericToken).ConfigureAwait(false),
                                        objVehicle.Weapons,
                                        blnFree: frmPickCyberware.MyForm.FreeCost,
                                        blnBlackMarket: frmPickCyberware.MyForm.BlackMarketDiscount,
                                        blnForVehicle: true,
                                        strExpenseString: "String_ExpensePurchaseVehicleCyberware",
                                        objParent: objCyberwareParent, token: GenericToken).ConfigureAwait(false))
                                    await objCyberware.DeleteCyberwareAsync(token: GenericToken).ConfigureAwait(false);
                            }
                            catch
                            {
                                await objCyberware.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorName_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treArmor.DoThreadSafeFuncAsync(x =>
                {
                    TreeNode objReturn = x.SelectedNode;
                    while (objReturn?.Level > 1)
                        objReturn = objReturn.Parent;
                    return objReturn;
                }, GenericToken).ConfigureAwait(false);

                // Make sure a parent item is selected, then open the Select Accessory window.
                if (objSelectedNode == null || objSelectedNode.Level <= 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectArmorName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Get the information for the currently selected Armor.
                if (!(objSelectedNode.Tag is Armor objArmor))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectArmorName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectArmor", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription = await LanguageManager.GetStringAsync("String_ArmorName", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objArmor.CustomName,
                               AllowEmptyString = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    objArmor.CustomName = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objArmor.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treArmor.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                              .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsLifestyleName_Click(object sender, EventArgs e)
        {
            try
            {
                // Get the information for the currently selected Lifestyle.
                TreeNode objSelectedNode = await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                              .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is IHasCustomName objCustomName))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectLifestyleName", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectLifestyle", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                string strDescription
                    = await LanguageManager.GetStringAsync("String_LifestyleName", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objCustomName.CustomName,
                               AllowEmptyString = true
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    if (objCustomName.CustomName == frmPickText.MyForm.SelectedValue)
                        return;
                    objCustomName.CustomName = frmPickText.MyForm.SelectedValue;

                    string strText = await objCustomName.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                    await treLifestyles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken).ConfigureAwait(false);

                    await SetDirty(true).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsGearRenameLocation_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                        .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Location objLocation))
                    return;
                string strDescription
                    = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objLocation.Name
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objLocation.Name = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objLocation.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                             .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponRenameLocation_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                           .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Location objLocation))
                    return;
                string strDescription
                    = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objLocation.Name
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objLocation.Name = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objLocation.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treWeapons.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken).ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCreateSpell_Click(object sender, EventArgs e)
        {
            try
            {
                // Run through the list of Active Skills and pick out the two applicable ones.
                int intSkillValue = 0;
                Skill objSpellcasting = await CharacterObject.SkillsSection.GetActiveSkillAsync("Spellcasting", GenericToken).ConfigureAwait(false);
                if (objSpellcasting != null)
                    intSkillValue = await objSpellcasting.GetRatingAsync(GenericToken).ConfigureAwait(false);
                Skill objRitualSpellcasting = await CharacterObject.SkillsSection.GetActiveSkillAsync("Ritual Spellcasting", GenericToken).ConfigureAwait(false);
                if (objRitualSpellcasting != null)
                    intSkillValue = Math.Max(intSkillValue, await objRitualSpellcasting.GetRatingAsync(GenericToken).ConfigureAwait(false));
                // The maximum number of Spells a character can start with is 2 x (highest of Spellcasting or Ritual Spellcasting Skill).
                if (await CharacterObject.Spells.GetCountAsync(GenericToken).ConfigureAwait(false) >= 2 * intSkillValue
                    + await ImprovementManager.ValueOfAsync(CharacterObject, Improvement.ImprovementType.SpellLimit, token: GenericToken)
                                              .ConfigureAwait(false)
                    && !await CharacterObject.GetIgnoreRulesAsync(GenericToken).ConfigureAwait(false))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SpellLimit", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SpellLimit", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // The character is still allowed to add Spells, so show the Create Spell window.
                using (ThreadSafeForm<CreateSpell> frmSpell
                       = await ThreadSafeForm<CreateSpell>.GetAsync(() => new CreateSpell(CharacterObject), GenericToken)
                                                          .ConfigureAwait(false))
                {
                    if (await frmSpell.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    Spell objSpell = frmSpell.MyForm.SelectedSpell;
                    await CharacterObject.Spells.AddAsync(objSpell, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsArmorRenameLocation_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                         .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Location objLocation))
                    return;
                string strDescription
                    = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objLocation.Name
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    objLocation.Name = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objLocation.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treArmor.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                              .ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode
                    = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false);
                // Make sure a parent items is selected, then open the Select Gear window.
                if (objSelectedNode == null || objSelectedNode.Level <= 0)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Make sure the Cyberware is allowed to accept Gear.
                if (!(objSelectedNode.Tag is Cyberware objCyberware) || objCyberware.AllowGear == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Gear XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken).ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    string strCategories = string.Empty;
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                               out StringBuilder sbdCategories))
                    {
                        using (XmlNodeList xmlGearCategoryList
                               = objCyberware.AllowGear?.SelectNodes("gearcategory"))
                        {
                            if (xmlGearCategoryList != null)
                            {
                                foreach (XmlNode objXmlCategory in xmlGearCategoryList)
                                    sbdCategories.Append(objXmlCategory.InnerTextViaPool(GenericToken), ',');
                                if (sbdCategories.Length > 0)
                                    --sbdCategories.Length;
                                strCategories = sbdCategories.ToString();
                            }
                        }
                    }

                    string strGearNames = string.Empty;
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                               out StringBuilder sbdGearNames))
                    {
                        using (XmlNodeList xmlGearNameList = objCyberware.AllowGear?.SelectNodes("gearname"))
                        {
                            if (xmlGearNameList?.Count > 0)
                            {
                                foreach (XmlNode objXmlName in xmlGearNameList)
                                    sbdGearNames.Append(objXmlName.InnerTextViaPool(GenericToken), ',');
                                --sbdGearNames.Length;
                                strGearNames = sbdGearNames.ToString();
                            }
                        }
                    }
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                       () => new SelectGear(CharacterObject, objGearParent: objCyberware, strAllowedCategories: strCategories,
                                           strAllowedNames: strGearNames), GenericToken).ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) &&
                                    !string.IsNullOrEmpty(objCyberware.Capacity) &&
                                    objCyberware.Capacity != "0" && (!objCyberware.Capacity.Contains('[') ||
                                                                     objCyberware.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                XmlNode objXmlGear
                                    = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                        frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objNewGear = new Gear(CharacterObject);
                                await objNewGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    await objCyberware.GetIsModularCurrentlyEquippedAsync(GenericToken)
                                        .ConfigureAwait(false), token: GenericToken).ConfigureAwait(false);
                                await objNewGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                objNewGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                                if (objNewGear.InternalId.IsEmptyGuid())
                                    continue;

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objNewGear.Cost = "(" + objNewGear.Cost + ") * 0.5";
                                // If the item was marked as free, change its cost.
                                if (frmPickGear.MyForm.FreeCost)
                                {
                                    objNewGear.Cost = "0";
                                }

                                // Create any Weapons that came with this Gear.
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }

                                await objCyberware.GearChildren.AddAsync(objNewGear, GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleCyberwareAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure a parent items is selected, then open the Select Gear window.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                        Cyberware objCyberware))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Make sure the Cyberware is allowed to accept Gear.
                if (objCyberware.AllowGear == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Gear XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken).ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    string strCategories;
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                               out StringBuilder sbdCategories))
                    {
                        foreach (XmlNode objXmlCategory in objCyberware.AllowGear)
                            sbdCategories.Append(objXmlCategory.InnerTextViaPool(GenericToken), ',');
                        if (sbdCategories.Length > 0)
                            --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                           () => new SelectGear(CharacterObject, objGearParent: objCyberware, strAllowedCategories: strCategories), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) &&
                                    !string.IsNullOrEmpty(objCyberware.Capacity) &&
                                    objCyberware.Capacity != "0" && (!objCyberware.Capacity.Contains('[') ||
                                                                     objCyberware.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                XmlNode objXmlGear
                                    = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                        frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objNewGear = new Gear(CharacterObject);
                                await objNewGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    false, token: GenericToken).ConfigureAwait(false);
                                await objNewGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                objNewGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                                if (objNewGear.InternalId.IsEmptyGuid())
                                    continue;

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objNewGear.Cost = "(" + objNewGear.Cost + ") * 0.5";
                                // If the item was marked as free, change its cost.
                                if (frmPickGear.MyForm.FreeCost)
                                {
                                    objNewGear.Cost = "0";
                                }

                                // Create any Weapons that came with this Gear.
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }

                                await objCyberware.GearChildren.AddAsync(objNewGear, GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsCyberwareGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                             .ConfigureAwait(false);
                // Make sure a parent items is selected, then open the Select Gear window.
                if (objSelectedNode == null || objSelectedNode.Level < 2)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Locate the Vehicle Sensor Gear.
                if (!(objSelectedNode.Tag is Gear objSensor))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                Cyberware objCyberware =
                    (await CharacterObject.Cyberware.FindCyberwareGearAsync(objSensor.InternalId, GenericToken).ConfigureAwait(false)).Item2;
                // Open the Gear XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken).ConfigureAwait(false);
                string strCategories = string.Empty;
                XPathNavigator objSensorNode = await objSensor.GetNodeXPathAsync(GenericToken).ConfigureAwait(false);
                XPathNodeIterator xmlAddonCategoryList = objSensorNode?.SelectAndCacheExpression("addoncategory", GenericToken);
                if (xmlAddonCategoryList?.Count > 0)
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                            sbdCategories.Append(objXmlCategory.Value, ',');
                        // Remove the trailing comma.
                        --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                           () => new SelectGear(CharacterObject, objGearParent: objSensor, strAllowedCategories: strCategories), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                         && (!objSensor.Capacity.Contains('[')
                                                                             || objSensor.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                XmlNode objXmlGear
                                    = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                        frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    (objSensor.Parent as Gear)?.Equipped
                                    ?? objCyberware != null && await objCyberware
                                        .GetIsModularCurrentlyEquippedAsync(GenericToken).ConfigureAwait(false),
                                    token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";
                                // If the item was marked as free, change its cost.
                                if (frmPickGear.MyForm.FreeCost)
                                {
                                    objGear.Cost = "0";
                                }

                                await objSensor.Children.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleCyberwareGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false);
                // Make sure a parent items is selected, then open the Select Gear window.
                if (objSelectedNode == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Locate the Vehicle Sensor Gear.
                if (!(objSelectedNode.Tag is Gear objSensor))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Gear XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken).ConfigureAwait(false);
                string strCategories = string.Empty;
                XPathNavigator objSensorNode = await objSensor.GetNodeXPathAsync(GenericToken).ConfigureAwait(false);
                XPathNodeIterator xmlAddonCategoryList = objSensorNode?.SelectAndCacheExpression("addoncategory", GenericToken);
                if (xmlAddonCategoryList?.Count > 0)
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                            sbdCategories.Append(objXmlCategory.Value, ',');
                        // Remove the trailing comma.
                        --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                           () => new SelectGear(CharacterObject, objGearParent: objSensor, strAllowedCategories: strCategories), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                         && (!objSensor.Capacity.Contains('[')
                                                                             || objSensor.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                XmlNode objXmlGear
                                    = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                        frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    false, token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";
                                // If the item was marked as free, change its cost.
                                if (frmPickGear.MyForm.FreeCost)
                                {
                                    objGear.Cost = "0";
                                }

                                await objSensor.Children.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponAccessoryAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                           .ConfigureAwait(false);

                // Make sure the Weapon Accessory is allowed to accept Gear.
                if (!(objSelectedNode?.Tag is WeaponAccessory objAccessory) || objAccessory.AllowGear == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_WeaponGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Open the Gear XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                string strCategories;
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XmlNode objXmlCategory in objAccessory.AllowGear)
                        sbdCategories.Append(objXmlCategory.InnerTextViaPool(GenericToken), ',');
                    if (sbdCategories.Length > 0)
                        --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                       () => new SelectGear(CharacterObject, objGearParent: objAccessory, strAllowedCategories: strCategories),
                                       GenericToken).ConfigureAwait(false))
                            {
                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                XmlNode objXmlGear
                                    = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                        frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    objAccessory.Equipped, token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";
                                // If the item was marked as free, change its cost.
                                if (frmPickGear.MyForm.FreeCost)
                                {
                                    objGear.Cost = "0";
                                }

                                await objAccessory.GearChildren.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                                // Create any Weapons that came with this Gear.
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void tsWeaponAccessoryDetach_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is WeaponAccessory objAccessory))
                    return;

                // Check if this accessory is part of the base weapon
                if (objAccessory.IncludedInWeapon)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_AccessoryCannotBeDetached", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_DetachAccessory", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Confirm detachment
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_ConfirmDetachAccessory", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_DetachAccessory", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) != DialogResult.Yes)
                    return;

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();

                        // Remove from parent weapon
                        Weapon objParentWeapon = objAccessory.Parent;
                        if (objParentWeapon != null)
                        {
                            // Store the parent weapon reference before removal
                            string strParentWeaponId = objParentWeapon.InternalId;
                            
                            // Try multiple removal methods to ensure it's removed
                            bool blnRemoved = false;
                            
                            // Method 1: Async removal
                            if (objParentWeapon.WeaponAccessories.Contains(objAccessory))
                            {
                                await objParentWeapon.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                blnRemoved = !objParentWeapon.WeaponAccessories.Contains(objAccessory);
                            }
                            
                            // Method 2: Synchronous removal if async failed
                            if (!blnRemoved && objParentWeapon.WeaponAccessories.Contains(objAccessory))
                            {
                                objParentWeapon.WeaponAccessories.Remove(objAccessory);
                                blnRemoved = !objParentWeapon.WeaponAccessories.Contains(objAccessory);
                            }
                            
                            // Method 3: Force removal by index if still present
                            if (!blnRemoved)
                            {
                                int intIndex = objParentWeapon.WeaponAccessories.IndexOf(objAccessory);
                                if (intIndex >= 0)
                                {
                                    objParentWeapon.WeaponAccessories.RemoveAt(intIndex);
                                }
                            }
                            
                        // Clear the accessory's parent reference and mounting relationship
                        objAccessory.Parent = null;
                        objAccessory.MountedOnAccessoryID = string.Empty;
                        }

                        // Check if this accessory has other accessories mounted on it (cascading detach)
                        if (!string.IsNullOrEmpty(objAccessory.AddMount) && objAccessory.AddMount.Equals("Passthrough", StringComparison.OrdinalIgnoreCase))
                        {
                            // Find any accessories that are mounted on this accessory
                            List<WeaponAccessory> lstMountedAccessories = new List<WeaponAccessory>();
                            foreach (WeaponAccessory objMountedAccessory in objParentWeapon.WeaponAccessories)
                            {
                                if (objMountedAccessory.MountedOnAccessoryID == objAccessory.InternalId)
                                {
                                    lstMountedAccessories.Add(objMountedAccessory);
                                }
                            }
                            
                            // Detach all accessories that are mounted on this accessory
                            foreach (WeaponAccessory objMountedAccessory in lstMountedAccessories)
                            {
                                // Remove from parent weapon
                                if (objParentWeapon.WeaponAccessories.Contains(objMountedAccessory))
                                {
                                    await objParentWeapon.WeaponAccessories.RemoveAsync(objMountedAccessory, GenericToken).ConfigureAwait(false);
                                }
                                
                                // Clear the mounted accessory's parent reference and mounting relationship
                                objMountedAccessory.Parent = null;
                                objMountedAccessory.MountedOnAccessoryID = string.Empty;
                                
                                // Add to detached accessories collection
                                if (!CharacterObject.DetachedWeaponAccessories.Contains(objMountedAccessory))
                                {
                                    await CharacterObject.DetachedWeaponAccessories.AddAsync(objMountedAccessory, GenericToken).ConfigureAwait(false);
                                }
                            }
                        }

                        // Ensure accessory is not already in detached collection
                        if (!CharacterObject.DetachedWeaponAccessories.Contains(objAccessory))
                        {
                            // Add to character's detached accessories collection
                            await CharacterObject.DetachedWeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                        }
                        
                        // Accessory is now detached (no need to change equip status)

                        // Refresh only the detached accessories node to avoid debug errors
                        await RefreshDetachedAccessoriesNode(treWeapons, cmsWeaponAccessory, cmsWeaponAccessoryGear, GenericToken).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponAccessoryAttach_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is WeaponAccessory objAccessory))
                    return;

                // All accessories can be attached to other weapons/accessories

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    using (ThreadSafeForm<SelectWeaponAccessoryTarget> frmSelectTarget
                           = await ThreadSafeForm<SelectWeaponAccessoryTarget>.GetAsync(
                               () => new SelectWeaponAccessoryTarget(CharacterObject, objAccessory), GenericToken).ConfigureAwait(false))
                    {
                        if (await frmSelectTarget.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.OK)
                        {
                            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken).ConfigureAwait(false);
                            try
                            {
                                GenericToken.ThrowIfCancellationRequested();

                                Weapon objTargetWeapon = frmSelectTarget.MyForm.SelectedWeapon;
                                WeaponAccessory objTargetAccessory = frmSelectTarget.MyForm.SelectedAccessory;

                                if (objTargetWeapon != null)
                                {
                                    // Check if the accessory is already on this weapon to prevent conflicts
                                    if (objAccessory.Parent != objTargetWeapon)
                                    {
                                        // Remove from current parent if it has one
                                        if (objAccessory.Parent != null)
                                        {
                                            await objAccessory.Parent.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                        
                                        // Ensure accessory is not already in target weapon's accessories
                                        if (!objTargetWeapon.WeaponAccessories.Contains(objAccessory))
                                        {
                                            // Set the parent weapon reference
                                            objAccessory.Parent = objTargetWeapon;
                                            
                                            // Add to target weapon
                                            await objTargetWeapon.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else if (objTargetAccessory != null)
                                {
                                    // Attach to another accessory - set the mounting relationship
                                    if (objAccessory.Parent != objTargetAccessory.Parent)
                                    {
                                        // Remove from current parent if it has one
                                        if (objAccessory.Parent != null)
                                        {
                                            await objAccessory.Parent.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                        
                                        // Set the mounting relationship
                                        objAccessory.MountedOnAccessoryID = objTargetAccessory.InternalId;
                                        
                                        // Add to the target accessory's parent weapon
                                        await objTargetAccessory.Parent.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                    }
                                }

                                // Remove from detached accessories collection if it's there
                                if (CharacterObject.DetachedWeaponAccessories.Contains(objAccessory))
                                {
                                    await CharacterObject.DetachedWeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                }

                                // Accessory is now attached (no need to change equip status)

                                // Show appropriate message based on target location
                                bool blnTargetIsVehicle = objTargetWeapon?.Parent?.Parent is Vehicle || objTargetAccessory?.Parent?.Parent?.Parent is Vehicle;
                                bool blnSourceIsVehicle = objAccessory.Parent?.Parent is Vehicle;
                                
                                if (blnTargetIsVehicle && !blnSourceIsVehicle)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_AccessoryMovedToVehicle", token: GenericToken).ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_AttachAccessory", token: GenericToken).ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                }
                                else if (!blnTargetIsVehicle && blnSourceIsVehicle)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_AccessoryMovedToCharacter", token: GenericToken).ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_AttachAccessory", token: GenericToken).ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                }

                                // Refresh only the detached accessories node to avoid debug errors
                                await  RefreshDetachedAccessoriesNode(treWeapons, cmsWeaponAccessory, cmsWeaponAccessoryGear, GenericToken).ConfigureAwait(false);
                            }
                            finally
                            {
                                await objLocker.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleWeaponAccessoryDetach_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is WeaponAccessory objAccessory))
                    return;

                // Check if accessory is part of base weapon
                if (objAccessory.IncludedInWeapon)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_AccessoryCannotBeDetached", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_DetachAccessory", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                // Confirm detach
                if (await Program.ShowScrollableMessageBoxAsync(
                        this,
                        await LanguageManager.GetStringAsync("Message_ConfirmDetachAccessory", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_DetachAccessory", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: GenericToken).ConfigureAwait(false) != DialogResult.Yes)
                    return;

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();

                        // Get the parent weapon
                        Weapon objParentWeapon = objAccessory.Parent;
                        if (objParentWeapon != null)
                        {
                            // Try multiple removal methods to ensure it's removed
                            bool blnRemoved = false;
                            // Method 1: Async removal
                            if (objParentWeapon.WeaponAccessories.Contains(objAccessory))
                            {
                                await objParentWeapon.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                blnRemoved = !objParentWeapon.WeaponAccessories.Contains(objAccessory);
                            }
                            // Method 2: Synchronous removal if async failed
                            if (!blnRemoved && objParentWeapon.WeaponAccessories.Contains(objAccessory))
                            {
                                objParentWeapon.WeaponAccessories.Remove(objAccessory);
                                blnRemoved = !objParentWeapon.WeaponAccessories.Contains(objAccessory);
                            }
                            // Method 3: Force removal by index if still present
                            if (!blnRemoved)
                            {
                                int intIndex = objParentWeapon.WeaponAccessories.IndexOf(objAccessory);
                                if (intIndex >= 0)
                                {
                                    objParentWeapon.WeaponAccessories.RemoveAt(intIndex);
                                }
                            }
                        }

                        // Clear the accessory's parent reference and mounting relationship
                        objAccessory.Parent = null;
                        objAccessory.MountedOnAccessoryID = string.Empty;

                        // Check if this accessory has other accessories mounted on it (cascading detach)
                        if (!string.IsNullOrEmpty(objAccessory.AddMount) && objAccessory.AddMount.Equals("Passthrough", StringComparison.OrdinalIgnoreCase))
                        {
                            // Find any accessories that are mounted on this accessory
                            List<WeaponAccessory> lstMountedAccessories = new List<WeaponAccessory>();
                            foreach (WeaponAccessory objMountedAccessory in objParentWeapon.WeaponAccessories)
                            {
                                if (objMountedAccessory.MountedOnAccessoryID == objAccessory.InternalId)
                                {
                                    lstMountedAccessories.Add(objMountedAccessory);
                                }
                            }
                            
                            // Detach all accessories that are mounted on this accessory
                            foreach (WeaponAccessory objMountedAccessory in lstMountedAccessories)
                            {
                                // Remove from parent weapon
                                if (objParentWeapon.WeaponAccessories.Contains(objMountedAccessory))
                                {
                                    await objParentWeapon.WeaponAccessories.RemoveAsync(objMountedAccessory, GenericToken).ConfigureAwait(false);
                                }
                                
                                // Clear the mounted accessory's parent reference and mounting relationship
                                objMountedAccessory.Parent = null;
                                objMountedAccessory.MountedOnAccessoryID = string.Empty;
                                
                                // Add to detached accessories collection
                                if (!CharacterObject.DetachedWeaponAccessories.Contains(objMountedAccessory))
                                {
                                    await CharacterObject.DetachedWeaponAccessories.AddAsync(objMountedAccessory, GenericToken).ConfigureAwait(false);
                                }
                            }
                        }

                        // Add to detached accessories collection
                        await CharacterObject.DetachedWeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);

                        // Refresh only the detached accessories node to avoid debug errors
                        await RefreshDetachedAccessoriesNode(treWeapons, cmsWeaponAccessory, cmsWeaponAccessoryGear, GenericToken).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsVehicleWeaponAccessoryAttach_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is WeaponAccessory objAccessory))
                    return;

                // All accessories can be attached to other weapons/accessories

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    // Show a dialog to select which weapon/accessory to attach to
                    using (ThreadSafeForm<SelectWeaponAccessoryTarget> frmSelectTarget
                           = await ThreadSafeForm<SelectWeaponAccessoryTarget>.GetAsync(
                               () => new SelectWeaponAccessoryTarget(CharacterObject, objAccessory), GenericToken).ConfigureAwait(false))
                    {
                        if (await frmSelectTarget.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.OK)
                        {
                            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken).ConfigureAwait(false);
                            try
                            {
                                GenericToken.ThrowIfCancellationRequested();

                                // Get the target weapon/accessory
                                Weapon objTargetWeapon = frmSelectTarget.MyForm.SelectedWeapon;
                                WeaponAccessory objTargetAccessory = frmSelectTarget.MyForm.SelectedAccessory;

                                // Remove from detached accessories collection if it's there
                                if (CharacterObject.DetachedWeaponAccessories.Contains(objAccessory))
                                {
                                    await CharacterObject.DetachedWeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                }

                                if (objTargetWeapon != null)
                                {
                                    // Check if the accessory is already on this weapon to prevent conflicts
                                    if (objAccessory.Parent != objTargetWeapon)
                                    {
                                        // Remove from current parent if it has one
                                        if (objAccessory.Parent != null)
                                        {
                                            await objAccessory.Parent.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                        
                                        // Ensure accessory is not already in target weapon's accessories
                                        if (!objTargetWeapon.WeaponAccessories.Contains(objAccessory))
                                        {
                                            // Set the parent weapon reference
                                            objAccessory.Parent = objTargetWeapon;
                                            
                                            // Add to target weapon
                                            await objTargetWeapon.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                    }
                                }
                                else if (objTargetAccessory != null)
                                {
                                    // Attach to another accessory - set the mounting relationship
                                    if (objAccessory.Parent != objTargetAccessory.Parent)
                                    {
                                        // Remove from current parent if it has one
                                        if (objAccessory.Parent != null)
                                        {
                                            await objAccessory.Parent.WeaponAccessories.RemoveAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                        }
                                        
                                        // Set the mounting relationship
                                        objAccessory.MountedOnAccessoryID = objTargetAccessory.InternalId;
                                        
                                        // Add to the target accessory's parent weapon
                                        await objTargetAccessory.Parent.WeaponAccessories.AddAsync(objAccessory, GenericToken).ConfigureAwait(false);
                                    }
                                }

                                // Show appropriate message for cross-platform movement
                                bool blnSourceIsVehicle = objAccessory.Parent?.Parent?.Parent is Vehicle;
                                bool blnTargetIsVehicle = objTargetWeapon?.Parent?.Parent is Vehicle || objTargetAccessory?.Parent?.Parent?.Parent is Vehicle;

                                if (blnSourceIsVehicle && !blnTargetIsVehicle)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_AccessoryMovedToCharacter", token: GenericToken).ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_AttachAccessory", token: GenericToken).ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                }
                                else if (!blnSourceIsVehicle && blnTargetIsVehicle)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager.GetStringAsync("Message_AccessoryMovedToVehicle", token: GenericToken).ConfigureAwait(false),
                                        await LanguageManager.GetStringAsync("MessageTitle_AttachAccessory", token: GenericToken).ConfigureAwait(false),
                                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                }

                                // Refresh only the detached accessories node to avoid debug errors
                                await RefreshDetachedAccessoriesNode(treWeapons, cmsWeaponAccessory, cmsWeaponAccessoryGear, GenericToken).ConfigureAwait(false);
                            }
                            finally
                            {
                                await objLocker.DisposeAsync().ConfigureAwait(false);
                            }
                        }
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsWeaponAccessoryGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is Gear objSensor))
                // Make sure the Gear was found.
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                WeaponAccessory objAccessory =
                    (await CharacterObject.Weapons.FindWeaponGearAsync(objSensor.InternalId, GenericToken).ConfigureAwait(false)).Item2;

                string strCategories = string.Empty;
                XPathNavigator objSensorNode = await objSensor.GetNodeXPathAsync(GenericToken).ConfigureAwait(false);
                XPathNodeIterator xmlAddonCategoryList = objSensorNode?.SelectAndCacheExpression("addoncategory", GenericToken);
                if (xmlAddonCategoryList?.Count > 0)
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                            sbdCategories.Append(objXmlCategory.Value, ',');
                        // Remove the trailing comma.
                        --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }
                }

                // Open the Gear XML file and locate the selected piece.
                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                           () => new SelectGear(CharacterObject, objGearParent: objSensor, strAllowedCategories: strCategories), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                         && (!objSensor.Capacity.Contains('[')
                                                                             || objSensor.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                XmlNode objXmlGear
                                    = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                        frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    (objSensor.Parent as Gear)?.Equipped ?? objAccessory?.Equipped == true,
                                    token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";
                                // If the item was marked as free, change its cost.
                                if (frmPickGear.MyForm.FreeCost)
                                {
                                    objGear.Cost = "0";
                                }

                                await objSensor.Children.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                                // Create any Weapons that came with this Gear.
                                foreach (Weapon objWeapon in lstWeapons)
                                {
                                    await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                        .ConfigureAwait(false);
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void tsVehicleRenameLocation_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Location objLocation))
                    return;

                string strDescription
                    = await LanguageManager.GetStringAsync("String_AddLocation", token: GenericToken).ConfigureAwait(false);
                using (ThreadSafeForm<SelectText> frmPickText = await ThreadSafeForm<SelectText>.GetAsync(
                           () => new SelectText
                           {
                               Description = strDescription,
                               DefaultString = objLocation.Name
                           }, GenericToken).ConfigureAwait(false))
                {
                    if (await frmPickText.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    objLocation.Name = frmPickText.MyForm.SelectedValue;
                }

                string strText = await objLocation.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treVehicles
                      .DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                      .ConfigureAwait(false);
                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void tsCreateNaturalWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                IAsyncDisposable objLocker =
                    await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    using (ThreadSafeForm<CreateNaturalWeapon> frmCreateNaturalWeapon
                           = await ThreadSafeForm<CreateNaturalWeapon>.GetAsync(
                               () => new CreateNaturalWeapon(CharacterObject), GenericToken).ConfigureAwait(false))
                    {
                        if (await frmCreateNaturalWeapon.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return;

                        Weapon objWeapon = frmCreateNaturalWeapon.MyForm.SelectedWeapon;
                        await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void tsVehicleWeaponAccessoryGearMenuAddAsPlugin_Click(object sender, EventArgs e)
        {
            try
            {
                // Make sure the Gear was found.
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Gear objSensor))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ModifyVehicleGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_SelectGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                string strCategories = string.Empty;
                XPathNavigator objSensorNode = await objSensor.GetNodeXPathAsync(GenericToken).ConfigureAwait(false);
                XPathNodeIterator xmlAddonCategoryList = objSensorNode?.SelectAndCacheExpression("addoncategory", GenericToken);
                if (xmlAddonCategoryList?.Count > 0)
                {
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdCategories))
                    {
                        foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                            sbdCategories.Append(objXmlCategory.Value, ',');
                        // Remove the trailing comma.
                        --sbdCategories.Length;
                        strCategories = sbdCategories.ToString();
                    }
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        IAsyncDisposable objLocker =
                            await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            using (ThreadSafeForm<SelectGear> frmPickGear
                                   = await ThreadSafeForm<SelectGear>.GetAsync(
                                           () => new SelectGear(CharacterObject, objGearParent: objSensor, strAllowedCategories: strCategories), GenericToken)
                                       .ConfigureAwait(false))
                            {
                                if (!string.IsNullOrEmpty(strCategories) && !string.IsNullOrEmpty(objSensor.Capacity)
                                                                         && (!objSensor.Capacity.Contains('[')
                                                                             || objSensor.Capacity.Contains("/[")))
                                    frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                                if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                    == DialogResult.Cancel)
                                    break;
                                blnAddAgain = frmPickGear.MyForm.AddAgain;

                                // Open the Gear XML file and locate the selected piece.
                                XmlNode objXmlGear
                                    = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                        frmPickGear.MyForm.SelectedGear);

                                // Create the new piece of Gear.
                                List<Weapon> lstWeapons = new List<Weapon>(1);

                                Gear objGear = new Gear(CharacterObject);
                                await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                                    string.Empty,
                                    false, token: GenericToken).ConfigureAwait(false);

                                if (objGear.InternalId.IsEmptyGuid())
                                    continue;

                                await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                                objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                                // Reduce the cost for Do It Yourself components.
                                if (frmPickGear.MyForm.DoItYourself)
                                    objGear.Cost = "(" + objGear.Cost + ") * 0.5";
                                // If the item was marked as free, change its cost.
                                if (frmPickGear.MyForm.FreeCost)
                                {
                                    objGear.Cost = "0";
                                }

                                await objSensor.Children.AddAsync(objGear, GenericToken).ConfigureAwait(false);

                                // Create any Weapons that came with this Gear.
                                if (lstWeapons.Count > 0)
                                {
                                    Vehicle objVehicle =
                                        (await CharacterObject.Vehicles.FindVehicleGearAsync(objGear.InternalId,
                                            GenericToken).ConfigureAwait(false)).Item2;
                                    foreach (Weapon objWeapon in lstWeapons)
                                    {
                                        await objVehicle.Weapons.AddAsync(objWeapon, GenericToken)
                                            .ConfigureAwait(false);
                                    }
                                }
                            }
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void tsVehicleWeaponAccessoryAddGear_Click(object sender, EventArgs e)
        {
            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false);

                // Make sure the Weapon Accessory is allowed to accept Gear.
                if (!(objSelectedNode?.Tag is WeaponAccessory objAccessory) || objAccessory.AllowGear == null)
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_WeaponGear", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_CyberwareGear", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                    return;
                }

                XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync("gear.xml", token: GenericToken)
                                                                  .ConfigureAwait(false);
                string strCategories;
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdCategories))
                {
                    foreach (XmlNode objXmlCategory in objAccessory.AllowGear)
                        sbdCategories.Append(objXmlCategory.InnerTextViaPool(GenericToken), ',');
                    if (sbdCategories.Length > 0)
                        --sbdCategories.Length;
                    strCategories = sbdCategories.ToString();
                }

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    bool blnAddAgain;
                    do
                    {
                        using (ThreadSafeForm<SelectGear> frmPickGear
                               = await ThreadSafeForm<SelectGear>.GetAsync(
                                   () => new SelectGear(CharacterObject, objGearParent: objAccessory, strAllowedCategories: strCategories),
                                   GenericToken).ConfigureAwait(false))
                        {
                            if (!string.IsNullOrEmpty(strCategories))
                                frmPickGear.MyForm.ShowNegativeCapacityOnly = true;

                            if (await frmPickGear.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                                break;
                            blnAddAgain = frmPickGear.MyForm.AddAgain;

                            // Open the Gear XML file and locate the selected piece.
                            XmlNode objXmlGear
                                = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear", frmPickGear.MyForm.SelectedGear);

                            // Create the new piece of Gear.
                            List<Weapon> lstWeapons = new List<Weapon>(1);

                            Gear objNewGear = new Gear(CharacterObject);
                            await objNewGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons, string.Empty,
                                false, token: GenericToken).ConfigureAwait(false);

                            if (objNewGear.InternalId.IsEmptyGuid())
                                continue;

                            await objNewGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                            objNewGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                            // Reduce the cost for Do It Yourself components.
                            if (frmPickGear.MyForm.DoItYourself)
                                objNewGear.Cost = "(" + objNewGear.Cost + ") * 0.5";
                            // If the item was marked as free, change its cost.
                            if (frmPickGear.MyForm.FreeCost)
                            {
                                objNewGear.Cost = "0";
                            }

                            await objAccessory.GearChildren.AddAsync(objNewGear, GenericToken).ConfigureAwait(false);

                            // Create any Weapons that came with this Gear.
                            foreach (Weapon objLoopWeapon in lstWeapons)
                            {
                                await objAccessory.Parent.Children.AddAsync(objLoopWeapon, GenericToken).ConfigureAwait(false);
                            }
                        }
                    } while (blnAddAgain);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        #endregion ContextMenu Events

        #region Additional Common Tab Control Events

        private async void treQualities_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedQuality(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async Task RefreshSelectedQuality(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            await tlpCommonLeftSide.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
            try
            {
                // Locate the selected Quality.
                Quality objQuality = await treQualities
                                           .DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag as Quality, token)
                                           .ConfigureAwait(false);
                if (objQuality == null)
                {
                    await lblQualitySourceLabel.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    await lblQualityBPLabel.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    await lblQualitySource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    await lblQualityBP.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    await UpdateQualityLevelValue(null, token).ConfigureAwait(false);
                }
                else
                {
                    await lblQualitySourceLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    await lblQualityBPLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    await lblQualitySource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    await lblQualityBP.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    IAsyncDisposable objLocker = await objQuality.LockObject.EnterReadLockAsync(token)
                        .ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        await UpdateQualityLevelValue(objQuality, token).ConfigureAwait(false);
                        await objQuality.SetSourceDetailAsync(lblQualitySource, token).ConfigureAwait(false);
                        string strText
                            = (await objQuality.GetBPAsync(token).ConfigureAwait(false) *
                               await objQuality.GetLevelsAsync(token).ConfigureAwait(false) *
                               await CharacterObjectSettings.GetKarmaQualityAsync(token).ConfigureAwait(false))
                              .ToString(
                                  GlobalSettings.CultureInfo) +
                              await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false)
                              + await LanguageManager.GetStringAsync("String_Karma", token: token)
                                  .ConfigureAwait(false);
                        await lblQualityBP.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                await tlpCommonLeftSide.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
            }
        }

        private async Task UpdateQualityLevelValue(Quality objSelectedQuality = null,
                                                        CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (objSelectedQuality == null)
            {
                await nudQualityLevel.DoThreadSafeAsync(x =>
                {
                    Interlocked.Increment(ref _intSkipQualityLevelChanged);
                    try
                    {
                        x.Value = 1;
                        x.Enabled = false;
                    }
                    finally
                    {
                        Interlocked.Decrement(ref _intSkipQualityLevelChanged);
                    }
                }, token).ConfigureAwait(false);
                return;
            }

            IAsyncDisposable objLocker = await objSelectedQuality.LockObject.EnterReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                if (await objSelectedQuality.GetOriginSourceAsync(token).ConfigureAwait(false) ==
                    QualitySource.Improvement
                    || await objSelectedQuality.GetOriginSourceAsync(token).ConfigureAwait(false) ==
                    QualitySource.Metatype
                    || await objSelectedQuality.GetOriginSourceAsync(token).ConfigureAwait(false) ==
                    QualitySource.Heritage
                    || await objSelectedQuality.GetLevelsAsync(token).ConfigureAwait(false) == 0)
                {
                    await nudQualityLevel.DoThreadSafeAsync(x =>
                    {
                        Interlocked.Increment(ref _intSkipQualityLevelChanged);
                        try
                        {
                            x.Value = 1;
                            x.Enabled = false;
                        }
                        finally
                        {
                            Interlocked.Decrement(ref _intSkipQualityLevelChanged);
                        }
                    }, token).ConfigureAwait(false);
                    return;
                }

                token.ThrowIfCancellationRequested();
                XPathNavigator objQualityNode
                    = await objSelectedQuality.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                string strLimitString =
                    objQualityNode?.SelectSingleNodeAndCacheExpression("chargenlimit", token: token)?.Value
                    ?? objQualityNode?.SelectSingleNodeAndCacheExpression("limit", token: token)?.Value
                    ?? string.Empty;
                token.ThrowIfCancellationRequested();
                if (!string.IsNullOrWhiteSpace(strLimitString)
                    && objQualityNode.SelectSingleNodeAndCacheExpression("nolevels", token: token) == null
                    && int.TryParse(strLimitString, out int intMaxRating))
                {
                    int intLevels = await objSelectedQuality.GetLevelsAsync(token).ConfigureAwait(false);
                    await nudQualityLevel.DoThreadSafeAsync(x =>
                    {
                        Interlocked.Increment(ref _intSkipQualityLevelChanged);
                        try
                        {
                            x.Maximum = intMaxRating;
                            x.Value = intLevels;
                            x.Enabled = true;
                        }
                        finally
                        {
                            Interlocked.Decrement(ref _intSkipQualityLevelChanged);
                        }
                    }, token).ConfigureAwait(false);
                }
                else
                {
                    await nudQualityLevel.DoThreadSafeAsync(x =>
                    {
                        Interlocked.Increment(ref _intSkipQualityLevelChanged);
                        try
                        {
                            x.Value = 1;
                            x.Enabled = false;
                        }
                        finally
                        {
                            Interlocked.Decrement(ref _intSkipQualityLevelChanged);
                        }
                    }, token).ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private int _intSkipQualityLevelChanged;

        private async void nudQualityLevel_ValueChanged(object sender, EventArgs e)
        {
            if (_intSkipQualityLevelChanged > 0)
                return;
            try
            {
                // Locate the selected Quality.
                if (!(await treQualities.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is Quality objSelectedQuality))
                    return;
                bool blnDoRemoveQuality = false;
                IAsyncDisposable objLocker = await objSelectedQuality.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    int intCurrentLevels = await objSelectedQuality.GetLevelsAsync(GenericToken).ConfigureAwait(false);
                    int intSelectedLevels = await nudQualityLevel.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                        .ConfigureAwait(false);
                    // Helps to capture a write lock here for performance purposes
                    IAsyncDisposable objLocker2 = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken)
                        .ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        // Adding new levels
                        for (; intSelectedLevels > intCurrentLevels; ++intCurrentLevels)
                        {
                            if (!await (await objSelectedQuality.GetNodeXPathAsync(GenericToken).ConfigureAwait(false))
                                    .RequirementsMetAsync(CharacterObject,
                                        strLocalName: await LanguageManager.GetStringAsync("String_Quality", token: GenericToken)
                                            .ConfigureAwait(false), token: GenericToken).ConfigureAwait(false))
                            {
                                await UpdateQualityLevelValue(objSelectedQuality, GenericToken).ConfigureAwait(false);
                                break;
                            }

                            List<Weapon> lstWeapons = new List<Weapon>(1);
                            Quality objQuality = new Quality(CharacterObject);
                            try
                            {
                                await objQuality.CreateAsync(await objSelectedQuality.GetNodeAsync(GenericToken).ConfigureAwait(false),
                                    QualitySource.Selected, lstWeapons, objSelectedQuality.Extra, token: GenericToken).ConfigureAwait(false);
                                if (objQuality.InternalId.IsEmptyGuid())
                                {
                                    await objQuality.DeleteQualityAsync(token: GenericToken).ConfigureAwait(false);
                                    await UpdateQualityLevelValue(objSelectedQuality, GenericToken).ConfigureAwait(false);
                                    break;
                                }

                                await objQuality.SetBPAsync(await objSelectedQuality.GetBPAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                                await objQuality.SetContributeToLimitAsync(await objSelectedQuality.GetContributeToLimitAsync(GenericToken).ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                                // Make sure that adding the Quality would not cause the character to exceed their BP limits.
                                bool blnAddItem = true;
                                if (await objQuality.GetContributeToLimitAsync(GenericToken).ConfigureAwait(false) && !await CharacterObject.GetIgnoreRulesAsync(GenericToken).ConfigureAwait(false))
                                {
                                    int intMaxQualityAmount = await CharacterObjectSettings.GetQualityKarmaLimitAsync(GenericToken).ConfigureAwait(false);
                                    // If the item being checked would cause the limit of 25 BP spent on Positive Qualities to be exceed, do not let it be checked and display a message.
                                    string strAmount
                                        = intMaxQualityAmount.ToString(GlobalSettings.CultureInfo)
                                          + await LanguageManager.GetStringAsync("String_Space", token: GenericToken)
                                              .ConfigureAwait(false)
                                          + await LanguageManager.GetStringAsync("String_Karma", token: GenericToken)
                                              .ConfigureAwait(false);

                                    // Add the cost of the Quality that is being added.
                                    int intBP = await objQuality.GetBPAsync(GenericToken).ConfigureAwait(false);

                                    if (await objQuality.GetTypeAsync(GenericToken).ConfigureAwait(false) == QualityType.Negative)
                                    {
                                        // Check if adding this Quality would put the character over their limit.
                                        if (!await CharacterObjectSettings.GetExceedNegativeQualitiesAsync(GenericToken).ConfigureAwait(false))
                                        {
                                            intBP += await CharacterObject.GetNegativeQualityLimitKarmaAsync(GenericToken).ConfigureAwait(false);
                                            if (intBP < intMaxQualityAmount * -1)
                                            {
                                                await Program.ShowScrollableMessageBoxAsync(
                                                    this,
                                                    string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager
                                                            .GetStringAsync("Message_NegativeQualityLimit",
                                                                token: GenericToken)
                                                            .ConfigureAwait(false), strAmount),
                                                    await LanguageManager
                                                        .GetStringAsync("MessageTitle_NegativeQualityLimit",
                                                            token: GenericToken)
                                                        .ConfigureAwait(false), MessageBoxButtons.OK,
                                                    MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                                blnAddItem = false;
                                            }
                                            else if (await CharacterObject.GetMetatypeBPAsync(GenericToken).ConfigureAwait(false) < 0
                                                     && intBP + await CharacterObject.GetMetatypeBPAsync(GenericToken).ConfigureAwait(false) < intMaxQualityAmount * -1)
                                            {
                                                await Program.ShowScrollableMessageBoxAsync(
                                                    this,
                                                    string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager
                                                            .GetStringAsync(
                                                                "Message_NegativeQualityAndMetatypeLimit",
                                                                token: GenericToken)
                                                            .ConfigureAwait(false), strAmount),
                                                    await LanguageManager
                                                        .GetStringAsync("MessageTitle_NegativeQualityLimit",
                                                            token: GenericToken)
                                                        .ConfigureAwait(false), MessageBoxButtons.OK,
                                                    MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                                blnAddItem = false;
                                            }
                                        }
                                    }
                                    // Check if adding this Quality would put the character over their limit.
                                    else if (!await CharacterObjectSettings.GetExceedPositiveQualitiesAsync(GenericToken).ConfigureAwait(false))
                                    {
                                        intBP += await CharacterObject.GetPositiveQualityLimitKarmaAsync(GenericToken).ConfigureAwait(false);
                                        if (intBP > intMaxQualityAmount)
                                        {
                                            await Program.ShowScrollableMessageBoxAsync(this,
                                                string.Format(
                                                    GlobalSettings.CultureInfo,
                                                    await LanguageManager
                                                        .GetStringAsync("Message_PositiveQualityLimit", token: GenericToken)
                                                        .ConfigureAwait(false), strAmount),
                                                await LanguageManager
                                                    .GetStringAsync(
                                                        "MessageTitle_PositiveQualityLimit", token: GenericToken)
                                                    .ConfigureAwait(false),
                                                MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                            blnAddItem = false;
                                        }
                                    }
                                }

                                if (blnAddItem)
                                {
                                    //to avoid an System.InvalidOperationException: Cannot change ObservableCollection during a CollectionChanged event.
                                    Interlocked.Increment(ref _intSkipQualityLevelChanged);
                                    try
                                    {
                                        await CharacterObject.Qualities.AddAsync(objQuality, GenericToken)
                                            .ConfigureAwait(false);
                                    }
                                    finally
                                    {
                                        Interlocked.Decrement(ref _intSkipQualityLevelChanged);
                                    }

                                    // Add any created Weapons to the character.
                                    foreach (Weapon objWeapon in lstWeapons)
                                    {
                                        await CharacterObject.Weapons.AddAsync(objWeapon, GenericToken)
                                            .ConfigureAwait(false);
                                    }
                                }
                                else
                                {
                                    await objQuality.DeleteQualityAsync(token: GenericToken).ConfigureAwait(false);
                                    await UpdateQualityLevelValue(objSelectedQuality, GenericToken).ConfigureAwait(false);
                                    break;
                                }
                            }
                            catch
                            {
                                await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }

                        // Removing levels
                        Guid guiSourceID = objSelectedQuality.SourceID;
                        string strExtra = await objSelectedQuality.GetExtraAsync(GenericToken).ConfigureAwait(false);
                        string strSourceName = await objSelectedQuality.GetSourceNameAsync(GenericToken).ConfigureAwait(false);
                        string strInternalId = objSelectedQuality.InternalId;
                        for (; intSelectedLevels < intCurrentLevels; --intCurrentLevels)
                        {
                            Quality objInvisibleQuality = await CharacterObject.Qualities.FirstOrDefaultAsync(
                                async x => x.SourceID == guiSourceID
                                     && await x.GetExtraAsync(GenericToken).ConfigureAwait(false) == strExtra
                                     && await x.GetSourceNameAsync(GenericToken).ConfigureAwait(false) == strSourceName
                                     && x.InternalId != strInternalId
                                     && !ReferenceEquals(x, objSelectedQuality), GenericToken).ConfigureAwait(false);
                            if (objInvisibleQuality == null
                                || !await RemoveQuality(objInvisibleQuality, false, false, GenericToken)
                                    .ConfigureAwait(false))
                            {
                                blnDoRemoveQuality = true;
                                break;
                            }
                        }
                    }
                    finally
                    {
                        await objLocker2.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }

                if (blnDoRemoveQuality && !await RemoveQuality(objSelectedQuality, false, false, GenericToken)
                        .ConfigureAwait(false))
                {
                    await UpdateQualityLevelValue(objSelectedQuality, GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Common Tab Control Events

        #region Additional Cyberware Tab Control Events

        private async void treCyberware_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedCyberware(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboCyberwareGrade_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || IsLoading)
                return;
            try
            {
                string strSelectedGrade = await cboCyberwareGrade
                                                .DoThreadSafeFuncAsync(x => x.SelectedValue?.ToString(), GenericToken)
                                                .ConfigureAwait(false);
                if (string.IsNullOrEmpty(strSelectedGrade) ||
                    !(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is Cyberware objCyberware))
                    return;
                // Locate the selected piece of Cyberware.
                Grade objNewGrade = await CharacterObject.GetGradeByNameAsync(await objCyberware.GetSourceTypeAsync(GenericToken).ConfigureAwait(false), strSelectedGrade, token: GenericToken).ConfigureAwait(false);
                if (objNewGrade == null)
                    return;
                // Updated the selected Cyberware Grade.
                await objCyberware.SetGradeAsync(objNewGrade, GenericToken).ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkPrototypeTranshuman_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is Cyberware objCyberware))
                    return;
                // Update the selected Cyberware Rating.
                await objCyberware.SetPrototypeTranshumanAsync(await chkPrototypeTranshuman
                    .DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudCyberwareRating_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                TreeNode objSelectedNode = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                             .ConfigureAwait(false);
                switch (objSelectedNode?.Tag)
                {
                    // Locate the selected piece of Cyberware.
                    case Cyberware objCyberware:
                    {
                        IAsyncDisposable objLocker =
                            await objCyberware.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                        try
                        {
                            GenericToken.ThrowIfCancellationRequested();
                            // Update the selected Cyberware Rating.
                            await objCyberware.SetRatingAsync(await nudCyberwareRating
                                .DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                .ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                            // See if a Bonus node exists.
                            if (objCyberware.Bonus?.InnerXmlContentContains("Rating", GenericToken) == true
                                || objCyberware.PairBonus?.InnerXmlContentContains("Rating", GenericToken) == true ||
                                objCyberware.WirelessOn
                                && objCyberware.WirelessBonus?.InnerXmlContentContains("Rating", GenericToken) == true)
                            {
                                // If the Bonus contains "Rating", remove the existing Improvements and create new ones.
                                await ImprovementManager
                                    .RemoveImprovementsAsync(CharacterObject, objCyberware.SourceType,
                                        objCyberware.InternalId, token: GenericToken).ConfigureAwait(false);
                                if (objCyberware.Bonus != null)
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, objCyberware.SourceType, objCyberware.InternalId,
                                        objCyberware.Bonus,
                                        await objCyberware.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                        await objCyberware.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), token: GenericToken).ConfigureAwait(false);
                                if (objCyberware.WirelessOn && objCyberware.WirelessBonus != null)
                                    await ImprovementManager.CreateImprovementsAsync(
                                        CharacterObject, objCyberware.SourceType, objCyberware.InternalId,
                                        objCyberware.WirelessBonus,
                                        await objCyberware.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                        await objCyberware.GetCurrentDisplayNameShortAsync(GenericToken)
                                            .ConfigureAwait(false), token: GenericToken).ConfigureAwait(false);

                                if (objCyberware.PairBonus != null)
                                {
                                    List<Cyberware> lstPairableCyberwares = await CharacterObject.Cyberware
                                        .DeepWhereAsync(x => x.GetChildrenAsync(GenericToken),
                                            async x => objCyberware.IncludePair.Contains(x.Name)
                                                       && x.Extra == objCyberware.Extra &&
                                                       await x.GetIsModularCurrentlyEquippedAsync(GenericToken)
                                                           .ConfigureAwait(false),
                                            GenericToken).ConfigureAwait(false);
                                    int intCyberwaresCount = lstPairableCyberwares.Count;
                                    // Need to use slightly different logic if this cyberware has a location (Left or Right) and only pairs with itself because Lefts can only be paired with Rights and Rights only with Lefts
                                    if (!string.IsNullOrEmpty(objCyberware.Location)
                                        && objCyberware.IncludePair.All(x => x == objCyberware.Name))
                                    {
                                        int intMatchLocationCount = 0;
                                        int intNotMatchLocationCount = 0;
                                        foreach (Cyberware objPairableCyberware in lstPairableCyberwares)
                                        {
                                            if (objPairableCyberware.Location != objCyberware.Location)
                                                ++intNotMatchLocationCount;
                                            else
                                                ++intMatchLocationCount;
                                        }

                                        // Set the count to the total number of cyberwares in matching pairs, which would mean 2x the number of whichever location contains the fewest members (since every single one of theirs would have a pair)
                                        intCyberwaresCount = Math.Min(intNotMatchLocationCount, intMatchLocationCount) *
                                                             2;
                                    }

                                    foreach (Cyberware objLoopCyberware in lstPairableCyberwares)
                                    {
                                        await ImprovementManager
                                            .RemoveImprovementsAsync(CharacterObject, objLoopCyberware.SourceType,
                                                objLoopCyberware.InternalId + "Pair", token: GenericToken)
                                            .ConfigureAwait(false);
                                        // Go down the list and create pair bonuses for every second item
                                        if (intCyberwaresCount > 0 && (intCyberwaresCount & 1) == 0)
                                        {
                                            await ImprovementManager.CreateImprovementsAsync(
                                                CharacterObject, objLoopCyberware.SourceType,
                                                objLoopCyberware.InternalId + "Pair", objLoopCyberware.PairBonus,
                                                await objLoopCyberware.GetRatingAsync(GenericToken)
                                                    .ConfigureAwait(false),
                                                await objLoopCyberware.GetCurrentDisplayNameShortAsync(GenericToken)
                                                    .ConfigureAwait(false), token: GenericToken).ConfigureAwait(false);
                                        }

                                        --intCyberwaresCount;
                                    }
                                }

                                if (!await objCyberware.GetIsModularCurrentlyEquippedAsync(GenericToken)
                                        .ConfigureAwait(false))
                                    await objCyberware.ChangeModularEquipAsync(false, token: GenericToken)
                                        .ConfigureAwait(false);
                            }

                            string strText = await objCyberware.GetCurrentDisplayNameAsync(GenericToken)
                                .ConfigureAwait(false);
                            await treCyberware.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                .ConfigureAwait(false);
                        }
                        finally
                        {
                            await objLocker.DisposeAsync().ConfigureAwait(false);
                        }

                        break;
                    }
                    case Gear objGear:
                    {
                        // Find the selected piece of Gear.
                        if (objGear.Category == "Foci" || objGear.Category == "Metamagic Foci"
                                                       || objGear.Category == "Stacked Focus")
                        {
                            if (!await objGear
                                    .RefreshSingleFocusRating(
                                        treFoci,
                                        await nudCyberwareRating
                                            .DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false))
                            {
                                int intRating = await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false);
                                IsRefreshing = true;
                                try
                                {
                                    await nudCyberwareRating
                                        .DoThreadSafeAsync(x => x.Value = intRating, GenericToken)
                                        .ConfigureAwait(false);
                                }
                                finally
                                {
                                    IsRefreshing = false;
                                }

                                return;
                            }
                        }
                        else
                            await objGear.SetRatingAsync(await nudCyberwareRating
                                .DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                .ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                        // See if a Bonus node exists.
                        if (objGear.Bonus != null || objGear.WirelessOn && objGear.WirelessBonus != null)
                        {
                            await ImprovementManager.RemoveImprovementsAsync(
                                                        CharacterObject, Improvement.ImprovementSource.Gear,
                                                        objGear.InternalId, token: GenericToken)
                                                    .ConfigureAwait(false);
                            if (!string.IsNullOrEmpty(objGear.Extra))
                            {
                                ImprovementManager.SetForcedValue(objGear.Extra.TrimEndOnce(", Hacked"), CharacterObject);
                            }

                            if (objGear.Bonus != null)
                                await ImprovementManager.CreateImprovementsAsync(
                                                            CharacterObject, Improvement.ImprovementSource.Gear,
                                                            objGear.InternalId,
                                                            objGear.Bonus, await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                            await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                         .ConfigureAwait(false), token: GenericToken)
                                                        .ConfigureAwait(false);
                            if (objGear.WirelessOn && objGear.WirelessBonus != null)
                                await ImprovementManager.CreateImprovementsAsync(
                                                            CharacterObject, Improvement.ImprovementSource.Gear,
                                                            objGear.InternalId,
                                                            objGear.WirelessBonus, await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                            await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                         .ConfigureAwait(false), token: GenericToken)
                                                        .ConfigureAwait(false);

                            if (!objGear.Equipped)
                                await objGear.ChangeEquippedStatusAsync(false, token: GenericToken)
                                             .ConfigureAwait(false);
                        }

                        string strName = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                        await treCyberware.DoThreadSafeAsync(() => objSelectedNode.Text = strName, GenericToken)
                                          .ConfigureAwait(false);
                        break;
                    }
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Cyberware Tab Control Events

        #region Additional Street Gear Tab Control Events

        private async void treWeapons_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedWeapon(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treArmor_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedArmor(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treLifestyles_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedLifestyle(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treLifestyles_DoubleClick(object sender, EventArgs e)
        {
            try
            {
                if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                         .ConfigureAwait(false) is Lifestyle objLifestyle))
                    return;

                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker =
                        await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken)
                            .ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        string strGuid = objLifestyle.InternalId;
                        int intMonths = await objLifestyle.GetIncrementsAsync(GenericToken).ConfigureAwait(false);
                        int intPosition = await CharacterObject.Lifestyles
                            .IndexOfAsync(
                                await CharacterObject.Lifestyles.FirstOrDefaultAsync(
                                    p => p.InternalId == strGuid,
                                    GenericToken).ConfigureAwait(false),
                                GenericToken)
                            .ConfigureAwait(false);

                        Lifestyle objLifestyleLocal = objLifestyle;
                        using (ThreadSafeForm<SelectLifestyle> frmPickLifestyle
                               = await ThreadSafeForm<SelectLifestyle>.GetAsync(
                                       () => new SelectLifestyle(
                                           CharacterObject, objLifestyleLocal),
                                       GenericToken)
                                   .ConfigureAwait(false))
                        {
                            DialogResult eResult = await frmPickLifestyle.ShowDialogSafeAsync(this, GenericToken)
                                .ConfigureAwait(false);
                            Lifestyle objSelected = frmPickLifestyle.MyForm.SelectedLifestyle;
                            if (eResult == DialogResult.Cancel)
                            {
                                if (objSelected != null && !ReferenceEquals(objLifestyle, objSelected))
                                    await objSelected.DisposeAsync().ConfigureAwait(false);
                                return;
                            }

                            // Update the selected Lifestyle and refresh the list.
                            objLifestyle = objSelected;
                        }

                        await objLifestyle.SetIncrementsAsync(intMonths, GenericToken).ConfigureAwait(false);

                        objLifestyle.SetInternalId(strGuid);
                        await CharacterObject.Lifestyles.SetValueAtAsync(intPosition, objLifestyle, GenericToken)
                            .ConfigureAwait(false);
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudLifestyleMonths_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                // Locate the selected Lifestyle.
                if (!(await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                         .ConfigureAwait(false) is Lifestyle objLifestyle))
                    return;

                IsRefreshing = true;
                try
                {
                    await objLifestyle.SetIncrementsAsync(
                        await nudLifestyleMonths.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    IsRefreshing = false;
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treGear_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedGear(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudGearRating_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is Gear objGear))
                    return;

                if (objGear.Category == "Foci" || objGear.Category == "Metamagic Foci"
                                               || objGear.Category == "Stacked Focus")
                {
                    if (!await objGear
                               .RefreshSingleFocusRating(
                                   treFoci,
                                   await nudGearRating.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                      .ConfigureAwait(false), GenericToken).ConfigureAwait(false))
                    {
                        int intRating = await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false);
                        IsRefreshing = true;
                        try
                        {
                            await nudGearRating.DoThreadSafeAsync(x => x.Value = intRating, GenericToken)
                                               .ConfigureAwait(false);
                        }
                        finally
                        {
                            IsRefreshing = false;
                        }

                        return;
                    }
                }
                else
                    await objGear.SetRatingAsync(await nudGearRating
                        .DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                if (objGear.Bonus != null || objGear.WirelessOn && objGear.WirelessBonus != null)
                {
                    await ImprovementManager.RemoveImprovementsAsync(CharacterObject,
                                                                     Improvement.ImprovementSource.Gear,
                                                                     objGear.InternalId, token: GenericToken).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(objGear.Extra))
                    {
                        ImprovementManager.SetForcedValue(objGear.Extra.TrimEndOnce(", Hacked"), CharacterObject);
                    }

                    if (objGear.Bonded || (objGear.Category != "Foci" && objGear.Category != "Metamagic Foci"
                                                                      && objGear.Category != "Stacked Focus"))
                    {
                        if (objGear.Bonus != null)
                            await ImprovementManager.CreateImprovementsAsync(
                                                        CharacterObject, Improvement.ImprovementSource.Gear,
                                                        objGear.InternalId, objGear.Bonus,
                                                        await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                        await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                     .ConfigureAwait(false), token: GenericToken)
                                                    .ConfigureAwait(false);
                        if (objGear.WirelessOn && objGear.WirelessBonus != null)
                            await ImprovementManager.CreateImprovementsAsync(
                                                        CharacterObject, Improvement.ImprovementSource.Gear,
                                                        objGear.InternalId,
                                                        objGear.WirelessBonus, await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                        await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                     .ConfigureAwait(false), token: GenericToken)
                                                    .ConfigureAwait(false);
                    }

                    if (!objGear.Equipped)
                        await objGear.ChangeEquippedStatusAsync(false, token: GenericToken).ConfigureAwait(false);
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudGearQty_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                // Attempt to locate the selected piece of Gear.
                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is Gear objGear))
                    return;
                await objGear.SetQuantityAsync(await nudGearQty.DoThreadSafeFuncAsync(x => x.Value, GenericToken)
                                                   .ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudDrugQty_ValueChanged(object sender, EventArgs e)
        {
            // Don't attempt to do anything while the data is still being populated.
            if (IsLoading || IsRefreshing)
                return;

            try
            {
                if (!(await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                          .ConfigureAwait(false) is Drug objDrug))
                    return;
                objDrug.Quantity = await nudDrugQty.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                   .ConfigureAwait(false);
                await RefreshSelectedDrug(GenericToken).ConfigureAwait(false);

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkArmorEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                object objSelected = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                                   .ConfigureAwait(false);
                if (objSelected == null)
                    return;

                bool blnChecked = await chkArmorEquipped.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                        .ConfigureAwait(false);

                // Locate the selected Armor or Armor Mod.
                switch (objSelected)
                {
                    case Armor objArmor:
                        await objArmor.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                        break;

                    case ArmorMod objMod:
                        await objMod.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                        break;

                    case Gear objGear:
                        await objGear.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                        if (blnChecked)
                        {
                            (_, Armor objParentArmor, ArmorMod objParentMod) = await CharacterObject.Armor.FindArmorGearAsync(objGear.InternalId, GenericToken).ConfigureAwait(false);
                            // Add the Gear's Improvements to the character.
                            if (objParentArmor.Equipped && objParentMod?.Equipped != false)
                            {
                                await objGear.ChangeEquippedStatusAsync(true, token: GenericToken)
                                             .ConfigureAwait(false);
                            }
                        }
                        else
                        {
                            await objGear.ChangeEquippedStatusAsync(false, token: GenericToken).ConfigureAwait(false);
                        }

                        break;

                    default:
                        return;
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudWeaponRating_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false);
                switch (objSelectedNode?.Tag)
                {
                    case Gear objGear:
                        {
                            if (objGear.Category == "Foci" || objGear.Category == "Metamagic Foci"
                                                           || objGear.Category == "Stacked Focus")
                            {
                                if (!await objGear.RefreshSingleFocusRating(
                                        treFoci,
                                        await nudWeaponRating.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                              .ConfigureAwait(false), GenericToken).ConfigureAwait(false))
                                {
                                    int intRating = await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false);
                                    IsRefreshing = true;
                                    try
                                    {
                                        await nudWeaponRating.DoThreadSafeAsync(
                                            x => x.Value = intRating, GenericToken).ConfigureAwait(false);
                                    }
                                    finally
                                    {
                                        IsRefreshing = false;
                                    }

                                    return;
                                }
                            }
                            else
                                await objGear.SetRatingAsync(await nudWeaponRating
                                    .DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                            string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                            await treWeapons.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                             .ConfigureAwait(false);
                            break;
                        }
                    case WeaponAccessory objAccessory:
                        {
                            await objAccessory.SetRatingAsync(await nudWeaponRating.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                            string strText = await objAccessory.GetCurrentDisplayNameAsync(GenericToken)
                                                               .ConfigureAwait(false);
                            await treWeapons.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                             .ConfigureAwait(false);
                            break;
                        }
                    case Weapon objWeapon:
                        {
                            await objWeapon.SetRatingAsync(await nudWeaponRating.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                            string strText = await objWeapon.GetCurrentDisplayNameAsync(GenericToken)
                                                               .ConfigureAwait(false);
                            await treWeapons.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                             .ConfigureAwait(false);
                            break;
                        }
                    default:
                        return;
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkWeaponEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                object objSelected = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                                     .ConfigureAwait(false);
                if (objSelected == null)
                    return;

                bool blnChecked = await chkWeaponEquipped.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                         .ConfigureAwait(false);
                // Determine if this is a Weapon.
                switch (objSelected)
                {
                    case Weapon objWeapon:
                        await objWeapon.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                        break;

                    case Gear objGear:
                        // Find the selected Gear.
                        await objGear.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                        await objGear.ChangeEquippedStatusAsync(blnChecked, token: GenericToken).ConfigureAwait(false);
                        break;

                    case WeaponAccessory objAccessory:
                        await objAccessory.SetEquippedAsync(blnChecked, token: GenericToken)
                            .ConfigureAwait(false);
                        break;

                    default:
                        return;
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkIncludedInWeapon_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                // Locate the selected Weapon Accessory or Modification.
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is WeaponAccessory objAccessory))
                    return;
                objAccessory.IncludedInWeapon = await chkIncludedInWeapon
                                                      .DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                      .ConfigureAwait(false);

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkGearEquipped_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false)
                        is Gear objSelectedGear))
                    return;
                bool blnChecked = await chkGearEquipped.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                       .ConfigureAwait(false);
                await objSelectedGear.SetEquippedAsync(blnChecked, GenericToken).ConfigureAwait(false);
                await objSelectedGear.ChangeEquippedStatusAsync(blnChecked, token: GenericToken).ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkGearHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    IHasMatrixAttributes objCommlink)
                {
                    await objCommlink.SetHomeNodeAsync(CharacterObject,
                            await chkGearHomeNode.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                .ConfigureAwait(false), GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkArmorHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    IHasMatrixAttributes objCommlink)
                {
                    await objCommlink.SetHomeNodeAsync(CharacterObject,
                            await chkArmorHomeNode.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                .ConfigureAwait(false), GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkWeaponHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    IHasMatrixAttributes objCommlink)
                {
                    await objCommlink.SetHomeNodeAsync(CharacterObject,
                            await chkWeaponHomeNode.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                .ConfigureAwait(false), GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkCyberwareHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    IHasMatrixAttributes objCommlink)
                {
                    await objCommlink.SetHomeNodeAsync(CharacterObject,
                            await chkCyberwareHomeNode.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                .ConfigureAwait(false), GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkVehicleHomeNode_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false) is
                    IHasMatrixAttributes objCommlink)
                {
                    await objCommlink.SetHomeNodeAsync(CharacterObject,
                            await chkVehicleHomeNode.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                .ConfigureAwait(false), GenericToken)
                        .ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkCommlinks_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                await RefreshGears(treGear, cmsGearLocation, cmsGear, cmsGearAllowRename,
                                   await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                     .ConfigureAwait(false), false, token: GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkGearActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is
                    IHasMatrixAttributes objSelectedCommlink)
                {
                    await objSelectedCommlink.SetActiveCommlinkAsync(CharacterObject,
                        await chkGearActiveCommlink.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkArmorActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is
                    IHasMatrixAttributes objSelectedCommlink)
                {
                    await objSelectedCommlink.SetActiveCommlinkAsync(CharacterObject,
                        await chkArmorActiveCommlink.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkWeaponActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is
                    IHasMatrixAttributes objSelectedCommlink)
                {
                    await objSelectedCommlink.SetActiveCommlinkAsync(CharacterObject,
                        await chkWeaponActiveCommlink.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                            .ConfigureAwait(false)).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkCyberwareActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is
                    IHasMatrixAttributes objSelectedCommlink)
                {
                    await objSelectedCommlink.SetActiveCommlinkAsync(CharacterObject,
                        await chkCyberwareActiveCommlink.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void chkVehicleActiveCommlink_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                // Attempt to locate the selected piece of Gear.
                if (await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false) is
                    IHasMatrixAttributes objSelectedCommlink)
                {
                    await objSelectedCommlink.SetActiveCommlinkAsync(CharacterObject,
                        await chkVehicleActiveCommlink.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // swallow this
            }
        }

        private async void cboGearAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboGearAttack.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                        .ConfigureAwait(false))
                    return;

                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboGearAttack, cboGearAttack,
                            cboGearSleaze, cboGearDataProcessing, cboGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboGearSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboGearSleaze.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                        .ConfigureAwait(false))
                    return;

                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboGearSleaze, cboGearAttack,
                            cboGearSleaze, cboGearDataProcessing, cboGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboGearDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboGearDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                                .ConfigureAwait(false))
                    return;

                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboGearDataProcessing, cboGearAttack,
                            cboGearSleaze, cboGearDataProcessing, cboGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboGearFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboGearFirewall.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                          .ConfigureAwait(false))
                    return;

                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                   .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                            CharacterObject, cboGearFirewall, cboGearAttack,
                            cboGearSleaze, cboGearDataProcessing, cboGearFirewall, GenericToken).ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboVehicleAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboVehicleAttack.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                           .ConfigureAwait(false))
                    return;

                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                                           CharacterObject, cboVehicleAttack, cboVehicleAttack,
                                           cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, GenericToken)
                                       .ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboVehicleSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboVehicleSleaze.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                           .ConfigureAwait(false))
                    return;

                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                                           CharacterObject, cboVehicleSleaze, cboVehicleAttack,
                                           cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, GenericToken)
                                       .ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboVehicleFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboVehicleFirewall.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                             .ConfigureAwait(false))
                    return;

                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                                           CharacterObject, cboVehicleFirewall, cboVehicleAttack,
                                           cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, GenericToken)
                                       .ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboVehicleDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboVehicleDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                                   .ConfigureAwait(false))
                    return;

                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                                           CharacterObject, cboVehicleDataProcessing, cboVehicleAttack,
                                           cboVehicleSleaze, cboVehicleDataProcessing, cboVehicleFirewall, GenericToken)
                                       .ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboCyberwareAttack_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboCyberwareAttack.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                             .ConfigureAwait(false))
                    return;

                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                                           CharacterObject, cboCyberwareAttack, cboCyberwareAttack,
                                           cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall,
                                           GenericToken)
                                       .ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboCyberwareSleaze_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboCyberwareSleaze.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                             .ConfigureAwait(false))
                    return;

                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                                           CharacterObject, cboCyberwareSleaze, cboCyberwareAttack,
                                           cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall,
                                           GenericToken)
                                       .ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboCyberwareDataProcessing_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing
                    || !await cboCyberwareDataProcessing.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                        .ConfigureAwait(false))
                    return;

                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                                           CharacterObject, cboCyberwareDataProcessing, cboCyberwareAttack,
                                           cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall,
                                           GenericToken)
                                       .ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboCyberwareFirewall_SelectedIndexChanged(object sender, EventArgs e)
        {
            try
            {
                if (IsRefreshing || !await cboCyberwareFirewall.DoThreadSafeFuncAsync(x => x.Enabled, GenericToken)
                                                               .ConfigureAwait(false))
                    return;

                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        IHasMatrixAttributes objTarget))
                    return;

                IsRefreshing = true;
                try
                {
                    if (await objTarget.ProcessMatrixAttributeComboBoxChangeAsync(
                                           CharacterObject, cboCyberwareFirewall, cboCyberwareAttack,
                                           cboCyberwareSleaze, cboCyberwareDataProcessing, cboCyberwareFirewall,
                                           GenericToken)
                                       .ConfigureAwait(false))
                    {
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    IsRefreshing = false;
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Street Gear Tab Control Events

        #region Additional Drug Tab Control Events

        private async void treCustomDrugs_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedDrug(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Drug Tab Control Events

        #region Additional Vehicle Tab Control Events

        private async void treVehicles_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedVehicle(GenericToken).ConfigureAwait(false);
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudVehicleRating_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false);
                switch (objSelectedNode?.Tag)
                {
                    case VehicleMod objMod:
                    {
                        await objMod.SetRatingAsync(await nudVehicleRating
                            .DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                        string strText = await objMod.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                        await treVehicles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                         .ConfigureAwait(false);
                        break;
                    }
                    case Gear objGear:
                    {
                        if (objGear.Category == "Foci" || objGear.Category == "Metamagic Foci"
                                                       || objGear.Category == "Stacked Focus")
                        {
                            if (!await objGear.RefreshSingleFocusRating(
                                    treFoci,
                                    await nudVehicleRating.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                          .ConfigureAwait(false), GenericToken).ConfigureAwait(false))
                            {
                                int intRating = await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false);
                                IsRefreshing = true;
                                try
                                {
                                    await nudVehicleRating.DoThreadSafeAsync(
                                        x => x.Value = intRating, GenericToken).ConfigureAwait(false);
                                }
                                finally
                                {
                                    IsRefreshing = false;
                                }

                                return;
                            }
                        }
                        else
                            await objGear.SetRatingAsync(await nudVehicleRating
                                .DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                .ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                        string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                        await treVehicles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                         .ConfigureAwait(false);
                        break;
                    }
                    case WeaponAccessory objAccessory:
                    {
                        await objAccessory.SetRatingAsync(await nudVehicleRating.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                        string strText = await objAccessory.GetCurrentDisplayNameAsync(GenericToken)
                                                           .ConfigureAwait(false);
                        await treVehicles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                         .ConfigureAwait(false);
                        break;
                    }
                    case Cyberware objCyberware:
                    {
                        await objCyberware.SetRatingAsync(await nudVehicleRating
                            .DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                        string strText = await objCyberware.GetCurrentDisplayNameAsync(GenericToken)
                                                           .ConfigureAwait(false);
                        await treVehicles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                         .ConfigureAwait(false);
                        break;
                    }
                    default:
                        return;
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkVehicleWeaponAccessoryInstalled_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is ICanEquip
                        objEquippable))
                    return;
                await objEquippable.SetEquippedAsync(await chkVehicleWeaponAccessoryInstalled
                    .DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                    .ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudVehicleGearQty_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                            .ConfigureAwait(false);
                if (!(objSelectedNode?.Tag is Gear objGear))
                    return;
                await objGear.SetQuantityAsync(await nudVehicleGearQty.DoThreadSafeFuncAsync(x => x.Value, GenericToken)
                                                          .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                string strText = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                await treVehicles.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                 .ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Vehicle Tab Control Events

        #region Additional Spells and Spirits Tab Control Events

        private async void treSpells_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedSpell(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treFoci_AfterCheck(object sender, TreeViewEventArgs e)
        {
            if (e.Node.Checked)
                return;
            if (!(e.Node.Tag is IHasInternalId objId))
                return;
            try
            {
                string strFindId = objId.InternalId;
                Focus objFocus
                    = await CharacterObject.Foci.FindAsync(x => x.GearObject?.InternalId == strFindId,
                          GenericToken).ConfigureAwait(false)
                      ?? await CharacterObject.Foci.FindAsync(x => x.InternalId == strFindId,
                          GenericToken).ConfigureAwait(false);

                // Mark the Gear as not Bonded and remove any Improvements.
                Gear objGear = objFocus?.GearObject;

                if (objGear != null)
                {
                    objGear.Bonded = false;
                    await ImprovementManager
                        .RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.Gear,
                            objGear.InternalId, token: GenericToken).ConfigureAwait(false);
                    await CharacterObject.Foci.RemoveAsync(objFocus, GenericToken).ConfigureAwait(false);
                }
                else
                {
                    // This is a Stacked Focus.
                    StackedFocus objStack = await CharacterObject.StackedFoci
                        .FindAsync(x => x.InternalId == objId.InternalId, GenericToken)
                        .ConfigureAwait(false);

                    if (objStack != null)
                    {
                        objStack.Bonded = false;
                        await ImprovementManager
                            .RemoveImprovementsAsync(CharacterObject, Improvement.ImprovementSource.StackedFocus,
                                objStack.InternalId, token: GenericToken).ConfigureAwait(false);
                    }
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void treFoci_BeforeCheck(object sender, TreeViewCancelEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            TreeView treViewToUse = e.Node.TreeView;

            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    CursorWait objCursorWait =
                        await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                    try
                    {
                        // Don't bother to do anything since a node is being unchecked.
                        if (await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Checked, GenericToken)
                                .ConfigureAwait(false))
                            return;

                        string strSelectedId
                            = (await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Tag, GenericToken)
                                .ConfigureAwait(false) as IHasInternalId)
                            ?.InternalId ?? string.Empty;

                        // Locate the Focus that is being touched.
                        Gear objSelectedFocus = await CharacterObject.Gear.DeepFindByIdAsync(strSelectedId, GenericToken).ConfigureAwait(false);

                        // Set the Focus count to 1 and get its current Rating (Force). This number isn't used in the following loops because it isn't yet checked or unchecked.
                        int intFociCount = 1;
                        int intFociTotal;

                        if (objSelectedFocus != null)
                            intFociTotal = await objSelectedFocus.GetRatingAsync(GenericToken).ConfigureAwait(false);
                        else
                        {
                            // This is a Stacked Focus.
                            intFociTotal = (await CharacterObject.StackedFoci
                                    .FindAsync(x => x.InternalId == strSelectedId, GenericToken)
                                    .ConfigureAwait(false))
                                ?.TotalForce ?? 0;
                        }

                        List<string> lstActiveIds = await treViewToUse.DoThreadSafeFuncAsync(y =>
                        {
                            List<string> lstInnerReturn = new List<string>(y.Nodes.Count);
                            // Run through the list of items. Count the number of Foci the character would have bonded including this one, plus the total Force of all checked Foci.
                            foreach (TreeNode objNode in y.Nodes)
                            {
                                if (objNode.Checked)
                                {
                                    lstInnerReturn.Add(objNode.Tag.ToString());
                                }
                            }
                            return lstInnerReturn;
                        }, GenericToken).ConfigureAwait(false);
                        intFociCount += lstActiveIds.Count;

                        foreach (string strNodeId in lstActiveIds)
                        {
                            Gear objGear = await CharacterObject.Gear.FindByIdAsync(strNodeId, GenericToken).ConfigureAwait(false);
                            if (objGear?.Bonded == true)
                                intFociTotal += await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false);
                            StackedFocus objFocus = await CharacterObject.StackedFoci.FindAsync(x => x.InternalId == strNodeId && x.Bonded, GenericToken).ConfigureAwait(false);
                            if (objFocus != null)
                                intFociTotal += await objFocus.GetTotalForceAsync(GenericToken).ConfigureAwait(false);
                        }

                        if (!await CharacterObject.GetIgnoreRulesAsync(GenericToken).ConfigureAwait(false))
                        {
                            if (intFociTotal > await (await CharacterObject
                                        .GetAttributeAsync("MAG", token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken).ConfigureAwait(false) * 5 ||
                                await CharacterObjectSettings.GetMysAdeptSecondMAGAttributeAsync(GenericToken).ConfigureAwait(false)
                                && await CharacterObject.GetIsMysticAdeptAsync(GenericToken).ConfigureAwait(false)
                                && await CharacterObject.GetInitiateGradeAsync(GenericToken).ConfigureAwait(false) + 1
                                > await (await CharacterObject
                                        .GetAttributeAsync(
                                            "MAGAdept",
                                            token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken)
                                    .ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager
                                        .GetStringAsync("Message_FocusMaximumForce", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager
                                        .GetStringAsync("MessageTitle_FocusMaximum", token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                e.Cancel = true;
                                return;
                            }

                            if (intFociCount > await (await CharacterObject
                                        .GetAttributeAsync("MAG", token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken).ConfigureAwait(false) ||
                                await CharacterObjectSettings.GetMysAdeptSecondMAGAttributeAsync(GenericToken).ConfigureAwait(false)
                                && await CharacterObject.GetIsMysticAdeptAsync(GenericToken).ConfigureAwait(false)
                                && intFociCount
                                > await (await CharacterObject
                                        .GetAttributeAsync(
                                            "MAGAdept",
                                            token: GenericToken)
                                        .ConfigureAwait(false))
                                    .GetTotalValueAsync(GenericToken)
                                    .ConfigureAwait(false))
                            {
                                await Program.ShowScrollableMessageBoxAsync(
                                    this,
                                    await LanguageManager
                                        .GetStringAsync("Message_FocusMaximumNumber", token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager
                                        .GetStringAsync("MessageTitle_FocusMaximum", token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                                e.Cancel = true;
                                return;
                            }
                        }

                        IAsyncDisposable objLocker2 = await CharacterObject.LockObject.EnterWriteLockAsync(GenericToken)
                            .ConfigureAwait(false);
                        try
                        {
                            if (objSelectedFocus != null)
                            {
                                Focus objFocus = new Focus(CharacterObject)
                                {
                                    GearObject = objSelectedFocus
                                };

                                if (objSelectedFocus.Equipped
                                    && (objSelectedFocus.Bonus != null || objSelectedFocus.WirelessOn &&
                                        objSelectedFocus.WirelessBonus != null))
                                {
                                    if (!string.IsNullOrEmpty(objSelectedFocus.Extra))
                                        ImprovementManager.SetForcedValue(objSelectedFocus.Extra, CharacterObject);
                                    if (objSelectedFocus.Bonus != null)
                                    {
                                        if (!await ImprovementManager.CreateImprovementsAsync(
                                                CharacterObject, Improvement.ImprovementSource.Gear,
                                                objSelectedFocus.InternalId,
                                                objSelectedFocus.Bonus,
                                                await objSelectedFocus.GetRatingAsync(GenericToken)
                                                    .ConfigureAwait(false),
                                                await objSelectedFocus.GetCurrentDisplayNameShortAsync(GenericToken)
                                                    .ConfigureAwait(false), token: GenericToken).ConfigureAwait(false))
                                        {
                                            // Clear created improvements
                                            await objSelectedFocus.ChangeEquippedStatusAsync(false, token: GenericToken)
                                                .ConfigureAwait(false);
                                            await objSelectedFocus.ChangeEquippedStatusAsync(true, token: GenericToken)
                                                .ConfigureAwait(false);
                                            e.Cancel = true;
                                            return;
                                        }

                                        objSelectedFocus.Extra = ImprovementManager.GetSelectedValue(CharacterObject);
                                    }

                                    if (objSelectedFocus.WirelessOn
                                        && objSelectedFocus.WirelessBonus != null
                                        && !await ImprovementManager.CreateImprovementsAsync(
                                            CharacterObject, Improvement.ImprovementSource.Gear,
                                            objSelectedFocus.InternalId,
                                            objSelectedFocus.WirelessBonus,
                                            await objSelectedFocus.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                            await objSelectedFocus.GetCurrentDisplayNameShortAsync(GenericToken)
                                                .ConfigureAwait(false), token: GenericToken).ConfigureAwait(false))
                                    {
                                        // Clear created improvements
                                        await objSelectedFocus.ChangeEquippedStatusAsync(false, token: GenericToken)
                                            .ConfigureAwait(false);
                                        await objSelectedFocus.ChangeEquippedStatusAsync(true, token: GenericToken)
                                            .ConfigureAwait(false);
                                        e.Cancel = true;
                                        return;
                                    }
                                }

                                string strName = await objSelectedFocus.GetCurrentDisplayNameAsync(GenericToken)
                                    .ConfigureAwait(false);
                                await treViewToUse.DoThreadSafeFuncAsync(() => e.Node.Text = strName, GenericToken)
                                    .ConfigureAwait(false);
                                await CharacterObject.Foci.AddAsync(objFocus, GenericToken).ConfigureAwait(false);
                                objSelectedFocus.Bonded = true;
                            }
                            else
                            {
                                // This is a Stacked Focus.
                                StackedFocus objStack
                                    = await CharacterObject.StackedFoci
                                        .FindAsync(x => x.InternalId == strSelectedId, GenericToken)
                                        .ConfigureAwait(false);
                                if (objStack != null)
                                {
                                    Gear objStackGear = await CharacterObject.Gear.DeepFindByIdAsync(objStack.GearId, GenericToken).ConfigureAwait(false);
                                    if (objStackGear.Equipped)
                                    {
                                        await objStack.Gear.ForEachWithSideEffectsWithBreakAsync(async objGear =>
                                        {
                                            if (objGear.Bonus == null &&
                                                (!objGear.WirelessOn || objGear.WirelessBonus == null))
                                                return true;
                                            if (!string.IsNullOrEmpty(objGear.Extra))
                                                ImprovementManager.SetForcedValue(objGear.Extra, CharacterObject);
                                            if (objGear.Bonus != null)
                                            {
                                                if (!await ImprovementManager.CreateImprovementsAsync(
                                                            CharacterObject, Improvement.ImprovementSource.StackedFocus,
                                                            objStack.InternalId, objGear.Bonus,
                                                            await objGear.GetRatingAsync(GenericToken)
                                                                .ConfigureAwait(false),
                                                            await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                .ConfigureAwait(false), token: GenericToken)
                                                        .ConfigureAwait(false))
                                                {
                                                    // Clear created improvements
                                                    await objStackGear
                                                        .ChangeEquippedStatusAsync(false, token: GenericToken)
                                                        .ConfigureAwait(false);
                                                    await objStackGear
                                                        .ChangeEquippedStatusAsync(true, token: GenericToken)
                                                        .ConfigureAwait(false);
                                                    e.Cancel = true;
                                                    return false;
                                                }

                                                objGear.Extra = ImprovementManager.GetSelectedValue(CharacterObject);
                                            }

                                            if (objGear.WirelessOn
                                                && objGear.WirelessBonus != null
                                                && !await ImprovementManager.CreateImprovementsAsync(
                                                        CharacterObject, Improvement.ImprovementSource.StackedFocus,
                                                        objStack.InternalId, objGear.WirelessBonus,
                                                        await objGear.GetRatingAsync(GenericToken)
                                                            .ConfigureAwait(false),
                                                        await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                                            .ConfigureAwait(false), token: GenericToken)
                                                    .ConfigureAwait(false))
                                            {
                                                // Clear created improvements
                                                await objStackGear.ChangeEquippedStatusAsync(false, token: GenericToken)
                                                    .ConfigureAwait(false);
                                                await objStackGear.ChangeEquippedStatusAsync(true, token: GenericToken)
                                                    .ConfigureAwait(false);
                                                e.Cancel = true;
                                                return false;
                                            }

                                            return true;
                                        }, GenericToken).ConfigureAwait(false);
                                        if (e.Cancel)
                                            return;
                                    }

                                    objStack.Bonded = true;
                                    string strName = await objStackGear.GetCurrentDisplayNameAsync(GenericToken)
                                        .ConfigureAwait(false);
                                    await treViewToUse.DoThreadSafeAsync(() => e.Node.Text = strName, GenericToken)
                                        .ConfigureAwait(false);
                                }
                            }
                            await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objCursorWait.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void nudArmorRating_ValueChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                TreeNode objSelectedNode = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken)
                                                         .ConfigureAwait(false);
                switch (objSelectedNode?.Tag)
                {
                    // Locate the selected ArmorMod.
                    case ArmorMod objMod:
                    {
                        await objMod.SetRatingAsync(await nudArmorRating.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                        string strText = await objMod.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                        await treArmor.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                      .ConfigureAwait(false);

                        // See if a Bonus node exists.
                        if (objMod.Bonus?.InnerXmlContentContains("Rating", GenericToken) == true || objMod.WirelessOn
                            && objMod.WirelessBonus?.InnerXmlContentContains("Rating", GenericToken) == true)
                        {
                            // If the Bonus contains "Rating", remove the existing Improvements and create new ones.
                            await ImprovementManager.RemoveImprovementsAsync(
                                                        CharacterObject, Improvement.ImprovementSource.ArmorMod,
                                                        objMod.InternalId, GenericToken)
                                                    .ConfigureAwait(false);
                            if (objMod.Bonus != null)
                                await ImprovementManager.CreateImprovementsAsync(
                                                            CharacterObject, Improvement.ImprovementSource.ArmorMod,
                                                            objMod.InternalId,
                                                            objMod.Bonus, await objMod.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                            await objMod.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                        .ConfigureAwait(false), token: GenericToken)
                                                        .ConfigureAwait(false);
                            if (objMod.WirelessOn && objMod.WirelessBonus != null)
                                await ImprovementManager.CreateImprovementsAsync(
                                                            CharacterObject, Improvement.ImprovementSource.ArmorMod,
                                                            objMod.InternalId,
                                                            objMod.WirelessBonus, await objMod.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                            await objMod.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                        .ConfigureAwait(false), token: GenericToken)
                                                        .ConfigureAwait(false);
                        }

                        break;
                    }
                    case Gear objGear:
                    {
                        if (objGear.Category == "Foci" || objGear.Category == "Metamagic Foci"
                                                       || objGear.Category == "Stacked Focus")
                        {
                            if (!await objGear.RefreshSingleFocusRating(
                                    treFoci,
                                    await nudArmorRating.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false))
                            {
                                int intRating = await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false);
                                IsRefreshing = true;
                                try
                                {
                                    await nudArmorRating.DoThreadSafeAsync(
                                        x => x.Value = intRating, GenericToken).ConfigureAwait(false);
                                }
                                finally
                                {
                                    IsRefreshing = false;
                                }

                                return;
                            }
                        }
                        else
                            await objGear.SetRatingAsync(await nudArmorRating
                                .DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                .ConfigureAwait(false), GenericToken).ConfigureAwait(false);

                        string strName = await objGear.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                        await treArmor.DoThreadSafeAsync(() => objSelectedNode.Text = strName, GenericToken)
                                      .ConfigureAwait(false);

                        // See if a Bonus node exists.
                        if (objGear.Bonus?.InnerXmlContentContains("Rating", GenericToken) == true || objGear.WirelessOn
                            && objGear.WirelessBonus?.InnerXmlContentContains("Rating", GenericToken) == true)
                        {
                            // If the Bonus contains "Rating", remove the existing Improvements and create new ones.
                            await ImprovementManager.RemoveImprovementsAsync(
                                                        CharacterObject, Improvement.ImprovementSource.Gear,
                                                        objGear.InternalId, GenericToken)
                                                    .ConfigureAwait(false);
                            if (objGear.Bonus != null)
                                await ImprovementManager.CreateImprovementsAsync(
                                                            CharacterObject, Improvement.ImprovementSource.Gear,
                                                            objGear.InternalId,
                                                            objGear.Bonus, await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                            await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                         .ConfigureAwait(false), token: GenericToken)
                                                        .ConfigureAwait(false);
                            if (objGear.WirelessOn && objGear.WirelessBonus != null)
                                await ImprovementManager.CreateImprovementsAsync(
                                                            CharacterObject, Improvement.ImprovementSource.Gear,
                                                            objGear.InternalId,
                                                            objGear.WirelessBonus, await objGear.GetRatingAsync(GenericToken).ConfigureAwait(false),
                                                            await objGear.GetCurrentDisplayNameShortAsync(GenericToken)
                                                                         .ConfigureAwait(false), token: GenericToken)
                                                        .ConfigureAwait(false);

                            if (!objGear.Equipped)
                                await objGear.ChangeEquippedStatusAsync(false, token: GenericToken).ConfigureAwait(false);
                        }

                        break;
                    }
                    case Armor objArmor:
                    {
                        await objArmor.SetRatingAsync(await nudArmorRating.DoThreadSafeFuncAsync(x => x.ValueAsInt, GenericToken)
                                                              .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                        string strText = await objArmor.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                        await treArmor.DoThreadSafeAsync(() => objSelectedNode.Text = strText, GenericToken)
                                      .ConfigureAwait(false);
                        break;
                    }
                }
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboTradition_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing || IsDisposed)
                return;
            SkipUpdate = true;
            try
            {
                string strSelectedId
                    = await cboTradition.DoThreadSafeFuncAsync(x => x.SelectedValue?.ToString(), GenericToken)
                                        .ConfigureAwait(false);
                if (string.IsNullOrEmpty(strSelectedId))
                    return;

                XmlNode xmlTradition = (await CharacterObject.LoadDataAsync("traditions.xml", token: GenericToken)
                                                             .ConfigureAwait(false))
                    .TryGetNodeByNameOrId("/chummer/traditions/tradition", strSelectedId);

                Tradition objTradition =
                    await CharacterObject.GetMagicTraditionAsync(GenericToken).ConfigureAwait(false);
                if (xmlTradition == null)
                {
                    await lblTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                          .ConfigureAwait(false);
                    await txtTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                          .ConfigureAwait(false);
                    await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = false, GenericToken).ConfigureAwait(false);
                    await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                            .ConfigureAwait(false);
                    await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = false, GenericToken).ConfigureAwait(false);
                    await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                           .ConfigureAwait(false);
                    await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                               .ConfigureAwait(false);
                    await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                            .ConfigureAwait(false);
                    await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                                 .ConfigureAwait(false);
                    await cboSpiritCombat.DoThreadSafeAsync(x => x.Visible = false, GenericToken).ConfigureAwait(false);
                    await cboSpiritDetection.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                            .ConfigureAwait(false);
                    await cboSpiritHealth.DoThreadSafeAsync(x => x.Visible = false, GenericToken).ConfigureAwait(false);
                    await cboSpiritIllusion.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                           .ConfigureAwait(false);
                    await cboSpiritManipulation.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                               .ConfigureAwait(false);

                    if (await objTradition.GetTypeAsync(GenericToken).ConfigureAwait(false) == TraditionType.MAG)
                    {
                        await objTradition.ResetTraditionAsync(GenericToken).ConfigureAwait(false);
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }

                    string strSourceIDString = await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strSourceIDString))
                        await cboTradition.DoThreadSafeAsync(x => x.SelectedValue = strSourceIDString, GenericToken)
                            .ConfigureAwait(false);
                }
                else if (strSelectedId == Tradition.CustomMagicalTraditionGuidString)
                {
                    if (await objTradition.CreateAsync(xmlTradition, token: GenericToken).ConfigureAwait(false))
                    {
                        await lblTraditionName.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                              .ConfigureAwait(false);
                        await txtTraditionName.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                              .ConfigureAwait(false);
                        await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                             .ConfigureAwait(false);
                        await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                                .ConfigureAwait(false);
                        await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                             .ConfigureAwait(false);
                        await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                               .ConfigureAwait(false);
                        await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                                   .ConfigureAwait(false);
                        await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                                .ConfigureAwait(false);
                        await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                                     .ConfigureAwait(false);
                        await cboSpiritCombat.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken).ConfigureAwait(false);
                        await cboSpiritDetection.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken).ConfigureAwait(false);
                        await cboSpiritHealth.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken).ConfigureAwait(false);
                        await cboSpiritIllusion.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken).ConfigureAwait(false);
                        await cboSpiritManipulation.DoThreadSafeAsync(x =>
                        {
                            x.Enabled = true;
                            x.Visible = true;
                        }, GenericToken).ConfigureAwait(false);

                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }
                    else
                    {
                        await objTradition.ResetTraditionAsync(GenericToken).ConfigureAwait(false);
                        string strSourceIDString = await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false);
                        if (!string.IsNullOrEmpty(strSourceIDString))
                            await cboTradition.DoThreadSafeAsync(x => x.SelectedValue = strSourceIDString, GenericToken)
                                .ConfigureAwait(false);
                    }
                }
                else if (await objTradition.CreateAsync(xmlTradition, token: GenericToken).ConfigureAwait(false))
                {
                    await lblTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                          .ConfigureAwait(false);
                    await txtTraditionName.DoThreadSafeAsync(x => x.Visible = false, GenericToken)
                                          .ConfigureAwait(false);
                    await lblSpiritCombat.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                    await lblSpiritDetection.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                            .ConfigureAwait(false);
                    await lblSpiritHealth.DoThreadSafeAsync(x => x.Visible = true, GenericToken).ConfigureAwait(false);
                    await lblSpiritIllusion.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                           .ConfigureAwait(false);
                    await lblSpiritManipulation.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                               .ConfigureAwait(false);
                    await cboSpiritCombat.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken).ConfigureAwait(false);
                    await cboSpiritDetection.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken).ConfigureAwait(false);
                    await cboSpiritHealth.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken).ConfigureAwait(false);
                    await cboSpiritIllusion.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken).ConfigureAwait(false);
                    await cboSpiritManipulation.DoThreadSafeAsync(x =>
                    {
                        x.Enabled = false;
                        x.Visible = true;
                    }, GenericToken).ConfigureAwait(false);

                    await lblTraditionSource.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                            .ConfigureAwait(false);
                    await lblTraditionSourceLabel.DoThreadSafeAsync(x => x.Visible = true, GenericToken)
                                                 .ConfigureAwait(false);
                    await objTradition.SetSourceDetailAsync(lblTraditionSource, GenericToken)
                                         .ConfigureAwait(false);
                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await objTradition.ResetTraditionAsync(GenericToken).ConfigureAwait(false);
                    string strSourceIDString = await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strSourceIDString))
                        await cboTradition.DoThreadSafeAsync(x => x.SelectedValue = strSourceIDString, GenericToken)
                            .ConfigureAwait(false);
                }

                bool blnDrainVisible = (!await CharacterObject.GetAdeptEnabledAsync(GenericToken).ConfigureAwait(false)
                                        || await CharacterObject.GetMagicianEnabledAsync(GenericToken).ConfigureAwait(false)) &&
                                       await objTradition.GetCanChooseDrainAttributeAsync(GenericToken).ConfigureAwait(false);
                await cboDrain.DoThreadSafeAsync(x => x.Visible = blnDrainVisible, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
            finally
            {
                SkipUpdate = false;
            }
        }

        #endregion Additional Spells and Spirits Tab Control Events

        #region Additional Sprites and Complex Forms Tab Control Events

        private async void treComplexForms_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedComplexForm(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboStream_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing)
                return;
            try
            {
                string strSelectedId = await cboStream
                                             .DoThreadSafeFuncAsync(x => x.SelectedValue?.ToString(), GenericToken)
                                             .ConfigureAwait(false);
                if (string.IsNullOrEmpty(strSelectedId))
                    return;

                XmlNode xmlNewStreamNode = (await CharacterObject.LoadDataAsync("streams.xml", token: GenericToken)
                        .ConfigureAwait(false))
                    .TryGetNodeByNameOrId("/chummer/traditions/tradition", strSelectedId);

                Tradition objTradition =
                    await CharacterObject.GetMagicTraditionAsync(GenericToken).ConfigureAwait(false);
                if (strSelectedId == await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false))
                    return;
                if (xmlNewStreamNode == null)
                {
                    if (await objTradition.GetTypeAsync(GenericToken).ConfigureAwait(false) == TraditionType.RES)
                    {
                        await objTradition.ResetTraditionAsync(GenericToken).ConfigureAwait(false);
                        await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                    }

                    string strSourceIDString =
                        await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strSourceIDString))
                        await cboStream
                            .DoThreadSafeAsync(x => x.SelectedValue = strSourceIDString,
                                GenericToken).ConfigureAwait(false);
                }
                else if (await objTradition.CreateAsync(xmlNewStreamNode, true, token: GenericToken)
                             .ConfigureAwait(false))
                {
                    await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
                }
                else
                {
                    await objTradition.ResetTraditionAsync(GenericToken).ConfigureAwait(false);
                    string strSourceIDString =
                        await objTradition.GetSourceIDStringAsync(GenericToken).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strSourceIDString))
                        await cboStream
                            .DoThreadSafeAsync(x => x.SelectedValue = strSourceIDString,
                                GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Sprites and Complex Forms Tab Control Events

        #region Additional AI Advanced Programs Tab Control Events

        private async void treAIPrograms_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedAIProgram(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedAIProgram(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                // Locate the Program that is selected in the tree.
                if (await treAIPrograms.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                    AIProgram objProgram)
                {
                    string strText = await objProgram.DisplayRequiresProgramAsync(GlobalSettings.Language, token)
                                                     .ConfigureAwait(false);
                    await lblAIProgramsRequires.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                    await objProgram.SetSourceDetailAsync(lblAIProgramsSource, token).ConfigureAwait(false);
                }
                else
                {
                    await lblAIProgramsRequires.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                               .ConfigureAwait(false);
                    await SourceString.Blank.SetControlAsync(lblAIProgramsSource, this, token).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        #endregion Additional AI Advanced Programs Tab Control Events

        #region Additional Initiation Tab Control Events

        private void chkInitiationGroup_EnabledChanged(object sender, EventArgs e)
        {
            if (!chkInitiationGroup.Enabled)
            {
                chkInitiationGroup.Checked = false;
            }
        }

        private async void chkInitiationSchooling_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                await UpdateInitiationCost(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void chkInitiationSchooling_EnabledChanged(object sender, EventArgs e)
        {
            if (!chkInitiationSchooling.Enabled)
            {
                chkInitiationSchooling.Checked = false;
            }
        }

        private async void treMetamagic_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedMetamagic(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedMetamagic(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (!await CharacterObject.GetInitiationEnabledAsync(token).ConfigureAwait(false))
            {
                await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = false, token).ConfigureAwait(false);
                await cmdDeleteMetamagic.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                return;
            }

            IsRefreshing = true;
            try
            {
                string strText;
                switch (await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false))
                {
                    case Metamagic objMetamagic:
                    {
                        strText = await LanguageManager.GetStringAsync(
                            objMetamagic.SourceType == Improvement.ImprovementSource.Metamagic
                                ? "Button_RemoveMetamagic"
                                : "Button_RemoveEcho", token: token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objMetamagic.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await objMetamagic.SetSourceDetailAsync(lblMetamagicSource, token).ConfigureAwait(false);
                        break;
                    }
                    case Art objArt:
                    {
                        strText = await LanguageManager.GetStringAsync("Button_RemoveMetamagic", token: token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objArt.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await objArt.SetSourceDetailAsync(lblMetamagicSource, token).ConfigureAwait(false);
                        break;
                    }
                    case Spell objSpell:
                    {
                        strText = await LanguageManager.GetStringAsync("Button_RemoveMetamagic", token: token)
                            .ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objSpell.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await objSpell.SetSourceDetailAsync(lblMetamagicSource, token).ConfigureAwait(false);
                        break;
                    }
                    case ComplexForm objComplexForm:
                    {
                        strText = await LanguageManager.GetStringAsync("Button_RemoveEcho", token: token)
                            .ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objComplexForm.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await objComplexForm.SetSourceDetailAsync(lblMetamagicSource, token).ConfigureAwait(false);
                        break;
                    }
                    case Enhancement objEnhancement:
                    {
                        strText = await LanguageManager.GetStringAsync("Button_RemoveMetamagic", token: token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objEnhancement.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await objEnhancement.SetSourceDetailAsync(lblMetamagicSource, token).ConfigureAwait(false);
                        break;
                    }
                    case InitiationGrade objGrade:
                    {
                        strText = await LanguageManager.GetStringAsync(
                            objGrade.Technomancer
                                ? "Button_RemoveSubmersionGrade"
                                : "Button_RemoveInitiateGrade", token: token).ConfigureAwait(false);
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x =>
                        {
                            x.Text = strText;
                            x.Enabled = objGrade.Grade >= 0;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await SourceString.Blank.SetControlAsync(lblMetamagicSource, this, token).ConfigureAwait(false);
                        break;
                    }
                    default:
                    {
                        await cmsMetamagic.DoThreadSafeAsync(x => x.Enabled = false, token).ConfigureAwait(false);
                        await cmdDeleteMetamagic.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        break;
                    }
                }

                bool blnVisible = await lblMetamagicSource
                                        .DoThreadSafeFuncAsync(x => x.Visible = !string.IsNullOrEmpty(x.Text),
                                                               token: token).ConfigureAwait(false);
                await lblMetamagicSourceLabel.DoThreadSafeAsync(x => x.Visible = blnVisible, token: token)
                                             .ConfigureAwait(false);
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private void txtGroupNotes_KeyDown(object sender, KeyEventArgs e)
        {
            if (!e.Control || e.KeyCode != Keys.A)
                return;
            e.SuppressKeyPress = true;
            ((TextBox)sender)?.SelectAll();
        }

        #endregion Additional Initiation Tab Control Events

        #region Additional Critter Powers Tab Control Events

        private async void treCritterPowers_AfterSelect(object sender, TreeViewEventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshSelectedCritterPower(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task RefreshSelectedCritterPower(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                // Look for the selected Critter Power.
                if (await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token)
                                          .ConfigureAwait(false) is CritterPower
                    objPower)
                {
                    await cmdDeleteCritterPower.DoThreadSafeAsync(x => x.Enabled = objPower.Grade == 0, token)
                                               .ConfigureAwait(false);
                    string strName = await objPower.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                    await lblCritterPowerName.DoThreadSafeAsync(x => x.Text = strName, token).ConfigureAwait(false);
                    string strText = await objPower.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                   .ConfigureAwait(false);
                    await lblCritterPowerCategory.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                    string strText2 = await objPower.DisplayTypeAsync(GlobalSettings.Language, token)
                                                    .ConfigureAwait(false);
                    await lblCritterPowerType.DoThreadSafeAsync(x => x.Text = strText2, token).ConfigureAwait(false);
                    string strText3 = await objPower.DisplayActionAsync(GlobalSettings.Language, token)
                                                    .ConfigureAwait(false);
                    await lblCritterPowerAction.DoThreadSafeAsync(x => x.Text = strText3, token).ConfigureAwait(false);
                    string strText4 = await objPower.DisplayRangeAsync(GlobalSettings.Language, token)
                                                    .ConfigureAwait(false);
                    await lblCritterPowerRange.DoThreadSafeAsync(x => x.Text = strText4, token).ConfigureAwait(false);
                    string strText5 = await objPower.DisplayDurationAsync(GlobalSettings.Language, token)
                                                    .ConfigureAwait(false);
                    await lblCritterPowerDuration.DoThreadSafeAsync(x => x.Text = strText5, token)
                                                 .ConfigureAwait(false);
                    await chkCritterPowerCount.DoThreadSafeAsync(x => x.Checked = objPower.CountTowardsLimit, token)
                                              .ConfigureAwait(false);
                    await objPower.SetSourceDetailAsync(lblCritterPowerSource, token).ConfigureAwait(false);
                    if (objPower.PowerPoints > 0)
                    {
                        await lblCritterPowerPointCost.DoThreadSafeAsync(x =>
                        {
                            x.Text = objPower.PowerPoints.ToString(GlobalSettings
                                                                       .CultureInfo);
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                           .ConfigureAwait(false);
                    }
                    else
                    {
                        await lblCritterPowerPointCost.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                        await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                    }
                }
                else
                {
                    await cmdDeleteCritterPower.DoThreadSafeAsync(x => x.Enabled = false, token).ConfigureAwait(false);
                    await lblCritterPowerName.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                             .ConfigureAwait(false);
                    await lblCritterPowerCategory.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                                 .ConfigureAwait(false);
                    await lblCritterPowerType.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                             .ConfigureAwait(false);
                    await lblCritterPowerAction.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                               .ConfigureAwait(false);
                    await lblCritterPowerRange.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                              .ConfigureAwait(false);
                    await lblCritterPowerDuration.DoThreadSafeAsync(x => x.Text = string.Empty, token)
                                                 .ConfigureAwait(false);
                    await chkCritterPowerCount.DoThreadSafeAsync(x => x.Checked = false, token).ConfigureAwait(false);
                    await SourceString.Blank.SetControlAsync(lblCritterPowerSource, this, token).ConfigureAwait(false);
                    await lblCritterPowerPointCost.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                    await lblCritterPowerPointCostLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        private async void chkCritterPowerCount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                // Locate the selected Critter Power.
                if (!(await treCritterPowers.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                            .ConfigureAwait(false) is
                        CritterPower objPower))
                    return;
                objPower.CountTowardsLimit
                    = await chkCritterPowerCount.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                .ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        #endregion Additional Critter Powers Tab Control Events

        #region Tree KeyDown Events

        private async void treQualities_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Delete)
            {
                try
                {
                    await DeleteQuality(GenericToken).ConfigureAwait(false);
                }
                catch (OperationCanceledException)
                {
                    //swallow this
                }
            }
        }

        #endregion Tree KeyDown Events

        #region Other Control Events

        private async void OnTabsIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                await RefreshPasteStatus(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private enum CmdOperation
        {
            None,
            Up,
            Down
        }

        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            CmdOperation op = CmdOperation.None;

            // Determine which custom operation we're attempting, if any
            switch (keyData)
            {
                case Keys.Up | Keys.Alt:
                    op = CmdOperation.Up;
                    break;

                case Keys.Down | Keys.Alt:
                    op = CmdOperation.Down;
                    break;
            }

            if (op != CmdOperation.Up && op != CmdOperation.Down)
                return base.ProcessCmdKey(ref msg, keyData);
            bool up = op == CmdOperation.Up;
            bool requireParentSortable = false;
            TreeView treActiveView = null;

            if (tabCharacterTabs.SelectedTab == tabStreetGear)
            {
                // Lifestyle Tab.
                if (tabStreetGearTabs.SelectedTab == tabLifestyle)
                {
                    treActiveView = treLifestyles;
                }
                // Armor Tab.
                else if (tabStreetGearTabs.SelectedTab == tabArmor)
                {
                    treActiveView = treArmor;
                }
                // Weapons Tab.
                else if (tabStreetGearTabs.SelectedTab == tabWeapons)
                {
                    treActiveView = treWeapons;
                }
                // Gear Tab.
                else if (tabStreetGearTabs.SelectedTab == tabGear)
                {
                    treActiveView = treGear;
                }
                // Drugs Tab.
                else if (tabStreetGearTabs.SelectedTab == tabDrugs)
                {
                    treActiveView = treCustomDrugs;
                }
            }
            // Cyberware Tab.
            else if (tabCharacterTabs.SelectedTab == tabCyberware)
            {
                // Top-level cyberware is sorted alphabetically, but we can re-arrange any plugins/gear inside them
                requireParentSortable = true;
                treActiveView = treCyberware;
            }
            // Vehicles Tab.
            else if (tabCharacterTabs.SelectedTab == tabVehicles)
            {
                treActiveView = treVehicles;
            }
            // Critter Powers Tab.
            else if (tabCharacterTabs.SelectedTab == tabCritter)
            {
                treActiveView = treCritterPowers;
            }

            if (treActiveView == null)
                return true;
            TreeNode objSelectedNode = treActiveView.SelectedNode;
            TreeNode objParentNode = objSelectedNode?.Parent;
            TreeNodeCollection lstNodes = objParentNode?.Nodes ?? treActiveView.Nodes;

            if (requireParentSortable && !(objParentNode?.Tag is ICanSort))
                return true;
            int intNewIndex = lstNodes.IndexOf(objSelectedNode);
            intNewIndex = up ? Math.Max(0, intNewIndex - 1) : Math.Min(lstNodes.Count - 1, intNewIndex + 1);

            try
            {
                Utils.SafelyRunSynchronously(() => MoveTreeNode(objSelectedNode, intNewIndex, requireParentSortable, GenericToken),
                                             GenericToken);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }

            // Returning true tells the program to consume the input
            return true;

            // If none of our key combinations are used then use the default logic
        }

        #endregion Other Control Events

        #region Custom Methods

        /// <summary>
        /// Calculate the BP used by Primary Attributes.
        /// </summary>
        private static async Task<int> CalculateAttributeBP(IAsyncEnumerable<CharacterAttrib> attribs,
                                                                 IAsyncEnumerable<CharacterAttrib> extraAttribs = null,
                                                                 CancellationToken token = default)
        {
            // Primary and Special Attributes are calculated separately since you can only spend a maximum of 1/2 your BP allotment on Primary Attributes.
            // Special Attributes are not subject to the 1/2 of max BP rule.
            int intBP = await attribs.SumAsync(att => att.GetTotalKarmaCostAsync(token), token).ConfigureAwait(false);
            if (extraAttribs != null)
            {
                intBP += await extraAttribs.SumAsync(att => att.GetTotalKarmaCostAsync(token), token)
                                           .ConfigureAwait(false);
            }

            return intBP;
        }

        private async Task<int> CalculateAttributePriorityPoints(IAsyncEnumerable<CharacterAttrib> attribs,
                                                                      IAsyncEnumerable<CharacterAttrib> extraAttribs
                                                                          = null, CancellationToken token = default)
        {
            int intAtt = 0;
            if (await CharacterObject.GetEffectiveBuildMethodUsesPriorityTablesAsync(token).ConfigureAwait(false))
            {
                // Get the total of "free points" spent
                intAtt += await attribs.SumAsync(att => att.GetSpentPriorityPointsAsync(token), token: token)
                                       .ConfigureAwait(false);
                if (extraAttribs != null)
                {
                    // Get the total of "free points" spent
                    intAtt += await extraAttribs.SumAsync(att => att.GetSpentPriorityPointsAsync(token), token: token)
                                                .ConfigureAwait(false);
                }
            }

            return intAtt;
        }

        private async Task<string> BuildAttributes(IAsyncReadOnlyCollection<CharacterAttrib> attribs,
                                                        IAsyncReadOnlyCollection<CharacterAttrib> extraAttribs = null,
                                                        bool special = false, CancellationToken token = default)
        {
            int bp = await CalculateAttributeBP(attribs, extraAttribs, token).ConfigureAwait(false);
            string s = bp.ToString(GlobalSettings.CultureInfo)
                       + await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false)
                       + await LanguageManager.GetStringAsync("String_Karma", token: token).ConfigureAwait(false);
            if (CharacterObject.EffectiveBuildMethodUsesPriorityTables)
            {
                int att = await CalculateAttributePriorityPoints(attribs, extraAttribs, token).ConfigureAwait(false);
                int total = special
                    ? await CharacterObject.GetTotalSpecialAsync(token).ConfigureAwait(false)
                    : await CharacterObject.GetTotalAttributesAsync(token).ConfigureAwait(false);
                if (bp > 0)
                {
                    s = string.Format(GlobalSettings.CultureInfo,
                                      await LanguageManager.GetStringAsync("String_OverPriorityPoints", token: token)
                                                           .ConfigureAwait(false),
                                      total - att, total, bp);
                }
                else
                {
                    s = (total - att).ToString(GlobalSettings.CultureInfo)
                        + await LanguageManager.GetStringAsync("String_Of", token: token).ConfigureAwait(false)
                        + total.ToString(GlobalSettings.CultureInfo);
                }
            }

            return s;
        }

        /// <summary>
        /// Calculate the number of Build Points the character has remaining.
        /// </summary>
        private async Task<int> CalculateBPandRefreshBPDisplays(bool blnDoUIUpdate = true, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            int intKarmaPointsRemain = await CharacterObjectSettings.GetBuildKarmaAsync(token).ConfigureAwait(false);
            //int intPointsUsed = 0; // used as a running total for each section
            const int intFreestyleBPMin = 0;
            int intFreestyleBP = 0;
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            string strPoints = blnDoUIUpdate
                ? await LanguageManager.GetStringAsync("String_Karma", token: token).ConfigureAwait(false)
                : string.Empty;

            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterReadLockAsync(token)
                .ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Metatype/Metavariant only cost points when working with BP (or when the Metatype Costs Karma option is enabled when working with Karma).
                int intMetatypeBP;
                if (!await CharacterObject.GetEffectiveBuildMethodUsesPriorityTablesAsync(token).ConfigureAwait(false))
                {
                    // Subtract the BP used for Metatype.
                    intMetatypeBP = await CharacterObject.GetMetatypeBPAsync(token).ConfigureAwait(false)
                                    * await CharacterObjectSettings.GetMetatypeCostsKarmaMultiplierAsync(token)
                                        .ConfigureAwait(false);
                }
                else
                {
                    intMetatypeBP = await CharacterObject.GetMetatypeBPAsync(token).ConfigureAwait(false);
                }

                intKarmaPointsRemain -= intMetatypeBP;

                token.ThrowIfCancellationRequested();

                // ------------------------------------------------------------------------------
                // Calculate the points used by Contacts.
                bool blnFriendsInHighPlaces
                    = await CharacterObject.GetFriendsInHighPlacesAsync(token).ConfigureAwait(false);
                int intContactPoints = await CharacterObject.GetContactPointsAsync(token).ConfigureAwait(false);
                int intFriendsInHighPlacesPoints = blnFriendsInHighPlaces
                    ? await (await CharacterObject.GetAttributeAsync("CHA", token: token).ConfigureAwait(false))
                        .GetValueAsync(token).ConfigureAwait(false) * 4
                    : 0;
                (int intPointsInContacts, int intHighPlacesFriends) =
                    await CharacterObject.GetContactPointsUsedAsync(token).ConfigureAwait(false);

                intKarmaPointsRemain -= Math.Max(0, intPointsInContacts - intContactPoints) +
                                        Math.Max(0, intHighPlacesFriends - intFriendsInHighPlacesPoints);

                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Calculate the BP used by Qualities.
                int intLifeModuleQualities = 0;
                int intKarmaQuality = await CharacterObjectSettings.GetKarmaQualityAsync(token).ConfigureAwait(false);
                ThreadSafeObservableCollection<Quality> lstQualities
                    = await CharacterObject.GetQualitiesAsync(token).ConfigureAwait(false);
                HashSet<Quality> setVisibleQualities = new HashSet<Quality>();
                await treQualities.DoThreadSafeAsync(x =>
                {
                    foreach (TreeNode objCategoryNode in x.Nodes)
                    {
                        foreach (TreeNode objQualityNode in objCategoryNode.Nodes)
                        {
                            if (objQualityNode.Tag is Quality objLoop)
                                setVisibleQualities.Add(objLoop);
                        }
                    }
                }, token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                           out StringBuilder sbdPositiveQualityTooltip))
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                           out StringBuilder sbdNegativeQualityTooltip))
                {
                    await lstQualities.ForEachAsync(async objLoopQuality =>
                    {
                        if (!setVisibleQualities.Contains(objLoopQuality))
                            return;
                        if (!await objLoopQuality.GetContributeToBPAsync(token).ConfigureAwait(false))
                            return;
                        QualityType eType = await objLoopQuality.GetTypeAsync(token).ConfigureAwait(false);
                        int intLoopCost = await objLoopQuality.GetBPAsync(token).ConfigureAwait(false) *
                                          await objLoopQuality.GetLevelsAsync(token).ConfigureAwait(false) *
                                          intKarmaQuality;
                        if (await objLoopQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.LifeModule)
                        {
                            intLifeModuleQualities += intLoopCost;
                            if (blnDoUIUpdate)
                            {
                                sbdPositiveQualityTooltip.AppendFormat(
                                    GlobalSettings.CultureInfo, "{0}{1}({2})",
                                    await objLoopQuality.GetCurrentDisplayNameAsync(token).ConfigureAwait(false),
                                    strSpace, intLoopCost).AppendLine();
                            }
                        }
                        else if (blnDoUIUpdate)
                        {
                            switch (eType)
                            {
                                case QualityType.Positive:
                                    sbdPositiveQualityTooltip.AppendFormat(
                                        GlobalSettings.CultureInfo, "{0}{1}({2})",
                                        await objLoopQuality.GetCurrentDisplayNameAsync(token).ConfigureAwait(false),
                                        strSpace, intLoopCost).AppendLine();
                                    break;

                                case QualityType.Negative:
                                    sbdNegativeQualityTooltip.AppendFormat(
                                        GlobalSettings.CultureInfo, "{0}{1}({2})",
                                        await objLoopQuality.GetCurrentDisplayNameAsync(token).ConfigureAwait(false),
                                        strSpace, intLoopCost).AppendLine();
                                    break;
                            }
                        }
                    }, token: token).ConfigureAwait(false);

                    if (blnDoUIUpdate)
                    {
                        token.ThrowIfCancellationRequested();
                        ThreadSafeObservableCollection<Contact> lstContacts
                            = await CharacterObject.GetContactsAsync(token).ConfigureAwait(false);
                        if (await lstContacts
                                .AnyAsync(async x => await x.GetEntityTypeAsync(token).ConfigureAwait(false) == ContactType.Contact && await x.GetIsGroupAsync(token).ConfigureAwait(false) && !await x.GetFreeAsync(token).ConfigureAwait(false), token)
                                .ConfigureAwait(false))
                        {
                            sbdPositiveQualityTooltip.AppendLine(
                                await LanguageManager.GetStringAsync("Label_GroupContacts", token: token)
                                    .ConfigureAwait(false));
                            await lstContacts.ForEachAsync(async objGroupContact =>
                            {
                                if (await objGroupContact.GetEntityTypeAsync(token).ConfigureAwait(false) != ContactType.Contact
                                    || !await objGroupContact.GetIsGroupAsync(token).ConfigureAwait(false)
                                    || await objGroupContact.GetFreeAsync(token).ConfigureAwait(false))
                                    return;
                                string strName = await objGroupContact.GetNameAsync(token).ConfigureAwait(false);
                                string strNameToUse = objGroupContact.GroupName;
                                if (string.IsNullOrEmpty(strNameToUse))
                                {
                                    strNameToUse = strName;
                                    if (string.IsNullOrEmpty(strNameToUse))
                                        strNameToUse = await LanguageManager
                                            .GetStringAsync("String_Unknown", token: token)
                                            .ConfigureAwait(false);
                                }
                                else if (!string.IsNullOrWhiteSpace(strName))
                                    strNameToUse += "/" + strName;

                                sbdPositiveQualityTooltip.AppendFormat(GlobalSettings.CultureInfo, "{0}{1}({2})",
                                    strNameToUse,
                                    strSpace,
                                    await objGroupContact.GetContactPointsAsync(token).ConfigureAwait(false)
                                    * await CharacterObjectSettings.GetKarmaContactAsync(token).ConfigureAwait(false)).AppendLine();
                            }, token).ConfigureAwait(false);
                        }

                        await lblPositiveQualitiesBP.SetToolTipTextAsync(sbdPositiveQualityTooltip.ToString(), token)
                            .ConfigureAwait(false);
                        await lblNegativeQualitiesBP.SetToolTipTextAsync(sbdNegativeQualityTooltip.ToString(), token)
                            .ConfigureAwait(false);
                    }
                }

                int intQualityPointsUsed = intLifeModuleQualities
                                           - await CharacterObject.GetNegativeQualityKarmaAsync(token: token)
                                               .ConfigureAwait(false)
                                           + await CharacterObject.GetPositiveQualityKarmaAsync(token)
                                               .ConfigureAwait(false);

                intKarmaPointsRemain -= intQualityPointsUsed;
                intFreestyleBP += intQualityPointsUsed;
                // Changelings must either have a balanced negative and positive number of metagenic qualities, or have 1 more point of positive than negative.
                // If the latter, karma is used to balance them out.
                if (await CharacterObject.GetMetagenicPositiveQualityKarmaAsync(token).ConfigureAwait(false)
                    + await CharacterObject.GetMetagenicNegativeQualityKarmaAsync(token).ConfigureAwait(false) == 1)
                    intKarmaPointsRemain--;

                token.ThrowIfCancellationRequested();

                // ------------------------------------------------------------------------------
                // Update Primary Attributes and Special Attributes values.
                int intAttributePointsUsed
                    = await CalculateAttributeBP(
                        await (await CharacterObject.GetAttributeSectionAsync(token).ConfigureAwait(false))
                            .GetAttributeListAsync(token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                intAttributePointsUsed
                    += await CalculateAttributeBP(
                            await (await CharacterObject.GetAttributeSectionAsync(token).ConfigureAwait(false))
                                .GetSpecialAttributeListAsync(token).ConfigureAwait(false), token: token)
                        .ConfigureAwait(false);
                intKarmaPointsRemain -= intAttributePointsUsed;

                token.ThrowIfCancellationRequested();

                // ------------------------------------------------------------------------------
                // Include the BP used by Martial Arts.
                int intMartialArtsPoints = 0;
                string strColon = await LanguageManager.GetStringAsync("String_Colon", token: token)
                    .ConfigureAwait(false);
                string strOf = await LanguageManager.GetStringAsync("String_Of", token: token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                           out StringBuilder sbdMartialArtsBPToolTip))
                {
                    int intKarmaTechnique
                        = await CharacterObjectSettings.GetKarmaTechniqueAsync(token).ConfigureAwait(false);
                    await (await CharacterObject.GetMartialArtsAsync(token).ConfigureAwait(false)).ForEachAsync(
                        async objMartialArt =>
                        {
                            token.ThrowIfCancellationRequested();
                            if (objMartialArt.IsQuality)
                                return;
                            int intLoopCost = objMartialArt.Cost;
                            intMartialArtsPoints += intLoopCost;

                            if (blnDoUIUpdate)
                            {
                                if (sbdMartialArtsBPToolTip.Length > 0)
                                    sbdMartialArtsBPToolTip.AppendLine().Append(strSpace, '+', strSpace);
                                sbdMartialArtsBPToolTip
                                    .Append(await objMartialArt.GetCurrentDisplayNameAsync(token).ConfigureAwait(false))
                                    .Append(strSpace, '(')
                                    .Append(intLoopCost.ToString(GlobalSettings.CultureInfo), ')');

                                bool blnIsFirst = true;
                                await objMartialArt.Techniques.ForEachAsync(async objTechnique =>
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (blnIsFirst)
                                    {
                                        blnIsFirst = false;
                                        return;
                                    }

                                    intLoopCost = intKarmaTechnique;
                                    intMartialArtsPoints += intLoopCost;

                                    sbdMartialArtsBPToolTip.AppendLine().Append(strSpace, '+', strSpace)
                                        .Append(await objTechnique.GetCurrentDisplayNameAsync(token)
                                            .ConfigureAwait(false), strSpace)
                                        .Append('(', intLoopCost.ToString(GlobalSettings.CultureInfo), ')');
                                }, token: token).ConfigureAwait(false);
                            }
                            else
                                // Add in the Techniques
                                intMartialArtsPoints += Math.Max(await objMartialArt.Techniques.GetCountAsync(token).ConfigureAwait(false) - 1, 0)
                                                        * intKarmaTechnique;
                        }, token).ConfigureAwait(false);

                    token.ThrowIfCancellationRequested();

                    if (blnDoUIUpdate)
                        await lblBuildMartialArts.SetToolTipTextAsync(sbdMartialArtsBPToolTip.ToString(), token)
                            .ConfigureAwait(false);
                }

                intKarmaPointsRemain -= intMartialArtsPoints;

                SkillsSection objSkillSection =
                    await CharacterObject.GetSkillsSectionAsync(token).ConfigureAwait(false);

                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Calculate the BP used by Skill Groups.
                int intSkillGroupsPoints = await objSkillSection.SkillGroups
                    .SumAsync(x => x.GetCurrentKarmaCostAsync(token),
                        token: token).ConfigureAwait(false);
                intKarmaPointsRemain -= intSkillGroupsPoints;

                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Calculate the BP used by Active Skills.
                int skillPointsKarma = await objSkillSection.Skills
                    .SumAsync(x => x.GetCurrentKarmaCostAsync(token),
                        token: token).ConfigureAwait(false);
                intKarmaPointsRemain -= skillPointsKarma;

                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Calculate the points used by Knowledge Skills.
                int knowledgeKarmaUsed = await objSkillSection.KnowledgeSkills
                    .SumAsync(x => x.GetCurrentKarmaCostAsync(token),
                        token: token).ConfigureAwait(false);

                token.ThrowIfCancellationRequested();
                //TODO: Remaining is named USED?
                intKarmaPointsRemain -= knowledgeKarmaUsed;

                intFreestyleBP += knowledgeKarmaUsed;

                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Calculate the BP used by Resources/Nuyen.
                int intNuyenBP = (await CharacterObject.GetNuyenBPAsync(token).ConfigureAwait(false)).StandardRound();

                intKarmaPointsRemain -= intNuyenBP;

                intFreestyleBP += intNuyenBP;

                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Calculate the BP used by Spells.
                int intSpellPointsUsed = 0;
                int intRitualPointsUsed = 0;
                int intPrepPointsUsed = 0;
                if (await CharacterObject.GetMagicianEnabledAsync(token).ConfigureAwait(false)
                    || await CharacterObject.GetAdeptEnabledAsync(token).ConfigureAwait(false)
                    || (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(CharacterObject,
                            Improvement.ImprovementType.FreeSpells, token: token)
                        .ConfigureAwait(false)).Count > 0
                    || (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(CharacterObject,
                            Improvement.ImprovementType.FreeSpellsATT,
                            token: token).ConfigureAwait(false)).Count > 0
                    || (await ImprovementManager
                        .GetCachedImprovementListForValueOfAsync(CharacterObject,
                            Improvement.ImprovementType.FreeSpellsSkill,
                            token: token).ConfigureAwait(false)).Count > 0)
                {
                    ThreadSafeObservableCollection<Spell> lstSpells
                        = await CharacterObject.GetSpellsAsync(token).ConfigureAwait(false);
                    // Count the number of Spells the character currently has and make sure they do not try to select more Spells than they are allowed.
                    int spells = await lstSpells
                        .CountAsync(
                            spell => spell.Grade == 0 && !spell.Alchemical && spell.Category != "Rituals"
                                     && !spell.FreeBonus, token: token).ConfigureAwait(false);
                    int intTouchOnlySpells = await lstSpells
                        .CountAsync(
                            spell => spell.Grade == 0 && !spell.Alchemical
                                                      && spell.Category != "Rituals"
                                                      && (spell.Range == "T (A)"
                                                          || spell.Range == "T")
                                                      && !spell.FreeBonus, token: token)
                        .ConfigureAwait(false);
                    int rituals = await lstSpells
                        .CountAsync(
                            spell => spell.Grade == 0 && !spell.Alchemical && spell.Category == "Rituals"
                                     && !spell.FreeBonus, token: token).ConfigureAwait(false);
                    int preps = await lstSpells
                        .CountAsync(spell => spell.Grade == 0 && spell.Alchemical && !spell.FreeBonus,
                            token: token).ConfigureAwait(false);

                    token.ThrowIfCancellationRequested();

                    // Each spell costs KarmaSpell.
                    int spellCost = await CharacterObject.SpellKarmaCostAsync("Spells", token).ConfigureAwait(false);
                    int ritualCost = await CharacterObject.SpellKarmaCostAsync("Rituals", token).ConfigureAwait(false);
                    int prepCost = await CharacterObject.SpellKarmaCostAsync("Preparations", token)
                        .ConfigureAwait(false);
                    int intFreeSpells = await CharacterObject.GetFreeSpellsAsync(token).ConfigureAwait(false);
                    int intQualityKarmaToSpellPoints = 0;

                    token.ThrowIfCancellationRequested();

                    // Factor in any qualities that can be bought with spell points.
                    // It is only karma-efficient to use spell points for Mastery qualities if real spell karma cost is not greater than unmodified spell karma cost
                    int intKarmaSpell = await CharacterObjectSettings.GetKarmaSpellAsync(token).ConfigureAwait(false);
                    if (spellCost <= intKarmaSpell && intFreeSpells > 0 && intKarmaSpell != 0)
                    {
                        // Assume that every [spell cost] karma spent on a Mastery quality is paid for with a priority-given spell point instead, as that is the most karma-efficient.
                        int intMasteryQualityKarmaUsed = await lstQualities.SumAsync(
                                objQuality =>
                                    objQuality.CanBuyWithSpellPoints,
                                objQuality => objQuality.GetBPAsync(token), token)
                            .ConfigureAwait(false);
                        if (intMasteryQualityKarmaUsed != 0)
                        {
                            intQualityKarmaToSpellPoints
                                = Math.Min(
                                    intFreeSpells,
                                    intMasteryQualityKarmaUsed * intKarmaQuality
                                    / intKarmaSpell);
                            spells += intQualityKarmaToSpellPoints;
                        }
                    }

                    token.ThrowIfCancellationRequested();

                    int intLimitMod = (await ImprovementManager
                                           .ValueOfAsync(CharacterObject, Improvement.ImprovementType.SpellLimit,
                                               token: token).ConfigureAwait(false)
                                       + await ImprovementManager
                                           .ValueOfAsync(CharacterObject, Improvement.ImprovementType.FreeSpells,
                                               token: token).ConfigureAwait(false)).StandardRound();
                    int intLimitModTouchOnly = 0;
                    foreach (Improvement imp in await ImprovementManager
                                 .GetCachedImprovementListForValueOfAsync(
                                     CharacterObject, Improvement.ImprovementType.FreeSpellsATT,
                                     token: token).ConfigureAwait(false))
                    {
                        token.ThrowIfCancellationRequested();
                        int intAttValue
                            = await (await CharacterObject.GetAttributeAsync(imp.ImprovedName, token: token)
                                    .ConfigureAwait(false)).GetTotalValueAsync(token)
                                .ConfigureAwait(false);
                        if (imp.UniqueName.Contains("half"))
                            intAttValue = intAttValue.DivAwayFromZero(2);
                        if (imp.UniqueName.Contains("touchonly"))
                            intLimitModTouchOnly += intAttValue;
                        else
                            intLimitMod += intAttValue;
                    }

                    foreach (Improvement imp in await ImprovementManager
                                 .GetCachedImprovementListForValueOfAsync(
                                     CharacterObject, Improvement.ImprovementType.FreeSpellsSkill,
                                     token: token).ConfigureAwait(false))
                    {
                        token.ThrowIfCancellationRequested();
                        Skill skill = await objSkillSection.GetActiveSkillAsync(imp.ImprovedName, token)
                            .ConfigureAwait(false);
                        if (skill == null)
                            continue;
                        int intSkillValue = await skill.GetTotalBaseRatingAsync(token).ConfigureAwait(false);

                        if (imp.UniqueName.Contains("half"))
                            intSkillValue = intSkillValue.DivAwayFromZero(2);
                        if (imp.UniqueName.Contains("touchonly"))
                            intLimitModTouchOnly += intSkillValue;
                        else
                            intLimitMod += intSkillValue;
                        //TODO: I don't like this being hardcoded, even though I know full well CGL are never going to reuse this.
                        spells -= await skill.Specializations.CountAsync(
                                async spec =>
                                    await (await CharacterObject.GetSpellsAsync(token)
                                            .ConfigureAwait(false)).AnyAsync(
                                            async spell =>
                                                spell.Category ==
                                                await spec.GetNameAsync(token).ConfigureAwait(false) &&
                                                !spell.FreeBonus,
                                            token)
                                        .ConfigureAwait(false),
                                token)
                            .ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();

                    int intPPBought = await nudMysticAdeptMAGMagician.DoThreadSafeFuncAsync(x => x.ValueAsInt, token)
                        .ConfigureAwait(false);
                    if (intPPBought > 0)
                    {
                        if (await CharacterObjectSettings.GetPrioritySpellsAsAdeptPowersAsync(token)
                                .ConfigureAwait(false))
                        {
                            spells += Math.Min(intFreeSpells, intPPBought);
                            intPPBought = Math.Max(0, intPPBought - intFreeSpells);
                        }

                        intAttributePointsUsed = intPPBought * await CharacterObjectSettings
                            .GetKarmaMysticAdeptPowerPointAsync(token)
                            .ConfigureAwait(false);
                        intKarmaPointsRemain -= intAttributePointsUsed;
                    }

                    spells -= intTouchOnlySpells - Math.Max(0, intTouchOnlySpells - intLimitModTouchOnly);

                    int spellPoints = intFreeSpells + intLimitMod;
                    int ritualPoints = intFreeSpells + intLimitMod;
                    int prepPoints = intFreeSpells + intLimitMod;
                    for (int i = intFreeSpells + intLimitMod; i > 0; i--)
                    {
                        token.ThrowIfCancellationRequested();
                        if (spells > 0)
                        {
                            spells--;
                            spellPoints--;
                        }
                        else if (rituals > 0)
                        {
                            rituals--;
                            ritualPoints--;
                        }
                        else if (preps > 0)
                        {
                            preps--;
                            prepPoints--;
                        }
                        else
                        {
                            break;
                        }
                    }

                    intKarmaPointsRemain -= Math.Max(0, spells) * spellCost;
                    intKarmaPointsRemain -= Math.Max(0, rituals) * ritualCost;
                    intKarmaPointsRemain -= Math.Max(0, preps) * prepCost;

                    intSpellPointsUsed += Math.Max(Math.Max(0, spells) * spellCost, 0);
                    intRitualPointsUsed += Math.Max(Math.Max(0, rituals) * ritualCost, 0);
                    intPrepPointsUsed += Math.Max(Math.Max(0, preps) * prepCost, 0);
                    if (blnDoUIUpdate
                        && (lblBuildPrepsBP != null
                            || lblSpellsBP != null
                            || lblBuildRitualsBP != null))
                    {
                        token.ThrowIfCancellationRequested();
                        string strFormat = "{0}" + strSpace + "×" + strSpace + "{1}" + strSpace
                                           + await LanguageManager.GetStringAsync("String_Karma", token: token)
                                               .ConfigureAwait(false)
                                           + strSpace + "=" + strSpace + "{2}" + strSpace + await LanguageManager
                                               .GetStringAsync("String_Karma", token: token).ConfigureAwait(false);
                        if (lblSpellsBP != null)
                        {
                            string strTooltip = string.Format(GlobalSettings.CultureInfo, strFormat, spells, spellCost,
                                intSpellPointsUsed);
                            if (intQualityKarmaToSpellPoints != 0)
                                strTooltip += Environment.NewLine + await LanguageManager
                                    .GetStringAsync(
                                        "Tip_SelectSpell_MasteryQuality",
                                        token: token).ConfigureAwait(false);
                            await lblSpellsBP.SetToolTipTextAsync(strTooltip, token).ConfigureAwait(false);
                        }

                        if (lblBuildRitualsBP != null)
                            await lblBuildRitualsBP
                                .SetToolTipTextAsync(
                                    string.Format(GlobalSettings.CultureInfo, strFormat, rituals, spellCost,
                                        intRitualPointsUsed), token).ConfigureAwait(false);
                        if (lblBuildPrepsBP != null)
                            await lblBuildPrepsBP
                                .SetToolTipTextAsync(
                                    string.Format(GlobalSettings.CultureInfo, strFormat, preps, spellCost,
                                        intPrepPointsUsed), token).ConfigureAwait(false);
                        if (intFreeSpells + intLimitMod > 0)
                        {
                            if (lblBuildPrepsBP != null)
                            {
                                string strText = string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}",
                                    prepPoints + spellPoints + ritualPoints
                                    - 2 * (intFreeSpells + intLimitMod), strOf,
                                    spellPoints + ritualPoints - (intFreeSpells + intLimitMod));
                                if (intPrepPointsUsed > 0)
                                    strText += string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}{1}{3}", strColon,
                                        strSpace, intPrepPointsUsed, strPoints);
                                await lblBuildPrepsBP.DoThreadSafeAsync(x => x.Text = strText, token)
                                    .ConfigureAwait(false);
                            }

                            if (lblSpellsBP != null)
                            {
                                string strText;
                                if (intQualityKarmaToSpellPoints != 0)
                                    strText = string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}({3})",
                                        prepPoints + spellPoints + ritualPoints
                                        - 2 * (intFreeSpells + intLimitMod), strOf,
                                        prepPoints + ritualPoints - (intFreeSpells + intLimitMod),
                                        string.Format(GlobalSettings.CultureInfo, await LanguageManager
                                            .GetStringAsync(
                                                "String_MasteryPointsAcronym", token: token)
                                            .ConfigureAwait(false), intQualityKarmaToSpellPoints));
                                else
                                    strText = string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}",
                                        prepPoints + spellPoints + ritualPoints
                                        - 2 * (intFreeSpells + intLimitMod), strOf,
                                        prepPoints + ritualPoints - (intFreeSpells + intLimitMod));
                                if (intSpellPointsUsed > 0)
                                    strText += string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}{1}{3}", strColon,
                                        strSpace, intSpellPointsUsed, strPoints);
                                await lblSpellsBP.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                            }

                            if (lblBuildRitualsBP != null)
                            {
                                string strText = string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}",
                                    prepPoints + spellPoints + ritualPoints
                                    - 2 * (intFreeSpells + intLimitMod), strOf,
                                    prepPoints + spellPoints - (intFreeSpells + intLimitMod));
                                if (intRitualPointsUsed > 0)
                                    strText += string.Format(GlobalSettings.CultureInfo, "{0}{1}{2}{1}{3}", strColon,
                                        strSpace, intRitualPointsUsed, strPoints);
                                await lblBuildRitualsBP.DoThreadSafeAsync(x => x.Text = strText, token)
                                    .ConfigureAwait(false);
                            }
                        }
                        else if (intLimitMod == 0)
                        {
                            if (lblBuildPrepsBP != null)
                            {
                                await lblBuildPrepsBP.DoThreadSafeAsync(x => x.Text =
                                    intPrepPointsUsed.ToString(
                                        GlobalSettings.CultureInfo) + strSpace
                                                                    + strPoints, token).ConfigureAwait(false);
                            }

                            if (lblSpellsBP != null)
                            {
                                await lblSpellsBP.DoThreadSafeAsync(x => x.Text =
                                    intSpellPointsUsed.ToString(
                                        GlobalSettings.CultureInfo) + strSpace
                                                                    + strPoints, token).ConfigureAwait(false);
                            }

                            if (lblBuildRitualsBP != null)
                            {
                                await lblBuildRitualsBP.DoThreadSafeAsync(x => x.Text =
                                    intRitualPointsUsed.ToString(
                                        GlobalSettings.CultureInfo) + strSpace
                                                                    + strPoints, token).ConfigureAwait(false);
                            }
                        }
                        else
                        {
                            //TODO: Make the costs render better, currently looks wrong as hell
                            strFormat = "{0}" + strOf + "{1}" + strColon + strSpace + "{2}" + strSpace + strPoints;
                            if (lblBuildPrepsBP != null)
                            {
                                await lblBuildPrepsBP.DoThreadSafeAsync(x => x.Text =
                                        string.Format(
                                            GlobalSettings.CultureInfo, strFormat,
                                            prepPoints + spellPoints + ritualPoints
                                            - 2 * intLimitMod,
                                            spellPoints + ritualPoints - intLimitMod,
                                            intPrepPointsUsed), token)
                                    .ConfigureAwait(false);
                            }

                            if (lblSpellsBP != null)
                            {
                                await lblSpellsBP.DoThreadSafeAsync(x => x.Text =
                                        string.Format(GlobalSettings.CultureInfo, strFormat,
                                            prepPoints + spellPoints + ritualPoints
                                            - 2 * intLimitMod,
                                            prepPoints + ritualPoints - intLimitMod,
                                            intSpellPointsUsed), token)
                                    .ConfigureAwait(false);
                            }

                            if (lblBuildRitualsBP != null)
                            {
                                await lblBuildRitualsBP.DoThreadSafeAsync(x => x.Text =
                                        string.Format(
                                            GlobalSettings.CultureInfo, strFormat,
                                            prepPoints + spellPoints + ritualPoints
                                            - 2 * intLimitMod,
                                            prepPoints + spellPoints - intLimitMod,
                                            intRitualPointsUsed), token)
                                    .ConfigureAwait(false);
                            }
                        }
                    }
                }

                intFreestyleBP += intSpellPointsUsed + intRitualPointsUsed + intPrepPointsUsed;

                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Calculate the BP used by Foci.
                int intFociPointsUsed = 0;
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                           out StringBuilder sbdFociPointsTooltip))
                {
                    await (await CharacterObject.GetFociAsync(token).ConfigureAwait(false)).ForEachWithBreakAsync(
                        async objFocus =>
                        {
                            token.ThrowIfCancellationRequested();
                            int intBindingCost = await objFocus.BindingKarmaCostAsync(token).ConfigureAwait(false);
                            intFociPointsUsed += intBindingCost;

                            if (!blnDoUIUpdate)
                                return true;
                            if (sbdFociPointsTooltip.Length > 0)
                                sbdFociPointsTooltip.AppendLine().Append(strSpace, '+', strSpace);
                            if (objFocus.GearObject != null)
                                sbdFociPointsTooltip
                                    .Append(await objFocus.GearObject.GetCurrentDisplayNameAsync(token)
                                        .ConfigureAwait(false), strSpace);
                            sbdFociPointsTooltip
                                .Append('(', intBindingCost.ToString(GlobalSettings.CultureInfo), ')');
                            return true;
                        }, token).ConfigureAwait(false);

                    intKarmaPointsRemain -= intFociPointsUsed;

                    // Calculate the BP used by Stacked Foci.
                    intKarmaPointsRemain -=
                        await (await CharacterObject.GetStackedFociAsync(token).ConfigureAwait(false))
                            .SumAsync(
                                async objFocus =>
                                {
                                    token.ThrowIfCancellationRequested();
                                    if (!objFocus.Bonded)
                                        return 0;
                                    int intBindingCost = await objFocus.GetBindingCostAsync(token)
                                        .ConfigureAwait(false);
                                    intFociPointsUsed += intBindingCost;

                                    if (!blnDoUIUpdate)
                                        return intBindingCost;
                                    if (sbdFociPointsTooltip.Length > 0)
                                        sbdFociPointsTooltip.AppendLine().Append(strSpace, '+', strSpace);
                                    sbdFociPointsTooltip
                                        .Append(await objFocus.GetCurrentDisplayNameAsync(token)
                                            .ConfigureAwait(false), strSpace)
                                        .Append('(', intBindingCost.ToString(GlobalSettings.CultureInfo), ')');
                                    return intBindingCost;
                                }, token).ConfigureAwait(false);

                    intFreestyleBP += intFociPointsUsed;

                    if (blnDoUIUpdate)
                    {
                        await lblBuildFoci.SetToolTipTextAsync(sbdFociPointsTooltip.ToString(), token)
                            .ConfigureAwait(false);
                    }
                }

                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Calculate the BP used by Spirits and Sprites.
                int intSpiritPointsUsed = 0;
                int intSpritePointsUsed = 0;
                intKarmaPointsRemain -= await (await CharacterObject.GetSpiritsAsync(token).ConfigureAwait(false))
                    .SumAsync(
                        async objSpirit =>
                        {
                            token.ThrowIfCancellationRequested();
                            int intLoopKarma = await objSpirit.GetServicesOwedAsync(token).ConfigureAwait(false)
                                               * await CharacterObjectSettings.GetKarmaSpiritAsync(token)
                                                   .ConfigureAwait(false);
                            // Each Sprite costs KarmaSpirit x Services Owed.
                            int intReturn = intLoopKarma;
                            if (await objSpirit.GetEntityTypeAsync(token).ConfigureAwait(false) == SpiritType.Spirit)
                            {
                                intSpiritPointsUsed += intLoopKarma;
                                // Each Fettered Spirit costs 3 x Force.
                                if (await objSpirit.GetFetteredAsync(token).ConfigureAwait(false))
                                {
                                    int intTemp = await objSpirit.GetForceAsync(token).ConfigureAwait(false)
                                                  * await CharacterObjectSettings.GetKarmaSpiritFetteringAsync(token)
                                                      .ConfigureAwait(false);
                                    intReturn += intTemp;
                                    intSpiritPointsUsed += intTemp;
                                }
                            }
                            else
                            {
                                intSpritePointsUsed += intLoopKarma;
                            }

                            return intReturn;
                        }, token: token).ConfigureAwait(false);
                intFreestyleBP += intSpiritPointsUsed + intSpritePointsUsed;

                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Calculate the BP used by Complex Forms.
                int intFormsPointsUsed = await (await CharacterObject.GetComplexFormsAsync(token).ConfigureAwait(false))
                    .CountAsync(x => x.Grade == 0, token).ConfigureAwait(false);
                int intCfpLimit = await CharacterObject.GetCFPLimitAsync(token).ConfigureAwait(false);
                if (intFormsPointsUsed > intCfpLimit)
                    intKarmaPointsRemain -= (intFormsPointsUsed - intCfpLimit)
                                            * await CharacterObject.GetComplexFormKarmaCostAsync(token)
                                                .ConfigureAwait(false);
                intFreestyleBP += intFormsPointsUsed;

                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Calculate the BP used by Programs and Advanced Programs.
                int intAIAdvancedProgramPointsUsed = 0;
                int intAINormalProgramPointsUsed
                    = await (await CharacterObject.GetAIProgramsAsync(token).ConfigureAwait(false)).SumAsync(
                        objProgram =>
                        {
                            token.ThrowIfCancellationRequested();
                            if (!objProgram.CanDelete)
                                return 0;
                            if (objProgram.IsAdvancedProgram)
                                ++intAIAdvancedProgramPointsUsed;
                            else
                                return 1;
                            return 0;
                        }, token).ConfigureAwait(false);
                int intKarmaCost = 0;
                int intNumAdvancedProgramPointsAsNormalPrograms = 0;
                int intAiNormalProgramLimit
                    = await CharacterObject.GetAINormalProgramLimitAsync(token).ConfigureAwait(false);
                int intAiAdvancedProgramLimit
                    = await CharacterObject.GetAIAdvancedProgramLimitAsync(token).ConfigureAwait(false);
                int intAiNormalProgramKarmaCost
                    = await CharacterObject.GetAIProgramKarmaCostAsync(token).ConfigureAwait(false);
                int intAiAdvancedProgramKarmaCost
                    = await CharacterObject.GetAIAdvancedProgramKarmaCostAsync(token).ConfigureAwait(false);
                if (intAINormalProgramPointsUsed > intAiNormalProgramLimit)
                {
                    if (intAIAdvancedProgramPointsUsed < intAiAdvancedProgramLimit)
                    {
                        intNumAdvancedProgramPointsAsNormalPrograms = Math.Min(
                            intAINormalProgramPointsUsed - intAiNormalProgramLimit,
                            intAiAdvancedProgramLimit - intAIAdvancedProgramPointsUsed);
                        intAINormalProgramPointsUsed -= intNumAdvancedProgramPointsAsNormalPrograms;
                    }

                    if (intAINormalProgramPointsUsed > intAiNormalProgramLimit)
                        intKarmaCost += (intAINormalProgramPointsUsed - intAiNormalProgramLimit)
                                        * intAiNormalProgramKarmaCost;
                }

                if (intAIAdvancedProgramPointsUsed > intAiAdvancedProgramLimit)
                {
                    intKarmaCost += (intAIAdvancedProgramPointsUsed - intAiAdvancedProgramLimit)
                                    * intAiAdvancedProgramKarmaCost;
                }

                intKarmaPointsRemain -= intKarmaCost;
                intFreestyleBP += intAIAdvancedProgramPointsUsed + intAINormalProgramPointsUsed
                                                                 + intNumAdvancedProgramPointsAsNormalPrograms;

                token.ThrowIfCancellationRequested();
                // ------------------------------------------------------------------------------
                // Calculate the BP used by Initiation.
                int intInitiationPoints
                    = await (await CharacterObject.GetInitiationGradesAsync(token).ConfigureAwait(false)).SumAsync(
                        async objGrade =>
                        {
                            int intLoop = await objGrade.GetKarmaCostAsync(token).ConfigureAwait(false);
                            // Add the Karma cost of extra Metamagic/Echoes to the Initiation cost.
                            int metamagicKarma
                                = Math.Max(
                                    await (await CharacterObject.GetMetamagicsAsync(token).ConfigureAwait(false))
                                        .CountAsync(x => x.Grade == objGrade.Grade, token: token).ConfigureAwait(false)
                                    - 1,
                                    0);
                            intLoop
                                += await CharacterObjectSettings.GetKarmaMetamagicAsync(token).ConfigureAwait(false)
                                   * metamagicKarma;
                            return intLoop;
                        }, token).ConfigureAwait(false);

                // Add the Karma cost of extra Metamagic/Echoes to the Initiation cost.
                intInitiationPoints += await (await CharacterObject.GetEnhancementsAsync(token).ConfigureAwait(false))
                    .GetCountAsync(token).ConfigureAwait(false) * 2;
                intInitiationPoints += await (await CharacterObject.GetPowersAsync(token).ConfigureAwait(false))
                    .SumAsync(objPower => objPower.Enhancements.GetCountAsync(token),
                        token).ConfigureAwait(false) * 2;

                // Joining a Network does not cost Karma for Technomancers, so this only applies to Magicians/Adepts.
                // Check to see if the character is a member of a Group.
                if (await CharacterObject.GetGroupMemberAsync(token).ConfigureAwait(false)
                    && await CharacterObject.GetMAGEnabledAsync(token).ConfigureAwait(false))
                    intInitiationPoints
                        += await CharacterObjectSettings.GetKarmaJoinGroupAsync(token).ConfigureAwait(false);

                intKarmaPointsRemain -= intInitiationPoints;
                intFreestyleBP += intInitiationPoints;

                // Add the Karma cost of any Critter Powers.
                intKarmaPointsRemain -= await (await CharacterObject.GetCritterPowersAsync(token).ConfigureAwait(false))
                    .SumAsync(
                        objPower => objPower.Karma, token).ConfigureAwait(false);

                if (!blnDoUIUpdate)
                    return intKarmaPointsRemain;
                token.ThrowIfCancellationRequested();
                await lblKarmaMetatypeBP.DoThreadSafeAsync(
                        x => x.Text = intMetatypeBP.ToString(GlobalSettings.CultureInfo) + strSpace
                            + strPoints, token: token)
                    .ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                           out StringBuilder sbdContactPoints))
                {
                    sbdContactPoints.Append(Math.Max(0, intContactPoints - intPointsInContacts).ToString(GlobalSettings.CultureInfo));
                    if (blnFriendsInHighPlaces)
                    {
                        sbdContactPoints.Append('/', Math.Max(0, intFriendsInHighPlacesPoints - intHighPlacesFriends)
                                .ToString(GlobalSettings.CultureInfo));
                    }

                    sbdContactPoints.Append(strOf).Append(intContactPoints.ToString(GlobalSettings.CultureInfo));
                    if (blnFriendsInHighPlaces)
                    {
                        sbdContactPoints.Append('/', intFriendsInHighPlacesPoints.ToString(GlobalSettings.CultureInfo));
                    }

                    if (intPointsInContacts > intContactPoints || intHighPlacesFriends > intFriendsInHighPlacesPoints)
                    {
                        int intKarmaUsed = Math.Max(0, intPointsInContacts - intContactPoints) +
                                           Math.Max(0, intHighPlacesFriends - intFriendsInHighPlacesPoints);
                        sbdContactPoints.Append(strSpace, '(', intKarmaUsed.ToString(GlobalSettings.CultureInfo))
                            .Append(strSpace, strPoints, ')');
                    }

                    string strContactPoints = sbdContactPoints.ToString();
                    await lblContactsBP.DoThreadSafeAsync(x => x.Text = strContactPoints, token).ConfigureAwait(false);
                    await lblContactPoints.DoThreadSafeAsync(x => x.Text = strContactPoints, token)
                        .ConfigureAwait(false);
                }

                string strTemp
                    = await BuildAttributes(
                        await (await CharacterObject.GetAttributeSectionAsync(token).ConfigureAwait(false))
                            .GetAttributeListAsync(token).ConfigureAwait(false), token: token).ConfigureAwait(false);
                token.ThrowIfCancellationRequested();
                await lblAttributesBP.DoThreadSafeAsync(x => x.Text = strTemp, token).ConfigureAwait(false);
                string strTemp2
                    = await BuildAttributes(
                            await (await CharacterObject.GetAttributeSectionAsync(token).ConfigureAwait(false))
                                .GetSpecialAttributeListAsync(token).ConfigureAwait(false), null, true, token)
                        .ConfigureAwait(false);
                token.ThrowIfCancellationRequested();
                await lblPBuildSpecial.DoThreadSafeAsync(x => x.Text = strTemp2, token).ConfigureAwait(false);
                await lblMartialArtsBP
                    .DoThreadSafeAsync(
                        x => x.Text = intMartialArtsPoints.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints,
                        token).ConfigureAwait(false);
                await lblNuyenBP
                    .DoThreadSafeAsync(
                        x => x.Text = intNuyenBP.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints, token)
                    .ConfigureAwait(false);
                await lblFociBP
                    .DoThreadSafeAsync(
                        x => x.Text = intFociPointsUsed.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints,
                        token).ConfigureAwait(false);
                await lblSpiritsBP
                    .DoThreadSafeAsync(
                        x => x.Text = intSpiritPointsUsed.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints,
                        token).ConfigureAwait(false);
                await lblSpritesBP
                    .DoThreadSafeAsync(
                        x => x.Text = intSpritePointsUsed.ToString(GlobalSettings.CultureInfo) + strSpace + strPoints,
                        token).ConfigureAwait(false);
                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                           out StringBuilder sbdComplexFormsBP))
                {
                    if (intCfpLimit > 0)
                    {
                        sbdComplexFormsBP.Append(intFormsPointsUsed.ToString(GlobalSettings.CultureInfo)).Append(strOf)
                            .Append(intCfpLimit.ToString(GlobalSettings.CultureInfo));
                        if (intFormsPointsUsed > intCfpLimit)
                        {
                            sbdComplexFormsBP.Append(strColon).Append(strSpace)
                                .Append(((intFormsPointsUsed - intCfpLimit)
                                         * await CharacterObject.GetComplexFormKarmaCostAsync(token)
                                             .ConfigureAwait(false))
                                    .ToString(GlobalSettings.CultureInfo)).Append(strSpace)
                                .Append(strPoints);
                        }
                    }
                    else
                    {
                        sbdComplexFormsBP
                            .Append(((intFormsPointsUsed - intCfpLimit)
                                     * await CharacterObject.GetComplexFormKarmaCostAsync(token).ConfigureAwait(false))
                                .ToString(GlobalSettings.CultureInfo)).Append(strSpace).Append(strPoints);
                    }

                    await lblComplexFormsBP.DoThreadSafeAsync(x => x.Text = sbdComplexFormsBP.ToString(), token)
                        .ConfigureAwait(false);
                }

                await lblAINormalProgramsBP.DoThreadSafeAsync(
                    x => x.Text = ((intAINormalProgramPointsUsed - intAiNormalProgramLimit)
                                   * intAiNormalProgramKarmaCost).ToString(GlobalSettings.CultureInfo) + strSpace
                        + strPoints, token).ConfigureAwait(false);
                await lblAIAdvancedProgramsBP.DoThreadSafeAsync(
                    x => x.Text = ((intAIAdvancedProgramPointsUsed - intAiAdvancedProgramLimit)
                                   * intAiAdvancedProgramKarmaCost).ToString(GlobalSettings.CultureInfo)
                                  + strSpace + strPoints, token).ConfigureAwait(false);
                await lblInitiationBP.DoThreadSafeAsync(
                    x => x.Text = intInitiationPoints.ToString(GlobalSettings.CultureInfo)
                                  + strSpace + strPoints, token).ConfigureAwait(false);
                // ------------------------------------------------------------------------------
                // Update the number of BP remaining in the StatusBar.
                int intBuildKarma = _blnFreestyle
                    ? 0
                    : await CharacterObjectSettings.GetBuildKarmaAsync(token).ConfigureAwait(false);
                await tsMain.DoThreadSafeAsync(() =>
                {
                    tslKarmaRemaining.Text = intKarmaPointsRemain.ToString(GlobalSettings.CultureInfo);
                    if (_blnFreestyle)
                    {
                        tslKarma.Text = Math.Max(intFreestyleBP, intFreestyleBPMin)
                            .ToString(GlobalSettings.CultureInfo);
                        tslKarma.ForeColor = intFreestyleBP < intFreestyleBPMin
                            ? ColorManager.ErrorColor
                            : ColorManager.ControlText;
                    }
                    else
                    {
                        tslKarma.Text = intBuildKarma.ToString(GlobalSettings.CultureInfo);
                        tslKarma.ForeColor = ColorManager.ControlText;
                    }
                }, token).ConfigureAwait(false);

                return intKarmaPointsRemain;
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        private async Task UpdateSkillRelatedInfo(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strKarma = await LanguageManager.GetStringAsync("String_Karma", token: token).ConfigureAwait(false);
            string strOf = await LanguageManager.GetStringAsync("String_Of", token: token).ConfigureAwait(false);
            string strColon = await LanguageManager.GetStringAsync("String_Colon", token: token).ConfigureAwait(false);
            string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token).ConfigureAwait(false);
            string strZeroKarma = 0.ToString(GlobalSettings.CultureInfo) + strSpace + strKarma;
            //Update Skill Labels
            //Active skills
            string strTemp = strZeroKarma;
            int intActiveSkillPointsMaximum = CharacterObject.SkillsSection.SkillPointsMaximum;
            if (intActiveSkillPointsMaximum > 0)
            {
                strTemp = (await CharacterObject.SkillsSection.GetSkillPointsAsync(token).ConfigureAwait(false))
                    .ToString(GlobalSettings.CultureInfo) + strOf
                                                          + intActiveSkillPointsMaximum.ToString(
                                                              GlobalSettings.CultureInfo);
            }

            int intActiveSkillsTotalCostKarma = await CharacterObject.SkillsSection.Skills
                                                                     .SumAsync(
                                                                         x => x.GetCurrentKarmaCostAsync(token)
                                                                               , token: token)
                                                                     .ConfigureAwait(false);
            if (intActiveSkillsTotalCostKarma > 0)
            {
                if (strTemp != strZeroKarma)
                {
                    strTemp += strColon + strSpace + intActiveSkillsTotalCostKarma.ToString(GlobalSettings.CultureInfo)
                               + strSpace + strKarma;
                }
                else
                {
                    strTemp = intActiveSkillsTotalCostKarma.ToString(GlobalSettings.CultureInfo) + strSpace + strKarma;
                }
            }

            await lblActiveSkillsBP.DoThreadSafeAsync(x => x.Text = strTemp, token).ConfigureAwait(false);
            //Knowledge skills
            string strTemp2 = strZeroKarma;
            int intKnowledgeSkillPointsMaximum = await CharacterObject.SkillsSection.GetKnowledgeSkillPointsAsync(token)
                                                                      .ConfigureAwait(false);
            if (intKnowledgeSkillPointsMaximum > 0)
            {
                strTemp2
                    = (await CharacterObject.SkillsSection.GetKnowledgeSkillPointsRemainAsync(token)
                                            .ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo) + strOf
                    + intKnowledgeSkillPointsMaximum.ToString(GlobalSettings.CultureInfo);
            }

            int intKnowledgeSkillsTotalCostKarma
                = await CharacterObject.SkillsSection.KnowledgeSkills
                                       .SumAsync(x => x.GetCurrentKarmaCostAsync(token), token: token)
                                       .ConfigureAwait(false);
            if (intKnowledgeSkillsTotalCostKarma > 0)
            {
                if (strTemp2 != strZeroKarma)
                {
                    strTemp2 += strColon + strSpace
                                         + intKnowledgeSkillsTotalCostKarma.ToString(GlobalSettings.CultureInfo)
                                         + strSpace + strKarma;
                }
                else
                {
                    strTemp2 = intKnowledgeSkillsTotalCostKarma.ToString(GlobalSettings.CultureInfo) + strSpace
                        + strKarma;
                }
            }

            await lblKnowledgeSkillsBP.DoThreadSafeAsync(x => x.Text = strTemp2, token).ConfigureAwait(false);
            //Groups
            string strTemp3 = strZeroKarma;
            int intSkillGroupPointsMaximum = CharacterObject.SkillsSection.SkillGroupPointsMaximum;
            if (intSkillGroupPointsMaximum > 0)
            {
                strTemp3
                    = (await CharacterObject.SkillsSection.GetSkillGroupPointsAsync(token).ConfigureAwait(false))
                    .ToString(GlobalSettings.CultureInfo) + strOf
                                                          + intSkillGroupPointsMaximum.ToString(
                                                              GlobalSettings.CultureInfo);
            }

            int intSkillGroupsTotalCostKarma = await CharacterObject.SkillsSection.SkillGroups
                                                                    .SumAsync(
                                                                        x => x.GetCurrentKarmaCostAsync(token),
                                                                        token: token).ConfigureAwait(false);
            if (intSkillGroupsTotalCostKarma > 0)
            {
                if (strTemp3 != strZeroKarma)
                {
                    strTemp3 += strColon + strSpace + intSkillGroupsTotalCostKarma.ToString(GlobalSettings.CultureInfo)
                                + strSpace + strKarma;
                }
                else
                {
                    strTemp3 = intSkillGroupsTotalCostKarma.ToString(GlobalSettings.CultureInfo) + strSpace + strKarma;
                }
            }

            await lblSkillGroupsBP.DoThreadSafeAsync(x => x.Text = strTemp3, token).ConfigureAwait(false);
        }

        private int _intFileUpdateQueued;

        protected override async void LiveUpdateFromCharacterFile(object sender, FileSystemEventArgs e)
        {
            if (Interlocked.Increment(ref _intFileUpdateQueued) > 1)
            {
                Interlocked.Decrement(ref _intFileUpdateQueued);
                return;
            }

            try
            {
                while (IsDirty || IsLoading || SkipUpdate || IsCharacterUpdateRequested)
                    await Utils.SafeSleepAsync(GenericToken).ConfigureAwait(false);

                string strCharacterFile = await CharacterObject.GetFileNameAsync(GenericToken).ConfigureAwait(false);
                if (string.IsNullOrEmpty(strCharacterFile) || !File.Exists(strCharacterFile))
                    return;

                // Character is not dirty and their save file was updated outside of Chummer5 while it is open, so reload them
                CursorWait objCursorWaitOuter
                    = await CursorWait.NewAsync(this, true, GenericToken).ConfigureAwait(false);
                try
                {
                    IAsyncDisposable objLocker =
                        await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                    try
                    {
                        GenericToken.ThrowIfCancellationRequested();
                        CursorWait objCursorWait
                            = await CursorWait.NewAsync(this, token: GenericToken).ConfigureAwait(false);
                        try
                        {
                            using (ThreadSafeForm<LoadingBar> frmLoadingBar = await Program
                                       .CreateAndShowProgressBarAsync(
                                           Path.GetFileName(strCharacterFile),
                                           Character.NumLoadingSections + 1, GenericToken).ConfigureAwait(false))
                            {
                                SkipUpdate = true;
                                try
                                {
                                    await CharacterObject
                                        .LoadAsync(frmLoadingForm: frmLoadingBar.MyForm, token: GenericToken)
                                        .ConfigureAwait(false);
                                    await frmLoadingBar.MyForm.PerformStepAsync(
                                        await LanguageManager.GetStringAsync("String_UI", token: GenericToken)
                                            .ConfigureAwait(false),
                                        token: GenericToken).ConfigureAwait(false);

                                    Tradition objTradition = await CharacterObject.GetMagicTraditionAsync(GenericToken)
                                        .ConfigureAwait(false);
                                    TraditionType eTraditionType = await objTradition.GetTypeAsync(GenericToken)
                                        .ConfigureAwait(false);
                                    string strTraditionSourceIdString =
                                        await objTradition.GetSourceIDStringAsync(GenericToken)
                                            .ConfigureAwait(false);
                                    await cboTradition.DoThreadSafeAsync(x =>
                                    {
                                        if (eTraditionType == TraditionType.MAG &&
                                            !string.IsNullOrEmpty(strTraditionSourceIdString))
                                            x.SelectedValue = strTraditionSourceIdString;
                                        if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                            x.SelectedIndex = 0;
                                    }, GenericToken).ConfigureAwait(false);
                                    await cboStream.DoThreadSafeAsync(x =>
                                    {
                                        if (eTraditionType == TraditionType.RES &&
                                            !string.IsNullOrEmpty(strTraditionSourceIdString))
                                            x.SelectedValue = strTraditionSourceIdString;
                                        if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                            x.SelectedIndex = 0;
                                    }, GenericToken).ConfigureAwait(false);
                                }
                                finally
                                {
                                    SkipUpdate = false;
                                }
                            }
                        }
                        finally
                        {
                            await objCursorWait.DisposeAsync().ConfigureAwait(false);
                        }

                        // Immediately call character update because we know it's necessary
                        try
                        {
                            await RequestAndProcessCharacterUpdate(GenericToken).ConfigureAwait(false);
                        }
                        catch (OperationCanceledException)
                        {
                            return;
                        }

                        IsDirty = false;

                        ConcurrentBag<string> lstInternalIdsNeedingReapplyImprovements
                            = await CharacterObject.TakeInternalIdsNeedingReapplyImprovementsAsync(GenericToken)
                                .ConfigureAwait(false);
                        if (lstInternalIdsNeedingReapplyImprovements?.Count > 0 && !Utils.IsUnitTest)
                        {
                            string strListFriendlyNames;
                            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool, out StringBuilder sbdListFriendlyNames))
                            {
                                foreach (IHasInternalId objSource in await CharacterObject.GetItemsByInternalIdsAsync(lstInternalIdsNeedingReapplyImprovements, true, GenericToken).ConfigureAwait(false))
                                {
                                    string strToAdd;
                                    if (objSource is IHasCustomName objCustomNameItem)
                                        strToAdd = objCustomNameItem.CustomName;
                                    else if (objSource is Improvement objImprovement)
                                        strToAdd = await CharacterObject.GetObjectNameAsync(objImprovement, token: GenericToken).ConfigureAwait(false);
                                    else if (objSource is IHasName objNamedItem)
                                        strToAdd = await objNamedItem.GetCurrentDisplayNameAsync(GenericToken).ConfigureAwait(false);
                                    else
                                        strToAdd = objSource.InternalId;
                                    sbdListFriendlyNames.AppendLine(strToAdd);
                                }
                                strListFriendlyNames = sbdListFriendlyNames.ToString();
                            }
                            string strDescription = await LanguageManager.GetStringAsync("Message_ImprovementLoadError", token: GenericToken).ConfigureAwait(false);
                            if (!string.IsNullOrEmpty(strListFriendlyNames))
                            {
                                strDescription += await LanguageManager.GetStringAsync("Message_ImprovementLoadErrorPart2", token: GenericToken).ConfigureAwait(false) + strListFriendlyNames;
                            }
                            if (await Program.ShowScrollableMessageBoxAsync(
                                this, strDescription,
                                await LanguageManager.GetStringAsync("MessageTitle_ImprovementLoadError", token: GenericToken).ConfigureAwait(false),
                                MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation, token: GenericToken).ConfigureAwait(false) == DialogResult.Yes)
                            {
                                await DoReapplyImprovements(lstInternalIdsNeedingReapplyImprovements,
                                    GenericToken).ConfigureAwait(false);
                            }
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWaitOuter.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
            finally
            {
                Interlocked.Decrement(ref _intFileUpdateQueued);
            }
        }

        /// <summary>
        /// Update the Character information.
        /// </summary>
        protected override async Task DoUpdateCharacterInfo(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            await base.DoUpdateCharacterInfo(token).ConfigureAwait(false);
            while (SkipUpdate)
                await Utils.SafeSleepAsync(token).ConfigureAwait(false);
            SkipUpdate = true;
            try
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, true, token).ConfigureAwait(false);
                try
                {
                    // Upgradeable read lock so that we make sure all potential write locks are finished before executing
                    IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                        .ConfigureAwait(false);
                    try
                    {
                        token.ThrowIfCancellationRequested();
                        // Read lock to make sure we are not writing anything despite being in an upgradeable read lock
                        IAsyncDisposable objLocker2 = await CharacterObject.LockObject.EnterReadLockAsync(token)
                            .ConfigureAwait(false);
                        try
                        {
                            token.ThrowIfCancellationRequested();
                            ProcessCharacterUpdateHasStarted();

                            Task tskAutosave = Task.CompletedTask;
                            if (AutosaveStopwatch?.Elapsed.Minutes >= 5 && IsDirty)
                            {
                                tskAutosave = AutoSaveCharacter(token);
                            }

                            // TODO: DataBind these wherever possible
                            if (await CharacterObject.GetMetatypeAsync(token).ConfigureAwait(false) == "Free Spirit"
                                && !await CharacterObject.GetIsCritterAsync(token).ConfigureAwait(false)
                                || (await CharacterObject.GetMetatypeCategoryAsync(token).ConfigureAwait(false))
                                .EndsWith(
                                    "Spirits", StringComparison.Ordinal))
                            {
                                await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                    .ConfigureAwait(false);
                                string strFreeSpiritPowerPoints = await CharacterObject
                                    .CalculateFreeSpiritPowerPointsAsync(token)
                                    .ConfigureAwait(false);
                                await lblCritterPowerPoints.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strFreeSpiritPowerPoints;
                                }, token).ConfigureAwait(false);
                            }
                            else if (await CharacterObject.GetIsFreeSpriteAsync(token).ConfigureAwait(false))
                            {
                                await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                    .ConfigureAwait(false);
                                string strFreeSpritePowerPoints = await CharacterObject
                                    .CalculateFreeSpritePowerPointsAsync(token)
                                    .ConfigureAwait(false);
                                await lblCritterPowerPoints.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strFreeSpritePowerPoints;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblCritterPowerPointsLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                                await lblCritterPowerPoints.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                            }

                            await Task.WhenAll(RefreshSelectedQuality(token), RefreshSelectedCyberware(token),
                                    RefreshSelectedArmor(token),
                                    RefreshSelectedGear(token), RefreshSelectedDrug(token),
                                    RefreshSelectedLifestyle(token),
                                    RefreshSelectedVehicle(token), RefreshSelectedWeapon(token),
                                    RefreshSelectedSpell(token),
                                    RefreshSelectedComplexForm(token), RefreshSelectedCritterPower(token),
                                    RefreshSelectedAIProgram(token), RefreshSelectedMetamagic(token),
                                    RefreshSelectedMartialArt(token), UpdateInitiationCost(token),
                                    UpdateSkillRelatedInfo(token), RefreshNuyenDisplays(token),
                                    CalculateBPandRefreshBPDisplays(true, token), RefreshPasteStatus(token))
                                .ConfigureAwait(false);
                            await tskAutosave.ConfigureAwait(false);
                        }
                        finally
                        {
                            await objLocker2.DisposeAsync().ConfigureAwait(false);
                        }
                    }
                    finally
                    {
                        await objLocker.DisposeAsync().ConfigureAwait(false);
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                SkipUpdate = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed piece of Cyberware.
        /// </summary>
        private async Task RefreshSelectedCyberware(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpCyberware.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    TreeNode objSelectedNode = await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                                 .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag == null || objSelectedNode.Level == 0)
                    {
                        await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbCyberwareMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);

                        // Buttons
                        await cmdDeleteCyberware
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                        return;
                    }

                    if (objSelectedNodeTag is IHasRating objHasRating)
                    {
                        string strText = string.Format(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Label_RatingFormat", token: token).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync(
                                objHasRating.RatingLabel, token: token).ConfigureAwait(false));
                        await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token)
                                                     .ConfigureAwait(false);
                    }

                    string strESSFormat = await CharacterObjectSettings.GetEssenceFormatAsync(token).ConfigureAwait(false);
                    if (objSelectedNodeTag is IHasSource objSelected)
                    {
                        await lblCyberwareSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                     .ConfigureAwait(false);
                        await lblCyberwareSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await objSelected.SetSourceDetailAsync(lblCyberwareSource, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await lblCyberwareSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                        await lblCyberwareSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    if (objSelectedNodeTag is IHasStolenProperty loot && (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                CharacterObject,
                                Improvement.ImprovementType.Nuyen, "Stolen", token: token).ConfigureAwait(false))
                        .Count > 0)
                    {
                        await chkCyberwareStolen.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await chkCyberwareStolen.DoThreadSafeAsync(x => x.Checked = loot.Stolen, token)
                                                .ConfigureAwait(false);
                    }
                    else
                    {
                        await chkCyberwareStolen.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    switch (objSelectedNodeTag)
                    {
                        // Locate the selected piece of Cyberware.
                        case Cyberware objCyberware:
                        {
                            await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            bool blnIsCyberware = (await objCyberware.GetSourceTypeAsync(token).ConfigureAwait(false)) == Improvement.ImprovementSource.Cyberware;
                            await gpbCyberwareMatrix
                                  .DoThreadSafeAsync(
                                      x => x.Visible = blnIsCyberware, token)
                                  .ConfigureAwait(false);

                            // Buttons
                            await cmdDeleteCyberware
                                  .DoThreadSafeAsync(x => x.Enabled = string.IsNullOrEmpty(objCyberware.ParentID),
                                                     token).ConfigureAwait(false);

                            // gpbCyberwareCommon
                            string strName = await objCyberware.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                            await lblCyberwareName
                                  .DoThreadSafeAsync(x => x.Text = strName, token)
                                  .ConfigureAwait(false);
                            string strCategory = await objCyberware.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                                   .ConfigureAwait(false);
                            await lblCyberwareCategory.DoThreadSafeAsync(x => x.Text = strCategory, token)
                                                      .ConfigureAwait(false);
                            bool blnNoParent = await objCyberware.GetParentAsync(token).ConfigureAwait(false) == null;
                            // Cyberware Grade is not available for Genetech items.
                            // Cyberware Grade is only available on root-level items (sub-components cannot have a different Grade than the piece they belong to).
                            await cboCyberwareGrade.DoThreadSafeAsync(x => x.Enabled = blnNoParent
                                                                          && !objCyberware.Suite
                                                                          && string.IsNullOrWhiteSpace(
                                                                              objCyberware.ForceGrade), token)
                                                   .ConfigureAwait(false);
                            XPathNavigator xmlCyberware
                                = await objCyberware.GetNodeXPathAsync(token: token).ConfigureAwait(false);
                            HashSet<string> setDisallowedGrades = null;
                            if (xmlCyberware?.SelectSingleNodeAndCacheExpression("bannedgrades", token) != null)
                            {
                                setDisallowedGrades = new HashSet<string>();
                                foreach (XPathNavigator objNode in xmlCyberware
                                                                         .SelectAndCacheExpression(
                                                                             "bannedgrades/grade", token))
                                {
                                    setDisallowedGrades.Add(objNode.Value);
                                }
                            }

                            string strGradeName = (await objCyberware.GetGradeAsync(token).ConfigureAwait(false)).Name;
                            await PopulateCyberwareGradeList(
                                objCyberware.SourceType == Improvement.ImprovementSource.Bioware,
                                setDisallowedGrades,
                                await cboCyberwareGrade.DoThreadSafeFuncAsync(x => x.Enabled, token)
                                                       .ConfigureAwait(false)
                                    ? string.Empty
                                    : strGradeName, token).ConfigureAwait(false);
                            await lblCyberwareGradeLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                            await cboCyberwareGrade.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                if (!string.IsNullOrEmpty(strGradeName))
                                    x.SelectedValue = strGradeName;
                                if (x.SelectedIndex == -1 && x.Items.Count > 0)
                                    x.SelectedIndex = 0;
                            }, token).ConfigureAwait(false);
                            await lblCyberwareEssenceLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                            await lblCyberwareEssence.DoThreadSafeAsync(x => x.Visible = true, token)
                                                     .ConfigureAwait(false);
                            if (blnNoParent || await objCyberware.GetAddToParentESSAsync(token).ConfigureAwait(false))
                            {
                                decimal decCalculatedEss
                                    = await objCyberware.GetCalculatedESSAsync(token).ConfigureAwait(false);
                                await lblCyberwareEssence
                                    .DoThreadSafeAsync(
                                        x => x.Text = blnNoParent
                                            ? decCalculatedEss.ToString(
                                                strESSFormat, GlobalSettings.CultureInfo)
                                            : "+"
                                              + decCalculatedEss.ToString(
                                                  strESSFormat, GlobalSettings.CultureInfo), token)
                                    .ConfigureAwait(false);
                            }
                            else
                                await lblCyberwareEssence
                                      .DoThreadSafeAsync(
                                          x => x.Text = 0.0m.ToString(strESSFormat, GlobalSettings.CultureInfo), token)
                                      .ConfigureAwait(false);

                            string strAvail = await objCyberware.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblCyberwareAvail
                                  .DoThreadSafeAsync(x => x.Text = strAvail, token)
                                  .ConfigureAwait(false);
                            bool blnVisible = !string.IsNullOrEmpty(await objCyberware.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false));
                            await cmdCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = blnVisible, token).ConfigureAwait(false);
                            // Enable and set the Rating values as needed.
                            int intMaxRating = await objCyberware.GetMaxRatingAsync(token).ConfigureAwait(false);
                            if (intMaxRating == 0)
                            {
                                await nudCyberwareRating.DoThreadSafeAsync(x =>
                                {
                                    x.Maximum = 0;
                                    x.Minimum = 0;
                                    x.Value = 0;
                                    x.Visible = false;
                                }, token).ConfigureAwait(false);
                                await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                            }
                            else
                            {
                                int intMinRating = await objCyberware.GetMinRatingAsync(token).ConfigureAwait(false);
                                int intRating = await objCyberware.GetRatingAsync(token).ConfigureAwait(false);
                                await nudCyberwareRating.DoThreadSafeAsync(x =>
                                {
                                    x.Maximum = intMaxRating;
                                    x.Minimum = intMinRating;
                                    x.Value = intRating;
                                    x.Visible = true;
                                    x.Enabled = intMaxRating != intMinRating
                                                && string.IsNullOrEmpty(objCyberware.ParentID);
                                }, token).ConfigureAwait(false);
                                await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                             .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            string strCapacity = await objCyberware.GetDisplayCapacityAsync(token).ConfigureAwait(false);
                            await lblCyberwareCapacity
                                  .DoThreadSafeAsync(x => x.Text = strCapacity, token)
                                  .ConfigureAwait(false);
                            string strCost = (await objCyberware.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblCyberwareCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                  .ConfigureAwait(false);
                            if (await objCyberware.GetIsLimbAsync(token).ConfigureAwait(false))
                            {
                                await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                string strAgi = (await objCyberware.GetAttributeTotalValueAsync("AGI", token).ConfigureAwait(false))
                                    .ToString(GlobalSettings.CultureInfo);
                                await lblCyberlimbAGI.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strAgi;
                                }, token).ConfigureAwait(false);
                                await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                string strStr = (await objCyberware.GetAttributeTotalValueAsync("STR", token).ConfigureAwait(false))
                                    .ToString(GlobalSettings.CultureInfo);
                                await lblCyberlimbSTR.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strStr;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblCyberlimbAGI.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                                await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblCyberlimbSTR.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                        (await CharacterObject
                                            .LoadDataXPathAsync(
                                                objCyberware.SourceType
                                                == Improvement.ImprovementSource
                                                    .Cyberware
                                                    ? "cyberware.xml"
                                                    : "bioware.xml", token: token)
                                            .ConfigureAwait(false))
                                        .SelectSingleNodeAndCacheExpression(
                                            "/chummer", token: token), token).ConfigureAwait(false))
                                                                 .Contains(objCyberware.Category);
                                bool blnChecked = !string.IsNullOrEmpty(objCyberware.ParentID)
                                    ? (await objCyberware.GetParentAsync(token).ConfigureAwait(false))?.DiscountCost == true
                                    : objCyberware.DiscountCost;
                                await chkCyberwareBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = blnChecked;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkCyberwareBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            bool blnPTVisible = await CharacterObject.GetIsPrototypeTranshumanAsync(token).ConfigureAwait(false);
                            bool blnCanBePT = blnPTVisible && blnNoParent && await objCyberware.GetSourceTypeAsync(token).ConfigureAwait(false) == Improvement.ImprovementSource.Bioware;
                            bool blnIsPT = blnPTVisible && await objCyberware.GetPrototypeTranshumanAsync(token).ConfigureAwait(false);
                            await chkPrototypeTranshuman.DoThreadSafeAsync(x =>
                            {
                                x.Visible = blnPTVisible;
                                x.Enabled = blnCanBePT;
                                x.Checked = blnIsPT;
                            }, token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbCyberwareMatrix
                            if (await gpbCyberwareMatrix.DoThreadSafeFuncAsync(x => x.Visible, token)
                                                        .ConfigureAwait(false))
                            {
                                int intDeviceRating = await objCyberware.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                                await lblCyberDeviceRating
                                      .DoThreadSafeAsync(
                                          x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token)
                                      .ConfigureAwait(false);
                                await objCyberware.RefreshMatrixAttributeComboBoxesAsync(
                                    cboCyberwareAttack, cboCyberwareSleaze, cboCyberwareDataProcessing,
                                    cboCyberwareFirewall, token).ConfigureAwait(false);

                                bool blnIsActiveCommlink = await objCyberware.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnIsCommlink = await objCyberware.GetIsCommlinkAsync(token).ConfigureAwait(false);
                                if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                                {
                                    bool blnIsHomeNode = await objCyberware.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                    bool blnCanBeHomeNode = blnIsCommlink &&
                                                            await objCyberware.GetTotalMatrixAttributeAsync(
                                                                "Program Limit", token).ConfigureAwait(false) >=
                                                            (await (await CharacterObject.GetAttributeAsync("DEP",
                                                                token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                                ? 2
                                                                : 1);
                                    await chkCyberwareHomeNode.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Checked = blnIsHomeNode;
                                        x.Enabled = blnCanBeHomeNode;
                                    }, token).ConfigureAwait(false);
                                }
                                else
                                    await chkCyberwareHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                        .ConfigureAwait(false);

                                await chkCyberwareActiveCommlink.DoThreadSafeAsync(x =>
                                {
                                    x.Checked = blnIsActiveCommlink;
                                    x.Visible = blnIsCommlink;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            string strNodeText
                                = await objCyberware.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                            await treCyberware
                                  .DoThreadSafeAsync(() => objSelectedNode.Text = strNodeText,
                                                     token).ConfigureAwait(false);
                            break;
                        }
                        case Gear objGear:
                        {
                            await gpbCyberwareCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            await gpbCyberwareMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteCyberware
                                  .DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token)
                                  .ConfigureAwait(false);
                            // gpbCyberwareCommon
                            string strName = await objGear.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false);
                            await lblCyberwareName
                                  .DoThreadSafeAsync(x => x.Text = strName, token)
                                  .ConfigureAwait(false);
                            string strCategory = await objGear.GetCurrentDisplayCategoryAsync(token).ConfigureAwait(false);
                            await lblCyberwareCategory
                                  .DoThreadSafeAsync(x => x.Text = strCategory, token).ConfigureAwait(false);
                            await lblCyberwareGradeLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await cboCyberwareGrade.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await lblCyberwareEssenceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                            await lblCyberwareEssence.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            string strAvail = await objGear.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblCyberwareAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                   .ConfigureAwait(false);
                            await cmdCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                            int intGearMaxRatingValue = await objGear.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                            if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                            {
                                int intGearMinRatingValue = await objGear.GetMinRatingValueAsync(token).ConfigureAwait(false);
                                int intRating = await objGear.GetRatingAsync(token).ConfigureAwait(false);
                                await nudCyberwareRating.DoThreadSafeAsync(x =>
                                {
                                    x.Minimum = intGearMinRatingValue;
                                    x.Maximum = intGearMaxRatingValue;
                                    x.Value = intRating;
                                    x.Enabled = x.Maximum > x.Minimum && string.IsNullOrEmpty(objGear.ParentID);
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                                await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                             .ConfigureAwait(false);
                            }
                            else
                            {
                                await nudCyberwareRating.DoThreadSafeAsync(x =>
                                {
                                    x.Minimum = 0;
                                    x.Maximum = 0;
                                    x.Visible = false;
                                }, token).ConfigureAwait(false);
                                await lblCyberwareRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                            }

                            string strCapacity = await objGear.GetDisplayCapacityAsync(token).ConfigureAwait(false);
                            await lblCyberwareCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token)
                                                      .ConfigureAwait(false);
                            string strCost = (await objGear.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                                    .ConfigureAwait(false);
                            await lblCyberwareCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                  .ConfigureAwait(false);
                            await lblCyberlimbAGILabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            await lblCyberlimbAGI.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                            await lblCyberlimbSTRLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            await lblCyberlimbSTR.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = !objGear.IncludedInParent &&
                                                  (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                      (await CharacterObject
                                                          .LoadDataXPathAsync(
                                                              "gear.xml", token: token)
                                                          .ConfigureAwait(false))
                                                      .SelectSingleNodeAndCacheExpression(
                                                          "/chummer", token: token), token).ConfigureAwait(false))
                                                                               .Contains(objGear.Category);
                                await chkCyberwareBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objGear.IncludedInParent
                                        ? (objGear.Parent as ICanBlackMarketDiscount)?.DiscountCost == true
                                        : objGear.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkCyberwareBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await chkPrototypeTranshuman.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbCyberwareMatrix
                            int intDeviceRating = await objGear.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblCyberDeviceRating
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await objGear.RefreshMatrixAttributeComboBoxesAsync(cboCyberwareAttack, cboCyberwareSleaze,
                                cboCyberwareDataProcessing,
                                cboCyberwareFirewall, token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            bool blnIsActiveCommlink = await objGear.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objGear.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objGear.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objGear.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkCyberwareHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkCyberwareHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkCyberwareActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                                token.ThrowIfCancellationRequested();
                            string strText = await objGear.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                            await treCyberware
                                  .DoThreadSafeAsync(() => objSelectedNode.Text = strText, token)
                                  .ConfigureAwait(false);
                            break;
                        }
                    }
                }
                finally
                {
                    await flpCyberware.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Weapon.
        /// </summary>
        private async Task RefreshSelectedWeapon(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpWeapons.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    TreeNode objSelectedNode = await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                               .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag == null || objSelectedNode.Level <= 0)
                    {
                        await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteWeapon
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                        return;
                    }

                    string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token)
                                                           .ConfigureAwait(false);
                    if (objSelectedNodeTag is IHasSource objSelected)
                    {
                        await lblWeaponSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                        await lblWeaponSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await objSelected.SetSourceDetailAsync(lblWeaponSource, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await lblWeaponSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                        await lblWeaponSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    if (objSelectedNodeTag is IHasRating objHasRating)
                    {
                        string strText = string.Format(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Label_RatingFormat", token: token).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync(
                                objHasRating.RatingLabel, token: token).ConfigureAwait(false));
                        await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token)
                                                  .ConfigureAwait(false);
                    }

                    if (objSelectedNodeTag is IHasStolenProperty loot
                        && (await ImprovementManager
                                  .GetCachedImprovementListForValueOfAsync(
                                      CharacterObject,
                                      Improvement.ImprovementType.Nuyen,
                                      "Stolen", token: token).ConfigureAwait(false)).Count > 0)
                    {
                        await chkWeaponStolen.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await chkWeaponStolen.DoThreadSafeAsync(x => x.Checked = loot.Stolen, token)
                                             .ConfigureAwait(false);
                    }
                    else
                    {
                        await chkWeaponStolen.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    switch (objSelectedNodeTag)
                    {
                        case Weapon objWeapon:
                        {
                            await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = !objWeapon.IncludedInWeapon &&
                                                                        !objWeapon.Cyberware &&
                                                                        objWeapon.Category != "Gear" &&
                                                                        !objWeapon.Category.StartsWith(
                                                                            "Quality", StringComparison.Ordinal) &&
                                                                        string.IsNullOrEmpty(objWeapon.ParentID), token)
                                                 .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbWeaponsCommon
                            string strName = await objWeapon.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                            await lblWeaponName.DoThreadSafeAsync(x => x.Text = strName, token)
                                               .ConfigureAwait(false);
                            string strText = await objWeapon.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                            .ConfigureAwait(false);
                            await lblWeaponCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                   .ConfigureAwait(false);
                            int intRating = await objWeapon.GetRatingAsync(GenericToken).ConfigureAwait(false);
                            if (intRating > 0)
                            {
                                int intMaxRating = await objWeapon.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                                int intMinRating = await objWeapon.GetMinRatingValueAsync(token).ConfigureAwait(false);
                                await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                    .ConfigureAwait(false);
                                await nudWeaponRating.DoThreadSafeAsync(x =>
                                {
                                    x.Minimum = Math.Min(intMinRating, intMaxRating);
                                    x.Maximum = intMaxRating;
                                    x.Value = intRating;
                                    x.Increment = 1;
                                    x.Enabled = intMaxRating > intMinRating && string.IsNullOrEmpty(objWeapon.ParentID);
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                                await nudWeaponRating.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = false;
                                    x.Minimum = 0;
                                    x.Maximum = 0;
                                    x.Increment = 1;
                                    x.Enabled = false;
                                }, token).ConfigureAwait(false);
                            }
                            await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                            await lblWeaponCapacity.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            string strAvail = await objWeapon.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblWeaponAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                .ConfigureAwait(false);
                            string strCost = (await objWeapon.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblWeaponCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                           .ConfigureAwait(false);
                            await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                     .ConfigureAwait(false);
                            string strMounts = await objWeapon.GetCurrentDisplayAccessoryMounts(token).ConfigureAwait(false);
                            await lblWeaponSlots.DoThreadSafeAsync(x =>
                            {
                                x.Text = strMounts;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);

                            token.ThrowIfCancellationRequested();
                            string strConcealText = await objWeapon.GetDisplayConcealabilityAsync(token).ConfigureAwait(false);
                            await lblWeaponConcealLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            await lblWeaponConceal.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strConcealText;
                            }, token).ConfigureAwait(false);
                            string strText2 = await LanguageManager.GetStringAsync(objWeapon.Parent == null
                                ? "Checkbox_Equipped"
                                : "Checkbox_Installed", token: token).ConfigureAwait(false);
                            await chkWeaponEquipped.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText2;
                                x.Enabled = !objWeapon.IncludedInWeapon;
                                x.Checked = objWeapon.Equipped;
                            }, token).ConfigureAwait(false);
                            await chkIncludedInWeapon.DoThreadSafeAsync(x =>
                            {
                                x.Visible = objWeapon.Parent != null;
                                x.Enabled = false;
                                x.Checked = objWeapon.IncludedInWeapon;
                            }, token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = !objWeapon.IncludedInWeapon &&
                                                  (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                      (await CharacterObject
                                                          .LoadDataXPathAsync(
                                                              "weapons.xml", token: token).ConfigureAwait(false))
                                                      .SelectSingleNodeAndCacheExpression(
                                                          "/chummer", token: token), token).ConfigureAwait(false))
                                    .Contains(objWeapon.Category);
                                await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objWeapon.IncludedInWeapon
                                        ? objWeapon.Parent?.DiscountCost == true
                                        : objWeapon.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            // gpbWeaponsWeapon
                            string strText3 = await LanguageManager.GetStringAsync("String_Weapon", token: token)
                                                                   .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Text = strText3, token)
                                                  .ConfigureAwait(false);
                            await lblWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                            string strDamage = await objWeapon.GetDisplayDamageAsync(token).ConfigureAwait(false);
                            await lblWeaponDamage.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strDamage;
                            }, token).ConfigureAwait(false);
                            await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            string strAP = await objWeapon.GetDisplayTotalAPAsync(token).ConfigureAwait(false);
                            await lblWeaponAP.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strAP;
                            }, token).ConfigureAwait(false);
                            await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                            string strAccuracy = await objWeapon.GetDisplayAccuracyAsync(token).ConfigureAwait(false);
                            await lblWeaponAccuracy.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strAccuracy;
                            }, token).ConfigureAwait(false);
                            await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                            string strPool
                                = (await objWeapon.GetDicePoolAsync(token: token).ConfigureAwait(false)).ToString(
                                    GlobalSettings.CultureInfo);
                            await lblWeaponDicePool.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strPool;
                            }, token).ConfigureAwait(false);
                            await lblWeaponDicePool.SetToolTipTextAsync(await objWeapon.GetDicePoolTooltipAsync(token).ConfigureAwait(false), token)
                                                   .ConfigureAwait(false);
                            if (objWeapon.RangeType == "Ranged")
                            {
                                await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                                await lblWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                                await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                                (string strRC, string strRCTooltip) = await objWeapon.GetDisplayTotalRCAsync(token).ConfigureAwait(false);
                                await lblWeaponRC.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strRC;
                                }, token).ConfigureAwait(false);
                                await lblWeaponRC.SetToolTipTextAsync(strRCTooltip, token).ConfigureAwait(false);
                                await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                string strAmmo = await objWeapon.GetDisplayAmmoAsync(token).ConfigureAwait(false);
                                await lblWeaponAmmo.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strAmmo;
                                }, token).ConfigureAwait(false);
                                await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                string strMode = await objWeapon.GetDisplayModeAsync(token).ConfigureAwait(false);
                                await lblWeaponMode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strMode;
                                }, token).ConfigureAwait(false);

                                await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                                string strRange = await objWeapon.GetCurrentDisplayRangeAsync(token).ConfigureAwait(false);
                                string strAltRange = await objWeapon.GetCurrentDisplayAlternateRangeAsync(token).ConfigureAwait(false);
                                await lblWeaponRangeMain
                                      .DoThreadSafeAsync(x => x.Text = strRange, token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeAlternate
                                      .DoThreadSafeAsync(x => x.Text = strAltRange, token)
                                      .ConfigureAwait(false);
                                Dictionary<string, string> dicRanges
                                    = await objWeapon.GetRangeStringsAsync(GlobalSettings.CultureInfo, token: token)
                                                     .ConfigureAwait(false);
                                string strModifierShort = await objWeapon.RangeModifierAsync("Short", token).ConfigureAwait(false);
                                string strModifierMedium = await objWeapon.RangeModifierAsync("Medium", token).ConfigureAwait(false);
                                string strModifierLong = await objWeapon.RangeModifierAsync("Long", token).ConfigureAwait(false);
                                string strModifierExtreme = await objWeapon.RangeModifierAsync("Extreme", token).ConfigureAwait(false);
                                await lblWeaponRangeShortLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierShort, token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeMediumLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierMedium, token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeLongLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierLong, token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeExtremeLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierExtreme, token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeShort
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["short"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeMedium
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["medium"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeLong
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["long"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponRangeExtreme
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["extreme"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponAlternateRangeShort
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternateshort"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponAlternateRangeMedium
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternatemedium"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponAlternateRangeLong
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternatelong"], token)
                                      .ConfigureAwait(false);
                                await lblWeaponAlternateRangeExtreme
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternateextreme"], token)
                                      .ConfigureAwait(false);
                            }
                            else
                            {
                                await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                         .ConfigureAwait(false);
                                string strReach
                                    = (await objWeapon.GetTotalReachAsync(token).ConfigureAwait(false)).ToString(
                                        GlobalSettings.CultureInfo);
                                await lblWeaponReach.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strReach;
                                }, token).ConfigureAwait(false);
                                await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                                await lblWeaponRC.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                                if (objWeapon.Ammo != "0")
                                {
                                    await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                                    string strAmmo = await objWeapon.GetDisplayAmmoAsync(token).ConfigureAwait(false);
                                    await lblWeaponAmmo.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strAmmo;
                                    }, token).ConfigureAwait(false);
                                }
                                else
                                {
                                    await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                    await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                                }

                                await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                                await lblWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                                await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            }

                            // gpbWeaponsMatrix
                            int intDeviceRating = await objWeapon.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            int intAttack = await objWeapon.GetTotalMatrixAttributeAsync("Attack", token).ConfigureAwait(false);
                            int intSleaze = await objWeapon.GetTotalMatrixAttributeAsync("Sleaze", token).ConfigureAwait(false);
                            int intDP = await objWeapon.GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false);
                            int intFirewall = await objWeapon.GetTotalMatrixAttributeAsync("Firewall", token).ConfigureAwait(false);
                            await lblWeaponDeviceRating
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await lblWeaponAttack.DoThreadSafeAsync(x => x.Text = intAttack
                                                                        .ToString(GlobalSettings.CultureInfo), token)
                                                 .ConfigureAwait(false);
                            await lblWeaponSleaze.DoThreadSafeAsync(x => x.Text = intSleaze
                                                                        .ToString(GlobalSettings.CultureInfo), token)
                                                 .ConfigureAwait(false);
                            await lblWeaponDataProcessing.DoThreadSafeAsync(
                                                             x => x.Text = intDP
                                                                           .ToString(GlobalSettings.CultureInfo), token)
                                                         .ConfigureAwait(false);
                            await lblWeaponFirewall.DoThreadSafeAsync(x => x.Text = intFirewall
                                                                          .ToString(GlobalSettings.CultureInfo), token)
                                                   .ConfigureAwait(false);
                            bool blnIsActiveCommlink = await objWeapon.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objWeapon.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objWeapon.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objWeapon.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkWeaponHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkWeaponHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkWeaponActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                            token.ThrowIfCancellationRequested();
                            break;
                        }
                        case WeaponAccessory objSelectedAccessory:
                        {
                            await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled
                                                                        = !objSelectedAccessory.IncludedInWeapon &&
                                                                          string.IsNullOrEmpty(
                                                                              objSelectedAccessory.ParentID), token)
                                                 .ConfigureAwait(false);
                            // gpbWeaponsCommon
                            string strName = await objSelectedAccessory.GetCurrentDisplayNameAsync(token)
                                                                       .ConfigureAwait(false);
                            await lblWeaponName
                                  .DoThreadSafeAsync(x => x.Text = strName, token)
                                  .ConfigureAwait(false);
                            string strText = await LanguageManager
                                                   .GetStringAsync("String_WeaponAccessory", token: token)
                                                   .ConfigureAwait(false);
                            await lblWeaponCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                   .ConfigureAwait(false);
                            int intRating = await objSelectedAccessory.GetRatingAsync(token).ConfigureAwait(false);
                            if (intRating > 0)
                            {
                                int intMaxRating = await objSelectedAccessory.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                                await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                    .ConfigureAwait(false);
                                await nudWeaponRating.DoThreadSafeAsync(x =>
                                {
                                    x.Maximum = intMaxRating;
                                    x.Minimum = Math.Min(1, intMaxRating);
                                    x.Visible = true;
                                    x.Value = intRating;
                                    x.Increment = 1;
                                    x.Enabled = intMaxRating > 1 && !objSelectedAccessory.IncludedInWeapon;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                                await nudWeaponRating.DoThreadSafeAsync(x =>
                                {
                                    x.Minimum = 0;
                                    x.Increment = 1;
                                    x.Maximum = 0;
                                    x.Enabled = false;
                                    x.Visible = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await lblWeaponCapacity.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            string strAvail = await objSelectedAccessory.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblWeaponAvail
                                  .DoThreadSafeAsync(x => x.Text = strAvail, token)
                                  .ConfigureAwait(false);
                            string strCost = (await objSelectedAccessory.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblWeaponCost.DoThreadSafeAsync(x => x.Text = strCost, token).ConfigureAwait(false);
                            await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                     .ConfigureAwait(false);
                            string strSlotsText;
                            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                          out StringBuilder sbdSlotsText))
                            {
                                sbdSlotsText.Append(await objSelectedAccessory.DisplayMountAsync(GlobalSettings.Language, token).ConfigureAwait(false));

                                token.ThrowIfCancellationRequested();
                                if (!string.IsNullOrEmpty(objSelectedAccessory.ExtraMount)
                                    && objSelectedAccessory.ExtraMount != "None")
                                {
                                    bool boolHaveAddedItem = false;
                                    foreach (string strCurrentExtraMount in
                                             objSelectedAccessory.ExtraMount.SplitNoAlloc(
                                                 '/', StringSplitOptions.RemoveEmptyEntries))
                                    {
                                        if (!boolHaveAddedItem)
                                        {
                                            sbdSlotsText.Append(strSpace, '+', strSpace);
                                            boolHaveAddedItem = true;
                                        }

                                        sbdSlotsText
                                            .Append(await LanguageManager.GetStringAsync(
                                                                             "String_Mount" + strCurrentExtraMount,
                                                                             token: token)
                                                                         .ConfigureAwait(false), '/');
                                    }

                                    // Remove the trailing /
                                    if (boolHaveAddedItem)
                                        --sbdSlotsText.Length;
                                }

                                if (!string.IsNullOrEmpty(objSelectedAccessory.AddMount))
                                {
                                    sbdSlotsText.Append(strSpace, "(++", strSpace).Append(await LanguageManager.GetStringAsync(
                                                                                "String_Mount" + objSelectedAccessory.AddMount,
                                                                                token: token)
                                                                            .ConfigureAwait(false), ')');
                                }

                                strSlotsText = sbdSlotsText.ToString();
                            }
                            await lblWeaponSlots.DoThreadSafeAsync(x =>
                            {
                                x.Text = strSlotsText;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);

                            decimal decConceal = await objSelectedAccessory.GetTotalConcealabilityAsync(token).ConfigureAwait(false);
                            await lblWeaponConcealLabel
                                  .DoThreadSafeAsync(x => x.Visible = decConceal != 0,
                                                     token).ConfigureAwait(false);
                            await lblWeaponConceal.DoThreadSafeAsync(x =>
                            {
                                x.Visible = decConceal != 0;
                                x.Text
                                    = decConceal.ToString(
                                        "+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                            }, token).ConfigureAwait(false);
                            string strText2 = await LanguageManager.GetStringAsync(objSelectedAccessory.Parent == null
                                ? "Checkbox_Equipped"
                                : "Checkbox_Installed", token: token).ConfigureAwait(false);
                            await chkWeaponEquipped.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText2;
                                x.Enabled = !objSelectedAccessory.IncludedInWeapon;
                                x.Checked = objSelectedAccessory.Equipped;
                            }, token).ConfigureAwait(false);
                            await chkIncludedInWeapon.DoThreadSafeAsync(x =>
                            {
                                x.Visible = objSelectedAccessory.Parent != null;
                                x.Enabled = CharacterObjectSettings.AllowEditPartOfBaseWeapon;
                                x.Checked = objSelectedAccessory.IncludedInWeapon;
                            }, token).ConfigureAwait(false);
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = !objSelectedAccessory.IncludedInWeapon
                                                  && (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                      (await CharacterObject
                                                          .LoadDataXPathAsync("weapons.xml", token: token)
                                                          .ConfigureAwait(false))
                                                      .SelectSingleNodeAndCacheExpression(
                                                          "/chummer", token: token),
                                                      token).ConfigureAwait(false))
                                                     .Contains(objSelectedAccessory.Parent?.Category);
                                await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objSelectedAccessory.IncludedInWeapon
                                        ? objSelectedAccessory.Parent?.DiscountCost == true
                                        : objSelectedAccessory.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            // gpbWeaponsWeapon
                            string strText3 = await LanguageManager
                                                    .GetStringAsync("String_WeaponAccessory", token: token)
                                                    .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Text = strText3, token)
                                                  .ConfigureAwait(false);
                            if (string.IsNullOrEmpty(objSelectedAccessory.Damage))
                            {
                                await lblWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblWeaponDamage.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            }
                            else
                            {
                                string strDamageText = (await objSelectedAccessory.GetTotalDamageAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                                await lblWeaponDamage.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strDamageText;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            if (string.IsNullOrEmpty(objSelectedAccessory.AP))
                            {
                                await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                                await lblWeaponAP.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                            }
                            else
                            {
                                string strAPText = (await objSelectedAccessory.GetTotalAPAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                                await lblWeaponAP.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strAPText;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            if (string.IsNullOrEmpty(objSelectedAccessory.Accuracy))
                            {
                                await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                await lblWeaponAccuracy.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            }
                            else
                            {
                                string strAccuracyText = (await objSelectedAccessory.GetTotalAccuracyAsync(token).ConfigureAwait(false))
                                    .ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                await lblWeaponAccuracy.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strAccuracyText;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            decimal decDicePool = await objSelectedAccessory.GetDicePoolAsync(token).ConfigureAwait(false);
                            if (objSelectedAccessory.DicePool == 0)
                            {
                                await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                await lblWeaponDicePool.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            }
                            else
                            {
                                await lblWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                                await lblWeaponDicePool.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text
                                        = decDicePool.ToString(
                                            "+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            await lblWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                            if (string.IsNullOrEmpty(objSelectedAccessory.RC))
                            {
                                await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                                await lblWeaponRC.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                            }
                            else
                            {
                                string strRCText = (await objSelectedAccessory.GetTotalRCAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                                await lblWeaponRC.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strRCText;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            decimal decAmmoBonus = await objSelectedAccessory.GetTotalAmmoBonusAsync(token).ConfigureAwait(false);
                            if (decAmmoBonus != 0
                                || (!string.IsNullOrEmpty(objSelectedAccessory.ModifyAmmoCapacity)
                                    && objSelectedAccessory.ModifyAmmoCapacity != "0"))
                            {
                                await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdAmmoBonus))
                                {
                                    if (decAmmoBonus != 0)
                                        sbdAmmoBonus.Append(
                                            (decAmmoBonus / 100.0m).ToString(
                                                "+#,0.##%;-#,0.##%;0.##%", GlobalSettings.CultureInfo));
                                    if (!string.IsNullOrEmpty(objSelectedAccessory.ModifyAmmoCapacity)
                                        && objSelectedAccessory.ModifyAmmoCapacity != "0")
                                        sbdAmmoBonus.Append(objSelectedAccessory.ModifyAmmoCapacity);
                                    await lblWeaponAmmo.DoThreadSafeAsync(x => x.Text = sbdAmmoBonus.ToString(), token)
                                                       .ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                await lblWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                                await lblWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await lblWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            await tlpWeaponsRanges.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            break;
                        }
                        case Gear objGear:
                        {
                            await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token)
                                                 .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbWeaponsCommon
                            string strName = await objGear.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false);
                            await lblWeaponName.DoThreadSafeAsync(x => x.Text = strName, token)
                                               .ConfigureAwait(false);
                            string strCategory = await objGear.GetCurrentDisplayCategoryAsync(token).ConfigureAwait(false);
                            await lblWeaponCategory
                                  .DoThreadSafeAsync(x => x.Text = strCategory, token).ConfigureAwait(false);
                            int intGearMaxRatingValue = await objGear.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                            if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                            {
                                await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                    .ConfigureAwait(false);
                                int intGearMinRatingValue = await objGear.GetMinRatingValueAsync(token).ConfigureAwait(false);
                                int intRating = await objGear.GetRatingAsync(token).ConfigureAwait(false);
                                await nudWeaponRating.DoThreadSafeAsync(x =>
                                {
                                    x.Minimum = intGearMinRatingValue;
                                    x.Maximum = intGearMaxRatingValue;
                                    x.Value = intRating;
                                    x.Increment = 1;
                                    x.Enabled = x.Maximum > x.Minimum && !objGear.IncludedInParent;
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblWeaponRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                                await nudWeaponRating.DoThreadSafeAsync(x =>
                                {
                                    x.Minimum = 0;
                                    x.Increment = 1;
                                    x.Maximum = 0;
                                    x.Enabled = false;
                                    x.Visible = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblWeaponCapacityLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                            string strCapacity = await objGear.GetDisplayCapacityAsync(token).ConfigureAwait(false);
                            await lblWeaponCapacity.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strCapacity;
                            }, token).ConfigureAwait(false);
                            string strAvail = await objGear.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblWeaponAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                .ConfigureAwait(false);
                            string strCost = (await objGear.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                                    .ConfigureAwait(false);
                            await lblWeaponCost.DoThreadSafeAsync(x => x.Text = strCost, token).ConfigureAwait(false);
                            await lblWeaponSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            await lblWeaponSlots.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                            await lblWeaponConcealLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            await lblWeaponConceal.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            string strText = await LanguageManager.GetStringAsync(
                                "Checkbox_Equipped", token: token).ConfigureAwait(false);
                            await chkWeaponEquipped.DoThreadSafeAsync(x =>
                            {
                                x.Text = strText;
                                x.Checked = objGear.Equipped;
                                x.Enabled = objGear.CanChangeEquip;
                            }, token).ConfigureAwait(false);
                            await chkIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = !objGear.IncludedInParent &&
                                                  (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                      (await CharacterObject
                                                          .LoadDataXPathAsync(
                                                              "gear.xml", token: token)
                                                          .ConfigureAwait(false))
                                                      .SelectSingleNodeAndCacheExpression(
                                                          "/chummer", token: token), token).ConfigureAwait(false))
                                                                               .Contains(objGear.Category);
                                await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objGear.IncludedInParent
                                        ? (objGear.Parent as ICanBlackMarketDiscount)?.DiscountCost == true
                                        : objGear.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkWeaponBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            // gpbWeaponsMatrix
                            int intDeviceRating = await objGear.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            int intAttack = await objGear.GetTotalMatrixAttributeAsync("Attack", token).ConfigureAwait(false);
                            int intSleaze = await objGear.GetTotalMatrixAttributeAsync("Sleaze", token).ConfigureAwait(false);
                            int intDP = await objGear.GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false);
                            int intFirewall = await objGear.GetTotalMatrixAttributeAsync("Firewall", token).ConfigureAwait(false);
                            await lblWeaponDeviceRating
                                .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                    token).ConfigureAwait(false);
                            await lblWeaponAttack.DoThreadSafeAsync(x => x.Text = intAttack
                                    .ToString(GlobalSettings.CultureInfo), token)
                                .ConfigureAwait(false);
                            await lblWeaponSleaze.DoThreadSafeAsync(x => x.Text = intSleaze
                                    .ToString(GlobalSettings.CultureInfo), token)
                                .ConfigureAwait(false);
                            await lblWeaponDataProcessing.DoThreadSafeAsync(
                                    x => x.Text = intDP
                                        .ToString(GlobalSettings.CultureInfo), token)
                                .ConfigureAwait(false);
                            await lblWeaponFirewall.DoThreadSafeAsync(x => x.Text = intFirewall
                                    .ToString(GlobalSettings.CultureInfo), token)
                                .ConfigureAwait(false);
                            bool blnIsActiveCommlink = await objGear.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objGear.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objGear.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objGear.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkWeaponHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkWeaponHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkWeaponActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                                break;
                        }
                        default:
                            await gpbWeaponsCommon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await gpbWeaponsMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteWeapon.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                 .ConfigureAwait(false);
                            break;
                    }
                }
                finally
                {
                    await flpWeapons.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Armor.
        /// </summary>
        private async Task RefreshSelectedArmor(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpArmor.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    TreeNode objSelectedNode = await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                             .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag == null)
                    {
                        await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        // Buttons
                        await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token).ConfigureAwait(false);
                        return;
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasSource objSelected)
                    {
                        await lblArmorSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await lblArmorSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await objSelected.SetSourceDetailAsync(lblArmorSource, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await lblArmorSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                        await lblArmorSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasStolenProperty loot && (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                CharacterObject,
                                Improvement.ImprovementType.Nuyen, "Stolen", token: token).ConfigureAwait(false)).Count
                        > 0)
                    {
                        await chkArmorStolen.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = loot.Stolen;
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await chkArmorStolen.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasRating objHasRating)
                    {
                        string strText = string.Format(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Label_RatingFormat", token: token).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync(
                                objHasRating.RatingLabel, token: token).ConfigureAwait(false));
                        await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is Armor objArmor)
                    {
                        await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        // gpbArmorCommon
                        await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        string strArmorValue = await objArmor.GetDisplayArmorValueAsync(token).ConfigureAwait(false);
                        await lblArmorValue.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Text = strArmorValue;
                        }, token).ConfigureAwait(false);
                        string strAvail = await objArmor.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                        await lblArmorAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                           .ConfigureAwait(false);
                        string strCapacity = await objArmor.GetDisplayCapacityAsync(token).ConfigureAwait(false);
                        await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token)
                                              .ConfigureAwait(false);
                        await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                        await nudArmorRating.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        string strCost = (await objArmor.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                             await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                             GlobalSettings.CultureInfo)
                                         + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                        await lblArmorCost.DoThreadSafeAsync(x => x.Text = strCost, token).ConfigureAwait(false);
                        await chkArmorEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objArmor.Equipped;
                            x.Enabled = true;
                        }, token).ConfigureAwait(false);
                        await chkIncludedInArmor.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                        {
                            bool blnEnabled = (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                    (await CharacterObject.LoadDataXPathAsync(
                                        "armor.xml", token: token).ConfigureAwait(false))
                                    .SelectSingleNodeAndCacheExpression(
                                        "/chummer", token: token), token).ConfigureAwait(false))
                                              .Contains(objArmor.Category);
                            await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objArmor.DiscountCost;
                            }, token).ConfigureAwait(false);
                        }
                        else
                        {
                            await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token).ConfigureAwait(false);
                        }

                        token.ThrowIfCancellationRequested();
                        // gpbArmorMatrix
                        int intDeviceRating = await objArmor.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                        int intAttack = await objArmor.GetTotalMatrixAttributeAsync("Attack", token).ConfigureAwait(false);
                        int intSleaze = await objArmor.GetTotalMatrixAttributeAsync("Sleaze", token).ConfigureAwait(false);
                        int intDP = await objArmor.GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false);
                        int intFirewall = await objArmor.GetTotalMatrixAttributeAsync("Firewall", token).ConfigureAwait(false);
                        await lblArmorDeviceRating
                              .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                 token).ConfigureAwait(false);
                        await lblArmorAttack.DoThreadSafeAsync(x => x.Text
                                                                   = intAttack
                                                                             .ToString(GlobalSettings.CultureInfo),
                                                               token).ConfigureAwait(false);
                        await lblArmorSleaze.DoThreadSafeAsync(x => x.Text
                                                                   = intSleaze
                                                                             .ToString(GlobalSettings.CultureInfo),
                                                               token).ConfigureAwait(false);
                        await lblArmorDataProcessing.DoThreadSafeAsync(x => x.Text = intDP
                                                                           .ToString(GlobalSettings.CultureInfo), token)
                                                    .ConfigureAwait(false);
                        await lblArmorFirewall.DoThreadSafeAsync(x => x.Text = intFirewall
                                                                               .ToString(GlobalSettings.CultureInfo),
                                                                 token).ConfigureAwait(false);
                        bool blnIsActiveCommlink = await objArmor.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                        bool blnIsCommlink = await objArmor.GetIsCommlinkAsync(token).ConfigureAwait(false);
                        if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                        {
                            bool blnIsHomeNode = await objArmor.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnCanBeHomeNode = blnIsCommlink &&
                                                    await objArmor.GetTotalMatrixAttributeAsync(
                                                        "Program Limit", token).ConfigureAwait(false) >=
                                                    (await (await CharacterObject.GetAttributeAsync("DEP",
                                                        token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                        ? 2
                                                        : 1);
                            await chkArmorHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = blnIsHomeNode;
                                x.Enabled = blnCanBeHomeNode;
                            }, token).ConfigureAwait(false);
                        }
                        else
                            await chkArmorHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                .ConfigureAwait(false);

                        token.ThrowIfCancellationRequested();
                        await chkArmorActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Checked = blnIsActiveCommlink;
                            x.Visible = blnIsCommlink;
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token)
                                                               .ConfigureAwait(false);
                        if (objSelectedNodeTag is ArmorMod objArmorMod)
                        {
                            await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                            await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                            await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = !objArmorMod.IncludedInArmor, token)
                                                .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbArmorCommon
                            if (objArmorMod.Armor != 0)
                            {
                                await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                await lblArmorValue.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = objArmorMod.Armor.ToString("+0;-0;0", GlobalSettings.CultureInfo);
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                                await lblArmorValue.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            }

                            string strAvail = await objArmorMod.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblArmorAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                               .ConfigureAwait(false);
                            string strCapacity = objArmorMod.Parent.CapacityDisplayStyle == CapacityStyle.Zero
                                ? "[0]"
                                : await objArmorMod.GetCalculatedCapacityAsync(token).ConfigureAwait(false);
                            await lblArmorCapacity.DoThreadSafeAsync(
                                x => x.Text = strCapacity, token).ConfigureAwait(false);
                            if (!string.IsNullOrEmpty(objArmorMod.GearCapacity))
                            {
                                string strText = objArmorMod.GearCapacity + "/" + strCapacity + strSpace + "(" +
                                                 (await objArmorMod.GetGearCapacityRemainingAsync(token).ConfigureAwait(false)).ToString(
                                                     "#,0.##", GlobalSettings.CultureInfo) + strSpace +
                                                 await LanguageManager.GetStringAsync("String_Remaining", token: token)
                                                     .ConfigureAwait(false) + ")";
                                await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = strText, token)
                                                      .ConfigureAwait(false);
                            }

                            int intRating = await objArmorMod.GetRatingAsync(token).ConfigureAwait(false);
                            if (intRating > 1)
                            {
                                int intMaxRating = await objArmorMod.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                                await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                         .ConfigureAwait(false);
                                await nudArmorRating.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Maximum = intMaxRating;
                                    x.Value = intRating;
                                    x.Enabled = !objArmorMod.IncludedInArmor;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                         .ConfigureAwait(false);
                                await nudArmorRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            string strCost = (await objArmorMod.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblArmorCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                              .ConfigureAwait(false);
                            await chkArmorEquipped.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objArmorMod.Equipped;
                                x.Enabled = !objArmorMod.IncludedInArmor;
                            }, token).ConfigureAwait(false);
                            await chkIncludedInArmor.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objArmorMod.IncludedInArmor;
                            }, token).ConfigureAwait(false);
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = !objArmorMod.IncludedInArmor &&
                                                  (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                      (await CharacterObject
                                                          .LoadDataXPathAsync(
                                                              "armor.xml", token: token).ConfigureAwait(false))
                                                      .SelectSingleNodeAndCacheExpression(
                                                          "/chummer/modcategories", token: token), token).ConfigureAwait(false))
                                    .Contains(objArmorMod.Category);
                                await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objArmorMod.IncludedInArmor
                                        ? objArmorMod.Parent?.DiscountCost == true
                                        : objArmorMod.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }
                        }
                        else
                        {
                            switch (objSelectedNodeTag)
                            {
                                case Gear objSelectedGear:
                                {
                                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                    await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                    token.ThrowIfCancellationRequested();
                                    // Buttons
                                    await cmdDeleteArmor
                                          .DoThreadSafeAsync(x => x.Enabled = !objSelectedGear.IncludedInParent, token)
                                          .ConfigureAwait(false);
                                    token.ThrowIfCancellationRequested();
                                    // gpbArmorCommon
                                    await lblArmorValueLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                    await lblArmorValue.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                                    string strAvail = await objSelectedGear.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                                    await lblArmorAvail
                                          .DoThreadSafeAsync(x => x.Text = strAvail, token)
                                          .ConfigureAwait(false);
                                    (_, objArmor, objArmorMod) = await CharacterObject.Armor.FindArmorGearAsync(objSelectedGear.InternalId, token).ConfigureAwait(false);
                                    if (objArmorMod != null)
                                    {
                                        string strCapacity = await objSelectedGear.GetCalculatedCapacityAsync(token).ConfigureAwait(false);
                                        await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token).ConfigureAwait(false);
                                    }
                                    else if (objArmor.CapacityDisplayStyle == CapacityStyle.Zero)
                                    {
                                        await lblArmorCapacity
                                            .DoThreadSafeAsync(
                                                x => x.Text = "[" + 0.ToString(GlobalSettings.CultureInfo) + "]",
                                                token).ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        string strCapacity = await objSelectedGear.GetCalculatedArmorCapacityAsync(token).ConfigureAwait(false);
                                        await lblArmorCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token).ConfigureAwait(false);
                                    }
                                    int intMaxRatingValue = await objSelectedGear.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                                    if (intMaxRatingValue > 1 && intMaxRatingValue != int.MaxValue)
                                    {
                                        await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                 .ConfigureAwait(false);
                                        int intMinRatingValue = await objSelectedGear.GetMinRatingValueAsync(token).ConfigureAwait(false);
                                        int intRating = await objSelectedGear.GetRatingAsync(token).ConfigureAwait(false);
                                        await nudArmorRating.DoThreadSafeAsync(x =>
                                        {
                                            x.Visible = true;
                                            x.Maximum = intMaxRatingValue;
                                            x.Minimum = intMinRatingValue;
                                            x.Value = intRating;
                                            x.Enabled = intMinRatingValue != intMaxRatingValue
                                                        && string.IsNullOrEmpty(objSelectedGear.ParentID);
                                        }, token).ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        await lblArmorRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                 .ConfigureAwait(false);
                                        await nudArmorRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                    }

                                    string strCost = (await objSelectedGear.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                         await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                         GlobalSettings.CultureInfo)
                                                     + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                                            .ConfigureAwait(false);

                                    await lblArmorCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                      .ConfigureAwait(false);
                                    await chkArmorEquipped.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Checked = objSelectedGear.Equipped;
                                        x.Enabled = objSelectedGear.CanChangeEquip;
                                    }, token).ConfigureAwait(false);
                                    await chkIncludedInArmor.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Checked = objSelectedGear.IncludedInParent;
                                    }, token).ConfigureAwait(false);
                                    if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                                    {
                                        bool blnEnabled = !objSelectedGear.IncludedInParent
                                                          && (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                              (await CharacterObject
                                                                  .LoadDataXPathAsync(
                                                                      "gear.xml", token: token)
                                                                  .ConfigureAwait(false))
                                                              .SelectSingleNodeAndCacheExpression(
                                                                  "/chummer", token: token), token).ConfigureAwait(false))
                                                             .Contains(objSelectedGear.Category);
                                        await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                                        {
                                            x.Enabled = blnEnabled;
                                            x.Checked = objSelectedGear.IncludedInParent
                                                ? (objSelectedGear.Parent as ICanBlackMarketDiscount)?.DiscountCost
                                                  == true
                                                : objSelectedGear.DiscountCost;
                                        }, token).ConfigureAwait(false);
                                    }
                                    else
                                    {
                                        await chkArmorBlackMarketDiscount.DoThreadSafeAsync(x =>
                                        {
                                            x.Enabled = false;
                                            x.Checked = false;
                                        }, token).ConfigureAwait(false);
                                    }

                                    token.ThrowIfCancellationRequested();
                                    // gpbArmorMatrix
                                    int intDeviceRating = await objSelectedGear.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                                    int intAttack = await objSelectedGear
                                        .GetTotalMatrixAttributeAsync("Attack", token).ConfigureAwait(false);
                                    int intSleaze = await objSelectedGear
                                        .GetTotalMatrixAttributeAsync("Sleaze", token).ConfigureAwait(false);
                                    int intDP = await objSelectedGear
                                        .GetTotalMatrixAttributeAsync("Data Processing", token).ConfigureAwait(false);
                                    int intFirewall = await objSelectedGear
                                        .GetTotalMatrixAttributeAsync("Firewall", token).ConfigureAwait(false);
                                        await lblArmorDeviceRating
                                          .DoThreadSafeAsync(
                                              x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo), token)
                                          .ConfigureAwait(false);
                                    await lblArmorAttack.DoThreadSafeAsync(
                                                            x => x.Text = intAttack.ToString(GlobalSettings.CultureInfo), token)
                                                        .ConfigureAwait(false);
                                    await lblArmorSleaze.DoThreadSafeAsync(
                                                            x => x.Text = intSleaze
                                                                          .ToString(GlobalSettings.CultureInfo), token)
                                                        .ConfigureAwait(false);
                                    await lblArmorDataProcessing.DoThreadSafeAsync(
                                                                    x => x.Text = intDP
                                                                        .ToString(GlobalSettings.CultureInfo), token)
                                                                .ConfigureAwait(false);
                                    await lblArmorFirewall.DoThreadSafeAsync(
                                                              x => x.Text = intFirewall
                                                                            .ToString(GlobalSettings.CultureInfo),
                                                              token)
                                                          .ConfigureAwait(false);
                                    bool blnIsActiveCommlink = await objSelectedGear.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                                    bool blnIsCommlink = await objSelectedGear.GetIsCommlinkAsync(token).ConfigureAwait(false);
                                    if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                                    {
                                        bool blnIsHomeNode = await objSelectedGear.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                        bool blnCanBeHomeNode = blnIsCommlink &&
                                                                await objSelectedGear.GetTotalMatrixAttributeAsync(
                                                                    "Program Limit", token).ConfigureAwait(false) >=
                                                                (await (await CharacterObject.GetAttributeAsync("DEP",
                                                                    token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                                    ? 2
                                                                    : 1);
                                        await chkArmorHomeNode.DoThreadSafeAsync(x =>
                                        {
                                            x.Visible = true;
                                            x.Checked = blnIsHomeNode;
                                            x.Enabled = blnCanBeHomeNode;
                                        }, token).ConfigureAwait(false);
                                    }
                                    else
                                        await chkArmorHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                            .ConfigureAwait(false);

                                    token.ThrowIfCancellationRequested();
                                    await chkArmorActiveCommlink.DoThreadSafeAsync(x =>
                                    {
                                        x.Checked = blnIsActiveCommlink;
                                        x.Visible = blnIsCommlink;
                                    }, token).ConfigureAwait(false);

                                    token.ThrowIfCancellationRequested();
                                    break;
                                }
                                case Location objLocation:
                                {
                                    await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                                    await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                                    await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                    token.ThrowIfCancellationRequested();
                                    // Buttons
                                    await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = true, token)
                                                        .ConfigureAwait(false);
                                    token.ThrowIfCancellationRequested();
                                    // gpbArmorLocation
                                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                               out StringBuilder sbdArmorEquipped))
                                    {
                                        await CharacterObject.Armor.ForEachAsync(async objLoopArmor =>
                                        {
                                            if (objLoopArmor.Equipped && objLoopArmor.Location == objLocation)
                                            {
                                                sbdArmorEquipped
                                                    .Append(await objLoopArmor.GetCurrentDisplayNameAsync(token)
                                                                              .ConfigureAwait(false), strSpace)
                                                    .Append('(', await objLoopArmor.GetDisplayArmorValueAsync(token).ConfigureAwait(false))
                                                    .AppendLine(')');
                                            }
                                        }, token).ConfigureAwait(false);

                                        token.ThrowIfCancellationRequested();
                                        if (sbdArmorEquipped.Length > 0)
                                        {
                                            --sbdArmorEquipped.Length;
                                            await lblArmorEquipped
                                                  .DoThreadSafeAsync(x => x.Text = sbdArmorEquipped.ToString(), token)
                                                  .ConfigureAwait(false);
                                        }
                                        else
                                        {
                                            string strNone = await LanguageManager
                                                                   .GetStringAsync("String_None", token: token)
                                                                   .ConfigureAwait(false);
                                            await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = strNone, token)
                                                                  .ConfigureAwait(false);
                                        }
                                    }

                                    token.ThrowIfCancellationRequested();
                                    break;
                                }
                                default:
                                {
                                    if (objSelectedNodeTag.ToString() == "Node_SelectedArmor")
                                    {
                                        await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                        await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                        await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = true, token)
                                                              .ConfigureAwait(false);
                                        // Buttons
                                        await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                            .ConfigureAwait(false);
                                        using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                   out StringBuilder sbdArmorEquipped))
                                        {
                                            await CharacterObject.Armor.ForEachAsync(async objLoopArmor =>
                                            {
                                                if (objLoopArmor.Equipped && objLoopArmor.Location == null)
                                                {
                                                    sbdArmorEquipped
                                                        .Append(await objLoopArmor.GetCurrentDisplayNameAsync(token)
                                                                    .ConfigureAwait(false), strSpace)
                                                        .Append('(', await objLoopArmor.GetDisplayArmorValueAsync(token).ConfigureAwait(false))
                                                        .AppendLine(')');
                                                }
                                            }, token).ConfigureAwait(false);

                                            if (sbdArmorEquipped.Length > 0)
                                            {
                                                --sbdArmorEquipped.Length;
                                                await lblArmorEquipped
                                                      .DoThreadSafeAsync(
                                                          x => x.Text = sbdArmorEquipped.ToString(), token)
                                                      .ConfigureAwait(false);
                                            }
                                            else
                                            {
                                                string strNone = await LanguageManager
                                                                       .GetStringAsync("String_None", token: token)
                                                                       .ConfigureAwait(false);
                                                await lblArmorEquipped.DoThreadSafeAsync(x => x.Text = strNone, token)
                                                                      .ConfigureAwait(false);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        await gpbArmorCommon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                        await gpbArmorMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                        await gpbArmorLocation.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                                        // Buttons
                                        await cmdDeleteArmor.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                            .ConfigureAwait(false);
                                    }

                                    break;
                                }
                            }
                        }
                    }
                }
                finally
                {
                    await flpArmor.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently displayed Gear.
        /// </summary>
        private async Task RefreshSelectedGear(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpGear.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    TreeNode objSelectedNode = await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                            .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag == null || objSelectedNode.Level == 0)
                    {
                        await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        token.ThrowIfCancellationRequested();
                        // Buttons
                        await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                                           .ConfigureAwait(false);
                        return;
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasStolenProperty loot && (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                CharacterObject,
                                Improvement.ImprovementType.Nuyen, "Stolen", token: token).ConfigureAwait(false))
                        .Count > 0)
                    {
                        await chkGearStolen.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = loot.Stolen;
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await chkGearStolen.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasSource objSelected)
                    {
                        await lblGearSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await lblGearSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await objSelected.SetSourceDetailAsync(lblGearSource, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await lblGearSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await lblGearSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is IHasRating objHasRating)
                    {
                        string strText = string.Format(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Label_RatingFormat", token: token).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync(
                                objHasRating.RatingLabel, token: token).ConfigureAwait(false));
                        await lblGearRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                    if (objSelectedNodeTag is Gear objGear)
                    {
                        await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);

                        // Buttons
                        await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token)
                                           .ConfigureAwait(false);

                        // gpbGearCommon
                        string strName = await objGear.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false);
                        await lblGearName.DoThreadSafeAsync(x => x.Text = strName, token)
                                         .ConfigureAwait(false);
                        string strCategory = await objGear.GetCurrentDisplayCategoryAsync(token).ConfigureAwait(false);
                        await lblGearCategory
                              .DoThreadSafeAsync(x => x.Text = strCategory, token)
                              .ConfigureAwait(false);
                        int intGearMaxRatingValue = await objGear.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                        if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                        {
                            int intGearMinRatingValue = await objGear.GetMinRatingValueAsync(token).ConfigureAwait(false);
                            int intRating = await objGear.GetRatingAsync(token).ConfigureAwait(false);
                            await nudGearRating.DoThreadSafeAsync(x =>
                            {
                                x.Minimum = intGearMinRatingValue;
                                x.Maximum = intGearMaxRatingValue;
                                x.Value = intRating;
                                x.Enabled = x.Maximum > x.Minimum && string.IsNullOrEmpty(objGear.ParentID);
                            }, token).ConfigureAwait(false);
                        }
                        else
                        {
                            await nudGearRating.DoThreadSafeAsync(x =>
                            {
                                x.Minimum = 0;
                                x.Maximum = 0;
                                x.Enabled = false;
                            }, token).ConfigureAwait(false);
                        }

                        await nudGearQty.DoThreadSafeAsync(x => x.Increment = objGear.CostFor, token)
                                        .ConfigureAwait(false);
                        if (objGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
                        {
                            int intDecimalPlaces = await CharacterObjectSettings.GetMaxNuyenDecimalsAsync(token).ConfigureAwait(false);
                            if (intDecimalPlaces <= 0)
                            {
                                await nudGearQty.DoThreadSafeAsync(x =>
                                {
                                    x.DecimalPlaces = 0;
                                    x.Minimum = 1.0m;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await nudGearQty.DoThreadSafeAsync(x => x.DecimalPlaces = intDecimalPlaces, token)
                                                .ConfigureAwait(false);
                                decimal decMinimum = 1.0m;
                                // Need a for loop instead of a power system to maintain exact precision
                                for (int i = 0; i < intDecimalPlaces; ++i)
                                    decMinimum /= 10.0m;
                                await nudGearQty.DoThreadSafeAsync(x => x.Minimum = decMinimum, token)
                                                .ConfigureAwait(false);
                            }
                        }
                        else if (objGear.Category == "Currency")
                        {
                            await nudGearQty.DoThreadSafeAsync(x =>
                            {
                                x.DecimalPlaces = 2;
                                x.Minimum = 0.01m;
                            }, token).ConfigureAwait(false);
                        }
                        else
                        {
                            await nudGearQty.DoThreadSafeAsync(x =>
                            {
                                x.DecimalPlaces = 0;
                                x.Minimum = 1.0m;
                            }, token).ConfigureAwait(false);
                        }

                        await nudGearQty.DoThreadSafeAsync(x =>
                        {
                            x.Value = objGear.Quantity;
                            x.Enabled = !objGear.IncludedInParent;
                        }, token).ConfigureAwait(false);

                        string strCost;
                        try
                        {
                            strCost = (await objGear.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                          await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                          GlobalSettings.CultureInfo)
                                      + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                             .ConfigureAwait(false);
                        }
                        catch (FormatException)
                        {
                            strCost = objGear.Cost + await LanguageManager
                                                           .GetStringAsync("String_NuyenSymbol", token: token)
                                                           .ConfigureAwait(false);
                        }
                        await lblGearCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                         .ConfigureAwait(false);
                        string strAvail = await objGear.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                        await lblGearAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                          .ConfigureAwait(false);
                        string strCapacity = await objGear.GetDisplayCapacityAsync(token).ConfigureAwait(false);
                        await lblGearCapacity.DoThreadSafeAsync(x => x.Text = strCapacity, token)
                                             .ConfigureAwait(false);
                        await chkGearEquipped.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = objGear.Equipped;
                            x.Enabled = objGear.CanChangeEquip;
                        }, token).ConfigureAwait(false);
                        // If this is a Program, determine if its parent Gear (if any) is a Commlink. If so, show the Equipped checkbox.
                        if (objGear.IsProgram && objGear.Parent is IHasMatrixAttributes objCommlink
                                              && await objCommlink.GetIsCommlinkAsync(token).ConfigureAwait(false))
                        {
                            string strText = await LanguageManager
                                                   .GetStringAsync("Checkbox_SoftwareRunning", token: token)
                                                   .ConfigureAwait(false);
                            await chkGearEquipped.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                        }
                        else
                        {
                            string strText = await LanguageManager.GetStringAsync("Checkbox_Equipped", token: token)
                                                                  .ConfigureAwait(false);
                            await chkGearEquipped.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                        }

                        token.ThrowIfCancellationRequested();
                        if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                        {
                            bool blnEnabled = !objGear.IncludedInParent &&
                                              (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                  (await CharacterObject
                                                      .LoadDataXPathAsync(
                                                          "gear.xml", token: token)
                                                      .ConfigureAwait(false))
                                                  .SelectSingleNodeAndCacheExpression(
                                                      "/chummer", token: token), token).ConfigureAwait(false))
                                                                           .Contains(objGear.Category);
                            await chkGearBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = blnEnabled;
                                x.Checked = objGear.IncludedInParent
                                    ? (objGear.Parent as ICanBlackMarketDiscount)?.DiscountCost == true
                                    : objGear.DiscountCost;
                            }, token).ConfigureAwait(false);
                        }
                        else
                        {
                            await chkGearBlackMarketDiscount.DoThreadSafeAsync(x =>
                            {
                                x.Enabled = false;
                                x.Checked = false;
                            }, token).ConfigureAwait(false);
                        }

                        token.ThrowIfCancellationRequested();
                        // gpbGearMatrix
                        int intDeviceRating = await objGear.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                        await lblGearDeviceRating
                              .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                 token).ConfigureAwait(false);
                        await objGear.RefreshMatrixAttributeComboBoxesAsync(cboGearAttack, cboGearSleaze,
                                                                            cboGearDataProcessing, cboGearFirewall,
                                                                            token).ConfigureAwait(false);
                        bool blnIsActiveCommlink = await objGear.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                        bool blnIsCommlink = await objGear.GetIsCommlinkAsync(token).ConfigureAwait(false);
                        if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                        {
                            bool blnIsHomeNode = await objGear.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnCanBeHomeNode = blnIsCommlink &&
                                                    await objGear.GetTotalMatrixAttributeAsync(
                                                        "Program Limit", token).ConfigureAwait(false) >=
                                                    (await (await CharacterObject.GetAttributeAsync("DEP",
                                                        token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                        ? 2
                                                        : 1);
                            await chkGearHomeNode.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = blnIsHomeNode;
                                x.Enabled = blnCanBeHomeNode;
                            }, token).ConfigureAwait(false);
                        }
                        else
                            await chkGearHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                .ConfigureAwait(false);

                        await chkGearActiveCommlink.DoThreadSafeAsync(x =>
                        {
                            x.Checked = blnIsActiveCommlink;
                            x.Visible = blnIsCommlink;
                        }, token).ConfigureAwait(false);

                        token.ThrowIfCancellationRequested();
                        string strNodeText = await objGear.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                        await treGear.DoThreadSafeAsync(() => objSelectedNode.Text = strNodeText, token)
                                     .ConfigureAwait(false);
                    }
                    else
                    {
                        await gpbGearCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbGearMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        // Buttons
                        await cmdDeleteGear.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                                           .ConfigureAwait(false);
                    }

                    token.ThrowIfCancellationRequested();
                }
                finally
                {
                    await flpGear.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        protected override string FormMode
        {
            get
            {
                try
                {
                    return LanguageManager.GetString("Title_CreateNewCharacter", token: GenericToken);
                }
                catch (OperationCanceledException)
                {
                    //swallow this
                    return string.Empty;
                }
            }
        }

        protected override Task<string> GetFormModeAsync(CancellationToken token = default)
        {
            return LanguageManager.GetStringAsync("Title_CreateNewCharacter", token: token);
        }

        /// <summary>
        /// Save the Character.
        /// </summary>
        public override async Task<bool> SaveCharacter(bool blnNeedConfirm = true, bool blnDoCreated = false,
                                                            CancellationToken token = default)
        {
            blnDoCreated = blnDoCreated || await chkCharacterCreated.DoThreadSafeFuncAsync(x => x.Checked, token)
                                                                    .ConfigureAwait(false);
            return await base.SaveCharacter(blnNeedConfirm, blnDoCreated, token).ConfigureAwait(false);
        }

        /// <summary>
        /// Save the Character using the Save As dialogue box.
        /// </summary>
        /// <param name="blnDoCreated">If True, forces the character to be saved in Career Mode (if possible to do so).</param>
        /// <param name="token">Cancellation token to use.</param>
        public override async Task<bool> SaveCharacterAs(bool blnDoCreated = false,
                                                              CancellationToken token = default)
        {
            blnDoCreated = blnDoCreated || await chkCharacterCreated.DoThreadSafeFuncAsync(x => x.Checked, token)
                                                                    .ConfigureAwait(false);
            return await base.SaveCharacterAs(blnDoCreated, token).ConfigureAwait(false);
        }

        /// <summary>
        /// Save the character as Created and re-open it in Career Mode.
        /// </summary>
        public override async Task<bool> SaveCharacterAsCreated(CancellationToken token = default)
        {
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    SkipUpdate = true;
                    try
                    {
                        // If the character was built with Karma, record their staring Karma amount (if any).
                        int intKarma = await CharacterObject.GetKarmaAsync(GenericToken).ConfigureAwait(false);
                        if (intKarma != 0)
                        {
                            ExpenseLogEntry objKarma = new ExpenseLogEntry(CharacterObject);
                            objKarma.Create(intKarma,
                                await LanguageManager.GetStringAsync(
                                    "Label_SelectBP_StartingKarma", token: token).ConfigureAwait(false),
                                ExpenseType.Karma, DateTime.Now);
                            await CharacterObject.ExpenseEntries.AddWithSortAsync(objKarma, token: token)
                                .ConfigureAwait(false);

                            // Create an Undo entry so that the starting Karma amount can be modified if needed.
                            ExpenseUndo objKarmaUndo = new ExpenseUndo();
                            objKarmaUndo.CreateKarma(KarmaExpenseType.ManualAdd, string.Empty);
                            objKarma.Undo = objKarmaUndo;
                        }

                        List<CharacterAttrib> lstAttributesToAdd = null;
                        if (await CharacterObject.GetMetatypeCategoryAsync(token).ConfigureAwait(false) ==
                            "Shapeshifter")
                        {
                            lstAttributesToAdd = new List<CharacterAttrib>(AttributeSection.AttributeStrings.Count);
                            XPathNavigator xmlDoc = await CharacterObject
                                .LoadDataXPathAsync("metatypes.xml", token: token)
                                .ConfigureAwait(false);
                            string strMetatypeGuidString = CharacterObject.MetatypeGuid
                                .ToString(
                                    "D", GlobalSettings.InvariantCultureInfo);
                            string strMetavariantGuidString = CharacterObject.MetavariantGuid
                                .ToString(
                                    "D", GlobalSettings.InvariantCultureInfo);
                            string strMetavariantXPath = "/chummer/metatypes/metatype[id = "
                                                         + strMetatypeGuidString.CleanXPath()
                                                         + " or translate(id, 'abcdef', 'ABCDEF') = "
                                                         + strMetatypeGuidString.ToUpperInvariant().CleanXPath()
                                                         + "]/metavariants/metavariant[id = "
                                                         + strMetavariantGuidString.CleanXPath()
                                                         + " or translate(id, 'abcdef', 'ABCDEF') = "
                                                         + strMetavariantGuidString.ToUpperInvariant().CleanXPath()
                                                         + "]";
                            AttributeSection objAttributeSection =
                                await CharacterObject.GetAttributeSectionAsync(token).ConfigureAwait(false);
                            ThreadSafeObservableCollection<CharacterAttrib> lstAttributeList =
                                await objAttributeSection.GetAttributeListAsync(token).ConfigureAwait(false);
                            try
                            {
                                await lstAttributeList.ForEachWithSideEffectsAsync(async objOldAttribute =>
                                {
                                    CharacterAttrib objNewAttribute = new CharacterAttrib(
                                        CharacterObject, objOldAttribute.Abbrev,
                                        AttributeCategory.Shapeshifter);
                                    try
                                    {
                                        await AttributeSection.CopyAttributeAsync(objOldAttribute, objNewAttribute,
                                            strMetavariantXPath,
                                            xmlDoc, token).ConfigureAwait(false);
                                        lstAttributesToAdd.Add(objNewAttribute);
                                    }
                                    catch
                                    {
                                        await objNewAttribute.DisposeAsync().ConfigureAwait(false);
                                        throw;
                                    }
                                }, token).ConfigureAwait(false);

                                foreach (CharacterAttrib objAttributeToAdd in lstAttributesToAdd)
                                {
                                    await lstAttributeList.AddAsync(objAttributeToAdd, token)
                                        .ConfigureAwait(false);
                                }
                            }
                            catch
                            {
                                foreach (CharacterAttrib objAttribute in lstAttributesToAdd)
                                {
                                    await lstAttributeList.RemoveAsync(objAttribute, CancellationToken.None).ConfigureAwait(false);
                                    await objAttribute.DisposeAsync().ConfigureAwait(false);
                                }
                                throw;
                            }
                        }

                        // Create an Expense Entry for Starting Nuyen.
                        ExpenseLogEntry objNuyen = new ExpenseLogEntry(CharacterObject);
                        objNuyen.Create(await CharacterObject.GetNuyenAsync(token).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("Title_LifestyleNuyen", token: token)
                                .ConfigureAwait(false),
                            ExpenseType.Nuyen, DateTime.Now);
                        await CharacterObject.ExpenseEntries.AddWithSortAsync(objNuyen, token: token)
                            .ConfigureAwait(false);

                        // Create an Undo entry so that the Starting Nuyen amount can be modified if needed.
                        ExpenseUndo objNuyenUndo = new ExpenseUndo();
                        objNuyenUndo.CreateNuyen(NuyenExpenseType.ManualAdd, string.Empty);
                        objNuyen.Undo = objNuyenUndo;

                        await CharacterObject.SetCreatedAsync(true, false, token: token).ConfigureAwait(false);

                        // Save all essence modifiers for all Cyberware.
                        await (await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false))
                                .GetAllDescendantsAsync(x => x.Children, token)
                                .ConfigureAwait(false))
                            .ForEachAsync(x => x.SaveNonRetroactiveEssenceModifiersAsync(token), token)
                            .ConfigureAwait(false);
                        await CharacterObject.Vehicles.ForEachWithSideEffectsAsync(async objVehicle =>
                        {
                            await objVehicle.Mods.SelectMany(objMod => objMod.Cyberware)
                                .GetAllDescendants(x => x.Children)
                                .ForEachAsync(x => x.SaveNonRetroactiveEssenceModifiersAsync(token), token)
                                .ConfigureAwait(false);
                            await objVehicle.WeaponMounts
                                .SelectMany(objMount => objMount.Mods.SelectMany(objMod => objMod.Cyberware))
                                .GetAllDescendants(x => x.Children)
                                .ForEachAsync(x => x.SaveNonRetroactiveEssenceModifiersAsync(token), token)
                                .ConfigureAwait(false);
                        }, token).ConfigureAwait(false);

                        using (ThreadSafeForm<LoadingBar> frmLoadingBar
                               = await Program.CreateAndShowProgressBarAsync(token: token).ConfigureAwait(false))
                        {
                            await frmLoadingBar.MyForm.PerformStepAsync(CharacterObject.CharacterName,
                                    LoadingBar.ProgressBarTextPatterns.Saving, token)
                                .ConfigureAwait(false);
                            Interlocked.Increment(ref _intFileUpdateQueued);
                            try
                            {
                                if (!await CharacterObject.SaveAsync(token: token).ConfigureAwait(false))
                                {
                                    await CharacterObject.ExpenseEntries.ClearAsync(token).ConfigureAwait(false);
                                    if (lstAttributesToAdd != null)
                                    {
                                        foreach (CharacterAttrib objAttributeToAdd in lstAttributesToAdd)
                                        {
                                            await CharacterObject.AttributeSection.AttributeList.RemoveAsync(
                                                objAttributeToAdd, token).ConfigureAwait(false);
                                        }
                                    }

                                    await CharacterObject.SetCreatedAsync(false, false, token: token)
                                        .ConfigureAwait(false);
                                    SkipUpdate = false;
                                    return false;
                                }
                            }
                            finally
                            {
                                Interlocked.Decrement(ref _intFileUpdateQueued);
                            }

                            IsDirty = false;
                        }

                        IsReopenQueued = true;
                    }
                    catch
                    {
                        SkipUpdate = false;
                        throw;
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }

            return true;
        }

        /// <summary>
        /// Open the Select Cyberware window and handle adding to the Tree and Character.
        /// </summary>
        private async Task<bool> PickCyberware(Cyberware objSelectedCyberware,
                                                    Improvement.ImprovementSource objSource,
                                                    CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    using (ThreadSafeForm<SelectCyberware> frmPickCyberware
                           = await ThreadSafeForm<SelectCyberware>.GetAsync(
                                   () => new SelectCyberware(CharacterObject, objSource,
                                       objSelectedCyberware), token)
                               .ConfigureAwait(false))
                    {
                        List<Improvement> lstImprovements;
                        decimal decMultiplier = 1.0m;
                        switch (objSource)
                        {
                            // Apply the character's Cyberware Essence cost multiplier if applicable.
                            case Improvement.ImprovementSource.Cyberware:
                            {
                                lstImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject, Improvement.ImprovementType.CyberwareEssCost,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstImprovements.Count != 0)
                                {
                                    foreach (Improvement objImprovement in lstImprovements)
                                    {
                                        decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterESSMultiplier *= decMultiplier;
                                }

                                lstImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.CyberwareTotalEssMultiplier,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstImprovements)
                                    {
                                        decMultiplier *= objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                                }

                                lstImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                        CharacterObject, Improvement.ImprovementType.CyberwareEssCostNonRetroactive,
                                        token: token).ConfigureAwait(false);
                                if (lstImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstImprovements)
                                    {
                                        decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterESSMultiplier *= decMultiplier;
                                }

                                lstImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                        CharacterObject,
                                        Improvement.ImprovementType.CyberwareTotalEssMultiplierNonRetroactive,
                                        token: token).ConfigureAwait(false);
                                if (lstImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstImprovements)
                                    {
                                        decMultiplier *= objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                                }

                                break;
                            }
                            // Apply the character's Bioware Essence cost multiplier if applicable.
                            case Improvement.ImprovementSource.Bioware:
                            {
                                lstImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject, Improvement.ImprovementType.BiowareEssCost,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstImprovements.Count != 0)
                                {
                                    foreach (Improvement objImprovement in lstImprovements)
                                    {
                                        decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterESSMultiplier = decMultiplier;
                                }

                                lstImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.BiowareTotalEssMultiplier,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstImprovements)
                                    {
                                        decMultiplier *= objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                                }

                                lstImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.BiowareEssCostNonRetroactive,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstImprovements)
                                    {
                                        decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterESSMultiplier = decMultiplier;
                                }

                                lstImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                        CharacterObject,
                                        Improvement.ImprovementType.BiowareTotalEssMultiplierNonRetroactive,
                                        token: token).ConfigureAwait(false);
                                if (lstImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstImprovements)
                                    {
                                        decMultiplier *= objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.CharacterTotalESSMultiplier *= decMultiplier;
                                }

                                // Apply the character's Basic Bioware Essence cost multiplier if applicable.
                                lstImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.BasicBiowareEssCost, token: token)
                                        .ConfigureAwait(false);
                                if (lstImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstImprovements)
                                    {
                                        decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.BasicBiowareESSMultiplier = decMultiplier;
                                }

                                // Apply the character's Genetech Essence cost multiplier if applicable.
                                lstImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.GenetechEssMultiplier,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstImprovements)
                                    {
                                        decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.GenetechEssMultiplier = decMultiplier;
                                }

                                // Genetech Cost multiplier.
                                lstImprovements
                                    = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                            CharacterObject,
                                            Improvement.ImprovementType.GenetechCostMultiplier,
                                            token: token)
                                        .ConfigureAwait(false);
                                if (lstImprovements.Count != 0)
                                {
                                    decMultiplier = 1.0m;
                                    foreach (Improvement objImprovement in lstImprovements)
                                    {
                                        decMultiplier -= 1.0m - objImprovement.Value / 100.0m;
                                    }

                                    frmPickCyberware.MyForm.GenetechCostMultiplier = decMultiplier;
                                }

                                break;
                            }
                        }

                        Dictionary<string, int> dicDisallowedMounts = new Dictionary<string, int>(6);
                        Dictionary<string, int> dicHasMounts = new Dictionary<string, int>(6);
                        if (objSelectedCyberware != null)
                        {
                            frmPickCyberware.MyForm.ForcedGrade =
                                await objSelectedCyberware.GetGradeAsync(token).ConfigureAwait(false);
                            frmPickCyberware.MyForm.LockGrade();
                            frmPickCyberware.MyForm.Subsystems = objSelectedCyberware.AllowedSubsystems;
                            // If the Cyberware has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that consume Capacity).
                            if (!objSelectedCyberware.Capacity.Contains('[') ||
                                objSelectedCyberware.Capacity.Contains("/["))
                            {
                                await frmPickCyberware.MyForm.SetMaximumCapacityAsync(await objSelectedCyberware
                                    .GetCapacityRemainingAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                            }

                            string strLoopHasModularMount = await objSelectedCyberware.GetHasModularMountAsync(token)
                                .ConfigureAwait(false);
                            if (!string.IsNullOrEmpty(strLoopHasModularMount)
                                && !dicHasMounts.ContainsKey(strLoopHasModularMount))
                                dicHasMounts.Add(strLoopHasModularMount, int.MaxValue);
                            string strSelectedLocation =
                                await objSelectedCyberware.GetLocationAsync(token).ConfigureAwait(false);
                            foreach (Cyberware objLoopCyberware in await (await objSelectedCyberware.GetChildrenAsync(token).ConfigureAwait(false)).DeepWhereAsync(
                                             x => x.GetChildrenAsync(token),
                                             async x => string.IsNullOrEmpty(await x
                                                 .GetPlugsIntoModularMountAsync(token).ConfigureAwait(false)), token)
                                         .ConfigureAwait(false))
                            {
                                string strLoopLocation =
                                    await objLoopCyberware.GetLocationAsync(token).ConfigureAwait(false);
                                foreach (string strLoop in objLoopCyberware.BlocksMounts.SplitNoAlloc(
                                             ',', StringSplitOptions.RemoveEmptyEntries))
                                {
                                    string strKey = strLoop;
                                    if (strSelectedLocation != strLoopLocation)
                                        strKey += strLoopLocation;
                                    if (!dicDisallowedMounts.ContainsKey(strKey))
                                        dicDisallowedMounts.Add(strKey, int.MaxValue);
                                }

                                strLoopHasModularMount = strSelectedLocation != strLoopLocation
                                    ? await objLoopCyberware.GetHasModularMountAsync(token).ConfigureAwait(false) +
                                      strLoopLocation
                                    : await objLoopCyberware.GetHasModularMountAsync(token).ConfigureAwait(false);
                                if (!string.IsNullOrEmpty(strLoopHasModularMount)
                                    && !dicHasMounts.ContainsKey(strLoopHasModularMount))
                                    dicHasMounts.Add(strLoopHasModularMount, int.MaxValue);
                            }
                        }
                        else
                        {
                            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                       out HashSet<string> setLoopDisallowedMounts))
                            using (new FetchSafelyFromSafeObjectPool<HashSet<string>>(Utils.StringHashSetPool,
                                       out HashSet<string> setLoopHasModularMount))
                            {
                                await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).ForEachAsync(async objLoopCyberware =>
                                {
                                    setLoopDisallowedMounts.Clear();
                                    setLoopDisallowedMounts.AddRange(
                                        objLoopCyberware.BlocksMounts.SplitNoAlloc(',',
                                            StringSplitOptions.RemoveEmptyEntries));
                                    setLoopHasModularMount.Clear();
                                    string strLoopHasModularMount = await objLoopCyberware
                                        .GetHasModularMountAsync(token).ConfigureAwait(false);
                                    if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                        setLoopHasModularMount.Add(strLoopHasModularMount);
                                    foreach (Cyberware objInnerLoopCyberware in await
                                                 (await objLoopCyberware.GetChildrenAsync(token).ConfigureAwait(false))
                                                 .DeepWhereAsync(
                                                     x => x.GetChildrenAsync(token),
                                                     async x => string.IsNullOrEmpty(
                                                         await x.GetPlugsIntoModularMountAsync(token)
                                                             .ConfigureAwait(false)),
                                                     token).ConfigureAwait(false))
                                    {
                                        foreach (string strLoop in objInnerLoopCyberware.BlocksMounts.SplitNoAlloc(
                                                     ',', StringSplitOptions.RemoveEmptyEntries))
                                            setLoopDisallowedMounts.Add(strLoop);
                                        strLoopHasModularMount = await objInnerLoopCyberware
                                            .GetHasModularMountAsync(token).ConfigureAwait(false);
                                        if (!string.IsNullOrEmpty(strLoopHasModularMount))
                                            setLoopHasModularMount.Add(strLoopHasModularMount);
                                    }

                                    foreach (string strLoop in setLoopDisallowedMounts)
                                    {
                                        string strKey = strLoop + objLoopCyberware.Location;
                                        if (!dicDisallowedMounts.ContainsKey(strKey))
                                            dicDisallowedMounts.Add(strKey,
                                                await objLoopCyberware.GetLimbSlotCountAsync(token)
                                                    .ConfigureAwait(false));
                                        else
                                            dicDisallowedMounts[strKey] += await objLoopCyberware
                                                .GetLimbSlotCountAsync(token).ConfigureAwait(false);
                                    }

                                    foreach (string strLoop in setLoopHasModularMount)
                                    {
                                        string strKey = strLoop + objLoopCyberware.Location;
                                        if (!dicHasMounts.ContainsKey(strKey))
                                            dicHasMounts.Add(strKey,
                                                await objLoopCyberware.GetLimbSlotCountAsync(token)
                                                    .ConfigureAwait(false));
                                        else
                                            dicHasMounts[strKey] += await objLoopCyberware.GetLimbSlotCountAsync(token)
                                                .ConfigureAwait(false);
                                    }
                                }, token).ConfigureAwait(false);
                            }
                        }

                        using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                   out StringBuilder sbdDisallowedMounts))
                        {
                            foreach (KeyValuePair<string, int> kvpLoop in dicDisallowedMounts)
                            {
                                string strKey = kvpLoop.Key;
                                if (strKey.EndsWith("Right", StringComparison.Ordinal))
                                    continue;
                                int intValue = kvpLoop.Value;
                                if (strKey.EndsWith("Left", StringComparison.Ordinal))
                                {
                                    strKey = strKey.TrimEndOnce("Left", true);
                                    intValue = dicDisallowedMounts.TryGetValue(strKey + "Right",
                                        out int intExistingValue)
                                        ? 2 * Math.Min(intValue, intExistingValue)
                                        : 0;
                                    if (dicDisallowedMounts.TryGetValue(strKey, out intExistingValue))
                                        intValue += intExistingValue;
                                }

                                if (intValue >= await CharacterObject
                                        .LimbCountAsync(Cyberware.MountToLimbType(strKey), token)
                                        .ConfigureAwait(false))
                                    sbdDisallowedMounts.Append(strKey, ',');
                            }

                            // Remove trailing ","
                            if (sbdDisallowedMounts.Length > 0)
                                --sbdDisallowedMounts.Length;
                            frmPickCyberware.MyForm.DisallowedMounts = sbdDisallowedMounts.ToString();
                        }

                        using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                   out StringBuilder sbdHasMounts))
                        {
                            foreach (KeyValuePair<string, int> kvpLoop in dicHasMounts)
                            {
                                string strKey = kvpLoop.Key;
                                if (strKey.EndsWith("Right", StringComparison.Ordinal))
                                    continue;
                                int intValue = kvpLoop.Value;
                                if (strKey.EndsWith("Left", StringComparison.Ordinal))
                                {
                                    strKey = strKey.TrimEndOnce("Left", true);
                                    intValue = dicHasMounts.TryGetValue(strKey + "Right", out int intExistingValue)
                                        ? 2 * Math.Min(intValue, intExistingValue)
                                        : 0;
                                    if (dicHasMounts.TryGetValue(strKey, out intExistingValue))
                                        intValue += intExistingValue;
                                }

                                if (intValue >= await CharacterObject
                                        .LimbCountAsync(Cyberware.MountToLimbType(strKey), token)
                                        .ConfigureAwait(false))
                                    sbdHasMounts.Append(strKey, ',');
                            }

                            // Remove trailing ","
                            if (sbdHasMounts.Length > 0)
                                --sbdHasMounts.Length;
                            frmPickCyberware.MyForm.HasModularMounts = sbdHasMounts.ToString();
                        }

                        // Make sure the dialogue window was not canceled.
                        if (await frmPickCyberware.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                            == DialogResult.Cancel)
                            return false;

                        // Open the Cyberware XML file and locate the selected piece.
                        XmlNode objXmlCyberware = objSource == Improvement.ImprovementSource.Bioware
                            ? (await CharacterObject.LoadDataAsync("bioware.xml", token: token).ConfigureAwait(false))
                            .TryGetNodeByNameOrId("/chummer/biowares/bioware",
                                frmPickCyberware.MyForm.SelectedCyberware)
                            : (await CharacterObject.LoadDataAsync("cyberware.xml", token: token).ConfigureAwait(false))
                            .TryGetNodeByNameOrId("/chummer/cyberwares/cyberware",
                                frmPickCyberware.MyForm.SelectedCyberware);

                        Cyberware objCyberware = new Cyberware(CharacterObject);
                        try
                        {
                            await objCyberware
                                   .SetPrototypeTranshumanAsync(frmPickCyberware.MyForm.PrototypeTranshuman, token)
                                   .ConfigureAwait(false);
                            if (await CharacterObjectSettings.GetAllowCyberwareESSDiscountsAsync(token).ConfigureAwait(false))
                                await objCyberware.SetESSDiscountAsync(frmPickCyberware.MyForm.SelectedESSDiscount, token).ConfigureAwait(false);
                            await objCyberware.SetParentAsync(objSelectedCyberware, token).ConfigureAwait(false);
                            if (!await objCyberware.Purchase(objXmlCyberware, objSource,
                                    frmPickCyberware.MyForm.SelectedGrade,
                                    frmPickCyberware.MyForm.SelectedRating, null,
                                    objSelectedCyberware != null
                                        ? await objSelectedCyberware.GetChildrenAsync(token).ConfigureAwait(false)
                                        : await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false),
                                    await CharacterObject.GetVehiclesAsync(token).ConfigureAwait(false),
                                    await CharacterObject.GetWeaponsAsync(token).ConfigureAwait(false),
                                    frmPickCyberware.MyForm.Markup,
                                    frmPickCyberware.MyForm.FreeCost,
                                    frmPickCyberware.MyForm.BlackMarketDiscount,
                                    objParent: objSelectedCyberware, token: token).ConfigureAwait(false))
                                await objCyberware.DeleteCyberwareAsync(token: token).ConfigureAwait(false);

                            return frmPickCyberware.MyForm.AddAgain;
                        }
                        catch
                        {
                            await objCyberware.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Select a piece of Gear to be added to the character.
        /// </summary>
        private async Task<bool> PickGear(string strSelectedId, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    bool blnNullParent = false;
                    Gear objSelectedGear =
                        await CharacterObject.Gear.DeepFindByIdAsync(strSelectedId, token).ConfigureAwait(false);
                    Location objLocation = null;
                    if (objSelectedGear == null)
                    {
                        blnNullParent = true;
                        objLocation =
                            await CharacterObject.GearLocations
                                .FirstOrDefaultAsync(location => location.InternalId == strSelectedId, token)
                                .ConfigureAwait(false);
                    }

                    // Open the Gear XML file and locate the selected Gear.
                    XPathNavigator xmlParent
                        = blnNullParent ? null : await objSelectedGear.GetNodeXPathAsync(token).ConfigureAwait(false);
                    string strCategories = string.Empty;

                    if (xmlParent != null)
                    {
                        XPathNodeIterator xmlAddonCategoryList = xmlParent
                            .SelectAndCacheExpression(
                                "addoncategory", token);
                        if (xmlAddonCategoryList.Count > 0)
                        {
                            using (new FetchSafelyFromObjectPool<StringBuilder>(
                                       Utils.StringBuilderPool, out StringBuilder sbdCategories))
                            {
                                foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                                    sbdCategories.Append(objXmlCategory.Value, ',');
                                // Remove the trailing comma.
                                --sbdCategories.Length;
                                strCategories = sbdCategories.ToString();
                            }
                        }
                    }

                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject,
                                   objSelectedGear?.ChildAvailModifier ?? 0,
                                   objSelectedGear?.ChildCostMultiplier ?? 1,
                                   objSelectedGear, strCategories), token).ConfigureAwait(false))
                    {
                        if (!blnNullParent
                            && (!string.IsNullOrEmpty(objSelectedGear.Capacity) &&
                                !objSelectedGear.Capacity.Contains('[')
                                || objSelectedGear.Capacity.Contains("/[")))
                        {
                            // If the Gear has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that conume Capacity).
                            await frmPickGear.MyForm.SetMaximumCapacityAsync(await objSelectedGear.GetCapacityRemainingAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                            if (!string.IsNullOrEmpty(strCategories))
                                frmPickGear.MyForm.ShowNegativeCapacityOnly = true;
                        }

                        // Make sure the dialogue window was not canceled.
                        if (await frmPickGear.ShowDialogSafeAsync(this, token).ConfigureAwait(false) ==
                            DialogResult.Cancel)
                            return false;

                        // Open the Cyberware XML file and locate the selected piece.
                        XmlDocument objXmlDocument
                            = await CharacterObject.LoadDataAsync("gear.xml", token: token).ConfigureAwait(false);
                        XmlNode objXmlGear
                            = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                frmPickGear.MyForm.SelectedGear);

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                            string.Empty,
                            objSelectedGear?.Equipped != false, token: token).ConfigureAwait(false);
                        if (objGear.InternalId.IsEmptyGuid())
                            return frmPickGear.MyForm.AddAgain;
                        await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);

                        // If a Commlink has just been added, see if the character already has one. If not, make it the active Commlink.
                        if (await CharacterObject.GetActiveCommlinkAsync(token).ConfigureAwait(false) == null &&
                            await objGear.GetIsCommlinkAsync(token).ConfigureAwait(false))
                        {
                            await objGear.SetActiveCommlinkAsync(CharacterObject, true, token).ConfigureAwait(false);
                        }

                        // reduce the cost for Black Market Pipeline
                        objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;
                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = "(" + objGear.Cost + ") * 0.5";
                        // If the item was marked as free, change its cost.
                        if (frmPickGear.MyForm.FreeCost)
                        {
                            objGear.Cost = "0";
                        }

                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                        }

                        ThreadSafeObservableCollection<Gear> destinationGear =
                            blnNullParent ? CharacterObject.Gear : objSelectedGear.Children;
                        bool blnMatchFound = false;
                        await destinationGear.ForEachWithBreakAsync(async objExistingGear =>
                        {
                            if (objExistingGear.Location == objLocation
                                && objGear.IsIdenticalToOtherGear(objExistingGear, true)
                                && await Program.ShowScrollableMessageBoxAsync(this,
                                        string.Format(GlobalSettings.CultureInfo,
                                            await LanguageManager.GetStringAsync(
                                                    "Message_MergeIdentical",
                                                    token: token)
                                                .ConfigureAwait(false),
                                            await objGear
                                                .GetCurrentDisplayNameShortAsync(
                                                    token)
                                                .ConfigureAwait(false)),
                                        await LanguageManager.GetStringAsync(
                                                "MessageTitle_MergeIdentical",
                                                token: token)
                                            .ConfigureAwait(false),
                                        MessageBoxButtons.YesNo, MessageBoxIcon.Question, token: token)
                                    .ConfigureAwait(false)
                                == DialogResult.Yes)
                            {
                                // A match was found, so increase the quantity instead.
                                await objExistingGear.SetQuantityAsync(objExistingGear.Quantity + objGear.Quantity, token).ConfigureAwait(false);
                                blnMatchFound = true;
                                return false;
                            }

                            return true;
                        }, token).ConfigureAwait(false);

                        if (!blnMatchFound)
                        {
                            if (objLocation != null)
                                await objLocation.Children.AddAsync(objGear, token).ConfigureAwait(false);
                            await destinationGear.AddAsync(objGear, token).ConfigureAwait(false);
                        }
                        else
                        {
                            await MakeDirtyWithCharacterUpdate(token).ConfigureAwait(false);
                        }

                        return frmPickGear.MyForm.AddAgain;
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Select a piece of Gear and add it to a piece of Armor.
        /// </summary>
        /// <param name="strSelectedId">Id attached to the object to which the gear should be added.</param>
        /// <param name="blnShowArmorCapacityOnly">Whether only items that consume capacity should be shown.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        private async Task<bool> PickArmorGear(string strSelectedId, bool blnShowArmorCapacityOnly = false,
                                                    CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
            try
            {
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    (Gear objSelectedGear, Armor objSelectedArmor, ArmorMod objSelectedMod)
                        = await CharacterObject.Armor.FindArmorGearAsync(strSelectedId, token)
                            .ConfigureAwait(false);
                    if (objSelectedGear == null)
                    {
                        objSelectedMod = await CharacterObject.Armor.FindArmorModAsync(strSelectedId, token)
                            .ConfigureAwait(false);
                        if (objSelectedMod == null)
                            objSelectedArmor = await CharacterObject.Armor.FindByIdAsync(strSelectedId, token).ConfigureAwait(false);
                        else
                            objSelectedArmor = objSelectedMod.Parent;
                    }

                    // Open the Gear XML file and locate the selected Gear.
                    object objParent = objSelectedGear ?? objSelectedMod ?? (object)objSelectedArmor;
                    string strCategories = string.Empty;
                    if (!string.IsNullOrEmpty(strSelectedId) && objParent is IHasXmlDataNode objParentWithDataNode)
                    {
                        XPathNavigator objParentDataNode
                            = await objParentWithDataNode.GetNodeXPathAsync(token).ConfigureAwait(false);
                        XPathNodeIterator xmlAddonCategoryList =
                            objParentDataNode?.SelectAndCacheExpression("addoncategory", token);
                        if (xmlAddonCategoryList?.Count > 0)
                        {
                            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                       out StringBuilder sbdCategories))
                            {
                                foreach (XPathNavigator objXmlCategory in xmlAddonCategoryList)
                                    sbdCategories.Append(objXmlCategory.Value, ',');
                                // Remove the trailing comma.
                                if (sbdCategories.Length > 0)
                                    --sbdCategories.Length;
                                strCategories = sbdCategories.ToString();
                            }
                        }
                    }

                    using (ThreadSafeForm<SelectGear> frmPickGear = await ThreadSafeForm<SelectGear>.GetAsync(
                               () => new SelectGear(CharacterObject, objGearParent: objParent, strAllowedCategories: strCategories)
                               {
                                   ShowArmorCapacityOnly = blnShowArmorCapacityOnly,
                                   CapacityDisplayStyle = objSelectedMod != null
                                       ? CapacityStyle.Standard
                                       : objSelectedArmor.CapacityDisplayStyle
                               }, token).ConfigureAwait(false))
                    {
                        if (!string.IsNullOrEmpty(strSelectedId))
                        {
                            // If the Gear has a Capacity with no brackets (meaning it grants Capacity), show only Subsystems (those that conume Capacity).
                            if (objSelectedGear?.Capacity.Contains('[') == false)
                                await frmPickGear.MyForm.SetMaximumCapacityAsync(await objSelectedGear
                                    .GetCapacityRemainingAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                            else if (objSelectedMod != null)
                                await frmPickGear.MyForm.SetMaximumCapacityAsync(await objSelectedMod
                                    .GetGearCapacityRemainingAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                        }

                        // Make sure the dialogue window was not canceled.
                        if (await frmPickGear.ShowDialogSafeAsync(this, token).ConfigureAwait(false) ==
                            DialogResult.Cancel)
                            return false;

                        // Open the Cyberware XML file and locate the selected piece.
                        XmlDocument objXmlDocument
                            = await CharacterObject.LoadDataAsync("gear.xml", token: token).ConfigureAwait(false);
                        XmlNode objXmlGear
                            = objXmlDocument.TryGetNodeByNameOrId("/chummer/gears/gear",
                                frmPickGear.MyForm.SelectedGear);

                        // Create the new piece of Gear.
                        List<Weapon> lstWeapons = new List<Weapon>(1);

                        Gear objGear = new Gear(CharacterObject);
                        await objGear.CreateAsync(objXmlGear, frmPickGear.MyForm.SelectedRating, lstWeapons,
                            string.Empty,
                            objSelectedGear?.Equipped ?? objSelectedMod?.Equipped ?? objSelectedArmor.Equipped,
                            token: token).ConfigureAwait(false);

                        if (objGear.InternalId.IsEmptyGuid())
                            return frmPickGear.MyForm.AddAgain;

                        await objGear.SetQuantityAsync(frmPickGear.MyForm.SelectedQty, GenericToken).ConfigureAwait(false);
                        objGear.DiscountCost = frmPickGear.MyForm.BlackMarketDiscount;

                        if (objSelectedGear != null)
                        {
                            await objGear.SetParentAsync(objSelectedGear, token).ConfigureAwait(false);
                        }

                        // Reduce the cost for Do It Yourself components.
                        if (frmPickGear.MyForm.DoItYourself)
                            objGear.Cost = "(" + objGear.Cost + ") * 0.5";
                        // If the item was marked as free, change its cost.
                        if (frmPickGear.MyForm.FreeCost)
                        {
                            objGear.Cost = "0";
                        }

                        // Create any Weapons that came with this Gear.
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                        }

                        Gear objMatchingGear = null;
                        // If this is Ammunition, see if the character already has it on them.
                        if (objGear.Category == "Ammunition" || !string.IsNullOrEmpty(objGear.AmmoForWeaponType))
                        {
                            TaggedObservableCollection<Gear> lstToSearch = !string.IsNullOrEmpty(objSelectedGear?.Name)
                                ? objSelectedGear.Children
                                : !string.IsNullOrEmpty(objSelectedMod?.Name)
                                    ? objSelectedMod.GearChildren
                                    : objSelectedArmor.GearChildren;
                            objMatchingGear = lstToSearch.FirstOrDefault(x => objGear.IsIdenticalToOtherGear(x));
                        }

                        if (objMatchingGear != null)
                        {
                            await objMatchingGear.SetQuantityAsync(objMatchingGear.Quantity + objGear.Quantity, token).ConfigureAwait(false);
                        }
                        else
                        {
                            // Add the Gear.
                            if (!string.IsNullOrEmpty(objSelectedGear?.Name))
                            {
                                await objSelectedGear.Children.AddAsync(objGear, token).ConfigureAwait(false);
                            }
                            else if (!string.IsNullOrEmpty(objSelectedMod?.Name))
                            {
                                await objSelectedMod.GearChildren.AddAsync(objGear, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await objSelectedArmor.GearChildren.AddAsync(objGear, token).ConfigureAwait(false);
                            }
                        }

                        return frmPickGear.MyForm.AddAgain;
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objCursorWait.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Refresh the currently-selected Lifestyle.
        /// </summary>
        private async Task RefreshSelectedLifestyle(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpLifestyleDetails.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    TreeNode objSelectedNode = await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                                  .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag == null || objSelectedNode.Level <= 0
                                                   || !(objSelectedNodeTag is Lifestyle objLifestyle))
                    {
                        await flpLifestyleDetails.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                        await cmdDeleteLifestyle
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                        return;
                    }

                    await flpLifestyleDetails.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                    await cmdDeleteLifestyle.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                    string strMonthlyCost = await objLifestyle.GetDisplayTotalMonthlyCostAsync(token).ConfigureAwait(false);
                    await lblLifestyleCost.DoThreadSafeAsync(x => x.Text
                                                                 = strMonthlyCost, token)
                                          .ConfigureAwait(false);
                    int intMonths = await objLifestyle.GetIncrementsAsync(GenericToken).ConfigureAwait(false);
                    await nudLifestyleMonths.DoThreadSafeAsync(x => x.Value = intMonths, token)
                                            .ConfigureAwait(false);
                    string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token)
                                                           .ConfigureAwait(false);
                    string strText = objLifestyle.Dice.ToString(GlobalSettings.CultureInfo)
                                     + await LanguageManager.GetStringAsync("String_D6", token: token)
                                                            .ConfigureAwait(false)
                                     + strSpace
                                     + "×" + strSpace
                                     + objLifestyle.Multiplier.ToString(
                                         await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                         GlobalSettings.CultureInfo) + await LanguageManager
                                                                             .GetStringAsync(
                                                                                 "String_NuyenSymbol", token: token)
                                                                             .ConfigureAwait(false);
                    await lblLifestyleStartingNuyen.DoThreadSafeAsync(x => x.Text = strText, token)
                                                   .ConfigureAwait(false);
                    await objLifestyle.SetSourceDetailAsync(lblLifestyleSource, token).ConfigureAwait(false);
                    string strCost
                        = (await objLifestyle.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                            await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false), GlobalSettings.CultureInfo) + await LanguageManager
                            .GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                    await lblLifestyleTotalCost.DoThreadSafeAsync(x => x.Text = strCost, token).ConfigureAwait(false);
                    string strCostLabelString;
                    string strIncrementString;
                    // Change the Cost/Month label.
                    switch (await objLifestyle.GetIncrementTypeAsync(token).ConfigureAwait(false))
                    {
                        case LifestyleIncrement.Day:
                            strCostLabelString = await LanguageManager
                                                       .GetStringAsync("Label_SelectLifestyle_CostPerDay", token: token)
                                                       .ConfigureAwait(false);
                            strIncrementString = await LanguageManager.GetStringAsync("String_Days", token: token)
                                                                      .ConfigureAwait(false);
                            break;

                        case LifestyleIncrement.Week:
                            strCostLabelString = await LanguageManager
                                                       .GetStringAsync("Label_SelectLifestyle_CostPerWeek",
                                                                       token: token).ConfigureAwait(false);
                            strIncrementString = await LanguageManager.GetStringAsync("String_Weeks", token: token)
                                                                      .ConfigureAwait(false);
                            break;

                        default:
                            strCostLabelString = await LanguageManager
                                                       .GetStringAsync("Label_SelectLifestyle_CostPerMonth",
                                                                       token: token).ConfigureAwait(false);
                            strIncrementString = await LanguageManager.GetStringAsync("String_Months", token: token)
                                                                      .ConfigureAwait(false);
                            break;
                    }

                    await lblLifestyleCostLabel.DoThreadSafeAsync(x => x.Text = strCostLabelString, token)
                                               .ConfigureAwait(false);
                    string strMonthsLabel = strIncrementString + string.Format(
                        GlobalSettings.CultureInfo,
                        await LanguageManager.GetStringAsync("Label_LifestylePermanent", token: token)
                                             .ConfigureAwait(false),
                        (await objLifestyle.GetIncrementsRequiredForPermanentAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo));
                    await lblLifestyleMonthsLabel.DoThreadSafeAsync(x => x.Text = strMonthsLabel, token)
                                                 .ConfigureAwait(false);
                    token.ThrowIfCancellationRequested();
                    if (!string.IsNullOrEmpty(await objLifestyle.GetBaseLifestyleAsync(token).ConfigureAwait(false)))
                    {
                        using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdQualities))
                        {
                            await sbdQualities.AppendJoinAsync("," + Environment.NewLine,
                                                               objLifestyle.LifestyleQualities.Select(
                                                                   r => r.GetCurrentFormattedDisplayNameAsync(token)),
                                                               token).ConfigureAwait(false);
                            foreach (Improvement objImprovement in await ImprovementManager
                                                                         .GetCachedImprovementListForValueOfAsync(
                                                                             CharacterObject,
                                                                             Improvement.ImprovementType.LifestyleCost,
                                                                             token: token).ConfigureAwait(false))
                            {
                                if (sbdQualities.Length > 0)
                                    sbdQualities.AppendLine(',');

                                sbdQualities.Append(await CharacterObject
                                                          .GetObjectNameAsync(objImprovement, token: token)
                                                          .ConfigureAwait(false),
                                                          await LanguageManager.GetStringAsync("String_Space", token: token)
                                                                         .ConfigureAwait(false))
                                            .Append('[',
                                                objImprovement.Value.ToString(
                                                    "+#,0;-#,0;0", GlobalSettings.CultureInfo), "%]");
                            }

                            if (await objLifestyle.GetStyleTypeAsync(token).ConfigureAwait(false) == LifestyleType.Standard)
                            {
                                foreach (Improvement objImprovement in await ImprovementManager
                                             .GetCachedImprovementListForValueOfAsync(
                                                 CharacterObject,
                                                 Improvement.ImprovementType.BasicLifestyleCost,
                                                 token: token).ConfigureAwait(false))
                                {
                                    if (sbdQualities.Length > 0)
                                        sbdQualities.AppendLine(',');

                                    sbdQualities.Append(await CharacterObject
                                            .GetObjectNameAsync(objImprovement, token: token)
                                            .ConfigureAwait(false), await LanguageManager.GetStringAsync("String_Space", token: token)
                                            .ConfigureAwait(false))
                                        .Append('[',
                                            objImprovement.Value.ToString(
                                                "+#,0;-#,0;0", GlobalSettings.CultureInfo), "%]");
                                }
                            }

                            await lblLifestyleQualities.DoThreadSafeAsync(x => x.Text = sbdQualities.ToString(), token)
                                                       .ConfigureAwait(false);
                        }

                        string strName = await objLifestyle.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                        await lblBaseLifestyle.DoThreadSafeAsync(x => x.Text = strName, token)
                                              .ConfigureAwait(false);
                        await lblLifestyleQualitiesLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                        await lblLifestyleQualities.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                    }
                    else
                    {
                        string strError = await LanguageManager.GetStringAsync("String_Error", token: token)
                                                               .ConfigureAwait(false);
                        await lblBaseLifestyle.DoThreadSafeAsync(x => x.Text = strError, token).ConfigureAwait(false);
                        await lblLifestyleQualitiesLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                        await lblLifestyleQualities.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                    }

                    //Controls Visibility and content of the City, District and Borough Labels
                    string strCity = await objLifestyle.GetCityAsync(token).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strCity))
                    {
                        await lblLifestyleCity.DoThreadSafeAsync(x =>
                        {
                            x.Text = strCity;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await lblLifestyleCityLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                    }
                    else
                    {
                        await lblLifestyleCity.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await lblLifestyleCityLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                    }

                    string strDistrict = await objLifestyle.GetDistrictAsync(token).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strDistrict))
                    {
                        await lblLifestyleDistrict.DoThreadSafeAsync(x =>
                        {
                            x.Text = strDistrict;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await lblLifestyleDistrictLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                       .ConfigureAwait(false);
                    }
                    else
                    {
                        await lblLifestyleDistrict.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                        await lblLifestyleDistrictLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                    }

                    string strBorough = await objLifestyle.GetBoroughAsync(token).ConfigureAwait(false);
                    if (!string.IsNullOrEmpty(strBorough))
                    {
                        await lblLifestyleBorough.DoThreadSafeAsync(x =>
                        {
                            x.Text = strBorough;
                            x.Visible = true;
                        }, token).ConfigureAwait(false);
                        await lblLifestyleBoroughLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                    }
                    else
                    {
                        await lblLifestyleBorough.DoThreadSafeAsync(x => x.Visible = false, token)
                                                 .ConfigureAwait(false);
                        await lblLifestyleBoroughLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await flpLifestyleDetails.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the currently-selected Vehicle.
        /// </summary>
        private async Task RefreshSelectedVehicle(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpVehicles.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    TreeNode objSelectedNode = await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                                .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag == null || objSelectedNode.Level <= 0 || objSelectedNodeTag is Location)
                    {
                        await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        // Buttons
                        await cmdDeleteVehicle
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                        return;
                    }

                    string strSpace = await LanguageManager.GetStringAsync("String_Space", token: token)
                                                           .ConfigureAwait(false);
                    if (objSelectedNodeTag is IHasStolenProperty selectedLoot && (await ImprovementManager
                            .GetCachedImprovementListForValueOfAsync(
                                CharacterObject,
                                Improvement.ImprovementType.Nuyen,
                                "Stolen", token: token).ConfigureAwait(false)).Count > 0)
                    {
                        await chkVehicleStolen.DoThreadSafeAsync(x =>
                        {
                            x.Visible = true;
                            x.Checked = selectedLoot.Stolen;
                        }, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await chkVehicleStolen.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    if (objSelectedNodeTag is IHasSource objSelected)
                    {
                        await lblVehicleSourceLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                        await lblVehicleSource.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await objSelected.SetSourceDetailAsync(lblVehicleSource, token).ConfigureAwait(false);
                    }
                    else
                    {
                        await lblVehicleSourceLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                        await lblVehicleSource.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                    }

                    if (objSelectedNodeTag is IHasRating objHasRating)
                    {
                        string strText = string.Format(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync(
                                "Label_RatingFormat", token: token).ConfigureAwait(false),
                            await LanguageManager.GetStringAsync(
                                objHasRating.RatingLabel, token: token).ConfigureAwait(false));
                        await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Text = strText, token)
                                                   .ConfigureAwait(false);
                    }

                    switch (objSelectedNodeTag)
                    {
                        // Locate the selected Vehicle.
                        case Vehicle objVehicle:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteVehicle
                                  .DoThreadSafeAsync(x => x.Enabled = string.IsNullOrEmpty(objVehicle.ParentID), token)
                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesCommon
                            string strName = await objVehicle.GetCurrentDisplayNameShortAsync(token)
                                                             .ConfigureAwait(false);
                            await lblVehicleName
                                  .DoThreadSafeAsync(x => x.Text = strName, token)
                                  .ConfigureAwait(false);
                            string strCategory = await objVehicle.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                                 .ConfigureAwait(false);
                            await lblVehicleCategory
                                  .DoThreadSafeAsync(x => x.Text = strCategory,
                                                     token).ConfigureAwait(false);
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            await nudVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            string strAvail = await objVehicle.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objVehicle.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                                    .ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                .ConfigureAwait(false);
                            if (await CharacterObjectSettings.BookEnabledAsync("R5", token).ConfigureAwait(false))
                            {
                                await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblVehicleSlots.DoThreadSafeAsync(x => x.Visible = false, token)
                                                     .ConfigureAwait(false);
                            }
                            else
                            {
                                int intSlots = await objVehicle.GetSlotsAsync(token).ConfigureAwait(false);
                                string strText = intSlots.ToString(GlobalSettings.CultureInfo) + strSpace
                                    + "("
                                    + (intSlots - await objVehicle.GetSlotsUsedAsync(token).ConfigureAwait(false)).ToString(
                                        GlobalSettings.CultureInfo)
                                    + strSpace + await LanguageManager.GetStringAsync("String_Remaining", token: token)
                                                                      .ConfigureAwait(false)
                                    + ")";
                                await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                await lblVehicleSlots.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strText;
                                }, token).ConfigureAwait(false);
                            }

                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                    .ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                        (await CharacterObject.LoadDataXPathAsync(
                                            "vehicles.xml", token: token).ConfigureAwait(false))
                                        .SelectSingleNodeAndCacheExpression(
                                            "/chummer", token: token), token).ConfigureAwait(false))
                                                  .Contains(objVehicle.Category);
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objVehicle.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesVehicle
                            string strHandling = await objVehicle.GetTotalHandlingAsync(token).ConfigureAwait(false);
                            await lblVehicleHandling.DoThreadSafeAsync(x => x.Text = strHandling, token)
                                                    .ConfigureAwait(false);
                            string strAccel = await objVehicle.GetTotalAccelAsync(token).ConfigureAwait(false);
                            await lblVehicleAccel.DoThreadSafeAsync(x => x.Text = strAccel, token)
                                                 .ConfigureAwait(false);
                            string strSpeed = await objVehicle.GetTotalSpeedAsync(token).ConfigureAwait(false);
                            await lblVehicleSpeed.DoThreadSafeAsync(x => x.Text = strSpeed, token)
                                .ConfigureAwait(false);
                            string strPilot =
                                (await objVehicle.GetPilotAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehiclePilot
                                  .DoThreadSafeAsync(
                                      x => x.Text = strPilot, token)
                                  .ConfigureAwait(false);
                            string strBody =
                                (await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehicleBody
                                .DoThreadSafeAsync(
                                    x => x.Text = strBody, token)
                                .ConfigureAwait(false);
                            string strArmor = (await objVehicle.GetTotalArmorAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehicleArmor
                                .DoThreadSafeAsync(
                                    x => x.Text = strArmor, token)
                                .ConfigureAwait(false);
                            string strSeats =
                                (await objVehicle.GetTotalSeatsAsync(token).ConfigureAwait(false)).ToString(
                                    GlobalSettings.CultureInfo);
                            await lblVehicleSeats.DoThreadSafeAsync(x => x.Text = strSeats, token)
                                .ConfigureAwait(false);
                            string strSensor = (await objVehicle.GetCalculatedSensorAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehicleSensor.DoThreadSafeAsync(x => x.Text = strSensor, token)
                                .ConfigureAwait(false);
                            if (await CharacterObjectSettings.BookEnabledAsync("R5", token).ConfigureAwait(false))
                            {
                                if (objVehicle.IsDrone && await CharacterObjectSettings.GetDroneModsAsync(token)
                                        .ConfigureAwait(false))
                                {
                                    await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                    await lblVehiclePowertrain.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                                    await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                 .ConfigureAwait(false);
                                    await lblVehicleCosmetic.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                    await lblVehicleElectromagneticLabel
                                          .DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                                    await lblVehicleElectromagnetic.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                    await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                                    await lblVehicleBodymod.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                                    await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                    await lblVehicleWeaponsmod.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                                    await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                    await lblVehicleProtection.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                                    await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                      .ConfigureAwait(false);
                                    string strText
                                        = (await objVehicle.GetDroneModSlotsUsedAsync(token).ConfigureAwait(false)).ToString(
                                            GlobalSettings.CultureInfo) + "/"
                                                                        + (await objVehicle
                                                                            .GetDroneModSlotsAsync(token).ConfigureAwait(false))
                                                                        .ToString(GlobalSettings.CultureInfo);
                                    await lblVehicleDroneModSlots.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strText;
                                    }, token).ConfigureAwait(false);
                                }
                                else
                                {
                                    await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                   .ConfigureAwait(false);
                                    string strPowertrain = await objVehicle.PowertrainModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehiclePowertrain.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strPowertrain;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                 .ConfigureAwait(false);
                                    string strCosmetic = await objVehicle.CosmeticModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehicleCosmetic.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strCosmetic;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleElectromagneticLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                        .ConfigureAwait(false);
                                    string strElectromagnetic = await objVehicle.ElectromagneticModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehicleElectromagnetic.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strElectromagnetic;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                .ConfigureAwait(false);
                                    string strBodyMods = await objVehicle.BodyModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehicleBodymod.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strBodyMods;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                   .ConfigureAwait(false);
                                    string strWeapon = await objVehicle.WeaponModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehicleWeaponsmod.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strWeapon;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                   .ConfigureAwait(false);
                                    string strProtection = await objVehicle.ProtectionModSlotsUsedAsync(token: token).ConfigureAwait(false);
                                    await lblVehicleProtection.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strProtection;
                                    }, token).ConfigureAwait(false);
                                    await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                      .ConfigureAwait(false);
                                    await lblVehicleDroneModSlots.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                 .ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                await lblVehiclePowertrainLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehiclePowertrain.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblVehicleCosmeticLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                                await lblVehicleCosmetic.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                                await lblVehicleElectromagneticLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                    .ConfigureAwait(false);
                                await lblVehicleElectromagnetic.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleBodymodLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                                await lblVehicleBodymod.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                                await lblVehicleWeaponsmodLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleWeaponsmod.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblVehicleProtectionLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleProtection.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await lblVehicleDroneModSlotsLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                  .ConfigureAwait(false);
                                await lblVehicleDroneModSlots.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesMatrix
                            int intDeviceRating = await objVehicle.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblVehicleDevice
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await objVehicle.RefreshMatrixAttributeComboBoxesAsync(
                                                cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing,
                                                cboVehicleFirewall, token)
                                            .ConfigureAwait(false);
                            bool blnIsActiveCommlink = await objVehicle.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objVehicle.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objVehicle.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objVehicle.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                            token.ThrowIfCancellationRequested();
                            await UpdateSensor(objVehicle, token).ConfigureAwait(false);
                            break;
                        }
                        // Locate the selected VehicleMod.
                        case WeaponMount objWeaponMount:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteVehicle
                                  .DoThreadSafeAsync(x => x.Enabled = !objWeaponMount.IncludedInVehicle, token)
                                  .ConfigureAwait(false);
                            // gpbVehiclesCommon
                            string strCategory = await objWeaponMount.DisplayCategoryAsync(GlobalSettings.Language, token).ConfigureAwait(false);
                            await lblVehicleCategory
                                  .DoThreadSafeAsync(
                                      x => x.Text = strCategory, token)
                                  .ConfigureAwait(false);
                            string strName = await objWeaponMount.GetCurrentDisplayNameAsync(token)
                                                                 .ConfigureAwait(false);
                            await lblVehicleName
                                  .DoThreadSafeAsync(x => x.Text = strName, token)
                                  .ConfigureAwait(false);
                            await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                       .ConfigureAwait(false);
                            await nudVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                  .ConfigureAwait(false);
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            string strAvail = await objWeaponMount.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail
                                  .DoThreadSafeAsync(x => x.Text = strAvail, token)
                                  .ConfigureAwait(false);
                            string strCost = (await objWeaponMount.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                .ConfigureAwait(false);
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                            string strSlots = (await objWeaponMount.GetCalculatedSlotsAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strSlots;
                            }, token).ConfigureAwait(false);
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objWeaponMount.Equipped;
                                x.Enabled = !objWeaponMount.IncludedInVehicle;
                            }, token).ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = !objWeaponMount.IncludedInVehicle &&
                                                  (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                      (await CharacterObject
                                                          .LoadDataXPathAsync("vehicles.xml", token: token)
                                                          .ConfigureAwait(false))
                                                      .SelectSingleNodeAndCacheExpression(
                                                          "/chummer/weaponmountcategories", token: token),
                                                      token).ConfigureAwait(false))
                                    .Contains(objWeaponMount.Category);
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objWeaponMount.IncludedInVehicle
                                        ? objWeaponMount.Parent?.DiscountCost == true
                                        : objWeaponMount.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            break;
                        }
                        case VehicleMod objMod:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objMod.IncludedInVehicle, token)
                                                  .ConfigureAwait(false);
                            // gpbVehiclesCommon
                            string strName = await objMod.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token)
                                                .ConfigureAwait(false);
                            string strText = await LanguageManager
                                                   .GetStringAsync("String_VehicleModification", token: token)
                                                   .ConfigureAwait(false);
                            await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                    .ConfigureAwait(false);
                            int intMaxRating = await objMod.GetMaxRatingAsync(token).ConfigureAwait(false);
                            if (intMaxRating > 0)
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                    .ConfigureAwait(false);
                                int intRating = await objMod.GetRatingAsync(token).ConfigureAwait(false);
                                await nudVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Maximum = intMaxRating;
                                    x.Minimum = Math.Min(1, intMaxRating);
                                    x.Visible = true;
                                    x.Value = intRating;
                                    x.Increment = 1;
                                    x.Enabled = !objMod.IncludedInVehicle;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                                await nudVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Minimum = 0;
                                    x.Increment = 1;
                                    x.Maximum = 0;
                                    x.Enabled = false;
                                    x.Visible = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            string strAvail = await objMod.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objMod.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                .ConfigureAwait(false);
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                            string strSlots = (await objMod.GetCalculatedSlotsAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strSlots;
                            }, token).ConfigureAwait(false);
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objMod.Equipped;
                                x.Enabled = !objMod.IncludedInVehicle;
                            }, token).ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = !objMod.IncludedInVehicle &&
                                                  (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                      (await CharacterObject
                                                          .LoadDataXPathAsync(
                                                              "weapons.xml",
                                                              token: token)
                                                          .ConfigureAwait(false))
                                                      .SelectSingleNodeAndCacheExpression(
                                                          "/chummer/modcategories",
                                                          token: token), token).ConfigureAwait(false))
                                                  .Contains(objMod.Category);
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objMod.IncludedInVehicle
                                        ? (objMod.WeaponMountParent?.DiscountCost ?? objMod.Parent?.DiscountCost)
                                          == true
                                        : objMod.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            break;
                        }
                        case Weapon objWeapon:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objWeapon.Cyberware
                                                                         && objWeapon.Category != "Gear"
                                                                         && !objWeapon.IncludedInWeapon
                                                                         && string.IsNullOrEmpty(objWeapon.ParentID)
                                                                         && !objWeapon.Category.StartsWith(
                                                                             "Quality", StringComparison.Ordinal),
                                                                     token).ConfigureAwait(false);
                            // gpbVehiclesCommon
                            string strName = await objWeapon.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token)
                                                .ConfigureAwait(false);
                            string strText = await objWeapon.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                            .ConfigureAwait(false);
                            await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                    .ConfigureAwait(false);
                            int intRating = await objWeapon.GetRatingAsync(GenericToken).ConfigureAwait(false);
                            if (intRating > 0)
                            {
                                int intMaxRating = await objWeapon.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                                int intMinRating = await objWeapon.GetMinRatingValueAsync(token).ConfigureAwait(false);
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                    .ConfigureAwait(false);
                                await nudVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Minimum = Math.Min(intMinRating, intMaxRating);
                                    x.Maximum = intMaxRating;
                                    x.Value = intRating;
                                    x.Increment = 1;
                                    x.Enabled = intMaxRating > intMinRating && string.IsNullOrEmpty(objWeapon.ParentID);
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);
                                await nudVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = false;
                                    x.Minimum = 0;
                                    x.Maximum = 0;
                                    x.Increment = 1;
                                    x.Enabled = false;
                                }, token).ConfigureAwait(false);
                            }
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            string strAvail = await objWeapon.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objWeapon.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                .ConfigureAwait(false);
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                            string strMounts = await objWeapon.GetCurrentDisplayAccessoryMounts(token).ConfigureAwait(false);
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Text = strMounts;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);

                            token.ThrowIfCancellationRequested();
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objWeapon.Equipped;
                                x.Enabled = objWeapon.ParentID != objWeapon.Parent?.InternalId
                                            && objWeapon.ParentID
                                            != objWeapon.ParentVehicle.InternalId;
                            }, token).ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objWeapon.IncludedInWeapon;
                            }, token).ConfigureAwait(false);
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = !objWeapon.IncludedInWeapon &&
                                                  (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                      (await CharacterObject
                                                          .LoadDataXPathAsync(
                                                              "weapons.xml", token: token).ConfigureAwait(false))
                                                      .SelectSingleNodeAndCacheExpression(
                                                          "/chummer", token: token), token).ConfigureAwait(false))
                                    .Contains(objWeapon.Category);
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objWeapon.IncludedInWeapon
                                        ? objWeapon.Parent?.DiscountCost == true
                                        : objWeapon.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesWeapon
                            await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                             .ConfigureAwait(false);
                            string strDamage = await objWeapon.GetDisplayDamageAsync(token).ConfigureAwait(false);
                            await lblVehicleWeaponDamage.DoThreadSafeAsync(x =>
                            {
                                x.Text = strDamage;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);
                            await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                         .ConfigureAwait(false);
                            string strAP = await objWeapon.GetDisplayTotalAPAsync(token).ConfigureAwait(false);
                            await lblVehicleWeaponAP.DoThreadSafeAsync(x =>
                            {
                                x.Text = strAP;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);
                            await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                               .ConfigureAwait(false);
                            string strAccuracy = await objWeapon.GetDisplayAccuracyAsync(token).ConfigureAwait(false);
                            await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x =>
                            {
                                x.Text = strAccuracy;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);
                            await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                               .ConfigureAwait(false);
                            string strPool
                                = (await objWeapon.GetDicePoolAsync(token: token).ConfigureAwait(false)).ToString(
                                    GlobalSettings.CultureInfo);
                            await lblVehicleWeaponDicePool.DoThreadSafeAsync(x =>
                            {
                                x.Text = strPool;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);
                            await lblVehicleWeaponDicePool.SetToolTipTextAsync(await objWeapon.GetDicePoolTooltipAsync(token).ConfigureAwait(false), token)
                                                          .ConfigureAwait(false);
                            await lblVehicleWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                         .ConfigureAwait(false);
                            (string strRC, string strRCTooltip) = await objWeapon.GetDisplayTotalRCAsync(token).ConfigureAwait(false);
                            await lblVehicleWeaponRC.DoThreadSafeAsync(x =>
                            {
                                x.Text = strRC;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);
                            await lblVehicleWeaponRC.SetToolTipTextAsync(strRCTooltip, token).ConfigureAwait(false);
                            await lblVehicleWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                            string strReach
                                = (await objWeapon.GetTotalReachAsync(token).ConfigureAwait(false)).ToString(
                                    GlobalSettings.CultureInfo);
                            await lblVehicleWeaponReach.DoThreadSafeAsync(x =>
                            {
                                x.Text = strReach;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);
                            if (objWeapon.RangeType == "Ranged")
                            {
                                await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                               .ConfigureAwait(false);
                                string strAmmo = await objWeapon.GetDisplayAmmoAsync(token).ConfigureAwait(false);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strAmmo;
                                }, token).ConfigureAwait(false);
                                await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                               .ConfigureAwait(false);
                                string strMode = await objWeapon.GetDisplayModeAsync(token).ConfigureAwait(false);
                                await lblVehicleWeaponMode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Text = strMode;
                                }, token).ConfigureAwait(false);
                                await cboVehicleWeaponFiringMode
                                      .DoThreadSafeAsync(x => x.SelectedValue = objWeapon.FireMode, token)
                                      .ConfigureAwait(false);
                                await tlpVehiclesWeaponRanges.DoThreadSafeAsync(x => x.Visible = true, token)
                                                             .ConfigureAwait(false);
                                string strRange = await objWeapon.GetCurrentDisplayRangeAsync(token).ConfigureAwait(false);
                                await lblVehicleWeaponRangeMain
                                      .DoThreadSafeAsync(x => x.Text = strRange, token)
                                      .ConfigureAwait(false);
                                string strAltRange = await objWeapon.GetCurrentDisplayAlternateRangeAsync(token).ConfigureAwait(false);
                                await lblVehicleWeaponRangeAlternate
                                      .DoThreadSafeAsync(x => x.Text = strAltRange, token)
                                      .ConfigureAwait(false);
                                Dictionary<string, string> dicRanges
                                    = await objWeapon.GetRangeStringsAsync(GlobalSettings.CultureInfo, token: token)
                                                     .ConfigureAwait(false);
                                string strModifierShort = await objWeapon.RangeModifierAsync("Short", token).ConfigureAwait(false);
                                string strModifierMedium = await objWeapon.RangeModifierAsync("Medium", token).ConfigureAwait(false);
                                string strModifierLong = await objWeapon.RangeModifierAsync("Long", token).ConfigureAwait(false);
                                string strModifierExtreme = await objWeapon.RangeModifierAsync("Extreme", token).ConfigureAwait(false);
                                await lblVehicleWeaponRangeShortLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierShort, token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeMediumLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierMedium, token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeLongLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierLong, token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeExtremeLabel
                                      .DoThreadSafeAsync(x => x.Text = strModifierExtreme, token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeShort
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["short"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeMedium
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["medium"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeLong
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["long"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponRangeExtreme
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["extreme"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponAlternateRangeShort
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternateshort"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponAlternateRangeMedium
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternatemedium"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponAlternateRangeLong
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternatelong"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponAlternateRangeExtreme
                                      .DoThreadSafeAsync(x => x.Text = dicRanges["alternateextreme"], token)
                                      .ConfigureAwait(false);
                                await lblVehicleWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                                await lblVehicleWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            }
                            else
                            {
                                if (objWeapon.Ammo != "0")
                                {
                                    await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                   .ConfigureAwait(false);
                                    string strAmmo = await objWeapon.GetDisplayAmmoAsync(token).ConfigureAwait(false);
                                    await lblVehicleWeaponAmmo.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.Text = strAmmo;
                                    }, token).ConfigureAwait(false);
                                    await cboVehicleWeaponFiringMode.DoThreadSafeAsync(x =>
                                    {
                                        x.Visible = true;
                                        x.SelectedValue = objWeapon.FireMode;
                                    }, token).ConfigureAwait(false);
                                }
                                else
                                {
                                    await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                    await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                                    await cboVehicleWeaponFiringMode.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                    .ConfigureAwait(false);
                                }

                                token.ThrowIfCancellationRequested();
                                await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                                await tlpVehiclesWeaponRanges.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesMatrix
                            int intDeviceRating = await objWeapon.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblVehicleDevice
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await objWeapon.RefreshMatrixAttributeComboBoxesAsync(
                                               cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing,
                                               cboVehicleFirewall, token)
                                           .ConfigureAwait(false);
                            bool blnIsActiveCommlink = await objWeapon.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objWeapon.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objWeapon.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objWeapon.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                            break;
                        }
                        case WeaponAccessory objAccessory:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // Buttons
                            await cmdDeleteVehicle
                                  .DoThreadSafeAsync(x => x.Enabled = !objAccessory.IncludedInWeapon, token)
                                  .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesCommon
                            string strName = await objAccessory.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token)
                                                .ConfigureAwait(false);
                            string strText = await LanguageManager
                                                   .GetStringAsync("String_VehicleWeaponAccessory", token: token)
                                                   .ConfigureAwait(false);
                            await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                    .ConfigureAwait(false);
                            int intRating = await objAccessory.GetRatingAsync(GenericToken).ConfigureAwait(false);
                            if (intRating > 0)
                            {
                                int intMaxRating = await objAccessory.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                await nudVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Minimum = Math.Min(1, intMaxRating);
                                    x.Maximum = intMaxRating;
                                    x.Value = intRating;
                                    x.Increment = 1;
                                    x.Enabled = !objAccessory.IncludedInWeapon;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                                await nudVehicleRating.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            }

                            if (!string.IsNullOrEmpty(objAccessory.RC))
                            {
                                string strRCText = (await objAccessory.GetTotalRCAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblVehicleWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                                await lblVehicleWeaponRC.DoThreadSafeAsync(x =>
                                {
                                    x.Text = strRCText;
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await lblVehicleWeaponRCLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                                await lblVehicleWeaponRC.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            }

                            if (string.IsNullOrEmpty(objAccessory.Reach)) 
                            {
                                await lblVehicleWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                                await lblVehicleWeaponReach.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            }
                            else
                            {
                                string strReachText = (await objAccessory.GetTotalReachAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblVehicleWeaponReachLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                                await lblVehicleWeaponReach.DoThreadSafeAsync(x =>
                                {
                                    x.Text = strReachText;
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            string strAvail = await objAccessory.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objAccessory.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync(
                                                 "String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                .ConfigureAwait(false);
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                    .ConfigureAwait(false);
                            string strMountText;
                            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                        out StringBuilder sbdMount))
                            {
                                sbdMount.Append(await objAccessory.DisplayMountAsync(GlobalSettings.Language, token).ConfigureAwait(false));
                                if (!string.IsNullOrEmpty(objAccessory.ExtraMount) && objAccessory.ExtraMount != "None")
                                {
                                    bool boolHaveAddedItem = false;
                                    foreach (string strCurrentExtraMount in objAccessory.ExtraMount.SplitNoAlloc(
                                                 '/', StringSplitOptions.RemoveEmptyEntries))
                                    {
                                        if (!boolHaveAddedItem)
                                        {
                                            sbdMount.Append(strSpace, '+', strSpace);
                                            boolHaveAddedItem = true;
                                        }

                                        sbdMount.Append(await LanguageManager.GetStringAsync(
                                                                                 "String_Mount" + strCurrentExtraMount,
                                                                                 token: token)
                                                                             .ConfigureAwait(false), '/');
                                    }

                                    token.ThrowIfCancellationRequested();
                                    // Remove the trailing /
                                    if (boolHaveAddedItem)
                                        --sbdMount.Length;
                                }

                                if (!string.IsNullOrEmpty(objAccessory.AddMount))
                                {
                                    sbdMount.Append(strSpace, "(++", strSpace).Append(await LanguageManager.GetStringAsync(
                                                                                "String_Mount" + objAccessory.AddMount,
                                                                                token: token)
                                                                            .ConfigureAwait(false), ')');
                                }

                                strMountText = sbdMount.ToString();
                            }
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Text = strMountText;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);

                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Enabled = true;
                                x.Checked = objAccessory.Equipped;
                            }, token).ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Checked = objAccessory.IncludedInWeapon;
                            }, token).ConfigureAwait(false);
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = !objAccessory.IncludedInWeapon &&
                                                  (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                      (await CharacterObject
                                                          .LoadDataXPathAsync(
                                                              "weapons.xml", token: token).ConfigureAwait(false))
                                                      .SelectSingleNodeAndCacheExpression(
                                                          "/chummer", token: token), token).ConfigureAwait(false))
                                    .Contains(objAccessory.Parent.Category);
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objAccessory.IncludedInWeapon
                                        ? objAccessory.Parent?.DiscountCost == true
                                        : objAccessory.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            // gpbVehiclesWeapon
                            await lblVehicleWeaponModeLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            await lblVehicleWeaponMode.DoThreadSafeAsync(x => x.Visible = false, token)
                                                      .ConfigureAwait(false);
                            await cboVehicleWeaponFiringMode.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            if (string.IsNullOrEmpty(objAccessory.Damage))
                            {
                                await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                 .ConfigureAwait(false);
                                await lblVehicleWeaponDamage.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            }
                            else
                            {
                                string strDamageText = (await objAccessory.GetTotalDamageAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblVehicleWeaponDamageLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                .ConfigureAwait(false);
                                await lblVehicleWeaponDamage.DoThreadSafeAsync(x =>
                                {
                                    x.Text = strDamageText;
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            if (string.IsNullOrEmpty(objAccessory.AP))
                            {
                                await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                             .ConfigureAwait(false);
                                await lblVehicleWeaponAP.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            }
                            else
                            {
                                string strAPText = (await objAccessory.GetTotalAPAsync(token).ConfigureAwait(false)).ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblVehicleWeaponAPLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                            .ConfigureAwait(false);
                                await lblVehicleWeaponAP.DoThreadSafeAsync(x =>
                                {
                                    x.Text = strAPText;
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            if (string.IsNullOrEmpty(objAccessory.Accuracy))
                            {
                                await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                            }
                            else
                            {
                                string strAccuracyText = (await objAccessory.GetTotalAccuracyAsync(token).ConfigureAwait(false))
                                        .ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                await lblVehicleWeaponAccuracyLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                .ConfigureAwait(false);
                                await lblVehicleWeaponAccuracy.DoThreadSafeAsync(x =>
                                {
                                    x.Text = strAccuracyText;
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }

                            decimal decDicePool = await objAccessory.GetDicePoolAsync(token).ConfigureAwait(false);
                            if (decDicePool == 0)
                            {
                                await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                   .ConfigureAwait(false);
                                await lblVehicleWeaponDicePool.DoThreadSafeAsync(x => x.Visible = false, token)
                                                              .ConfigureAwait(false);
                            }
                            else
                            {
                                await lblVehicleWeaponDicePoolLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                                   .ConfigureAwait(false);
                                await lblVehicleWeaponDicePool.DoThreadSafeAsync(x =>
                                {
                                    x.Text
                                        = decDicePool.ToString("+#,0.##;-#,0.##;0.##", GlobalSettings.CultureInfo);
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                                await lblVehicleWeaponDicePool.SetToolTipTextAsync(string.Empty, token)
                                                              .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            decimal decAmmoBonus = await objAccessory.GetTotalAmmoBonusAsync(token).ConfigureAwait(false);
                            if (decAmmoBonus != 0
                                || (!string.IsNullOrEmpty(objAccessory.ModifyAmmoCapacity)
                                    && objAccessory.ModifyAmmoCapacity != "0"))
                            {
                                await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = true, token)
                                                          .ConfigureAwait(false);
                                using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                              out StringBuilder sbdAmmoBonus))
                                {
                                    if (decAmmoBonus != 0)
                                        sbdAmmoBonus.Append(
                                            (decAmmoBonus / 100.0m).ToString(
                                                "+#,0.##%;-#,0.##%;0.##%", GlobalSettings.CultureInfo));
                                    if (!string.IsNullOrEmpty(objAccessory.ModifyAmmoCapacity)
                                        && objAccessory.ModifyAmmoCapacity != "0")
                                        sbdAmmoBonus.Append(objAccessory.ModifyAmmoCapacity);
                                    await lblVehicleWeaponAmmo
                                          .DoThreadSafeAsync(x => x.Text = sbdAmmoBonus.ToString(), token)
                                          .ConfigureAwait(false);
                                }
                            }
                            else
                            {
                                await lblVehicleWeaponAmmoLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                               .ConfigureAwait(false);
                                await lblVehicleWeaponAmmo.DoThreadSafeAsync(x => x.Visible = false, token)
                                                          .ConfigureAwait(false);
                            }

                            break;
                        }
                        case Cyberware objCyberware:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteVehicle
                                  .DoThreadSafeAsync(x => x.Enabled = string.IsNullOrEmpty(objCyberware.ParentID),
                                                     token).ConfigureAwait(false);
                            // gpbVehiclesCommon
                            string strName = await objCyberware.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token)
                                                .ConfigureAwait(false);
                            string strText = await objCyberware.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                               .ConfigureAwait(false);
                            await lblVehicleCategory.DoThreadSafeAsync(x => x.Text = strText, token)
                                                    .ConfigureAwait(false);
                            int intMaxRating = await objCyberware.GetMaxRatingAsync(token).ConfigureAwait(false);
                            if (intMaxRating == 0)
                            {
                                await nudVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Maximum = 0;
                                    x.Minimum = 0;
                                    x.Value = 0;
                                    x.Visible = false;
                                }, token).ConfigureAwait(false);
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                           .ConfigureAwait(false);
                            }
                            else
                            {
                                int intMinRating = await objCyberware.GetMinRatingAsync(token).ConfigureAwait(false);
                                int intRating = await objCyberware.GetRatingAsync(token).ConfigureAwait(false);
                                await nudVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Maximum = intMaxRating;
                                    x.Minimum = intMinRating;
                                    x.Value = intRating;
                                    x.Enabled = intMaxRating > intMinRating
                                                && string.IsNullOrEmpty(objCyberware.ParentID);
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                           .ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                            await nudVehicleGearQty.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            string strAvail = await objCyberware.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objCyberware.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                .ConfigureAwait(false);
                            bool blnVisible = !string.IsNullOrEmpty(await objCyberware.GetPlugsIntoModularMountAsync(token).ConfigureAwait(false));
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = blnVisible, token).ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                    .ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = string.IsNullOrEmpty(objCyberware.ParentID)
                                                  && (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                      (await CharacterObject
                                                          .LoadDataXPathAsync(
                                                              objCyberware.SourceType
                                                              == Improvement.ImprovementSource
                                                                  .Cyberware
                                                                  ? "cyberware.xml"
                                                                  : "bioware.xml", token: token)
                                                          .ConfigureAwait(false))
                                                      .SelectSingleNodeAndCacheExpression(
                                                          "/chummer", token: token), token).ConfigureAwait(false))
                                                                 .Contains(objCyberware.Category);
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objCyberware.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesMatrix
                            int intDeviceRating = await objCyberware.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblVehicleDevice
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await objCyberware.RefreshMatrixAttributeComboBoxesAsync(
                                                  cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing,
                                                  cboVehicleFirewall, token)
                                              .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            bool blnIsActiveCommlink = await objCyberware.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objCyberware.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objCyberware.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objCyberware.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                            break;
                        }
                        case Gear objGear:
                        {
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = true, token)
                                                   .ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token)
                                                  .ConfigureAwait(false);
                            // gpbVehiclesCommon
                            string strName = await objGear.GetCurrentDisplayNameShortAsync(token).ConfigureAwait(false);
                            await lblVehicleName.DoThreadSafeAsync(x => x.Text = strName, token)
                                                .ConfigureAwait(false);
                            string strCategory = await objGear.GetCurrentDisplayCategoryAsync(token).ConfigureAwait(false);
                            await lblVehicleCategory
                                  .DoThreadSafeAsync(x => x.Text = strCategory,
                                                     token).ConfigureAwait(false);
                            int intGearMaxRatingValue = await objGear.GetMaxRatingValueAsync(token).ConfigureAwait(false);
                            if (intGearMaxRatingValue > 0 && intGearMaxRatingValue != int.MaxValue)
                            {
                                await lblVehicleRatingLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                           .ConfigureAwait(false);
                                int intRating = await objGear.GetRatingAsync(token).ConfigureAwait(false);
                                int intGearMinRatingValue = await objGear.GetMinRatingValueAsync(token).ConfigureAwait(false);
                                await nudVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Minimum = intGearMinRatingValue;
                                    x.Maximum = intGearMaxRatingValue;
                                    x.Value = intRating;
                                    x.Enabled = x.Maximum > x.Minimum && string.IsNullOrEmpty(objGear.ParentID);
                                    x.Visible = true;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await nudVehicleRating.DoThreadSafeAsync(x =>
                                {
                                    x.Minimum = 0;
                                    x.Maximum = 0;
                                    x.Visible = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await nudVehicleGearQty.DoThreadSafeAsync(x => x.Enabled = !objGear.IncludedInParent, token)
                                                   .ConfigureAwait(false);
                            if (objGear.Name.StartsWith("Nuyen", StringComparison.Ordinal))
                            {
                                int intDecimalPlaces = await CharacterObjectSettings.GetMaxNuyenDecimalsAsync(token).ConfigureAwait(false);
                                if (intDecimalPlaces <= 0)
                                {
                                    await nudVehicleGearQty.DoThreadSafeAsync(x =>
                                    {
                                        x.DecimalPlaces = 0;
                                        x.Minimum = 1.0m;
                                    }, token).ConfigureAwait(false);
                                }
                                else
                                {
                                    await nudVehicleGearQty
                                          .DoThreadSafeAsync(x => x.DecimalPlaces = intDecimalPlaces, token)
                                          .ConfigureAwait(false);
                                    decimal decMinimum = 1.0m;
                                    // Need a for loop instead of a power system to maintain exact precision
                                    for (int i = 0; i < intDecimalPlaces; ++i)
                                        decMinimum /= 10.0m;
                                    await nudVehicleGearQty.DoThreadSafeAsync(x => x.Minimum = decMinimum, token)
                                                           .ConfigureAwait(false);
                                }
                            }
                            else if (objGear.Category == "Currency")
                            {
                                await nudVehicleGearQty.DoThreadSafeAsync(x =>
                                {
                                    x.DecimalPlaces = 2;
                                    x.Minimum = 0.01m;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await nudVehicleGearQty.DoThreadSafeAsync(x =>
                                {
                                    x.DecimalPlaces = 0;
                                    x.Minimum = 1.0m;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            await nudVehicleGearQty.DoThreadSafeAsync(x =>
                            {
                                x.Value = objGear.Quantity;
                                x.Increment = objGear.CostFor;
                                x.Visible = true;
                            }, token).ConfigureAwait(false);
                            await lblVehicleGearQtyLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                            string strAvail = await objGear.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                            await lblVehicleAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                                 .ConfigureAwait(false);
                            string strCost = (await objGear.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                                 await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                 GlobalSettings.CultureInfo)
                                             + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                                    .ConfigureAwait(false);
                            await lblVehicleCost.DoThreadSafeAsync(x => x.Text = strCost, token)
                                                .ConfigureAwait(false);
                            await lblVehicleSlotsLabel.DoThreadSafeAsync(x => x.Visible = true, token)
                                                      .ConfigureAwait(false);
                            string strText2 = objGear.CalculatedCapacity + strSpace + "("
                                              + objGear.CapacityRemaining.ToString(
                                                  "#,0.##", GlobalSettings.CultureInfo) +
                                              strSpace + await LanguageManager
                                                               .GetStringAsync("String_Remaining", token: token)
                                                               .ConfigureAwait(false)
                                              + ")";
                            await lblVehicleSlots.DoThreadSafeAsync(x =>
                            {
                                x.Visible = true;
                                x.Text = strText2;
                            }, token).ConfigureAwait(false);
                            await cmdVehicleCyberwareChangeMount.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                .ConfigureAwait(false);
                            await chkVehicleWeaponAccessoryInstalled.DoThreadSafeAsync(x => x.Visible = false, token)
                                                                    .ConfigureAwait(false);
                            await chkVehicleIncludedInWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                            .ConfigureAwait(false);
                            token.ThrowIfCancellationRequested();
                            if (await CharacterObject.GetBlackMarketDiscountAsync(token).ConfigureAwait(false))
                            {
                                bool blnEnabled = !objGear.IncludedInParent &&
                                                  (await CharacterObject.GenerateBlackMarketMappingsAsync(
                                                      (await CharacterObject
                                                          .LoadDataXPathAsync(
                                                              "gear.xml", token: token)
                                                          .ConfigureAwait(false))
                                                      .SelectSingleNodeAndCacheExpression(
                                                          "/chummer", token: token), token).ConfigureAwait(false))
                                                                               .Contains(objGear.Category);
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = blnEnabled;
                                    x.Checked = objGear.IncludedInParent
                                        ? (objGear.Parent as ICanBlackMarketDiscount)?.DiscountCost == true
                                        : objGear.DiscountCost;
                                }, token).ConfigureAwait(false);
                            }
                            else
                            {
                                await chkVehicleBlackMarketDiscount.DoThreadSafeAsync(x =>
                                {
                                    x.Enabled = false;
                                    x.Checked = false;
                                }, token).ConfigureAwait(false);
                            }

                            token.ThrowIfCancellationRequested();
                            // gpbVehiclesMatrix
                            int intDeviceRating = await objGear.GetTotalMatrixAttributeAsync("Device Rating", token).ConfigureAwait(false);
                            await lblVehicleDevice
                                  .DoThreadSafeAsync(x => x.Text = intDeviceRating.ToString(GlobalSettings.CultureInfo),
                                                     token).ConfigureAwait(false);
                            await objGear.RefreshMatrixAttributeComboBoxesAsync(
                                             cboVehicleAttack, cboVehicleSleaze, cboVehicleDataProcessing,
                                             cboVehicleFirewall, token)
                                         .ConfigureAwait(false);

                            bool blnIsActiveCommlink = await objGear.IsActiveCommlinkAsync(CharacterObject, token).ConfigureAwait(false);
                            bool blnIsCommlink = await objGear.GetIsCommlinkAsync(token).ConfigureAwait(false);
                            if (await CharacterObject.GetIsAIAsync(token).ConfigureAwait(false))
                            {
                                bool blnIsHomeNode = await objGear.IsHomeNodeAsync(CharacterObject, token).ConfigureAwait(false);
                                bool blnCanBeHomeNode = blnIsCommlink &&
                                                        await objGear.GetTotalMatrixAttributeAsync(
                                                            "Program Limit", token).ConfigureAwait(false) >=
                                                        (await (await CharacterObject.GetAttributeAsync("DEP",
                                                            token: token).ConfigureAwait(false)).GetTotalValueAsync(token).ConfigureAwait(false) > intDeviceRating
                                                            ? 2
                                                            : 1);
                                await chkVehicleHomeNode.DoThreadSafeAsync(x =>
                                {
                                    x.Visible = true;
                                    x.Checked = blnIsHomeNode;
                                    x.Enabled = blnCanBeHomeNode;
                                }, token).ConfigureAwait(false);
                            }
                            else
                                await chkVehicleHomeNode.DoThreadSafeAsync(x => x.Visible = false, token)
                                    .ConfigureAwait(false);

                            await chkVehicleActiveCommlink.DoThreadSafeAsync(x =>
                            {
                                x.Checked = blnIsActiveCommlink;
                                x.Visible = blnIsCommlink;
                            }, token).ConfigureAwait(false);

                            break;
                        }
                        default:
                            await gpbVehiclesCommon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesVehicle.DoThreadSafeAsync(x => x.Visible = false, token)
                                                    .ConfigureAwait(false);
                            await gpbVehiclesWeapon.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            await gpbVehiclesMatrix.DoThreadSafeAsync(x => x.Visible = false, token)
                                                   .ConfigureAwait(false);
                            // Buttons
                            await cmdDeleteVehicle.DoThreadSafeAsync(x => x.Enabled = false, token)
                                                  .ConfigureAwait(false);
                            break;
                    }
                }
                finally
                {
                    await flpVehicles.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the currently-selected Drug.
        /// </summary>
        private async Task RefreshSelectedDrug(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await flpDrugs.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    TreeNode objSelectedNode = await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                                   .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag is Drug objDrug && objSelectedNode.Level != 0)
                    {
                        await flpDrugs.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await btnDeleteCustomDrug.DoThreadSafeAsync(x => x.Enabled = true, token).ConfigureAwait(false);
                        string strName = await objDrug.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                        await lblDrugName.DoThreadSafeAsync(x => x.Text = strName, token).ConfigureAwait(false);
                        string strAvail = await objDrug.GetDisplayTotalAvailAsync(token).ConfigureAwait(false);
                        await lblDrugAvail.DoThreadSafeAsync(x => x.Text = strAvail, token)
                                          .ConfigureAwait(false);
                        string strGradeName
                            = await objDrug.Grade.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                        await lblDrugGrade.DoThreadSafeAsync(x => x.Text = strGradeName, token)
                                          .ConfigureAwait(false);
                        string strCost = (await objDrug.GetTotalCostAsync(token).ConfigureAwait(false)).ToString(
                                             await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                             GlobalSettings.CultureInfo)
                                         + await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token).ConfigureAwait(false);
                        await lblDrugCost.DoThreadSafeAsync(x => x.Text
                                                                = strCost,
                                                            token).ConfigureAwait(false);
                        await nudDrugQty.DoThreadSafeAsync(x =>
                        {
                            x.Value = objDrug.Quantity;
                            x.Visible = true;
                            x.Enabled = true;
                        }, token).ConfigureAwait(false);
                        string strCategory = await objDrug.DisplayCategoryAsync(GlobalSettings.Language, token).ConfigureAwait(false);
                        await lblDrugCategory.DoThreadSafeAsync(x => x.Text = strCategory, token)
                                             .ConfigureAwait(false);
                        string strAddictionRating = (await objDrug.GetAddictionRatingAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                        await lblDrugAddictionRating
                              .DoThreadSafeAsync(
                                  x => x.Text = strAddictionRating, token)
                              .ConfigureAwait(false);
                        string strAddictionThreshold = (await objDrug.GetAddictionThresholdAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                        await lblDrugAddictionThreshold
                              .DoThreadSafeAsync(
                                  x => x.Text = strAddictionThreshold, token)
                              .ConfigureAwait(false);
                        string strText = await objDrug.GetEffectDescriptionAsync(token).ConfigureAwait(false);
                        await lblDrugEffect.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                        using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                      out StringBuilder sbdComponents))
                        {
                            await objDrug.Components.ForEachAsync(async objComponent =>
                            {
                                sbdComponents.AppendLine(
                                    await objComponent.GetCurrentDisplayNameAsync(token).ConfigureAwait(false));
                            }, token).ConfigureAwait(false);
                            string strComponents = sbdComponents.ToString();
                            await lblDrugComponents.DoThreadSafeAsync(x => x.Text = strComponents, token)
                                                   .ConfigureAwait(false);
                        }
                    }
                    else
                    {
                        await flpDrugs.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await btnDeleteCustomDrug
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await flpDrugs.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently selected Spell
        /// </summary>
        private async Task RefreshSelectedSpell(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await gpbMagicianSpell.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    TreeNode objSelectedNode = await treSpells.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                              .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag is Spell objSpell && objSelectedNode.Level > 0)
                    {
                        await gpbMagicianSpell.DoThreadSafeAsync(x => x.Visible = true, token).ConfigureAwait(false);
                        await cmdDeleteSpell.DoThreadSafeAsync(x => x.Enabled = objSpell.Grade == 0, token)
                                            .ConfigureAwait(false);
                        string strText = await objSpell.DisplayDescriptorsAsync(GlobalSettings.Language, token)
                                                       .ConfigureAwait(false);
                        if (string.IsNullOrEmpty(strText))
                            strText = await LanguageManager.GetStringAsync("String_None", token: token)
                                                           .ConfigureAwait(false);
                        await lblSpellDescriptors.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                        string strText2 = await objSpell.DisplayCategoryAsync(GlobalSettings.Language, token)
                                                        .ConfigureAwait(false);
                        await lblSpellCategory.DoThreadSafeAsync(x => x.Text = strText2, token).ConfigureAwait(false);
                        string strText3 = await objSpell.DisplayTypeAsync(GlobalSettings.Language, token)
                                                        .ConfigureAwait(false);
                        await lblSpellType.DoThreadSafeAsync(x => x.Text = strText3, token).ConfigureAwait(false);
                        string strText4 = await objSpell.DisplayRangeAsync(GlobalSettings.Language, token)
                                                        .ConfigureAwait(false);
                        await lblSpellRange.DoThreadSafeAsync(x => x.Text = strText4, token).ConfigureAwait(false);
                        string strText5 = await objSpell.DisplayDamageAsync(GlobalSettings.Language, GlobalSettings.CultureInfo, token)
                                                        .ConfigureAwait(false);
                        await lblSpellDamage.DoThreadSafeAsync(x => x.Text = strText5, token).ConfigureAwait(false);
                        string strText6 = await objSpell.DisplayDurationAsync(GlobalSettings.Language, token)
                                                        .ConfigureAwait(false);
                        await lblSpellDuration.DoThreadSafeAsync(x => x.Text = strText6, token).ConfigureAwait(false);
                        string strText7 = await objSpell.DisplayDvAsync(GlobalSettings.Language, token)
                                                        .ConfigureAwait(false);
                        await lblSpellDV.DoThreadSafeAsync(x => x.Text = strText7, token).ConfigureAwait(false);
                        await lblSpellDV.SetToolTipTextAsync(await objSpell.GetDvTooltipAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                        await objSpell.SetSourceDetailAsync(lblSpellSource, token).ConfigureAwait(false);
                        // Determine the size of the Spellcasting Dice Pool.
                        int intPool = await objSpell.GetDicePoolAsync(token).ConfigureAwait(false);
                        await lblSpellDicePool
                              .DoThreadSafeAsync(x => x.Text = intPool.ToString(GlobalSettings.CultureInfo),
                                                 token).ConfigureAwait(false);
                        await lblSpellDicePool.SetToolTipTextAsync(await objSpell.GetDicePoolTooltipAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                    }
                    else
                    {
                        await gpbMagicianSpell.DoThreadSafeAsync(x => x.Visible = false, token).ConfigureAwait(false);
                        await cmdDeleteSpell.DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                                            .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await gpbMagicianSpell.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Refresh the information for the currently selected Complex Form.
        /// </summary>
        private async Task RefreshSelectedComplexForm(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IsRefreshing = true;
            try
            {
                await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.SuspendLayout(), token).ConfigureAwait(false);
                try
                {
                    TreeNode objSelectedNode = await treComplexForms.DoThreadSafeFuncAsync(x => x.SelectedNode, token)
                                                                    .ConfigureAwait(false);
                    object objSelectedNodeTag = objSelectedNode?.Tag;
                    if (objSelectedNodeTag is ComplexForm objComplexForm && objSelectedNode.Level > 0)
                    {
                        await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.Visible = true, token)
                                                        .ConfigureAwait(false);
                        await cmdDeleteComplexForm.DoThreadSafeAsync(x => x.Enabled = objComplexForm.Grade == 0, token)
                                                  .ConfigureAwait(false);
                        string strText = await objComplexForm.DisplayTargetAsync(GlobalSettings.Language, token)
                                                             .ConfigureAwait(false);
                        await lblTarget.DoThreadSafeAsync(x => x.Text = strText, token).ConfigureAwait(false);
                        string strText2 = await objComplexForm.DisplayDurationAsync(GlobalSettings.Language, token)
                                                              .ConfigureAwait(false);
                        await lblDuration.DoThreadSafeAsync(x => x.Text = strText2, token).ConfigureAwait(false);
                        string strText3 = await objComplexForm.DisplayFvAsync(GlobalSettings.Language, token)
                                                              .ConfigureAwait(false);
                        await lblFV.DoThreadSafeAsync(x => x.Text = strText3, token).ConfigureAwait(false);
                        await lblFV.SetToolTipTextAsync(await objComplexForm.GetFvTooltipAsync(token).ConfigureAwait(false), token).ConfigureAwait(false);
                        await objComplexForm.SetSourceDetailAsync(lblComplexFormSource, token).ConfigureAwait(false);
                        // Determine the size of the Threading Dice Pool.
                        string strDicePool = (await objComplexForm.GetDicePoolAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo);
                        await lblComplexFormDicePool
                              .DoThreadSafeAsync(
                                  x => x.Text = strDicePool, token)
                              .ConfigureAwait(false);
                        await lblComplexFormDicePool.SetToolTipTextAsync(await objComplexForm.GetDicePoolTooltipAsync(token).ConfigureAwait(false), token)
                                                    .ConfigureAwait(false);
                    }
                    else
                    {
                        await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.Visible = false, token)
                                                        .ConfigureAwait(false);
                        await cmdDeleteComplexForm
                              .DoThreadSafeAsync(x => x.Enabled = objSelectedNodeTag is ICanRemove, token)
                              .ConfigureAwait(false);
                    }
                }
                finally
                {
                    await gpbTechnomancerComplexForm.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken)
                                                    .ConfigureAwait(false);
                }
            }
            finally
            {
                IsRefreshing = false;
            }
        }

        /// <summary>
        /// Add or remove the Adapsin Cyberware Grade categories.
        /// </summary>
        public async Task PopulateCyberwareGradeList(bool blnBioware = false,
                                                     ICollection<string> setDisallowedGrades = null,
                                                     string strForceGrade = "", CancellationToken token = default)
        {
            if (setDisallowedGrades == null)
                setDisallowedGrades = Array.Empty<string>();
            List<Grade> objGradeList = await CharacterObject
                                             .GetGradesListAsync(
                                                 blnBioware
                                                     ? Improvement.ImprovementSource.Bioware
                                                     : Improvement.ImprovementSource.Cyberware, token: token)
                                             .ConfigureAwait(false);
            using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(Utils.ListItemListPool,
                                                           out List<ListItem> lstCyberwareGrades))
            {
                foreach (Grade objWareGrade in objGradeList)
                {
                    if (objWareGrade.Name == "None" && (string.IsNullOrEmpty(strForceGrade) || strForceGrade != "None"))
                        continue;
                    if (setDisallowedGrades.Contains(objWareGrade.Name))
                        continue;
                    if (blnBioware)
                    {
                        if (objWareGrade.Adapsin)
                            continue;

                        if (objWareGrade.Name.ContainsAny((await ImprovementManager
                                                                 .GetCachedImprovementListForValueOfAsync(
                                                                     CharacterObject,
                                                                     Improvement.ImprovementType
                                                                         .DisableBiowareGrade, token: token)
                                                                 .ConfigureAwait(false)).Select(x => x.ImprovedName)))
                            continue;
                    }
                    else
                    {
                        if (CharacterObject.AdapsinEnabled)
                        {
                            if (!objWareGrade.Adapsin
                                && objWareGrade.Name.ContainsAny(
                                    objGradeList.Where(x => x.Adapsin).Select(x => x.Name)))
                            {
                                continue;
                            }
                        }
                        else if (objWareGrade.Adapsin)
                            continue;

                        if (objWareGrade.Name.ContainsAny((await ImprovementManager
                                                                 .GetCachedImprovementListForValueOfAsync(
                                                                     CharacterObject,
                                                                     Improvement.ImprovementType
                                                                         .DisableCyberwareGrade, token: token)
                                                                 .ConfigureAwait(false)).Select(x => x.ImprovedName)))
                            continue;
                    }

                    if (CharacterObject.BurnoutsWayEnabled)
                    {
                        if (!objWareGrade.Burnout
                            && objWareGrade.Name.ContainsAny(objGradeList.Where(x => x.Burnout).Select(x => x.Name)))
                        {
                            continue;
                        }
                    }
                    else if (objWareGrade.Burnout)
                        continue;

                    if (objWareGrade.Name.ContainsAny(CharacterObjectSettings.BannedWareGrades)
                        && !CharacterObject.IgnoreRules)
                        continue;

                    if (!await (await objWareGrade.GetNodeXPathAsync(token).ConfigureAwait(false)).RequirementsMetAsync(
                            CharacterObject, token: token).ConfigureAwait(false))
                    {
                        continue;
                    }

                    lstCyberwareGrades.Add(new ListItem(objWareGrade.Name,
                                                        await objWareGrade.GetCurrentDisplayNameAsync(token)
                                                                          .ConfigureAwait(false)));
                }

                await cboCyberwareGrade.PopulateWithListItemsAsync(lstCyberwareGrades, token).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Check the character and determine if it has broken any of the rules.
        /// </summary>
        public async Task<bool> CheckCharacterValidity(bool blnUseArgBuildPoints = false, int intBuildPoints = 0,
                                                            CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (await CharacterObject.GetIgnoreRulesAsync(token).ConfigureAwait(false))
                return true;

            bool blnValid = true;
            using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                          out StringBuilder sbdMessage))
            {
                CursorWait objCursorWait = await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
                try
                {
                    // Check if the character has more than 1 Martial Art, not counting qualities.
                    int intMartialArts = await (await CharacterObject.GetMartialArtsAsync(token).ConfigureAwait(false))
                                               .CountAsync(objArt => !objArt.IsQuality, token).ConfigureAwait(false);
                    int intMaximumMartialArts = await CharacterObjectSettings.GetMaximumMartialArtsAsync(token).ConfigureAwait(false);
                    if (intMartialArts > intMaximumMartialArts)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .AppendFormat(GlobalSettings.CultureInfo,
                                                await LanguageManager
                                                      .GetStringAsync("Message_InvalidPointExcess", token: token)
                                                      .ConfigureAwait(false),
                                                intMartialArts - intMaximumMartialArts)
                                  .Append(await LanguageManager.GetStringAsync("String_Space", token: token)
                                                               .ConfigureAwait(false))
                                  .Append(await LanguageManager.GetStringAsync("String_MartialArtsCount", token: token)
                                                               .ConfigureAwait(false));
                    }

                    // Check if the character has more than 5 Techniques in a Martial Art
                    if (await (await CharacterObject.GetMartialArtsAsync(token).ConfigureAwait(false))
                              .AnyAsync(token).ConfigureAwait(false))
                    {
                        int intTechniques
                            = await (await CharacterObject.GetMartialArtsAsync(token).ConfigureAwait(false)).SumAsync(
                                x => x.Techniques.GetCountAsync(token), token).ConfigureAwait(false);
                        int intMaximumMartialArtsTechniques = await CharacterObjectSettings.GetMaximumMartialTechniquesAsync(token).ConfigureAwait(false);
                        if (intTechniques > intMaximumMartialArtsTechniques)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t')
                                      .AppendFormat(GlobalSettings.CultureInfo,
                                                    await LanguageManager
                                                          .GetStringAsync("Message_InvalidPointExcess", token: token)
                                                          .ConfigureAwait(false),
                                                    intTechniques - intMaximumMartialArtsTechniques)
                                      .Append(await LanguageManager.GetStringAsync("String_Space", token: token)
                                                                   .ConfigureAwait(false))
                                      .Append(await LanguageManager
                                                    .GetStringAsync("String_TechniquesCount", token: token)
                                                    .ConfigureAwait(false));
                        }
                    }

                    int intQualityKarmaLimit = await CharacterObjectSettings.GetQualityKarmaLimitAsync(token).ConfigureAwait(false);
                    // if positive points > 25
                    if (await CharacterObject.GetPositiveQualityLimitKarmaAsync(token).ConfigureAwait(false) > intQualityKarmaLimit
                        && !await CharacterObjectSettings.GetExceedPositiveQualitiesAsync(token).ConfigureAwait(false))
                    {
                        sbdMessage.AppendLine().Append('\t').AppendFormat(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync("Message_PositiveQualityLimit", token: token)
                                                 .ConfigureAwait(false),
                            intQualityKarmaLimit);
                        blnValid = false;
                    }

                    // if negative points > 25
                    if (await CharacterObject.GetNegativeQualityLimitKarmaAsync(token).ConfigureAwait(false) > intQualityKarmaLimit
                        && !await CharacterObjectSettings.GetExceedNegativeQualitiesAsync(token).ConfigureAwait(false))
                    {
                        sbdMessage.AppendLine().Append('\t').AppendFormat(
                            GlobalSettings.CultureInfo,
                            await LanguageManager.GetStringAsync("Message_NegativeQualityLimit", token: token)
                                                 .ConfigureAwait(false),
                            intQualityKarmaLimit);
                        blnValid = false;
                    }

                    if (await CharacterObject.GetFriendsInHighPlacesAsync(token).ConfigureAwait(false))
                    {
                        ThreadSafeObservableCollection<Contact> lstContacts
                            = await CharacterObject.GetContactsAsync(token).ConfigureAwait(false);
                        // If we have Friends in High Places, then we need to account for any mixture of Friends in High Places plus contact karma discounts (e.g. from Massive Network)
                        if (await lstContacts.AnyAsync(async x => await x.GetConnectionAsync(token).ConfigureAwait(false) < 8 && await x.GetContactPointsAsync(token).ConfigureAwait(false) > 7, token)
                                             .ConfigureAwait(false)
                            // With Friends in High Places, we can only have "too high contacts" if we overspend our Friends in High Places karma on eligible contacts
                            || await lstContacts
                                     .SumAsync(async x => await x.GetConnectionAsync(token).ConfigureAwait(false) >= 8 && await x.GetContactPointsAsync(token).ConfigureAwait(false) > 7,
                                               x => x.GetContactPointsAsync(token), token).ConfigureAwait(false)
                            > 4 * await (await CharacterObject.GetAttributeAsync("CHA", token: token)
                                                              .ConfigureAwait(false)).GetValueAsync(token)
                                .ConfigureAwait(false))
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t')
                                      .Append(await LanguageManager.GetStringAsync("Message_HighContact", token: token)
                                                                   .ConfigureAwait(false));
                        }
                    }
                    else if (await (await CharacterObject.GetContactsAsync(token).ConfigureAwait(false))
                                   .AnyAsync(async x => await x.GetContactPointsAsync(token).ConfigureAwait(false) > 7, token).ConfigureAwait(false))
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .Append(await LanguageManager.GetStringAsync("Message_HighContact", token: token)
                                                               .ConfigureAwait(false));
                    }

                    // Check if the character has gone over the Build Point total.
                    if (!blnUseArgBuildPoints)
                        intBuildPoints = await CalculateBPandRefreshBPDisplays(false, token).ConfigureAwait(false);
                    int intStagedPurchaseQualityPoints
                        = await (await CharacterObject.GetQualitiesAsync(token).ConfigureAwait(false))
                                .SumAsync(async objQuality =>
                                              objQuality.StagedPurchase
                                              && await objQuality.GetTypeAsync(token).ConfigureAwait(false) == QualityType.Positive
                                              && await objQuality.GetContributeToBPAsync(token).ConfigureAwait(false),
                                          x => x.GetBPAsync(token), token).ConfigureAwait(false);
                    if (intBuildPoints + intStagedPurchaseQualityPoints < 0 && !_blnFreestyle)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .AppendFormat(GlobalSettings.CultureInfo,
                                                await LanguageManager
                                                      .GetStringAsync("Message_InvalidPointExcess", token: token)
                                                      .ConfigureAwait(false),
                                                -(intBuildPoints + intStagedPurchaseQualityPoints))
                                  .Append(await LanguageManager.GetStringAsync("String_Space", token: token)
                                                               .ConfigureAwait(false))
                                  .Append(await LanguageManager.GetStringAsync("String_Karma", token: token)
                                                               .ConfigureAwait(false));
                    }

                    // if character has more than permitted Metagenic qualities
                    int intMetagenicLimit = await CharacterObject.GetMetagenicLimitAsync(token).ConfigureAwait(false);
                    if (intMetagenicLimit > 0)
                    {
                        int intMetagenicNegativeQualityKarma =
                            await CharacterObject.GetMetagenicNegativeQualityKarmaAsync(token).ConfigureAwait(false);
                        if (-intMetagenicNegativeQualityKarma > intMetagenicLimit)
                        {
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager
                                      .GetStringAsync("Message_OverNegativeMetagenicQualities", token: token)
                                      .ConfigureAwait(false),
                                -intMetagenicNegativeQualityKarma, intMetagenicLimit);
                            blnValid = false;
                        }

                        int intMetagenicPositiveQualityKarma =
                            await CharacterObject.GetMetagenicPositiveQualityKarmaAsync(token).ConfigureAwait(false);
                        if (intMetagenicPositiveQualityKarma > intMetagenicLimit)
                        {
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager
                                      .GetStringAsync("Message_OverPositiveMetagenicQualities", token: token)
                                      .ConfigureAwait(false),
                                intMetagenicPositiveQualityKarma, intMetagenicLimit);
                            blnValid = false;
                        }

                        if (-intMetagenicNegativeQualityKarma != intMetagenicPositiveQualityKarma &&
                            -intMetagenicNegativeQualityKarma != intMetagenicPositiveQualityKarma - 1)
                        {
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager
                                      .GetStringAsync("Message_MetagenicQualitiesUnbalanced", token: token)
                                      .ConfigureAwait(false),
                                -intMetagenicNegativeQualityKarma,
                                intMetagenicPositiveQualityKarma - 1,
                                intMetagenicPositiveQualityKarma);
                            blnValid = false;
                        }
                    }

                    AttributeSection objAttributeSection
                        = await CharacterObject.GetAttributeSectionAsync(token).ConfigureAwait(false);
                    ThreadSafeObservableCollection<CharacterAttrib> lstAttributes
                        = await objAttributeSection.GetAttributeListAsync(token).ConfigureAwait(false);
                    // Check if the character has more attributes at their metatype max than allowed
                    int intMaxNumberMaxAttributesCreate =
                        await CharacterObjectSettings.GetMaxNumberMaxAttributesCreateAsync(token).ConfigureAwait(false);
                    if (intMaxNumberMaxAttributesCreate
                        < await lstAttributes.GetCountAsync(token)
                            .ConfigureAwait(false))
                    {
                        int intCountAttributesAtMax
                            = await lstAttributes.CountAsync(
                                                     async x => x.MetatypeCategory
                                                                == AttributeCategory.Standard
                                                                && await x.GetAtMetatypeMaximumAsync(token)
                                                                          .ConfigureAwait(false), token)
                                                 .ConfigureAwait(false);
                        if (intCountAttributesAtMax > intMaxNumberMaxAttributesCreate)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                              await LanguageManager.GetStringAsync(
                                                                                  "Message_TooManyAttributesAtMax",
                                                                                  token: token).ConfigureAwait(false),
                                                                              intCountAttributesAtMax,
                                                                              intMaxNumberMaxAttributesCreate);
                        }
                    }

                    int i = CharacterObject.TotalAttributes
                            - await CalculateAttributePriorityPoints(lstAttributes, token: token).ConfigureAwait(false);
                    // Check if the character has gone over on Primary Attributes
                    if (i < 0)
                    {
                        //TODO: ATTACH TO ATTRIBUTE SECTION
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidAttributeExcess",
                                                                              token: token).ConfigureAwait(false), -i);
                    }

                    ThreadSafeObservableCollection<CharacterAttrib> lstSpecialAttributes
                        = await objAttributeSection.GetSpecialAttributeListAsync(token).ConfigureAwait(false);
                    i = await CharacterObject.GetTotalSpecialAsync(token).ConfigureAwait(false)
                        - await CalculateAttributePriorityPoints(lstSpecialAttributes, token: token)
                            .ConfigureAwait(false);
                    // Check if the character has gone over on Special Attributes
                    if (i < 0)
                    {
                        //TODO: ATTACH TO ATTRIBUTE SECTION
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidSpecialExcess",
                                                                              token: token).ConfigureAwait(false), -i);
                    }

                    // Check if the character has gone over on Skill Groups
                    SkillsSection objSkillsSection
                        = await CharacterObject.GetSkillsSectionAsync(token).ConfigureAwait(false);
                    int intSkillGroupPoints = await objSkillsSection.GetSkillGroupPointsAsync(token)
                                                                    .ConfigureAwait(false);
                    if (intSkillGroupPoints < 0)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidSkillGroupExcess",
                                                                              token: token).ConfigureAwait(false),
                                                                          -intSkillGroupPoints);
                    }

                    // Check if the character has gone over on Active Skills
                    int intSkillPoints = await objSkillsSection.GetSkillPointsAsync(token)
                                                               .ConfigureAwait(false);
                    if (intSkillPoints < 0)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidActiveSkillExcess",
                                                                              token: token).ConfigureAwait(false),
                                                                          -intSkillPoints);
                    }

                    // Check if the character has gone over on Knowledge Skills
                    int intKnoSkillPoints = await objSkillsSection
                                                  .GetKnowledgeSkillPointsRemainAsync(token)
                                                  .ConfigureAwait(false);
                    if (intKnoSkillPoints < 0)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidKnowledgeSkillExcess",
                                                                              token: token).ConfigureAwait(false),
                                                                          -intKnoSkillPoints);
                    }

                    ThreadSafeBindingList<Skill> lstSkills
                        = await objSkillsSection.GetSkillsAsync(token).ConfigureAwait(false);
                    if (await lstSkills
                              .AnyAsync(
                                  async s => await s.Specializations.GetCountAsync(token)
                                                    .ConfigureAwait(false) > 1, token)
                              .ConfigureAwait(false))
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').Append(await LanguageManager.GetStringAsync(
                                                                        "Message_InvalidActiveSkillExcessSpecializations",
                                                                        token: token).ConfigureAwait(false));
                        await lstSkills.ForEachAsync(async objSkill =>
                        {
                            ThreadSafeObservableCollection<SkillSpecialization> lstSpecs
                                = await objSkill.GetSpecializationsAsync(token).ConfigureAwait(false);
                            if (await lstSpecs.GetCountAsync(token).ConfigureAwait(false) < 1)
                                return;
                            (await sbdMessage.AppendLine()
                                             .Append(await objSkill.GetCurrentDisplayNameAsync(token)
                                                                   .ConfigureAwait(false),
                                                                   await LanguageManager.GetStringAsync("String_Space", token: token)
                                                                          .ConfigureAwait(false), '(')
                                             .AppendJoinAsync(
                                                 "," + await LanguageManager.GetStringAsync(
                                                     "String_Space", token: token).ConfigureAwait(false),
                                                 lstSpecs.Select(
                                                     x => x.GetCurrentDisplayNameAsync(token)), token)
                                             .ConfigureAwait(false))
                                .Append(')');
                        }, token).ConfigureAwait(false);
                    }

                    // Check if the character has gone over the Nuyen limit.
                    (decimal decNuyen, decimal decStolenNuyen) = await CharacterObject.CalculateNuyenCreateModeAsync(token).ConfigureAwait(false);
                    if (decNuyen < 0)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .AppendFormat(GlobalSettings.CultureInfo,
                                                await LanguageManager
                                                      .GetStringAsync("Message_InvalidNuyenExcess", token: token)
                                                      .ConfigureAwait(false),
                                                (-decNuyen).ToString(await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                                     GlobalSettings.CultureInfo))
                                  .Append(await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                               .ConfigureAwait(false));
                    }
                    if (decStolenNuyen < 0)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                          await LanguageManager.GetStringAsync(
                                                                              "Message_InvalidStolenNuyenExcess",
                                                                              token: token).ConfigureAwait(false),
                                                                          (-decStolenNuyen).ToString(
                                                                              await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                                                              GlobalSettings.CultureInfo))
                                  .Append(await LanguageManager.GetStringAsync("String_NuyenSymbol", token: token)
                                                               .ConfigureAwait(false));
                    }

                    // Check if the character's Essence is above 0.
                    if (await (await CharacterObject.GetAttributeAsync("ESS", token: token).ConfigureAwait(false))
                              .GetMetatypeMaximumAsync(token).ConfigureAwait(false) > 0)
                    {
                        decimal decEss = await CharacterObject.EssenceAsync(token: token).ConfigureAwait(false);
                        decimal decExcessEss = 0.0m;
                        // Need to split things up this way because without internal rounding, Essence can be as small as the player wants as long as it is positive
                        // And getting the smallest positive number supported by the decimal type is way trickier than just checking if it's zero or negative
                        if (await CharacterObjectSettings.GetDontRoundEssenceInternallyAsync(token).ConfigureAwait(false))
                        {
                            if (decEss < 0)
                                decExcessEss = -decEss;
                            else if (decEss == 0)
                                // Hacky, but necessary so that the player knows they need to increase their ESS
                                decExcessEss = 10.0m.Pow(-await CharacterObjectSettings.GetEssenceDecimalsAsync(token).ConfigureAwait(false));
                        }
                        else
                        {
                            decimal decMinEss = 10.0m.Pow(-await CharacterObjectSettings.GetEssenceDecimalsAsync(token).ConfigureAwait(false));
                            if (decEss < decMinEss)
                                decExcessEss = decMinEss - decEss;
                        }

                        if (decExcessEss > 0)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_InvalidEssenceExcess", token: token)
                                                     .ConfigureAwait(false),
                                decExcessEss);
                        }
                    }

                    // If the character has the Spells & Spirits Tab enabled, make sure a Tradition has been selected.
                    if ((await CharacterObject.GetMagicianEnabledAsync(token).ConfigureAwait(false)
                         || await CharacterObject.GetAdeptEnabledAsync(token).ConfigureAwait(false))
                        && (await CharacterObject.GetMagicTraditionAsync(token).ConfigureAwait(false)).Type
                        != TraditionType.MAG)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .Append(await LanguageManager
                                                .GetStringAsync("Message_InvalidNoTradition", token: token)
                                                .ConfigureAwait(false));
                    }

                    // If the character has the Spells & Spirits Tab enabled, make sure a Tradition has been selected.
                    if (await CharacterObject.GetAdeptEnabledAsync(token).ConfigureAwait(false))
                    {
                        decimal decPPUsed = await CharacterObject.GetPowerPointsUsedAsync(token).ConfigureAwait(false);
                        decimal decPPTotal
                            = await CharacterObject.GetPowerPointsTotalAsync(token).ConfigureAwait(false);
                        if (decPPUsed > decPPTotal)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                              await LanguageManager.GetStringAsync(
                                                                                  "Message_InvalidPowerPoints",
                                                                                  token: token).ConfigureAwait(false),
                                                                              decPPUsed - decPPTotal, decPPTotal);
                        }
                    }

                    // If the character has the Technomancer Tab enabled, make sure a Stream has been selected.
                    if (await CharacterObject.GetTechnomancerEnabledAsync(token).ConfigureAwait(false)
                        && (await CharacterObject.GetMagicTraditionAsync(token).ConfigureAwait(false)).Type
                        != TraditionType.RES)
                    {
                        blnValid = false;
                        sbdMessage.AppendLine().Append('\t')
                                  .Append(await LanguageManager.GetStringAsync("Message_InvalidNoStream", token: token)
                                                               .ConfigureAwait(false));
                    }

                    // Check if the character has more than the permitted amount of native languages.
                    int intLanguages
                        = await (await objSkillsSection.GetKnowledgeSkillsAsync(token).ConfigureAwait(false))
                                .CountAsync(
                                    objSkill => objSkill.GetIsNativeLanguageAsync(token), token)
                                .ConfigureAwait(false);

                    int intLanguageLimit = 1 + (await ImprovementManager
                                                      .ValueOfAsync(CharacterObject,
                                                                    Improvement.ImprovementType.NativeLanguageLimit,
                                                                    token: token).ConfigureAwait(false))
                        .StandardRound();

                    if (intLanguages != intLanguageLimit)
                    {
                        if (intLanguages > intLanguageLimit)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                              await LanguageManager.GetStringAsync(
                                                                                  "Message_OverLanguageLimit",
                                                                                  token: token).ConfigureAwait(false),
                                                                              intLanguages, intLanguageLimit);
                        }
                        else if (await Program.ShowScrollableMessageBoxAsync(this,
                                     string.Format(
                                         GlobalSettings.CultureInfo,
                                         await LanguageManager.GetStringAsync(
                                                 "Message_ExtraNativeLanguages",
                                                 token: token)
                                             .ConfigureAwait(false),
                                         (intLanguageLimit - intLanguages).ToString(
                                             GlobalSettings.CultureInfo)),
                                     await LanguageManager.GetStringAsync(
                                             "MessageTitle_ExtraNativeLanguages",
                                             token: token)
                                         .ConfigureAwait(false),
                                     MessageBoxButtons.YesNo,
                                     MessageBoxIcon.Warning, token: token).ConfigureAwait(false) == DialogResult.No)
                        {
                            blnValid = false;
                        }
                    }

                    // Check the character's equipment and make sure nothing goes over their set Maximum Availability.
                    // Number of items over the specified Availability the character is allowed to have (typically from the Restricted Gear Quality).
                    Dictionary<int, int> dicRestrictedGearLimits = new Dictionary<int, int>(1);
                    List<Improvement> lstUsedImprovements
                        = await ImprovementManager.GetCachedImprovementListForValueOfAsync(
                                                      CharacterObject, Improvement.ImprovementType.RestrictedGear,
                                                      token: token)
                                                  .ConfigureAwait(false);
                    bool blnHasRestrictedGearAvailable = lstUsedImprovements.Count != 0;
                    if (blnHasRestrictedGearAvailable)
                    {
                        foreach (Improvement objImprovement in lstUsedImprovements)
                        {
                            int intLoopAvailability = objImprovement.Value.StandardRound();
                            if (dicRestrictedGearLimits.TryGetValue(intLoopAvailability, out int intExistingValue))
                                dicRestrictedGearLimits[intLoopAvailability] = intExistingValue + objImprovement.Rating;
                            else
                                dicRestrictedGearLimits.Add(intLoopAvailability, objImprovement.Rating);
                        }
                    }

                    List<int> lstToRemove = new List<int>(dicRestrictedGearLimits.Count);
                    // Remove all Restricted Gear availabilities with non-positive counts
                    foreach (KeyValuePair<int, int> kvpLoop in dicRestrictedGearLimits)
                    {
                        if (kvpLoop.Value <= 0)
                            lstToRemove.Add(kvpLoop.Key);
                    }

                    foreach (int intLoop in lstToRemove)
                        dicRestrictedGearLimits.Remove(intLoop);

                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdAvailItems))
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdRestrictedItems))
                    {
                        // Gear Availability.
                        int intRestrictedCount = await (await CharacterObject.GetGearAsync(token).ConfigureAwait(false))
                                                       .SumAsync(objGear => objGear.CheckRestrictedGear(
                                                               dicRestrictedGearLimits, sbdAvailItems,
                                                               sbdRestrictedItems,
                                                               token), token)
                                                       .ConfigureAwait(false)
                                                 // Cyberware Availability.
                                                 + await (await CharacterObject.GetCyberwareAsync(token)
                                                                               .ConfigureAwait(false)).SumAsync(objGear => objGear.CheckRestrictedGear(
                                                         dicRestrictedGearLimits, sbdAvailItems, sbdRestrictedItems,
                                                         token), token).ConfigureAwait(false)
                                                 // Armor Availability.
                                                 + await (await CharacterObject.GetArmorAsync(token)
                                                                               .ConfigureAwait(false)).SumAsync(objGear => objGear.CheckRestrictedGear(
                                                         dicRestrictedGearLimits, sbdAvailItems, sbdRestrictedItems,
                                                         token), token).ConfigureAwait(false)
                                                 // Weapon Availability.
                                                 + await (await CharacterObject.GetWeaponsAsync(token)
                                                                               .ConfigureAwait(false)).SumAsync(objGear => objGear.CheckRestrictedGear(
                                                         dicRestrictedGearLimits, sbdAvailItems, sbdRestrictedItems,
                                                         token), token).ConfigureAwait(false)
                                                 // Vehicle Availability.
                                                 + await (await CharacterObject.GetVehiclesAsync(token)
                                                                               .ConfigureAwait(false)).SumAsync(objGear => objGear.CheckRestrictedGear(
                                                         dicRestrictedGearLimits, sbdAvailItems, sbdRestrictedItems,
                                                         token), token).ConfigureAwait(false);

                        // Make sure the character is not carrying more items over the allowed Avail than they are allowed.
                        if (intRestrictedCount > 0)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(GlobalSettings.CultureInfo,
                                                                              await LanguageManager.GetStringAsync(
                                                                                      "Message_InvalidAvail",
                                                                                      token: token)
                                                                                  .ConfigureAwait(false),
                                                                              intRestrictedCount,
                                                                              CharacterObjectSettings
                                                                                  .MaximumAvailability);
                            sbdMessage.Append(sbdAvailItems);
                            if (blnHasRestrictedGearAvailable)
                            {
                                sbdMessage.AppendLine().AppendFormat(GlobalSettings.CultureInfo,
                                                                     await LanguageManager.GetStringAsync(
                                                                             "Message_RestrictedGearUsed", token: token)
                                                                         .ConfigureAwait(false),
                                                                     sbdRestrictedItems.ToString());
                            }
                        }
                    }

                    // Check for any illegal cyberware grades
                    using (new FetchSafelyFromObjectPool<StringBuilder>(Utils.StringBuilderPool,
                                                                  out StringBuilder sbdIllegalCyberwareFromGrade))
                    {
                        await (await CharacterObject.GetCyberwareAsync(token).ConfigureAwait(false)).ForEachAsync(
                                objCyberware =>
                                    objCyberware.CheckBannedGradesAsync(sbdIllegalCyberwareFromGrade, token), token)
                            .ConfigureAwait(false);

                        await (await CharacterObject.GetVehiclesAsync(token).ConfigureAwait(false)).ForEachAsync(
                            async objVehicle =>
                            {
                                foreach (Cyberware objCyberware in objVehicle.Mods.SelectMany(
                                             objMod => objMod.Cyberware))
                                {
                                    await objCyberware.CheckBannedGradesAsync(sbdIllegalCyberwareFromGrade, token)
                                                      .ConfigureAwait(false);
                                }

                                foreach (Cyberware objCyberware in objVehicle.WeaponMounts.SelectMany(
                                             objMount => objMount.Mods.SelectMany(objMod => objMod.Cyberware)))
                                {
                                    await objCyberware.CheckBannedGradesAsync(sbdIllegalCyberwareFromGrade, token)
                                                      .ConfigureAwait(false);
                                }
                            }, token).ConfigureAwait(false);

                        if (sbdIllegalCyberwareFromGrade.Length > 0)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t')
                                      .Append(await LanguageManager
                                                    .GetStringAsync("Message_InvalidCyberwareGrades", token: token)
                                                    .ConfigureAwait(false))
                                      .Append(sbdIllegalCyberwareFromGrade);
                        }
                    }

                    // Cyberware: Prototype Transhuman
                    decimal decPrototypeTranshumanEssenceMax
                        = await CharacterObject.GetPrototypeTranshumanAsync(token).ConfigureAwait(false);
                    if (decPrototypeTranshumanEssenceMax > 0)
                    {
                        decimal decPrototypeTranshumanEssenceUsed = await CharacterObject.GetPrototypeTranshumanEssenceUsedAsync(token).ConfigureAwait(false);
                        if (decPrototypeTranshumanEssenceMax < decPrototypeTranshumanEssenceUsed)
                        {
                            blnValid = false;
                            string strEssenceFormat = await CharacterObjectSettings.GetEssenceFormatAsync(token).ConfigureAwait(false);
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_OverPrototypeLimit", token: token)
                                                     .ConfigureAwait(false),
                                decPrototypeTranshumanEssenceUsed.ToString(strEssenceFormat,
                                                                           GlobalSettings.CultureInfo),
                                decPrototypeTranshumanEssenceMax.ToString(strEssenceFormat,
                                                                          GlobalSettings.CultureInfo));
                        }
                    }

                    // Check item Capacities if the option is enabled.
                    if (await CharacterObjectSettings.GetEnforceCapacityAsync(token).ConfigureAwait(false))
                    {
                        List<string> lstOverCapacity = new List<string>(1);
                        // Armor Capacity.
                        foreach (Armor objArmor in await CharacterObject.GetArmorAsync(token).ConfigureAwait(false))
                        {
                            if (await objArmor.GetCapacityRemainingAsync(token).ConfigureAwait(false) < 0)
                            {
                                lstOverCapacity.Add(await objArmor.GetCurrentDisplayNameShortAsync(token)
                                    .ConfigureAwait(false));
                            }

                            foreach (Gear objGear in await objArmor.GearChildren.DeepWhereAsync(
                                         x => x.Children, async x => await x.GetCapacityRemainingAsync(token).ConfigureAwait(false) < 0,
                                         token).ConfigureAwait(false))
                            {
                                lstOverCapacity.Add(await objGear.GetCurrentDisplayNameShortAsync(token)
                                    .ConfigureAwait(false));
                            }

                            await objArmor.ArmorMods.ForEachAsync(async objMod =>
                            {
                                foreach (Gear objGear in await objMod.GearChildren.DeepWhereAsync(
                                             x => x.Children,
                                             async x => await x.GetCapacityRemainingAsync(token).ConfigureAwait(false) <
                                                        0,
                                             token).ConfigureAwait(false))
                                {
                                    lstOverCapacity.Add(await objGear.GetCurrentDisplayNameShortAsync(token)
                                        .ConfigureAwait(false));
                                }
                            }, token).ConfigureAwait(false);
                        }

                        foreach (Weapon objWeapon in
                                 await (await CharacterObject.GetWeaponsAsync(token).ConfigureAwait(false))
                                     .DeepWhereAsync(
                                         x => x.Children,
                                         async x =>
                                             await x.WeaponAccessories.GetCountAsync(token).ConfigureAwait(false) > 0,
                                         token).ConfigureAwait(false))
                        {
                            await objWeapon.WeaponAccessories.ForEachAsync(async objAccessory =>
                            {
                                foreach (Gear objGear in await objAccessory.GearChildren.DeepWhereAsync(
                                             x => x.Children,
                                             async x => await x.GetCapacityRemainingAsync(token).ConfigureAwait(false) <
                                                        0,
                                             token).ConfigureAwait(false))
                                {
                                    lstOverCapacity.Add(await objGear.GetCurrentDisplayNameShortAsync(token)
                                        .ConfigureAwait(false));
                                }
                            }, token).ConfigureAwait(false);
                        }

                        // Gear Capacity.
                        foreach (Gear objGear in await (await CharacterObject.GetGearAsync(token).ConfigureAwait(false))
                                     .DeepWhereAsync(
                                         x => x.Children, async x => await x.GetCapacityRemainingAsync(token).ConfigureAwait(false) < 0,
                                         token).ConfigureAwait(false))
                        {
                            lstOverCapacity.Add(await objGear.GetCurrentDisplayNameShortAsync(token)
                                .ConfigureAwait(false));
                        }

                        // Cyberware Capacity.
                        foreach (Cyberware objCyberware in await (await CharacterObject.GetCyberwareAsync(token)
                                         .ConfigureAwait(false)).GetAllDescendantsAsync(x => x.GetChildrenAsync(token), token)
                                     .ConfigureAwait(false))
                        {
                            if (await objCyberware.GetCapacityRemainingAsync(token).ConfigureAwait(false) < 0)
                            {
                                lstOverCapacity.Add(await objCyberware.GetCurrentDisplayNameShortAsync(token)
                                    .ConfigureAwait(false));
                            }

                            foreach (Gear objGear in await objCyberware.GearChildren.DeepWhereAsync(
                                         x => x.Children, async x => await x.GetCapacityRemainingAsync(token).ConfigureAwait(false) < 0,
                                         token).ConfigureAwait(false))
                            {
                                lstOverCapacity.Add(await objGear.GetCurrentDisplayNameShortAsync(token)
                                    .ConfigureAwait(false));
                            }
                        }

                        // Vehicle Capacity.
                        ThreadSafeObservableCollection<Vehicle> lstVehicles = await CharacterObject.GetVehiclesAsync(token).ConfigureAwait(false);
                        await lstVehicles.ForEachAsync(async objVehicle =>
                        {
                            if (await CharacterObjectSettings.BookEnabledAsync("R5", token).ConfigureAwait(false))
                            {
                                if (objVehicle.IsDrone && await CharacterObjectSettings.GetDroneModsAsync(token)
                                        .ConfigureAwait(false))
                                {
                                    if (await objVehicle.GetDroneModSlotsUsedAsync(token).ConfigureAwait(false)
                                        > await objVehicle.GetDroneModSlotsAsync(token).ConfigureAwait(false))
                                    {
                                        lstOverCapacity.Add(await objVehicle.GetCurrentDisplayNameShortAsync(token)
                                            .ConfigureAwait(false));
                                    }
                                }
                                else if (await objVehicle.OverR5CapacityAsync(token: token).ConfigureAwait(false))
                                {
                                    lstOverCapacity.Add(await objVehicle.GetCurrentDisplayNameShortAsync(token)
                                        .ConfigureAwait(false));
                                }
                            }
                            else if (await objVehicle.GetSlotsAsync(token).ConfigureAwait(false) <
                                     await objVehicle.GetSlotsUsedAsync(token).ConfigureAwait(false))
                            {
                                lstOverCapacity.Add(await objVehicle.GetCurrentDisplayNameShortAsync(token)
                                    .ConfigureAwait(false));
                            }

                            foreach (Gear objGear in await objVehicle.GearChildren.DeepWhereAsync(
                                         x => x.Children,
                                         async x => await x.GetCapacityRemainingAsync(token).ConfigureAwait(false) < 0,
                                         token).ConfigureAwait(false))
                            {
                                lstOverCapacity.Add(await objGear.GetCurrentDisplayNameShortAsync(token)
                                    .ConfigureAwait(false));
                            }

                            await objVehicle.Mods.ForEachAsync(async objMod =>
                            {
                                foreach (Cyberware objCyberware in await objMod.Cyberware.GetAllDescendantsAsync(
                                             x => x.GetChildrenAsync(token), token).ConfigureAwait(false))
                                {
                                    if (await objCyberware.GetCapacityRemainingAsync(token).ConfigureAwait(false) < 0)
                                    {
                                        lstOverCapacity.Add(await objCyberware
                                            .GetCurrentDisplayNameShortAsync(token)
                                            .ConfigureAwait(false));
                                    }

                                    foreach (Gear objGear in await objCyberware.GearChildren.DeepWhereAsync(
                                                 x => x.Children,
                                                 async x => await x.GetCapacityRemainingAsync(token)
                                                     .ConfigureAwait(false) < 0, token).ConfigureAwait(false))
                                    {
                                        lstOverCapacity.Add(await objGear.GetCurrentDisplayNameShortAsync(token)
                                            .ConfigureAwait(false));
                                    }
                                }
                            }, token).ConfigureAwait(false);

                            await objVehicle.WeaponMounts.ForEachAsync(async objMount =>
                            {
                                if (await objMount.Weapons.GetCountAsync(token).ConfigureAwait(false) >
                                    objMount.WeaponCapacity)
                                {
                                    lstOverCapacity.Add(await objMount.GetCurrentDisplayNameShortAsync(token)
                                        .ConfigureAwait(false));
                                }

                                foreach (Weapon objWeapon in
                                         await objMount.Weapons.DeepWhereAsync(
                                             x => x.Children,
                                             async x => await x.WeaponAccessories.GetCountAsync(token)
                                                 .ConfigureAwait(false) > 0, token).ConfigureAwait(false))
                                {
                                    await objWeapon.WeaponAccessories.ForEachAsync(async objAccessory =>
                                    {
                                        foreach (Gear objGear in await objAccessory.GearChildren.DeepWhereAsync(
                                                     x => x.Children,
                                                     async x => await x.GetCapacityRemainingAsync(token)
                                                         .ConfigureAwait(false) < 0, token).ConfigureAwait(false))
                                        {
                                            lstOverCapacity.Add(await objGear.GetCurrentDisplayNameShortAsync(token)
                                                .ConfigureAwait(false));
                                        }
                                    }, token).ConfigureAwait(false);
                                }

                                await objMount.Mods.ForEachAsync(async objMod =>
                                {
                                    foreach (Cyberware objCyberware in await objMod.Cyberware.GetAllDescendantsAsync(
                                                 x => x.GetChildrenAsync(token), token).ConfigureAwait(false))
                                    {
                                        if (await objCyberware.GetCapacityRemainingAsync(token).ConfigureAwait(false) <
                                            0)
                                        {
                                            lstOverCapacity.Add(await objCyberware
                                                .GetCurrentDisplayNameShortAsync(token)
                                                .ConfigureAwait(false));
                                        }

                                        foreach (Gear objGear in await (await objCyberware.GetGearChildrenAsync(token).ConfigureAwait(false)).DeepWhereAsync(
                                                     x => x.Children,
                                                     async x => await x.GetCapacityRemainingAsync(token)
                                                         .ConfigureAwait(false) < 0, token).ConfigureAwait(false))
                                        {
                                            lstOverCapacity.Add(await objGear.GetCurrentDisplayNameShortAsync(token)
                                                .ConfigureAwait(false));
                                        }
                                    }
                                }, token).ConfigureAwait(false);
                            }, token).ConfigureAwait(false);
                        }, token).ConfigureAwait(false);

                        if (lstOverCapacity.Count > 0)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_CapacityReachedValidate", token: token)
                                    .ConfigureAwait(false),
                                lstOverCapacity.Count);
                            foreach (string strItem in lstOverCapacity)
                            {
                                sbdMessage.AppendLine().Append("\t- ", strItem);
                            }
                        }
                    }

                    //Check Drone mods for illegalities
                    if (await CharacterObjectSettings.BookEnabledAsync("R5", token).ConfigureAwait(false))
                    {
                        List<string> lstDronesIllegalDowngrades = new List<string>(1);
                        bool blnIllegalDowngrades = false;
                        int intIllegalDowngrades = await CharacterObject.Vehicles.SumAsync(async objVehicle =>
                        {
                            if (!objVehicle.IsDrone || !await CharacterObjectSettings.GetDroneModsAsync(token)
                                    .ConfigureAwait(false))
                                return 0;
                            int intReturn = 0;
                            foreach (string strModCategory in objVehicle.Mods
                                                                        .Where(objMod => !objMod.IncludedInVehicle
                                                                                   && objMod.Equipped
                                                                                   && objMod.Downgrade)
                                                                        .Select(x => x.Category))
                            {
                                //Downgrades can't reduce a attribute to less than 1 (except Speed which can go to 0)
                                if (strModCategory == "Handling" &&
                                    Convert.ToInt32(await objVehicle.GetTotalHandlingAsync(token).ConfigureAwait(false),
                                        GlobalSettings.InvariantCultureInfo) < 1
                                    || strModCategory == "Speed" &&
                                    Convert.ToInt32(await objVehicle.GetTotalSpeedAsync(token).ConfigureAwait(false),
                                        GlobalSettings.InvariantCultureInfo) < 0
                                    || strModCategory == "Acceleration" &&
                                    Convert.ToInt32(await objVehicle.GetTotalAccelAsync(token).ConfigureAwait(false),
                                        GlobalSettings.InvariantCultureInfo) < 1
                                    || strModCategory == "Body" &&
                                    await objVehicle.GetTotalBodyAsync(token).ConfigureAwait(false) < 1
                                    || strModCategory == "Armor" &&
                                    await objVehicle.GetTotalArmorAsync(token).ConfigureAwait(false) < 1
                                    || strModCategory == "Sensor" &&
                                    await objVehicle.GetCalculatedSensorAsync(token).ConfigureAwait(false) < 1)
                                {
                                    blnIllegalDowngrades = true;
                                    intReturn++;
                                    lstDronesIllegalDowngrades.Add(objVehicle.Name);
                                    break;
                                }
                            }

                            return intReturn;
                        }, token).ConfigureAwait(false);

                        if (blnIllegalDowngrades)
                        {
                            blnValid = false;
                            sbdMessage.AppendLine().Append('\t').AppendFormat(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_DroneIllegalDowngrade", token: token)
                                                     .ConfigureAwait(false),
                                intIllegalDowngrades);
                            foreach (string strItem in lstDronesIllegalDowngrades)
                            {
                                sbdMessage.AppendLine().Append("\t- ", strItem);
                            }
                        }
                    }

                    i = await CharacterObject.GetAttributesAsync(token).ConfigureAwait(false)
                        - await CalculateAttributePriorityPoints(lstAttributes,
                                                                 token: token).ConfigureAwait(false);
                    // Check if the character has extra Attribute points
                    if (blnValid && i > 0 && await Program.ShowScrollableMessageBoxAsync(this,
                            string.Format(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync(
                                        "Message_ExtraPoints",
                                        token: token)
                                    .ConfigureAwait(false),
                                i.ToString(
                                    GlobalSettings.CultureInfo),
                                await LanguageManager
                                    .GetStringAsync(
                                        "Label_SummaryPrimaryAttributes",
                                        token: token)
                                    .ConfigureAwait(false)),
                            await LanguageManager.GetStringAsync(
                                    "MessageTitle_ExtraPoints",
                                    token: token)
                                .ConfigureAwait(false),
                            MessageBoxButtons.YesNo,
                            MessageBoxIcon.Warning, token: token).ConfigureAwait(false)
                        == DialogResult.No)
                    {
                        blnValid = false;
                    }

                    i = await CharacterObject.GetSpecialAsync(token).ConfigureAwait(false)
                        - await CalculateAttributePriorityPoints(lstSpecialAttributes, token: token)
                            .ConfigureAwait(false);
                    // Check if the character has extra Special Attribute points
                    if (blnValid && i > 0 && await Program.ShowScrollableMessageBoxAsync(this,
                            string.Format(
                                GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync(
                                        "Message_ExtraPoints",
                                        token: token)
                                    .ConfigureAwait(false),
                                i.ToString(
                                    GlobalSettings.CultureInfo),
                                await LanguageManager
                                    .GetStringAsync(
                                        "Label_SummarySpecialAttributes",
                                        token: token)
                                    .ConfigureAwait(false)),
                            await LanguageManager.GetStringAsync(
                                    "MessageTitle_ExtraPoints",
                                    token: token)
                                .ConfigureAwait(false),
                            MessageBoxButtons.YesNo,
                            MessageBoxIcon.Warning, token: token).ConfigureAwait(false)
                        == DialogResult.No)
                    {
                        blnValid = false;
                    }

                    // Check if the character has extra Skill Group points
                    if (blnValid && intSkillGroupPoints > 0
                                 && await Program.ShowScrollableMessageBoxAsync(this,
                                     string.Format(
                                         GlobalSettings.CultureInfo,
                                         await LanguageManager.GetStringAsync(
                                                 "Message_ExtraPoints", token: token)
                                             .ConfigureAwait(false),
                                         intSkillGroupPoints.ToString(
                                             GlobalSettings.CultureInfo),
                                         await LanguageManager
                                             .GetStringAsync(
                                                 "Label_SummarySkillGroups",
                                                 token: token).ConfigureAwait(false)),
                                     await LanguageManager.GetStringAsync(
                                             "MessageTitle_ExtraPoints", token: token)
                                         .ConfigureAwait(false),
                                     MessageBoxButtons.YesNo,
                                     MessageBoxIcon.Warning, token: token).ConfigureAwait(false) == DialogResult.No)
                    {
                        blnValid = false;
                    }

                    // Check if the character has extra Active Skill points
                    if (blnValid && intSkillPoints > 0 && await Program.ShowScrollableMessageBoxAsync(
                            this,
                            string.Format(GlobalSettings.CultureInfo,
                                await LanguageManager.GetStringAsync("Message_ExtraPoints", token: token)
                                    .ConfigureAwait(false),
                                intSkillPoints.ToString(
                                    GlobalSettings.CultureInfo),
                                await LanguageManager
                                    .GetStringAsync("Label_SummaryActiveSkills", token: token)
                                    .ConfigureAwait(false)),
                            await LanguageManager.GetStringAsync("MessageTitle_ExtraPoints", token: token)
                                .ConfigureAwait(false), MessageBoxButtons.YesNo,
                            MessageBoxIcon.Warning, token: token).ConfigureAwait(false) == DialogResult.No)
                    {
                        blnValid = false;
                    }

                    // Check if the character has extra Knowledge Skill points
                    if (blnValid && intKnoSkillPoints > 0
                                 && await Program.ShowScrollableMessageBoxAsync(this,
                                     string.Format(
                                         GlobalSettings.CultureInfo,
                                         await LanguageManager.GetStringAsync(
                                                 "Message_ExtraPoints", token: token)
                                             .ConfigureAwait(false),
                                         intKnoSkillPoints.ToString(
                                             GlobalSettings.CultureInfo),
                                         await LanguageManager
                                             .GetStringAsync(
                                                 "Label_SummaryKnowledgeSkills",
                                                 token: token).ConfigureAwait(false)),
                                     await LanguageManager.GetStringAsync(
                                             "MessageTitle_ExtraPoints", token: token)
                                         .ConfigureAwait(false),
                                     MessageBoxButtons.YesNo,
                                     MessageBoxIcon.Warning, token: token).ConfigureAwait(false) == DialogResult.No)
                    {
                        blnValid = false;
                    }

                    // Check if the character has extra Contact points
                    if (blnValid)
                    {
                        int intContactPointsRemain
                            = await CharacterObject.GetContactPointsAsync(token).ConfigureAwait(false);
                        if (intContactPointsRemain > 0)
                        {
                            intContactPointsRemain
                                -= (await CharacterObject.GetContactPointsUsedAsync(token).ConfigureAwait(false)).Item1;
                            if (intContactPointsRemain > 0
                                && await Program.ShowScrollableMessageBoxAsync(this,
                                    string.Format(
                                        GlobalSettings.CultureInfo,
                                        await LanguageManager.GetStringAsync(
                                                "Message_ExtraPoints", token: token)
                                            .ConfigureAwait(false),
                                        intContactPointsRemain.ToString(
                                            GlobalSettings.CultureInfo),
                                        await LanguageManager
                                            .GetStringAsync(
                                                "String_ContactPoints", token: token)
                                            .ConfigureAwait(false)),
                                    await LanguageManager.GetStringAsync(
                                            "MessageTitle_ExtraPoints", token: token)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.YesNo,
                                    MessageBoxIcon.Warning, token: token).ConfigureAwait(false) == DialogResult.No)
                            {
                                blnValid = false;
                            }
                        }
                    }

                    // Check if the character has extra spell points
                    if (blnValid && (await CharacterObject.GetFreeSpellsAsync(token).ConfigureAwait(false) > 0
                                     || (await ImprovementManager
                                         .GetCachedImprovementListForValueOfAsync(CharacterObject,
                                             Improvement.ImprovementType.FreeSpells,
                                             token: token)
                                         .ConfigureAwait(false)).Count > 0
                                     || (await ImprovementManager
                                         .GetCachedImprovementListForValueOfAsync(CharacterObject,
                                             Improvement.ImprovementType
                                                 .FreeSpellsATT,
                                             token: token).ConfigureAwait(false))
                                     .Count > 0
                                     || (await ImprovementManager
                                         .GetCachedImprovementListForValueOfAsync(CharacterObject,
                                             Improvement.ImprovementType
                                                 .FreeSpellsSkill,
                                             token: token).ConfigureAwait(false))
                                     .Count > 0))
                    {
                        ThreadSafeObservableCollection<Spell> lstSpells
                            = await CharacterObject.GetSpellsAsync(token).ConfigureAwait(false);
                        // Count the number of Spells the character currently has
                        int intUsedPoints = await lstSpells
                            .CountAsync(
                                spell => spell.Grade == 0 && !spell.FreeBonus,
                                token: token).ConfigureAwait(false);
                        int intTouchOnlySpells = await lstSpells
                            .CountAsync(
                                spell => spell.Grade == 0 && !spell.Alchemical
                                                          && spell.Category != "Rituals"
                                                          && (spell.Range == "T (A)"
                                                              || spell.Range == "T")
                                                          && !spell.FreeBonus, token: token)
                            .ConfigureAwait(false);

                        int intFreeSpells = await CharacterObject.GetFreeSpellsAsync(token).ConfigureAwait(false);

                        token.ThrowIfCancellationRequested();

                        if (intFreeSpells > 0)
                        {
                            // Each spell costs KarmaSpell.
                            int spellCost = await CharacterObject.SpellKarmaCostAsync("Spells", token)
                                .ConfigureAwait(false);
                            // Factor in any qualities that can be bought with spell points.
                            // It is only karma-efficient to use spell points for Mastery qualities if real spell karma cost is not greater than unmodified spell karma cost
                            int intKarmaSpell = await CharacterObjectSettings.GetKarmaSpellAsync(token)
                                .ConfigureAwait(false);
                            if (spellCost <= intKarmaSpell && intKarmaSpell != 0)
                            {
                                // Assume that every [spell cost] karma spent on a Mastery quality is paid for with a priority-given spell point instead, as that is the most karma-efficient.
                                int intMasteryQualityKarmaUsed
                                    = await (await CharacterObject.GetQualitiesAsync(token).ConfigureAwait(false))
                                        .SumAsync(
                                            objQuality =>
                                                objQuality.CanBuyWithSpellPoints,
                                            objQuality => objQuality.BP, token)
                                        .ConfigureAwait(false);
                                if (intMasteryQualityKarmaUsed != 0)
                                {
                                    int intQualityKarmaToSpellPoints
                                        = Math.Min(
                                            intFreeSpells,
                                            intMasteryQualityKarmaUsed * await CharacterObjectSettings
                                                .GetKarmaQualityAsync(token)
                                                .ConfigureAwait(false)
                                            / intKarmaSpell);
                                    intUsedPoints += intQualityKarmaToSpellPoints;
                                }
                            }
                        }

                        token.ThrowIfCancellationRequested();

                        int intLimitMod = (await ImprovementManager
                                               .ValueOfAsync(CharacterObject,
                                                   Improvement.ImprovementType.SpellLimit,
                                                   token: token).ConfigureAwait(false)
                                           + await ImprovementManager
                                               .ValueOfAsync(CharacterObject,
                                                   Improvement.ImprovementType.FreeSpells,
                                                   token: token).ConfigureAwait(false))
                            .StandardRound();
                        int intLimitModTouchOnly = 0;
                        foreach (Improvement imp in await ImprovementManager
                                     .GetCachedImprovementListForValueOfAsync(
                                         CharacterObject,
                                         Improvement.ImprovementType.FreeSpellsATT,
                                         token: token).ConfigureAwait(false))
                        {
                            token.ThrowIfCancellationRequested();
                            int intAttValue
                                = await (await CharacterObject.GetAttributeAsync(imp.ImprovedName, token: token)
                                        .ConfigureAwait(false)).GetTotalValueAsync(token)
                                    .ConfigureAwait(false);
                            if (imp.UniqueName.Contains("half"))
                                intAttValue = intAttValue.DivAwayFromZero(2);
                            if (imp.UniqueName.Contains("touchonly"))
                                intLimitModTouchOnly += intAttValue;
                            else
                                intLimitMod += intAttValue;
                        }

                        foreach (Improvement imp in await ImprovementManager
                                     .GetCachedImprovementListForValueOfAsync(
                                         CharacterObject,
                                         Improvement.ImprovementType.FreeSpellsSkill,
                                         token: token).ConfigureAwait(false))
                        {
                            token.ThrowIfCancellationRequested();
                            Skill skill = await objSkillsSection.GetActiveSkillAsync(imp.ImprovedName, token)
                                .ConfigureAwait(false);
                            if (skill == null)
                                continue;
                            int intSkillValue = await skill.GetTotalBaseRatingAsync(token).ConfigureAwait(false);

                            if (imp.UniqueName.Contains("half"))
                                intSkillValue = intSkillValue.DivAwayFromZero(2);
                            if (imp.UniqueName.Contains("touchonly"))
                                intLimitModTouchOnly += intSkillValue;
                            else
                                intLimitMod += intSkillValue;
                            //TODO: I don't like this being hardcoded, even though I know full well CGL are never going to reuse this.
                            intUsedPoints -= await (await skill.GetSpecializationsAsync(token).ConfigureAwait(false))
                                .CountAsync(
                                    async spec =>
                                    {
                                        string strNameInner = await spec.GetNameAsync(token).ConfigureAwait(false);
                                        return await (await CharacterObject.GetSpellsAsync(token)
                                                .ConfigureAwait(false)).AnyAsync(
                                                spell => spell.Category == strNameInner && !spell.FreeBonus,
                                                token)
                                            .ConfigureAwait(false);
                                    },
                                    token)
                                .ConfigureAwait(false);
                        }

                        if (await CharacterObject.GetUseMysticAdeptPPsAsync(token).ConfigureAwait(false)
                            && await CharacterObjectSettings.GetPrioritySpellsAsAdeptPowersAsync(token)
                                .ConfigureAwait(false))
                        {
                            intUsedPoints += await nudMysticAdeptMAGMagician
                                .DoThreadSafeFuncAsync(x => x.ValueAsInt, token)
                                .ConfigureAwait(false);
                        }

                        intUsedPoints -= intTouchOnlySpells - Math.Max(0, intTouchOnlySpells - intLimitModTouchOnly);

                        int intPointsRemaining = intFreeSpells + intLimitMod - intUsedPoints;

                        if (intPointsRemaining > 0
                            && await Program.ShowScrollableMessageBoxAsync(this,
                                string.Format(
                                    GlobalSettings.CultureInfo,
                                    await LanguageManager.GetStringAsync(
                                            "Message_ExtraPoints", token: token)
                                        .ConfigureAwait(false),
                                    intPointsRemaining.ToString(
                                        GlobalSettings.CultureInfo),
                                    await LanguageManager
                                        .GetStringAsync(
                                            "String_FreeSpells", token: token)
                                        .ConfigureAwait(false)),
                                await LanguageManager.GetStringAsync(
                                        "MessageTitle_ExtraPoints", token: token)
                                    .ConfigureAwait(false),
                                MessageBoxButtons.YesNo,
                                MessageBoxIcon.Warning, token: token).ConfigureAwait(false) == DialogResult.No)
                        {
                            blnValid = false;
                        }
                    }

                    // Check if the character has extra complex form points
                    if (blnValid)
                    {
                        int intCFPointsRemain
                            = await CharacterObject.GetCFPLimitAsync(token).ConfigureAwait(false);
                        if (intCFPointsRemain > 0)
                        {
                            intCFPointsRemain
                                -= await (await CharacterObject.GetComplexFormsAsync(token).ConfigureAwait(false))
                                         .CountAsync(x => x.Grade == 0, token).ConfigureAwait(false);
                            if (intCFPointsRemain > 0
                                && await Program.ShowScrollableMessageBoxAsync(this,
                                    string.Format(
                                        GlobalSettings.CultureInfo,
                                        await LanguageManager.GetStringAsync(
                                                "Message_ExtraPoints", token: token)
                                            .ConfigureAwait(false),
                                        intCFPointsRemain.ToString(
                                            GlobalSettings.CultureInfo),
                                        await LanguageManager
                                            .GetStringAsync(
                                                "String_FreeCFs", token: token)
                                            .ConfigureAwait(false)),
                                    await LanguageManager.GetStringAsync(
                                            "MessageTitle_ExtraPoints", token: token)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.YesNo,
                                    MessageBoxIcon.Warning, token: token).ConfigureAwait(false) == DialogResult.No)
                            {
                                blnValid = false;
                            }
                        }
                    }
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }

                if (!blnValid && sbdMessage.Length > 0)
                {
                    sbdMessage.Insert(0, await LanguageManager.GetStringAsync("Message_InvalidBeginning", token: token)
                                                       .ConfigureAwait(false));
                    await Program.ShowScrollableMessageBoxAsync(this, sbdMessage.ToString(),
                        await LanguageManager
                            .GetStringAsync("MessageTitle_Invalid", token: token)
                            .ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Error, token: token).ConfigureAwait(false);
                }
            }

            return blnValid;
        }

        /// <summary>
        /// Confirm that the character can move to career mode and perform final actions for karma carryover and such.
        /// </summary>
        public async Task<bool> ValidateCharacter(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();

            IAsyncDisposable objLocker =
                await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker2 = await CharacterObjectSettings.LockObject.EnterReadLockAsync(token)
                    .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    int intBuildPoints = await CalculateBPandRefreshBPDisplays(false, token).ConfigureAwait(false);

                    if (await CheckCharacterValidity(true, intBuildPoints, token).ConfigureAwait(false))
                    {
                        // See if the character has any Karma remaining.
                        if (intBuildPoints > await CharacterObjectSettings.GetKarmaCarryoverAsync(token)
                                .ConfigureAwait(false))
                        {
                            if (!await CharacterObject.GetEffectiveBuildMethodUsesPriorityTablesAsync(token)
                                    .ConfigureAwait(false))
                            {
                                if (await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        string.Format(GlobalSettings.CultureInfo,
                                            await LanguageManager.GetStringAsync("Message_NoExtraKarma", token: token)
                                                .ConfigureAwait(false),
                                            intBuildPoints.ToString(GlobalSettings.CultureInfo)),
                                        await LanguageManager.GetStringAsync("MessageTitle_ExtraKarma", token: token)
                                            .ConfigureAwait(false), MessageBoxButtons.YesNo,
                                        MessageBoxIcon.Warning, token: token).ConfigureAwait(false) == DialogResult.No)
                                    return false;
                            }
                            else if (await Program.ShowScrollableMessageBoxAsync(this, string.Format(GlobalSettings.CultureInfo,
                                             await LanguageManager
                                                 .GetStringAsync(
                                                     "Message_ExtraKarma", token: token)
                                                 .ConfigureAwait(false),
                                             intBuildPoints.ToString(
                                                 GlobalSettings.CultureInfo),
                                             (await CharacterObjectSettings.GetKarmaCarryoverAsync(token)
                                                 .ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo)),
                                         await LanguageManager
                                             .GetStringAsync("MessageTitle_ExtraKarma", token: token)
                                             .ConfigureAwait(false), MessageBoxButtons.YesNo,
                                         MessageBoxIcon.Warning, token: token).ConfigureAwait(false) == DialogResult.No)
                            {
                                return false;
                            }
                        }

                        decimal decNuyen = (await CharacterObject.CalculateNuyenCreateModeAsync(token).ConfigureAwait(false)).Item1;
                        if (decNuyen > await CharacterObjectSettings.GetNuyenCarryoverAsync(token)
                                .ConfigureAwait(false) && await Program.ShowScrollableMessageBoxAsync(
                                this, string.Format(GlobalSettings.CultureInfo,
                                    await LanguageManager.GetStringAsync("Message_ExtraNuyen", token: token)
                                        .ConfigureAwait(false),
                                    decNuyen.ToString(
                                        await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                        GlobalSettings.CultureInfo),
                                    (await CharacterObjectSettings.GetNuyenCarryoverAsync(token).ConfigureAwait(false))
                                    .ToString(
                                        await CharacterObjectSettings.GetNuyenFormatAsync(token).ConfigureAwait(false),
                                        GlobalSettings.CultureInfo)),
                                await LanguageManager.GetStringAsync("MessageTitle_ExtraNuyen", token: token)
                                    .ConfigureAwait(false), MessageBoxButtons.YesNo, MessageBoxIcon.Warning, token: token).ConfigureAwait(false)
                            == DialogResult.No)
                            return false;
                        if (GlobalSettings.CreateBackupOnCareer && await chkCharacterCreated
                                .DoThreadSafeFuncAsync(x => x.Checked, token)
                                .ConfigureAwait(false))
                        {
                            // Create a pre-Career Mode backup of the character.
                            // Make sure the backup directory exists.
                            if (!Directory.Exists(Utils.GetBackupSavesFolderPath))
                            {
                                try
                                {
                                    Directory.CreateDirectory(Utils.GetBackupSavesFolderPath);
                                }
                                catch (UnauthorizedAccessException)
                                {
                                    await Program.ShowScrollableMessageBoxAsync(
                                        this,
                                        await LanguageManager
                                            .GetStringAsync("Message_Insufficient_Permissions_Warning", token: token)
                                            .ConfigureAwait(false), token: token).ConfigureAwait(false);
                                    return false;
                                }
                            }

                            string strNewName = Path.GetFileNameWithoutExtension(CharacterObject.FileName);
                            if (string.IsNullOrEmpty(strNewName))
                            {
                                strNewName = await CharacterObject.GetAliasAsync(token).ConfigureAwait(false);
                                if (string.IsNullOrEmpty(strNewName))
                                {
                                    strNewName = await CharacterObject.GetNameAsync(token).ConfigureAwait(false);
                                    if (string.IsNullOrEmpty(strNewName))
                                        strNewName = Guid.NewGuid().ToString("N", GlobalSettings.InvariantCultureInfo);
                                }
                            }

                            strNewName += await LanguageManager.GetStringAsync("String_Space", token: token)
                                    .ConfigureAwait(false) + "("
                                                           + await LanguageManager
                                                               .GetStringAsync(
                                                                   "Title_CreateMode", token: token)
                                                               .ConfigureAwait(false)
                                                           + ").chum5";
                            if (CharacterObject.FileName?.EndsWith(".chum5lz", StringComparison.OrdinalIgnoreCase) ==
                                true)
                                strNewName += "lz";
                            strNewName = Path.Combine(Utils.GetBackupSavesFolderPath, strNewName);

                            CursorWait objCursorWait =
                                await CursorWait.NewAsync(this, token: token).ConfigureAwait(false);
                            try
                            {
                                using (ThreadSafeForm<LoadingBar> frmLoadingBar
                                       = await Program.CreateAndShowProgressBarAsync(token: token)
                                           .ConfigureAwait(false))
                                {
                                    await frmLoadingBar.MyForm.PerformStepAsync(CharacterObject.CharacterName,
                                        LoadingBar.ProgressBarTextPatterns.Saving,
                                        token).ConfigureAwait(false);
                                    if (!await CharacterObject.SaveAsync(strNewName, token: token)
                                            .ConfigureAwait(false))
                                        return false;
                                }
                            }
                            finally
                            {
                                await objCursorWait.DisposeAsync().ConfigureAwait(false);
                            }
                        }

                        SkipUpdate = true;
                        try
                        {
                            // If the character does not have any Lifestyles, give them the Street Lifestyle.
                            if (await CharacterObject.Lifestyles.GetCountAsync(token).ConfigureAwait(false) == 0)
                            {
                                XmlDocument objXmlDocument = await CharacterObject
                                    .LoadDataAsync("lifestyles.xml", token: token)
                                    .ConfigureAwait(false);
                                XmlNode objXmlLifestyle
                                    = objXmlDocument.SelectSingleNode(
                                        "/chummer/lifestyles/lifestyle[name = \"Street\"]");

                                Lifestyle objLifestyle = new Lifestyle(CharacterObject);
                                try
                                {
                                    await objLifestyle.CreateAsync(objXmlLifestyle, token).ConfigureAwait(false);
                                    await CharacterObject.Lifestyles.AddAsync(objLifestyle, token).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await objLifestyle.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }

                            decimal decStartingNuyen;
                            using (ThreadSafeForm<SelectLifestyleStartingNuyen> frmStartingNuyen
                                   = await ThreadSafeForm<SelectLifestyleStartingNuyen>.GetAsync(
                                       () => new SelectLifestyleStartingNuyen(CharacterObject),
                                       token).ConfigureAwait(false))
                            {
                                if (await frmStartingNuyen.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                                    != DialogResult.OK)
                                    return false;
                                decStartingNuyen = await frmStartingNuyen.MyForm.GetStartingNuyenAsync(token).ConfigureAwait(false);
                            }

                            // Assign starting values and overflows.
                            //This needs to be added to Character.Nuyen to ensure that the ExpanseEntries are created accurately
                            await CharacterObject
                                .SetNuyenAsync(
                                    Math.Min(decNuyen, await CharacterObjectSettings.GetNuyenCarryoverAsync(token).ConfigureAwait(false)) +
                                    Math.Max(decStartingNuyen, 0), token)
                                .ConfigureAwait(false);
                            // See if the character has any Karma remaining.
                            await CharacterObject
                                .SetKarmaAsync(
                                    Math.Min(intBuildPoints,
                                        await CharacterObjectSettings.GetKarmaCarryoverAsync(token).ConfigureAwait(false)), token)
                                .ConfigureAwait(false);

                            return true;
                        }
                        finally
                        {
                            SkipUpdate = false;
                        }
                    }
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            return false;
        }

        /// <summary>
        /// Verify that the user wants to save this character as Created.
        /// </summary>
        public override async Task<bool> ConfirmSaveCreatedCharacter(CancellationToken token = default)
        {
            return await Program.ShowScrollableMessageBoxAsync(
                this, await LanguageManager.GetStringAsync("Message_ConfirmCreate", token: token).ConfigureAwait(false),
                await LanguageManager.GetStringAsync("MessageTitle_ConfirmCreate", token: token).ConfigureAwait(false),
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question, token: token).ConfigureAwait(false) != DialogResult.No && await ValidateCharacter(token).ConfigureAwait(false);
        }

        /// <summary>
        /// Create Cyberware from a Cyberware Suite.
        /// </summary>
        /// <param name="xmlSuiteNode">XmlNode for the cyberware suite to add.</param>
        /// <param name="xmlCyberwareNode">XmlNode for the Cyberware to add.</param>
        /// <param name="objGrade">CyberwareGrade to add the item as.</param>
        /// <param name="intRating">Rating of the Cyberware.</param>
        /// <param name="eSource">Source representing whether the suite is cyberware or bioware.</param>
        /// <param name="token">CancellationToken to listen to.</param>
        private async Task<Cyberware> CreateSuiteCyberware(XmlNode xmlSuiteNode, XmlNode xmlCyberwareNode, Grade objGrade,
                                               int intRating, Improvement.ImprovementSource eSource,
                                               CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker =
                await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Create the Cyberware object.
                List<Weapon> lstWeapons = new List<Weapon>(1);
                List<Vehicle> lstVehicles = new List<Vehicle>(1);
                Cyberware objCyberware = new Cyberware(CharacterObject);
                try
                {
                    string strForced =
                        xmlSuiteNode.SelectSingleNodeAndCacheExpressionAsNavigator("name/@select", token)?.Value ??
                        string.Empty;

                    await objCyberware.CreateAsync(xmlCyberwareNode, objGrade, eSource, intRating, lstWeapons, lstVehicles,
                        true, true,
                        strForced, token: token).ConfigureAwait(false);
                    objCyberware.Suite = true;

                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                    }

                    foreach (Vehicle objVehicle in lstVehicles)
                    {
                        await CharacterObject.Vehicles.AddAsync(objVehicle, token).ConfigureAwait(false);
                    }

                    string strType = eSource == Improvement.ImprovementSource.Cyberware ? "cyberware" : "bioware";
                    using (XmlNodeList xmlChildrenList = xmlSuiteNode.SelectNodes(strType + "s/" + strType))
                    {
                        if (xmlChildrenList?.Count > 0)
                        {
                            XmlDocument objXmlDocument = await CharacterObject.LoadDataAsync(strType + ".xml", token: token)
                                .ConfigureAwait(false);
                            foreach (XmlNode objXmlChild in xmlChildrenList)
                            {
                                string strName = objXmlChild["name"]?.InnerTextViaPool(token);
                                if (string.IsNullOrEmpty(strName))
                                    continue;
                                XmlNode objXmlChildCyberware = objXmlDocument.TryGetNodeByNameOrId(
                                    "/chummer/" + strType + "s/" + strType, strName);
                                int.TryParse(objXmlChild["rating"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intChildRating);
                                await (await objCyberware.GetChildrenAsync(token).ConfigureAwait(false)).AddAsync(await CreateSuiteCyberware(objXmlChild,
                                    objXmlChildCyberware, objGrade,
                                    intChildRating, eSource, token).ConfigureAwait(false), token).ConfigureAwait(false);
                            }
                        }
                    }

                    return objCyberware;
                }
                catch
                {
                    if (lstWeapons.Count > 0)
                    {
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                        }
                    }

                    if (lstVehicles.Count > 0)
                    {
                        foreach (Vehicle objVehicle in lstVehicles)
                        {
                            await objVehicle.DeleteVehicleAsync(token: CancellationToken.None).ConfigureAwait(false);
                        }
                    }

                    await objCyberware.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                    throw;
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Add a PACKS Kit to the character.
        /// </summary>
        public async Task<bool> AddPACKSKit(CancellationToken token = default)
        {
            XmlNode objXmlKit;
            bool blnAddAgain;
            using (ThreadSafeForm<SelectPACKSKit> frmPickPACKSKit = await ThreadSafeForm<SelectPACKSKit>
                                                                          .GetAsync(
                                                                              () => new SelectPACKSKit(CharacterObject),
                                                                              token).ConfigureAwait(false))
            {
                // If the form was canceled, don't do anything.
                if (await frmPickPACKSKit.ShowDialogSafeAsync(this, token).ConfigureAwait(false) == DialogResult.Cancel)
                    return false;

                // Do not create child items for Gear if the chosen Kit is in the Custom category since these items will contain the exact plugins desired.
                //if (frmPickPACKSKit.SelectedCategory == "Custom")
                //blnCreateChildren = false;

                objXmlKit
                    = (await CharacterObject.LoadDataAsync("packs.xml", token: token).ConfigureAwait(false))
                    .TryGetNodeByNameOrId("/chummer/packs/pack", frmPickPACKSKit.MyForm.SelectedKit,
                                          "category = " + SelectPACKSKit.SelectedCategory.CleanXPath());
                blnAddAgain = frmPickPACKSKit.MyForm.AddAgain;
            }

            if (objXmlKit == null)
                return false;
            const bool blnCreateChildren = true;
            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                // Update Qualities.
                XmlElement xmlQualities = objXmlKit["qualities"];
                if (xmlQualities != null)
                {
                    XmlDocument xmlQualityDocument = await CharacterObject.LoadDataAsync("qualities.xml", token: token)
                        .ConfigureAwait(false);

                    // Positive and Negative Qualities.
                    using (XmlNodeList xmlQualityList = xmlQualities.SelectNodes("*/quality"))
                    {
                        if (xmlQualityList?.Count > 0)
                        {
                            foreach (XmlNode objXmlQuality in xmlQualityList)
                            {
                                XmlNode objXmlQualityNode = xmlQualityDocument.TryGetNodeByNameOrId(
                                    "/chummer/qualities/quality", objXmlQuality.InnerTextViaPool(token),
                                    await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false));

                                if (objXmlQualityNode == null)
                                    continue;
                                string strForceValue =
                                        objXmlQuality.Attributes?["select"]?.InnerTextViaPool(token) ?? string.Empty;
                                List<Weapon> lstWeapons = new List<Weapon>(1);
                                Quality objQuality = new Quality(CharacterObject);
                                try
                                {
                                    await objQuality.CreateAsync(objXmlQualityNode, QualitySource.Selected, lstWeapons,
                                        strForceValue, token: token).ConfigureAwait(false);

                                    await CharacterObject.Qualities.AddAsync(objQuality, token).ConfigureAwait(false);

                                    // Add any created Weapons to the character.
                                    foreach (Weapon objWeapon in lstWeapons)
                                    {
                                        await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                    }
                                }
                                catch
                                {
                                    await objQuality.DeleteQualityAsync(token: CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }
                        }
                    }
                }

                //TODO: PACKS SKILLS?

                // Select a Martial Art.
                XmlElement xmlSelectMartialArt = objXmlKit["selectmartialart"];
                if (xmlSelectMartialArt != null)
                {
                    string strForcedValue = xmlSelectMartialArt.Attributes["select"]?.InnerTextViaPool(token) ?? string.Empty;

                    using (ThreadSafeForm<SelectMartialArt> frmPickMartialArt = await ThreadSafeForm<SelectMartialArt>
                               .GetAsync(() => new SelectMartialArt(CharacterObject)
                               {
                                   ForcedValue = strForcedValue
                               }, token).ConfigureAwait(false))
                    {
                        if (await frmPickMartialArt.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                            != DialogResult.Cancel)
                        {
                            // Open the Martial Arts XML file and locate the selected piece.
                            XmlDocument objXmlMartialArtDocument = await CharacterObject
                                .LoadDataAsync("martialarts.xml", token: token)
                                .ConfigureAwait(false);

                            XmlNode objXmlArt = objXmlMartialArtDocument.TryGetNodeByNameOrId(
                                "/chummer/martialarts/martialart", frmPickMartialArt.MyForm.SelectedMartialArt);

                            MartialArt objMartialArt = new MartialArt(CharacterObject);
                            try
                            {
                                await objMartialArt.CreateAsync(objXmlArt, token).ConfigureAwait(false);
                                await CharacterObject.MartialArts.AddAsync(objMartialArt, token).ConfigureAwait(false);
                            }
                            catch
                            {
                                await objMartialArt.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    }
                }

                // Update Martial Arts.
                XmlElement xmlMartialArts = objXmlKit["martialarts"];
                if (xmlMartialArts != null)
                {
                    // Open the Martial Arts XML file and locate the selected art.
                    XmlDocument objXmlMartialArtDocument
                        = await CharacterObject.LoadDataAsync("martialarts.xml", token: token).ConfigureAwait(false);

                    using (XmlNodeList xmlMartialArtsList = xmlMartialArts.SelectNodes("martialart"))
                    {
                        if (xmlMartialArtsList?.Count > 0)
                        {
                            foreach (XmlNode objXmlArt in xmlMartialArtsList)
                            {
                                XmlNode objXmlArtNode = objXmlMartialArtDocument.TryGetNodeByNameOrId(
                                        "/chummer/martialarts/martialart", objXmlArt["name"]?.InnerTextViaPool(token),
                                        await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false));
                                if (objXmlArtNode == null)
                                    continue;
                                MartialArt objArt = new MartialArt(CharacterObject);
                                try
                                {
                                    await objArt.CreateAsync(objXmlArtNode, token).ConfigureAwait(false);
                                    await CharacterObject.MartialArts.AddAsync(objArt, token).ConfigureAwait(false);

                                    // Check for Techniques.
                                    using (XmlNodeList xmlTechniquesList = objXmlArt.SelectNodes("techniques/technique"))
                                    {
                                        if (xmlTechniquesList?.Count > 0)
                                        {
                                            foreach (XmlNode xmlTechnique in xmlTechniquesList)
                                            {
                                                MartialArtTechnique objTechnique = new MartialArtTechnique(CharacterObject);
                                                XmlNode xmlTechniqueNode = objXmlMartialArtDocument.TryGetNodeByNameOrId(
                                                    "/chummer/techniques/technique", xmlTechnique["name"]?.InnerTextViaPool(token),
                                                    await CharacterObjectSettings.BookXPathAsync(token: token)
                                                        .ConfigureAwait(false));
                                                await objTechnique.CreateAsync(xmlTechniqueNode, token)
                                                    .ConfigureAwait(false);
                                                await objArt.Techniques.AddAsync(objTechnique, token).ConfigureAwait(false);
                                            }
                                        }
                                    }
                                }
                                catch
                                {
                                    await objArt.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }
                        }
                    }
                }

                /*
                // Update Adept Powers.
                if (objXmlKit["powers"] != null)
                {
                    // Open the Powers XML file and locate the selected power.
                    XmlDocument objXmlPowerDocument = XmlManager.Load("powers.xml");

                    foreach (XmlNode objXmlPower in objXmlKit.SelectNodes("powers/power"))
                    {
                        //TODO: Fix
                    }
                }
                */

                // Update Complex Forms.
                XmlElement xmlComplexForms = objXmlKit["complexforms"];
                if (xmlComplexForms != null)
                {
                    // Open the Programs XML file and locate the selected program.
                    XmlDocument objXmlComplexFormDocument
                        = await CharacterObject.LoadDataAsync("complexforms.xml", token: token).ConfigureAwait(false);
                    using (XmlNodeList xmlComplexFormsList = xmlComplexForms.SelectNodes("complexform"))
                    {
                        if (xmlComplexFormsList?.Count > 0)
                        {
                            foreach (XmlNode objXmlComplexForm in xmlComplexFormsList)
                            {
                                XmlNode objXmlComplexFormNode =
                                    objXmlComplexFormDocument.TryGetNodeByNameOrId(
                                        "/chummer/complexforms/complexform", objXmlComplexForm["name"]?.InnerTextViaPool(token),
                                        await CharacterObjectSettings.BookXPathAsync(token: token)
                                            .ConfigureAwait(false));
                                if (objXmlComplexFormNode != null)
                                {
                                    ComplexForm objComplexForm = new ComplexForm(CharacterObject);
                                    try
                                    {
                                        await objComplexForm.CreateAsync(objXmlComplexFormNode, token: token)
                                            .ConfigureAwait(false);
                                        if (objComplexForm.InternalId.IsEmptyGuid())
                                        {
                                            await objComplexForm.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                            continue;
                                        }
                                        await CharacterObject.ComplexForms.AddAsync(objComplexForm, token)
                                            .ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await objComplexForm.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }
                            }
                        }
                    }
                }

                // Update AI Programs.
                XmlElement xmlPrograms = objXmlKit["programs"];
                if (xmlPrograms != null)
                {
                    // Open the Programs XML file and locate the selected program.
                    XmlDocument objXmlProgramDocument
                        = await CharacterObject.LoadDataAsync("programs.xml", token: token).ConfigureAwait(false);
                    using (XmlNodeList xmlProgramsList = xmlPrograms.SelectNodes("program"))
                    {
                        if (xmlProgramsList?.Count > 0)
                        {
                            foreach (XmlNode objXmlProgram in xmlProgramsList)
                            {
                                XmlNode objXmlProgramNode = objXmlProgramDocument.TryGetNodeByNameOrId(
                                    "/chummer/programs/program", objXmlProgram["name"]?.InnerTextViaPool(token),
                                    await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false));
                                if (objXmlProgramNode != null)
                                {
                                    AIProgram objProgram = new AIProgram(CharacterObject);
                                    await objProgram.CreateAsync(objXmlProgramNode, token: token).ConfigureAwait(false);
                                    await CharacterObject.AIPrograms.AddAsync(objProgram, token).ConfigureAwait(false);
                                }
                            }
                        }
                    }
                }

                // Update Spells.
                XmlElement xmlSpells = objXmlKit["spells"];
                if (xmlSpells != null)
                {
                    XmlDocument objXmlSpellDocument
                        = await CharacterObject.LoadDataAsync("spells.xml", token: token).ConfigureAwait(false);
                    using (XmlNodeList xmlSpellsList = xmlSpells.SelectNodes("spell"))
                    {
                        if (xmlSpellsList?.Count > 0)
                        {
                            foreach (XmlNode objXmlSpell in xmlSpellsList)
                            {
                                string strCategory = objXmlSpell["category"]?.InnerTextViaPool(token);
                                string strName = objXmlSpell["name"].InnerTextViaPool(token);
                                // Make sure the Spell has not already been added to the character.
                                if (await CharacterObject.Spells
                                        .AnyAsync(x => x.Name == strName && x.Category == strCategory, token)
                                        .ConfigureAwait(false))
                                    continue;
                                XmlNode objXmlSpellNode = objXmlSpellDocument.TryGetNodeByNameOrId(
                                    "/chummer/spells/spell", strName,
                                    "category = " + strCategory.CleanXPath() + " and (" + await CharacterObjectSettings
                                        .BookXPathAsync(token: token).ConfigureAwait(false) + ")");

                                if (objXmlSpellNode == null)
                                    continue;

                                string strForceValue = objXmlSpell.Attributes?["select"]?.InnerTextViaPool(token) ?? string.Empty;
                                Spell objSpell = new Spell(CharacterObject);
                                try
                                {
                                    await objSpell.CreateAsync(objXmlSpellNode, strForceValue, token: token)
                                        .ConfigureAwait(false);
                                    await CharacterObject.Spells.AddAsync(objSpell, token).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await objSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }
                        }
                    }
                }

                // Update Spirits.
                XmlElement xmlSpirits = objXmlKit["spirits"];
                if (xmlSpirits != null)
                {
                    using (XmlNodeList xmlSpiritsList = xmlSpirits.SelectNodes("spirit"))
                    {
                        if (xmlSpiritsList?.Count > 0)
                        {
                            foreach (XmlNode objXmlSpirit in xmlSpiritsList)
                            {
                                int.TryParse(objXmlSpirit["force"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intForce);
                                int.TryParse(objXmlSpirit["services"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intServices);
                                Spirit objSpirit = new Spirit(CharacterObject);
                                try
                                {
                                    await objSpirit.SetEntityTypeAsync(SpiritType.Spirit, token).ConfigureAwait(false);
                                    await objSpirit.SetNameAsync(objXmlSpirit["name"].InnerTextViaPool(token), token).ConfigureAwait(false);
                                    await objSpirit.SetForceAsync(intForce, token).ConfigureAwait(false);
                                    await objSpirit.SetServicesOwedAsync(intServices, token).ConfigureAwait(false);
                                    await CharacterObject.Spirits.AddAsync(objSpirit, token).ConfigureAwait(false);
                                }
                                catch
                                {
                                    try
                                    {
                                        await CharacterObject.Spirits.RemoveAsync(objSpirit, token: token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        //swallow this
                                    }
                                    await objSpirit.DisposeAsync().ConfigureAwait(false);
                                    throw;
                                }
                            }
                        }
                    }
                }

                // Update Lifestyles.
                XmlElement xmlLifestyles = objXmlKit["lifestyles"];
                if (xmlLifestyles != null)
                {
                    XmlDocument objXmlLifestyleDocument
                        = await CharacterObject.LoadDataAsync("lifestyles.xml", token: token).ConfigureAwait(false);

                    foreach (XmlNode objXmlLifestyle in xmlLifestyles.SelectNodes("lifestyle"))
                    {
                        // Create the Lifestyle.
                        XmlNode objXmlLifestyleNode = objXmlLifestyleDocument.TryGetNodeByNameOrId(
                            "/chummer/lifestyles/lifestyle", objXmlLifestyle["baselifestyle"].InnerTextViaPool(token));
                        if (objXmlLifestyleNode == null)
                            continue;
                        Lifestyle objLifestyle = new Lifestyle(CharacterObject);
                        try
                        {
                            await objLifestyle.CreateAsync(objXmlLifestyleNode, token).ConfigureAwait(false);
                            // This is an Advanced Lifestyle, so build it manually.
                            objLifestyle.CustomName = objXmlLifestyle["name"]?.InnerTextViaPool(token) ?? string.Empty;
                            int.TryParse(objXmlLifestyle["comforts"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intComforts);
                            objLifestyle.Comforts = intComforts;
                            int.TryParse(objXmlLifestyle["security"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intSecurity);
                            objLifestyle.Security = intSecurity;
                            int.TryParse(objXmlLifestyle["area"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intArea);
                            objLifestyle.Area = intArea;

                            foreach (XmlNode objXmlQuality in objXmlLifestyle.SelectNodes("qualities/quality"))
                            {
                                LifestyleQuality lq = new LifestyleQuality(CharacterObject);
                                try
                                {
                                    await lq.CreateAsync(objXmlQuality, objLifestyle, CharacterObject, QualitySource.Selected,
                                        token: token).ConfigureAwait(false);
                                    await objLifestyle.LifestyleQualities.AddAsync(lq, token).ConfigureAwait(false);
                                }
                                catch
                                {
                                    await lq.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }

                            // Add the Lifestyle to the character and Lifestyle Tree.
                            await CharacterObject.Lifestyles.AddAsync(objLifestyle, token).ConfigureAwait(false);
                        }
                        catch
                        {
                            await objLifestyle.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                }

                // Update NuyenBP.
                string strNuyenBP = objXmlKit["nuyenbp"]?.InnerTextViaPool(token);
                if (!string.IsNullOrEmpty(strNuyenBP)
                    && decimal.TryParse(strNuyenBP, NumberStyles.Any, GlobalSettings.InvariantCultureInfo,
                        out decimal decAmount))
                {
                    //if (_objCharacter.BuildMethod == CharacterBuildMethod.Karma)
                    //decAmount *= 2;

                    await CharacterObject.ModifyNuyenBPAsync(decAmount, token).ConfigureAwait(false);
                }

                XmlDocument objXmlGearDocument
                    = await CharacterObject.LoadDataAsync("gear.xml", token: token).ConfigureAwait(false);

                // Update Armor.
                XmlElement xmlArmors = objXmlKit["armors"];
                if (xmlArmors != null)
                {
                    XmlDocument objXmlArmorDocument
                        = await CharacterObject.LoadDataAsync("armor.xml", token: token).ConfigureAwait(false);
                    foreach (XmlNode objXmlArmor in xmlArmors.SelectNodes("armor"))
                    {
                        XmlNode objXmlArmorNode = objXmlArmorDocument.TryGetNodeByNameOrId(
                            "/chummer/armors/armor", objXmlArmor["name"].InnerTextViaPool(token),
                            await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false));
                        if (objXmlArmorNode == null)
                            continue;
                        Armor objArmor = new Armor(CharacterObject);
                        List<Weapon> lstWeapons = new List<Weapon>(1);
                        try
                        {
                            int.TryParse(objXmlArmor["rating"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intRating);
                            await objArmor.CreateAsync(objXmlArmorNode,
                                intRating, lstWeapons, false,
                                blnCreateChildren, token: token).ConfigureAwait(false);
                            await CharacterObject.Armor.AddAsync(objArmor, token).ConfigureAwait(false);

                            // Look for Armor Mods.
                            foreach (XmlNode objXmlMod in objXmlArmor.SelectNodes("mods/mod"))
                            {
                                XmlNode objXmlModNode = objXmlArmorDocument.TryGetNodeByNameOrId(
                                    "/chummer/mods/mod", objXmlMod["name"].InnerTextViaPool(token),
                                    await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false));
                                if (objXmlModNode != null)
                                {
                                    ArmorMod objMod = new ArmorMod(CharacterObject, objArmor);
                                    try
                                    {
                                        if (objXmlMod["rating"] != null)
                                            int.TryParse(objXmlMod["rating"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out intRating);
                                        await objMod.CreateAsync(objXmlModNode, intRating, lstWeapons, token: token)
                                            .ConfigureAwait(false);

                                        foreach (XmlNode objXmlGear in objXmlArmor.SelectNodes("gears/gear"))
                                            await AddPACKSGearAsync(objXmlGearDocument, objXmlGear, objMod, blnCreateChildren,
                                                token).ConfigureAwait(false);

                                        await objArmor.ArmorMods.AddAsync(objMod, token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await objMod.DeleteArmorModAsync(token: CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }
                            }

                            foreach (Weapon objWeapon in lstWeapons)
                                await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);

                            foreach (XmlNode objXmlGear in objXmlArmor.SelectNodes("gears/gear"))
                                await AddPACKSGearAsync(objXmlGearDocument, objXmlGear, objArmor, blnCreateChildren, token)
                                    .ConfigureAwait(false);
                        }
                        catch
                        {
                            foreach (Weapon objWeapon in lstWeapons)
                                await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                            await objArmor.DeleteArmorAsync(token: CancellationToken.None).ConfigureAwait(false);
                            throw;
                        }
                    }
                }

                // Update Weapons.
                XmlElement xmlWeapons = objXmlKit["weapons"];
                if (xmlWeapons != null)
                {
                    XmlDocument objXmlWeaponDocument
                        = await CharacterObject.LoadDataAsync("weapons.xml", token: token).ConfigureAwait(false);

                    XmlNodeList xmlWeaponsList = xmlWeapons.SelectNodes("weapon");
                    await tsMain.DoThreadSafeAsync(() =>
                    {
                        pgbProgress.Visible = true;
                        pgbProgress.Value = 0;
                        pgbProgress.Maximum = xmlWeaponsList.Count;
                    }, token).ConfigureAwait(false);
                    int i = 0;
                    try
                    {
                        foreach (XmlNode objXmlWeapon in xmlWeaponsList)
                        {
                            int i2 = ++i;
                            await tsMain.DoThreadSafeAsync(() => pgbProgress.Value = i2, token).ConfigureAwait(false);
                            Utils.DoEventsSafe();

                            XmlNode objXmlWeaponNode = objXmlWeaponDocument.TryGetNodeByNameOrId(
                                "/chummer/weapons/weapon", objXmlWeapon["name"].InnerTextViaPool(token),
                                await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false));
                            if (objXmlWeaponNode != null)
                            {
                                List<Weapon> lstWeapons = new List<Weapon>(1);
                                Weapon objWeapon = new Weapon(CharacterObject);
                                try
                                {
                                    await objWeapon.CreateAsync(objXmlWeaponNode, lstWeapons, blnCreateChildren,
                                            token: token)
                                        .ConfigureAwait(false);
                                    await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);

                                    // Look for Weapon Accessories.
                                    foreach (XmlNode objXmlAccessory in objXmlWeapon.SelectNodes("accessories/accessory"))
                                    {
                                        XmlNode objXmlAccessoryNode = objXmlWeaponDocument.TryGetNodeByNameOrId(
                                            "/chummer/accessories/accessory", objXmlAccessory["name"].InnerTextViaPool(token),
                                            await CharacterObjectSettings.BookXPathAsync(token: token)
                                                .ConfigureAwait(false));
                                        if (objXmlAccessoryNode == null)
                                            continue;
                                        string strMount = objXmlAccessory["mount"]?.InnerTextViaPool(token) ?? "Internal";
                                        string strExtraMount = objXmlAccessory["extramount"]?.InnerTextViaPool(token) ?? "None";
                                        WeaponAccessory objMod = new WeaponAccessory(CharacterObject);
                                        try
                                        {
                                            await objMod.CreateAsync(objXmlAccessoryNode,
                                                new ValueTuple<string, string>(strMount, strExtraMount), 0,
                                                false, blnCreateChildren, token: token).ConfigureAwait(false);
                                            await objMod.SetParentAsync(objWeapon, token).ConfigureAwait(false);

                                            await objWeapon.WeaponAccessories.AddAsync(objMod, token).ConfigureAwait(false);

                                            foreach (XmlNode objXmlGear in objXmlAccessory.SelectNodes("gears/gear"))
                                                await AddPACKSGearAsync(objXmlGearDocument, objXmlGear, objMod,
                                                    blnCreateChildren,
                                                    token).ConfigureAwait(false);
                                        }
                                        catch
                                        {
                                            await objMod.DeleteWeaponAccessoryAsync(token: CancellationToken.None).ConfigureAwait(false);
                                            throw;
                                        }
                                    }

                                    // Look for an Underbarrel Weapon.
                                    XmlElement xmlUnderbarrelNode = objXmlWeapon["underbarrel"];
                                    if (xmlUnderbarrelNode != null)
                                    {
                                        XmlNode objXmlUnderbarrelNode = objXmlWeaponDocument.TryGetNodeByNameOrId(
                                            "/chummer/weapons/weapon", objXmlWeapon["underbarrel"].InnerTextViaPool(token),
                                            await CharacterObjectSettings.BookXPathAsync(token: token)
                                                .ConfigureAwait(false));
                                        if (objXmlUnderbarrelNode == null)
                                        {
                                            List<Weapon> lstLoopWeapons = new List<Weapon>(1);
                                            Weapon objUnderbarrelWeapon = new Weapon(CharacterObject);
                                            try
                                            {
                                                await objUnderbarrelWeapon.CreateAsync(objXmlUnderbarrelNode, lstLoopWeapons,
                                                    blnCreateChildren, token: token).ConfigureAwait(false);
                                                await objWeapon.UnderbarrelWeapons.AddAsync(objUnderbarrelWeapon, token)
                                                    .ConfigureAwait(false);
                                                if (!objWeapon.AllowAccessory)
                                                    objUnderbarrelWeapon.AllowAccessory = false;

                                                foreach (Weapon objLoopWeapon in lstLoopWeapons)
                                                {
                                                    if (!objWeapon.AllowAccessory)
                                                        objLoopWeapon.AllowAccessory = false;
                                                    await objWeapon.UnderbarrelWeapons.AddAsync(objLoopWeapon, token)
                                                        .ConfigureAwait(false);
                                                }

                                                foreach (XmlNode objXmlAccessory in xmlUnderbarrelNode.SelectNodes(
                                                             "accessories/accessory"))
                                                {
                                                    XmlNode objXmlAccessoryNode =
                                                        objXmlWeaponDocument.TryGetNodeByNameOrId(
                                                            "/chummer/accessories/accessory", objXmlAccessory["name"].InnerTextViaPool(token),
                                                            await CharacterObjectSettings.BookXPathAsync(token: token)
                                                                .ConfigureAwait(false));
                                                    if (objXmlAccessoryNode == null)
                                                        continue;
                                                    string strMount = objXmlAccessory["mount"]?.InnerTextViaPool(token) ?? "Internal";
                                                    string strExtraMount = objXmlAccessory["extramount"]?.InnerTextViaPool(token) ?? "None";
                                                    WeaponAccessory objMod = new WeaponAccessory(CharacterObject);
                                                    try
                                                    {
                                                        await objMod.CreateAsync(objXmlAccessoryNode,
                                                            new ValueTuple<string, string>(strMount, strExtraMount), 0, false,
                                                            blnCreateChildren, token: token).ConfigureAwait(false);
                                                        await objMod.SetParentAsync(objWeapon, token).ConfigureAwait(false);

                                                        await objUnderbarrelWeapon.WeaponAccessories.AddAsync(objMod, token)
                                                            .ConfigureAwait(false);

                                                        foreach (XmlNode objXmlGear in objXmlAccessory.SelectNodes("gears/gear"))
                                                            await AddPACKSGearAsync(objXmlGearDocument, objXmlGear, objMod,
                                                                blnCreateChildren, token).ConfigureAwait(false);
                                                    }
                                                    catch
                                                    {
                                                        await objMod.DeleteWeaponAccessoryAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                        throw;
                                                    }
                                                }
                                            }
                                            catch
                                            {
                                                foreach (Weapon objLoopWeapon in lstLoopWeapons)
                                                    await objLoopWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                await objUnderbarrelWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                throw;
                                            }
                                        }
                                    }

                                    foreach (Weapon objLoopWeapon in lstWeapons)
                                    {
                                        await CharacterObject.Weapons.AddAsync(objLoopWeapon, token).ConfigureAwait(false);
                                    }
                                }
                                catch
                                {
                                    foreach (Weapon objLoopWeapon in lstWeapons)
                                        await objLoopWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                    await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                    throw;
                                }
                            }

                            Utils.DoEventsSafe();
                        }
                    }
                    finally
                    {
                        await tsMain.DoThreadSafeAsync(() => pgbProgress.Visible = false, token).ConfigureAwait(false);
                    }
                }

                XmlDocument objXmlCyberwareDocument
                    = await CharacterObject.LoadDataAsync("cyberware.xml", token: token).ConfigureAwait(false);
                XmlDocument objXmlBiowareDocument
                    = await CharacterObject.LoadDataAsync("bioware.xml", token: token).ConfigureAwait(false);

                // Update Cyberware.
                XmlElement xmlCyberwares = objXmlKit["cyberwares"];
                if (xmlCyberwares != null)
                {
                    XmlNodeList xmlCyberwaresList = xmlCyberwares.SelectNodes("cyberware");
                    await tsMain.DoThreadSafeAsync(() =>
                    {
                        pgbProgress.Visible = true;
                        pgbProgress.Value = 0;
                        pgbProgress.Maximum = xmlCyberwaresList.Count;
                    }, token).ConfigureAwait(false);
                    int i = 0;
                    try
                    {
                        foreach (XmlNode objXmlCyberware in xmlCyberwaresList)
                        {
                            int i2 = ++i;
                            await tsMain.DoThreadSafeAsync(() => pgbProgress.Value = i2, token).ConfigureAwait(false);
                            Utils.DoEventsSafe();

                            await AddPACKSCyberwareAsync(objXmlCyberwareDocument, objXmlBiowareDocument,
                                objXmlGearDocument,
                                objXmlCyberware, CharacterObject, blnCreateChildren, token).ConfigureAwait(false);

                            Utils.DoEventsSafe();
                        }
                    }
                    finally
                    {
                        await tsMain.DoThreadSafeAsync(() => pgbProgress.Visible = false, token).ConfigureAwait(false);
                    }
                }

                // Update Bioware.
                XmlElement xmlBiowares = objXmlKit["biowares"];
                if (xmlBiowares != null)
                {
                    XmlNodeList xmlBiowaresList = xmlBiowares.SelectNodes("bioware");
                    await tsMain.DoThreadSafeAsync(() =>
                    {
                        pgbProgress.Visible = true;
                        pgbProgress.Value = 0;
                        pgbProgress.Maximum = xmlBiowaresList.Count;
                    }, token).ConfigureAwait(false);
                    int i = 0;
                    try
                    {
                        foreach (XmlNode objXmlBioware in xmlBiowaresList)
                        {
                            int i2 = ++i;
                            await tsMain.DoThreadSafeAsync(() => pgbProgress.Value = i2, token).ConfigureAwait(false);
                            Utils.DoEventsSafe();

                            await AddPACKSCyberwareAsync(objXmlCyberwareDocument, objXmlBiowareDocument,
                                objXmlGearDocument,
                                objXmlBioware,
                                CharacterObject, blnCreateChildren, token).ConfigureAwait(false);

                            Utils.DoEventsSafe();
                        }
                    }
                    finally
                    {
                        await tsMain.DoThreadSafeAsync(() => pgbProgress.Visible = false, token).ConfigureAwait(false);
                    }
                }

                // Update Gear.
                XmlElement xmlGears = objXmlKit["gears"];
                if (xmlGears != null)
                {
                    XmlNodeList xmlGearsList = xmlGears.SelectNodes("gear");
                    await tsMain.DoThreadSafeAsync(() =>
                    {
                        pgbProgress.Visible = true;
                        pgbProgress.Value = 0;
                        pgbProgress.Maximum = xmlGearsList.Count;
                    }, token).ConfigureAwait(false);
                    int i = 0;
                    try
                    {
                        foreach (XmlNode objXmlGear in xmlGearsList)
                        {
                            int i2 = ++i;
                            await tsMain.DoThreadSafeAsync(() => pgbProgress.Value = i2, token).ConfigureAwait(false);
                            Utils.DoEventsSafe();

                            await AddPACKSGearAsync(objXmlGearDocument, objXmlGear, CharacterObject, blnCreateChildren,
                                token).ConfigureAwait(false);

                            Utils.DoEventsSafe();
                        }
                    }
                    finally
                    {
                        await tsMain.DoThreadSafeAsync(() => pgbProgress.Visible = false, token).ConfigureAwait(false);
                    }
                }

                // Update Vehicles.
                XmlElement xmlVehicles = objXmlKit["vehicles"];
                if (xmlVehicles != null)
                {
                    XmlDocument objXmlVehicleDocument
                        = await CharacterObject.LoadDataAsync("vehicles.xml", token: token).ConfigureAwait(false);
                    XmlNodeList xmlVehiclesList = xmlVehicles.SelectNodes("vehicle");
                    await tsMain.DoThreadSafeAsync(() =>
                    {
                        pgbProgress.Visible = true;
                        pgbProgress.Value = 0;
                        pgbProgress.Maximum = xmlVehiclesList.Count;
                    }, token).ConfigureAwait(false);
                    try
                    {
                        int i = 0;
                        foreach (XmlNode objXmlVehicle in xmlVehiclesList)
                        {
                            int i2 = ++i;
                            await tsMain.DoThreadSafeAsync(() => pgbProgress.Value = i2, token).ConfigureAwait(false);
                            Utils.DoEventsSafe();

                            Gear objDefaultSensor = null;

                            XmlNode objXmlVehicleNode = objXmlVehicleDocument.TryGetNodeByNameOrId(
                                "/chummer/vehicles/vehicle", objXmlVehicle["name"].InnerTextViaPool(token),
                                await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false));
                            if (objXmlVehicleNode == null)
                                continue;
                            Vehicle objVehicle = new Vehicle(CharacterObject);
                            try
                            {
                                await objVehicle
                                    .CreateAsync(objXmlVehicleNode, blnCreateChildren: blnCreateChildren, token: token)
                                    .ConfigureAwait(false);
                                await CharacterObject.Vehicles.AddAsync(objVehicle, token).ConfigureAwait(false);

                                // Grab the default Sensor that comes with the Vehicle.
                                foreach (Gear objSensorGear in objVehicle.GearChildren)
                                {
                                    if (objSensorGear.Category == "Sensors" && objSensorGear.Cost == "0"
                                                                            && await objSensorGear.GetRatingAsync(token)
                                                                                .ConfigureAwait(false) == 0)
                                    {
                                        objDefaultSensor = objSensorGear;
                                        break;
                                    }
                                }

                                // Add any Vehicle Mods.
                                foreach (XmlNode objXmlMod in objXmlVehicle.SelectNodes("mods/mod"))
                                {
                                    XmlNode objXmlModNode = objXmlVehicleDocument.TryGetNodeByNameOrId(
                                        "/chummer/mods/mod", objXmlMod["name"].InnerTextViaPool(token),
                                        await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false));
                                    if (objXmlModNode == null)
                                        continue;
                                    int intRating = 0;
                                    objXmlMod.TryGetInt32FieldQuickly("rating", ref intRating);
                                    VehicleMod objMod = new VehicleMod(CharacterObject);
                                    try
                                    {
                                        await objMod.CreateAsync(objXmlModNode, intRating, objVehicle, token: token)
                                            .ConfigureAwait(false);
                                        await objVehicle.Mods.AddAsync(objMod, token).ConfigureAwait(false);

                                        foreach (XmlNode objXmlCyberware in objXmlMod.SelectNodes("cyberwares/cyberware"))
                                            await AddPACKSCyberwareAsync(objXmlCyberwareDocument, objXmlBiowareDocument,
                                                objXmlGearDocument,
                                                objXmlCyberware, objMod, blnCreateChildren, token).ConfigureAwait(false);
                                    }
                                    catch
                                    {
                                        await objMod.DeleteVehicleModAsync(token: CancellationToken.None).ConfigureAwait(false);
                                        throw;
                                    }
                                }

                                // Add any Vehicle Gear.
                                foreach (XmlNode objXmlGear in objXmlVehicle.SelectNodes("gears/gear"))
                                {
                                    Gear objGear =
                                        await AddPACKSGearAsync(objXmlGearDocument, objXmlGear, objVehicle,
                                            blnCreateChildren,
                                            token).ConfigureAwait(false);
                                    // If this is a Sensor, it will replace the Vehicle's base sensor, so remove it.
                                    if (objGear?.Category == "Sensors" && objGear.Cost == "0" &&
                                        await objGear.GetRatingAsync(token).ConfigureAwait(false) == 0)
                                    {
                                        await objVehicle.GearChildren.RemoveAsync(objDefaultSensor, token)
                                            .ConfigureAwait(false);
                                    }
                                }

                                // Add any Vehicle Weapons.
                                if (objXmlVehicle["weapons"] != null)
                                {
                                    XmlDocument objXmlWeaponDocument = await CharacterObject
                                        .LoadDataAsync("weapons.xml", token: token)
                                        .ConfigureAwait(false);

                                    foreach (XmlNode objXmlWeapon in objXmlVehicle.SelectNodes("weapons/weapon"))
                                    {
                                        List<Weapon> lstSubWeapons = new List<Weapon>(1);
                                        XmlNode objXmlWeaponNode = objXmlWeaponDocument.TryGetNodeByNameOrId(
                                            "/chummer/weapons/weapon", objXmlWeapon["name"].InnerTextViaPool(token),
                                            await CharacterObjectSettings.BookXPathAsync(token: token)
                                                .ConfigureAwait(false));
                                        if (objXmlWeaponNode == null)
                                            continue;
                                        Weapon objWeapon = new Weapon(CharacterObject);
                                        try
                                        {
                                            await objWeapon.SetParentVehicleAsync(objVehicle, token).ConfigureAwait(false);
                                            await objWeapon
                                                .CreateAsync(objXmlWeaponNode, lstSubWeapons, blnCreateChildren, token: token)
                                                .ConfigureAwait(false);

                                            // Find the first Weapon Mount in the Vehicle.
                                            await objVehicle.Mods.ForEachWithBreakAsync(async objMod =>
                                            {
                                                if (objMod.Name.Contains("Weapon Mount")
                                                    || !string.IsNullOrEmpty(objMod.WeaponMountCategories)
                                                    && objMod.WeaponMountCategories.Contains(objWeapon.Category))
                                                {
                                                    await objMod.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                                                    foreach (Weapon objSubWeapon in lstSubWeapons)
                                                        await objMod.Weapons.AddAsync(objSubWeapon, token)
                                                            .ConfigureAwait(false);
                                                    return false;
                                                }

                                                return true;
                                            }, token).ConfigureAwait(false);

                                            // Look for Weapon Accessories.
                                            foreach (XmlNode objXmlAccessory in objXmlWeapon.SelectNodes(
                                                         "accessories/accessory"))
                                            {
                                                XmlNode objXmlAccessoryNode =
                                                    objXmlWeaponDocument.TryGetNodeByNameOrId(
                                                        "/chummer/accessories/accessory", objXmlAccessory["name"].InnerTextViaPool(token),
                                                        await CharacterObjectSettings.BookXPathAsync(token: token)
                                                            .ConfigureAwait(false));
                                                if (objXmlAccessoryNode == null)
                                                    continue;
                                                string strMount = objXmlAccessory["mount"]?.InnerTextViaPool(token) ?? "Internal";
                                                string strExtraMount = objXmlAccessory["extramount"]?.InnerTextViaPool(token) ?? "None";
                                                WeaponAccessory objMod = new WeaponAccessory(CharacterObject);
                                                try
                                                {
                                                    await objMod.CreateAsync(objXmlAccessoryNode,
                                                        new ValueTuple<string, string>(strMount, strExtraMount),
                                                        0, false, blnCreateChildren, token: token).ConfigureAwait(false);
                                                    await objMod.SetParentAsync(objWeapon, token).ConfigureAwait(false);

                                                    await objWeapon.WeaponAccessories.AddAsync(objMod, token).ConfigureAwait(false);
                                                }
                                                catch
                                                {
                                                    await objMod.DeleteWeaponAccessoryAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                    throw;
                                                }
                                            }

                                            // Look for an Underbarrel Weapon.
                                            XmlElement xmlUnderbarrelNode = objXmlWeapon["underbarrel"];
                                            if (xmlUnderbarrelNode != null)
                                            {
                                                XmlNode objXmlUnderbarrelNode =
                                                    objXmlWeaponDocument.TryGetNodeByNameOrId(
                                                        "/chummer/weapons/weapon", objXmlWeapon["underbarrel"].InnerTextViaPool(token),
                                                        await CharacterObjectSettings.BookXPathAsync(token: token)
                                                            .ConfigureAwait(false));
                                                if (objXmlUnderbarrelNode != null)
                                                {
                                                    List<Weapon> lstLoopWeapons = new List<Weapon>(1);
                                                    Weapon objUnderbarrelWeapon = new Weapon(CharacterObject);
                                                    try
                                                    {
                                                        await objUnderbarrelWeapon.CreateAsync(objXmlUnderbarrelNode,
                                                            lstLoopWeapons,
                                                            blnCreateChildren, token: token).ConfigureAwait(false);
                                                        await objWeapon.UnderbarrelWeapons.AddAsync(objUnderbarrelWeapon, token)
                                                            .ConfigureAwait(false);
                                                        if (!objWeapon.AllowAccessory)
                                                            objUnderbarrelWeapon.AllowAccessory = false;

                                                        foreach (Weapon objLoopWeapon in lstLoopWeapons)
                                                        {
                                                            if (!objWeapon.AllowAccessory)
                                                                objLoopWeapon.AllowAccessory = false;
                                                            await objWeapon.UnderbarrelWeapons.AddAsync(objLoopWeapon, token)
                                                                .ConfigureAwait(false);
                                                        }

                                                        foreach (XmlNode objXmlAccessory in xmlUnderbarrelNode.SelectNodes(
                                                                     "accessories/accessory"))
                                                        {
                                                            XmlNode objXmlAccessoryNode = objXmlWeaponDocument.TryGetNodeByNameOrId(
                                                                "/chummer/accessories/accessory", objXmlAccessory["name"].InnerTextViaPool(token),
                                                                await CharacterObjectSettings.BookXPathAsync(token: token)
                                                                    .ConfigureAwait(false));
                                                            if (objXmlAccessoryNode == null)
                                                                continue;
                                                            string strMount = objXmlAccessory["mount"]?.InnerTextViaPool(token) ?? "Internal";
                                                            string strExtraMount =
                                                                objXmlAccessory["extramount"]?.InnerTextViaPool(token) ?? "None";
                                                            WeaponAccessory objMod = new WeaponAccessory(CharacterObject);
                                                            try
                                                            {
                                                                await objMod.CreateAsync(objXmlAccessoryNode,
                                                                    new ValueTuple<string, string>(strMount, strExtraMount), 0, false,
                                                                    blnCreateChildren, token: token).ConfigureAwait(false);
                                                                await objMod.SetParentAsync(objWeapon, token).ConfigureAwait(false);

                                                                await objUnderbarrelWeapon.WeaponAccessories.AddAsync(objMod, token)
                                                                    .ConfigureAwait(false);

                                                                foreach (XmlNode objXmlGear in
                                                                         objXmlAccessory.SelectNodes("gears/gear"))
                                                                    await AddPACKSGearAsync(objXmlGearDocument, objXmlGear, objMod,
                                                                        blnCreateChildren, token).ConfigureAwait(false);
                                                            }
                                                            catch
                                                            {
                                                                await objMod.DeleteWeaponAccessoryAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                                throw;
                                                            }
                                                        }
                                                    }
                                                    catch
                                                    {
                                                        foreach (Weapon objLoopWeapon in lstLoopWeapons)
                                                            await objLoopWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                        await objUnderbarrelWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                                        throw;
                                                    }
                                                }
                                            }
                                        }
                                        catch
                                        {
                                            foreach (Weapon objLoopWeapon in lstSubWeapons)
                                                await objLoopWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                            await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                                            throw;
                                        }
                                    }
                                }

                                Utils.DoEventsSafe();
                            }
                            catch
                            {
                                await objVehicle.DeleteVehicleAsync(CancellationToken.None).ConfigureAwait(false);
                                throw;
                            }
                        }
                    }
                    finally
                    {
                        await tsMain.DoThreadSafeAsync(() => pgbProgress.Visible = false, token).ConfigureAwait(false);
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            return blnAddAgain;
        }

        /// <summary>
        /// Create a PACKS Kit from the character.
        /// </summary>
        public async Task CreatePACKSKit(CancellationToken token = default)
        {
            using (ThreadSafeForm<CreatePACKSKit> frmBuildPACKSKit = await ThreadSafeForm<CreatePACKSKit>
                                                                           .GetAsync(
                                                                               () => new CreatePACKSKit(
                                                                                   CharacterObject), token)
                                                                           .ConfigureAwait(false))
                await frmBuildPACKSKit.ShowDialogSafeAsync(this, token).ConfigureAwait(false);
        }

        /// <summary>
        /// Update the karma cost tooltip for Initiation/Submersion.
        /// </summary>
        private async Task UpdateInitiationCost(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            string strInitTip;
            IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterReadLockAsync(token)
                .ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker2 = await CharacterObjectSettings.LockObject.EnterReadLockAsync(token)
                .ConfigureAwait(false);
                try
                {
                    token.ThrowIfCancellationRequested();
                    decimal decMultiplier = 1.0m;
                    int intAmount;
                    if (await CharacterObject.GetMAGEnabledAsync(token).ConfigureAwait(false))
                    {
                        if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaMAGInitiationGroupPercentAsync(token).ConfigureAwait(false);
                        if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaMAGInitiationOrdealPercentAsync(token).ConfigureAwait(false);
                        if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaMAGInitiationSchoolingPercentAsync(token).ConfigureAwait(false);
                        int intGrade = await CharacterObject.GetInitiateGradeAsync(token).ConfigureAwait(false);
                        intAmount = ((await CharacterObjectSettings.GetKarmaInitiationFlatAsync(token).ConfigureAwait(false)
                                      + (intGrade + 1) * await CharacterObjectSettings.GetKarmaInitiationAsync(token).ConfigureAwait(false))
                                     * decMultiplier).StandardRound();
                        token.ThrowIfCancellationRequested();
                        strInitTip = string.Format(GlobalSettings.CultureInfo,
                            await LanguageManager
                                .GetStringAsync("Tip_ImproveInitiateGrade", token: token)
                                .ConfigureAwait(false),
                            (intGrade + 1).ToString(GlobalSettings.CultureInfo),
                            intAmount.ToString(GlobalSettings.CultureInfo));
                    }
                    else
                    {
                        if (await chkInitiationGroup.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaRESInitiationGroupPercentAsync(token).ConfigureAwait(false);
                        if (await chkInitiationOrdeal.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaRESInitiationOrdealPercentAsync(token).ConfigureAwait(false);
                        if (await chkInitiationSchooling.DoThreadSafeFuncAsync(x => x.Checked, token).ConfigureAwait(false))
                            decMultiplier -= await CharacterObjectSettings.GetKarmaRESInitiationSchoolingPercentAsync(token).ConfigureAwait(false);
                        int intGrade = await CharacterObject.GetSubmersionGradeAsync(token).ConfigureAwait(false);
                        intAmount = ((await CharacterObjectSettings.GetKarmaInitiationFlatAsync(token).ConfigureAwait(false)
                                      + (intGrade + 1) * await CharacterObjectSettings.GetKarmaInitiationAsync(token).ConfigureAwait(false))
                                     * decMultiplier).StandardRound();
                        token.ThrowIfCancellationRequested();
                        strInitTip = string.Format(GlobalSettings.CultureInfo,
                            await LanguageManager
                                .GetStringAsync("Tip_ImproveSubmersionGrade", token: token)
                                .ConfigureAwait(false),
                            (intGrade + 1).ToString(GlobalSettings.CultureInfo),
                            intAmount.ToString(GlobalSettings.CultureInfo));
                    }
                }
                finally
                {
                    await objLocker2.DisposeAsync().ConfigureAwait(false);
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }

            token.ThrowIfCancellationRequested();
            await cmdAddMetamagic.SetToolTipTextAsync(strInitTip, token).ConfigureAwait(false);
        }

        /// <summary>
        /// Change the character's Metatype or priority selection.
        /// </summary>
        public async Task ChangeMetatype(CancellationToken token = default)
        {
            if (CharacterObject.EffectiveBuildMethodUsesPriorityTables)
            {
                using (ThreadSafeForm<SelectMetatypePriority> frmSelectMetatype
                       = await ThreadSafeForm<SelectMetatypePriority>
                               .GetAsync(() => new SelectMetatypePriority(CharacterObject), token)
                               .ConfigureAwait(false))
                {
                    if (await frmSelectMetatype.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;
                }
            }
            else
            {
                using (ThreadSafeForm<SelectMetatypeKarma> frmSelectMetatype = await ThreadSafeForm<SelectMetatypeKarma>
                           .GetAsync(() => new SelectMetatypeKarma(CharacterObject), token).ConfigureAwait(false))
                {
                    if (await frmSelectMetatype.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;
                }
            }

            await MakeDirtyWithCharacterUpdate(token).ConfigureAwait(false);
        }

        /// <summary>
        /// Create a Cyberware Suite from the Cyberware the character currently has.
        /// </summary>
        private async Task CreateCyberwareSuite(Improvement.ImprovementSource objSource,
                                                     CancellationToken token = default)
        {
            // Make sure all of the Cyberware the character has is of the same grade.
            string strGrade = string.Empty;
            if (await CharacterObject.Cyberware.AnyAsync(async objCyberware =>
                {
                    if (objCyberware.SourceType != objSource)
                        return false;
                    string strLoop = (await objCyberware.GetGradeAsync(token).ConfigureAwait(false)).ToString();
                    if (string.IsNullOrEmpty(strGrade))
                        strGrade = strLoop;
                    else if (strGrade != strLoop)
                    {
                        await Program.ShowScrollableMessageBoxAsync(
                            this,
                            await LanguageManager.GetStringAsync("Message_CyberwareGradeMismatch", token: token)
                                .ConfigureAwait(false),
                            await LanguageManager.GetStringAsync("MessageTitle_CyberwareGradeMismatch", token: token)
                                .ConfigureAwait(false), MessageBoxButtons.OK, MessageBoxIcon.Error, token: token).ConfigureAwait(false);
                        return true;
                    }

                    return false;
                }, token).ConfigureAwait(false))
                return;

            // The character has no Cyberware!
            if (string.IsNullOrEmpty(strGrade))
            {
                await Program.ShowScrollableMessageBoxAsync(
                    this,
                    await LanguageManager.GetStringAsync("Message_NoCyberware", token: token).ConfigureAwait(false),
                    await LanguageManager.GetStringAsync("MessageTitle_NoCyberware", token: token)
                        .ConfigureAwait(false), MessageBoxButtons.OK, MessageBoxIcon.Exclamation, token: token).ConfigureAwait(false);
                return;
            }

            using (ThreadSafeForm<CreateCyberwareSuite> frmBuildCyberwareSuite
                   = await ThreadSafeForm<CreateCyberwareSuite>
                           .GetAsync(() => new CreateCyberwareSuite(CharacterObject, objSource), token)
                           .ConfigureAwait(false))
                await frmBuildCyberwareSuite.ShowDialogSafeAsync(this, token).ConfigureAwait(false);
        }

        /// <summary>
        /// Set the ToolTips from the Language file.
        /// </summary>
        private async Task SetTooltips(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            // Common Tab.
            await lblAttributes
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_CommonAttributes", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblAttributesBase
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_CommonAttributesBase", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblAttributesAug
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_CommonAttributesAug", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblAttributesMetatype
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_CommonAttributesMetatypeLimits", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            string strNuyenTooltip = await (await CharacterObjectSettings.GetChargenKarmaToNuyenExpressionAsync(token).ConfigureAwait(false))
                                        .CheapReplaceAsync("{Karma}", () => LanguageManager.GetStringAsync("String_Karma", token: token), token: token)
                                        .CheapReplaceAsync("{PriorityNuyen}", () => LanguageManager.GetStringAsync("Checkbox_CreatePACKSKit_StartingNuyen", token: token), token: token)
                                        .ConfigureAwait(false);
            strNuyenTooltip = await CharacterObject.ProcessAttributesInXPathForTooltipAsync(
                                                                  strNuyenTooltip, token: token).ConfigureAwait(false);
            strNuyenTooltip = string.Format(GlobalSettings.CultureInfo,
                                                         await LanguageManager
                                                               .GetStringAsync("Tip_CommonNuyen", token: token)
                                                               .ConfigureAwait(false),
                                                         strNuyenTooltip);
            await lblNuyen.SetToolTipTextAsync(strNuyenTooltip, token).ConfigureAwait(false);
            // Armor Tab.
            await chkArmorEquipped
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_ArmorEquipped", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            // Gear Tab.
            await chkGearActiveCommlink
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_ActiveCommlink", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await chkCyberwareActiveCommlink
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_ActiveCommlink", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            // Vehicles Tab.
            await chkVehicleWeaponAccessoryInstalled
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_WeaponInstalled", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await chkVehicleActiveCommlink
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_ActiveCommlink", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblVehiclePowertrainLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblVehicleCosmeticLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblVehicleElectromagneticLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblVehicleBodymodLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblVehicleWeaponsmodLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblVehicleProtectionLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_TotalVehicleModCapacity", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            // Character Info Tab.
            await chkCharacterCreated
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_CharacterCreated", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            // Build Point Summary Tab.
            await lblBuildPrimaryAttributes
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_CommonAttributes", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblBuildPositiveQualities
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_BuildPositiveQualities", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblBuildNegativeQualities
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_BuildNegativeQualities", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblBuildContacts.SetToolTipTextAsync(string.Format(GlobalSettings.CultureInfo,
                                                                 await LanguageManager
                                                                       .GetStringAsync(
                                                                           "Tip_CommonContacts", token: token)
                                                                       .ConfigureAwait(false),
                                                                 (await CharacterObjectSettings.GetKarmaContactAsync(token).ConfigureAwait(false)).ToString(
                                                                     GlobalSettings.CultureInfo)), token)
                                  .ConfigureAwait(false);
            await lblBuildEnemies
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_CommonEnemies", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblBuildNuyen.SetToolTipTextAsync(strNuyenTooltip, token).ConfigureAwait(false);
            await lblBuildSkillGroups.SetToolTipTextAsync(
                string.Format(GlobalSettings.CultureInfo,
                              await LanguageManager.GetStringAsync("Tip_SkillsSkillGroups", token: token)
                                                   .ConfigureAwait(false),
                              (await CharacterObjectSettings.GetKarmaImproveSkillGroupAsync(token).ConfigureAwait(false)).ToString(GlobalSettings.CultureInfo)),
                token).ConfigureAwait(false);
            await lblBuildActiveSkills.SetToolTipTextAsync(
                                          string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager
                                                              .GetStringAsync("Tip_SkillsActiveSkills", token: token)
                                                              .ConfigureAwait(false),
                                                        (await CharacterObjectSettings.GetKarmaImproveActiveSkillAsync(token).ConfigureAwait(false)).ToString(
                                                            GlobalSettings.CultureInfo),
                                                        (await CharacterObjectSettings.GetKarmaSpecializationAsync(token).ConfigureAwait(false)).ToString(
                                                            GlobalSettings.CultureInfo)), token)
                                      .ConfigureAwait(false);
            await lblBuildKnowledgeSkills.SetToolTipTextAsync(
                                             string.Format(GlobalSettings.CultureInfo,
                                                           await LanguageManager
                                                                 .GetStringAsync("Tip_SkillsKnowledgeSkills",
                                                                     token: token)
                                                                 .ConfigureAwait(false),
                                                           (await CharacterObjectSettings.GetKarmaImproveKnowledgeSkillAsync(token).ConfigureAwait(false)).ToString(
                                                               GlobalSettings.CultureInfo),
                                                           (await CharacterObjectSettings.GetKarmaKnowledgeSpecializationAsync(token).ConfigureAwait(false))
                                                               .ToString(GlobalSettings.CultureInfo)), token)
                                         .ConfigureAwait(false);
            await lblBuildSpells.SetToolTipTextAsync(
                                    string.Format(GlobalSettings.CultureInfo,
                                                  await LanguageManager
                                                        .GetStringAsync("Tip_SpellsSelectedSpells", token: token)
                                                        .ConfigureAwait(false),
                                                  (await CharacterObjectSettings.GetKarmaSpellAsync(token).ConfigureAwait(false)).ToString(
                                                      GlobalSettings.CultureInfo)), token)
                                .ConfigureAwait(false);
            await lblBuildSpirits.SetToolTipTextAsync(
                                     string.Format(GlobalSettings.CultureInfo,
                                                   await LanguageManager
                                                         .GetStringAsync("Tip_SpellsSpirits", token: token)
                                                         .ConfigureAwait(false),
                                                   (await CharacterObjectSettings.GetKarmaSpiritAsync(token).ConfigureAwait(false)).ToString(GlobalSettings
                                                       .CultureInfo)), token)
                                 .ConfigureAwait(false);
            await lblBuildSprites.SetToolTipTextAsync(
                                     string.Format(GlobalSettings.CultureInfo,
                                                   await LanguageManager
                                                         .GetStringAsync("Tip_TechnomancerSprites", token: token)
                                                         .ConfigureAwait(false),
                                                   (await CharacterObjectSettings.GetKarmaSpiritAsync(token).ConfigureAwait(false)).ToString(GlobalSettings
                                                       .CultureInfo)), token)
                                 .ConfigureAwait(false);
            await lblBuildComplexForms.SetToolTipTextAsync(
                                          string.Format(GlobalSettings.CultureInfo,
                                                        await LanguageManager
                                                              .GetStringAsync(
                                                                  "Tip_TechnomancerComplexForms", token: token)
                                                              .ConfigureAwait(false),
                                                        (await CharacterObjectSettings.GetKarmaNewComplexFormAsync(token).ConfigureAwait(false)).ToString(
                                                            GlobalSettings.CultureInfo)), token)
                                      .ConfigureAwait(false);
            // Other Info Tab.
            await lblCMPhysicalLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherCMPhysical", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblCMStunLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherCMStun", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblINILabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherInitiative", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblMatrixINILabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherMatrixInitiative", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblAstralINILabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherAstralInitiative", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblArmorLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherArmor", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await lblESS
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherEssence", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblRemainingNuyenLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherNuyen", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await lblMovementLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherMovement", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblSwimLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherSwim", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await lblFlyLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherFly", token: token).ConfigureAwait(false), token)
                  .ConfigureAwait(false);
            await lblLiftCarryLimitsLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherLiftAndCarryLimits", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblComposureLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherComposure", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblSurpriseLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherSurprise", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblJudgeIntentionsLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherJudgeIntentions", token: token)
                                           .ConfigureAwait(false), token).ConfigureAwait(false);
            await lblLiftCarryLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherLiftAndCarry", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
            await lblMemoryLabel
                  .SetToolTipTextAsync(
                      await LanguageManager.GetStringAsync("Tip_OtherMemory", token: token).ConfigureAwait(false),
                      token).ConfigureAwait(false);
        }

        /// <summary>
        /// Recheck all mods to see if Sensor has changed.
        /// </summary>
        private async Task UpdateSensor(Vehicle objVehicle, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            foreach (Gear objGear in objVehicle.GearChildren)
            {
                if (objGear.Category != "Sensors" || objGear.Name != "Sensor Array" || !objGear.IncludedInParent)
                    continue;
                token.ThrowIfCancellationRequested();
                // Update the name of the item in the TreeView.
                TreeNode objNode = treVehicles.FindNode(objGear.InternalId);
                if (objNode != null)
                {
                    string strText = await objGear.GetCurrentDisplayNameAsync(token).ConfigureAwait(false);
                    await treVehicles.DoThreadSafeAsync(() => objNode.Text = strText, token).ConfigureAwait(false);
                    token.ThrowIfCancellationRequested();
                }
            }
        }

        /// <summary>
        /// Enable/Disable the Paste Menu and ToolStrip items as appropriate.
        /// </summary>
        private Task DoRefreshPasteStatus(object sender, PropertyChangedEventArgs e, CancellationToken token = default)
        {
            return RefreshPasteStatus(token);
        }

        /// <summary>
        /// Enable/Disable the Paste Menu and ToolStrip items as appropriate.
        /// </summary>
        private async Task RefreshPasteStatus(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();

            bool blnPasteEnabled = false;
            bool blnCopyEnabled = false;

            TabPage objSelectedCharacterTab = await tabCharacterTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token)
                                                                    .ConfigureAwait(false);
            if (objSelectedCharacterTab == tabStreetGear)
            {
                TabPage objSelectedGearTabPage
                    = await tabStreetGearTabs.DoThreadSafeFuncAsync(x => x.SelectedTab, token).ConfigureAwait(false);
                // Lifestyle Tab.
                if (objSelectedGearTabPage == tabLifestyle)
                {
                    blnPasteEnabled = await GlobalSettings.GetClipboardContentTypeAsync(token).ConfigureAwait(false) == ClipboardContentType.Lifestyle;
                    blnCopyEnabled = await treLifestyles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token)
                                                        .ConfigureAwait(false) is Lifestyle;
                }
                // Armor Tab.
                else if (objSelectedGearTabPage == tabArmor)
                {
                    if (await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                        IHasInternalId
                        strSelectedId)
                    {
                        blnPasteEnabled = await GlobalSettings.GetClipboardContentTypeAsync(token).ConfigureAwait(false) == ClipboardContentType.Armor ||
                                          await GlobalSettings.GetClipboardContentTypeAsync(token).ConfigureAwait(false) == ClipboardContentType.Gear
                                          && (await CharacterObject.Armor
                                                  .AnyAsync(
                                                      x => x.InternalId == strSelectedId.InternalId,
                                                      token).ConfigureAwait(false)
                                              ||
                                              await CharacterObject.Armor.FindArmorModAsync(strSelectedId.InternalId, token).ConfigureAwait(false) != null ||
                                              (await CharacterObject.Armor.FindArmorGearAsync(strSelectedId.InternalId, token).ConfigureAwait(false)).Item1 != null);
                        blnCopyEnabled = await CharacterObject.Armor
                                                              .AnyAsync(x => x.InternalId == strSelectedId.InternalId,
                                                                        token).ConfigureAwait(false)
                                         || (await CharacterObject.Armor.FindArmorGearAsync(strSelectedId.InternalId, token).ConfigureAwait(false)).Item1 != null;
                    }
                }
                // Weapons Tab.
                else if (objSelectedGearTabPage == tabWeapons)
                {
                    if (await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                        IHasInternalId objSelected)
                    {
                        switch (await GlobalSettings.GetClipboardContentTypeAsync(token).ConfigureAwait(false))
                        {
                            case ClipboardContentType.Weapon:
                                blnPasteEnabled = true;
                                break;

                            case ClipboardContentType.Gear:
                            case ClipboardContentType.WeaponAccessory:
                                blnPasteEnabled = objSelected is ICanPaste objCanPaste && await objCanPaste.AllowPasteXml(GenericToken).ConfigureAwait(false);
                                break;
                        }

                        //TODO: ICanCopy interface? If weapon comes from something else == false, etc.
                        blnCopyEnabled = objSelected is Weapon || objSelected is Gear;
                    }
                }
                // Gear Tab.
                else if (objSelectedGearTabPage == tabGear
                         && await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token)
                                         .ConfigureAwait(false) is IHasInternalId
                             objSelected)
                {
                    blnPasteEnabled = await GlobalSettings.GetClipboardContentTypeAsync(token).ConfigureAwait(false) == ClipboardContentType.Gear;
                    blnCopyEnabled = objSelected is Gear;
                }
            }
            // Cyberware Tab.
            else if (objSelectedCharacterTab == tabCyberware)
            {
                if (await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token).ConfigureAwait(false) is
                    IHasInternalId
                    objSelected)
                {
                    blnPasteEnabled = objSelected is ICanPaste selected && await selected.AllowPasteXml(GenericToken).ConfigureAwait(false)
                                      || await GlobalSettings.GetClipboardContentTypeAsync(token).ConfigureAwait(false) == ClipboardContentType.Cyberware;
                    blnCopyEnabled = objSelected is Gear || objSelected is Cyberware;
                }
            }
            // Vehicles Tab.
            else if (objSelectedCharacterTab == tabVehicles
                     && await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token)
                                         .ConfigureAwait(false) is IHasInternalId
                         objSelected)
            {
                switch (await GlobalSettings.GetClipboardContentTypeAsync(token).ConfigureAwait(false))
                {
                    case ClipboardContentType.Vehicle:
                        blnPasteEnabled = true;
                        break;

                    case ClipboardContentType.Gear:
                    case ClipboardContentType.Weapon:
                    case ClipboardContentType.WeaponAccessory:
                    {
                        blnPasteEnabled = objSelected is ICanPaste selected && await selected.AllowPasteXml(GenericToken).ConfigureAwait(false);
                    }
                        break;
                }

                // In theory any object that's not a generic string node is valid to copy here. Locations might go screwy?
                blnCopyEnabled = true;
            }

            await mnuCreateMenu.DoThreadSafeAsync(() =>
            {
                mnuEditPaste.Enabled = blnPasteEnabled;
                mnuEditCopy.Enabled = blnCopyEnabled;
            }, token).ConfigureAwait(false);
            await tsMain.DoThreadSafeAsync(() =>
            {
                tsbPaste.Enabled = blnPasteEnabled;
                tsbCopy.Enabled = blnCopyEnabled;
            }, token).ConfigureAwait(false);
        }

        private async Task AddCyberwareSuite(Improvement.ImprovementSource objSource,
                                                  CancellationToken token = default)
        {
            IAsyncDisposable objLocker =
                await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                using (ThreadSafeForm<SelectCyberwareSuite> frmPickCyberwareSuite
                       = await ThreadSafeForm<SelectCyberwareSuite>
                           .GetAsync(() => new SelectCyberwareSuite(CharacterObject, objSource), token)
                           .ConfigureAwait(false))
                {
                    if (await frmPickCyberwareSuite.ShowDialogSafeAsync(this, token).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    string strType = objSource == Improvement.ImprovementSource.Cyberware ? "cyberware" : "bioware";
                    XmlDocument objXmlDocument = await CharacterObject
                        .LoadDataAsync(strType + ".xml", string.Empty, true, token)
                        .ConfigureAwait(false);
                    XmlNode xmlSuite = objXmlDocument.TryGetNodeByNameOrId("/chummer/suites/suite",
                        frmPickCyberwareSuite.MyForm.SelectedSuite);
                    if (xmlSuite == null)
                        return;
                    Grade objGrade
                        = await Grade
                            .ConvertToCyberwareGradeAsync(xmlSuite["grade"]?.InnerTextViaPool(token), objSource, CharacterObject,
                                token).ConfigureAwait(false);

                    string strXPathPrefix = strType + "s/" + strType;
                    // Run through each of the items in the Suite and add them to the character.
                    using (XmlNodeList xmlItemList = xmlSuite.SelectNodes(strXPathPrefix))
                    {
                        if (xmlItemList?.Count > 0)
                        {
                            foreach (XmlNode xmlItem in xmlItemList)
                            {
                                string strName = xmlItem["name"]?.InnerTextViaPool(token);
                                if (string.IsNullOrEmpty(strName))
                                    continue;
                                XmlNode objXmlCyberware
                                    = objXmlDocument.TryGetNodeByNameOrId(
                                        "/chummer/" + strXPathPrefix, strName);
                                int.TryParse(xmlItem["rating"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intRating);

                                Cyberware objCyberware
                                    = await CreateSuiteCyberware(xmlItem, objXmlCyberware, objGrade, intRating,
                                        objSource, token).ConfigureAwait(false);
                                await CharacterObject.Cyberware.AddAsync(objCyberware, token).ConfigureAwait(false);
                            }
                        }
                    }
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Add a piece of Gear that was found in a PACKS Kit.
        /// </summary>
        /// <param name="objXmlGearDocument">XmlDocument that contains the Gear.</param>
        /// <param name="objXmlGear">XmlNode of the Gear to add.</param>
        /// <param name="objParentObject">Object to associate the newly-created items with.</param>
        /// <param name="blnCreateChildren">Whether the default plugins for the Gear should be created.</param>
        /// <param name="token">Cancellation token to listen to.</param>
        private async Task<Gear> AddPACKSGearAsync(XmlDocument objXmlGearDocument, XmlNode objXmlGear, object objParentObject,
                                  bool blnCreateChildren, CancellationToken token = default)
        {
            XmlNode objXmlGearNode = null;
            string strName = objXmlGear["name"]?.InnerTextViaPool(token);
            if (!string.IsNullOrEmpty(strName))
            {
                string strCategory = objXmlGear["category"]?.InnerTextViaPool(token);
                if (!string.IsNullOrEmpty(strCategory))
                    objXmlGearNode = objXmlGearDocument.TryGetNodeByNameOrId(
                        "/chummer/gears/gear", strName.CleanXPath(),
                        "(" + await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false)
                            + ") and category = " + strCategory.CleanXPath());
                else
                    objXmlGearNode = objXmlGearDocument.TryGetNodeByNameOrId(
                        "/chummer/gears/gear", strName.CleanXPath(),
                        await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false));
            }

            if (objXmlGearNode == null)
                return null;

            int.TryParse(objXmlGear["rating"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intRating);
            decimal decQty = 1;
            string strQty = objXmlGear["qty"]?.InnerTextViaPool(token);
            if (!string.IsNullOrEmpty(strQty))
            {
                decimal.TryParse(strQty, NumberStyles.Any, GlobalSettings.InvariantCultureInfo, out decQty);
            }

            List<Weapon> lstWeapons = new List<Weapon>(1);
            string strForceValue = objXmlGear.SelectSingleNodeAndCacheExpressionAsNavigator("name/@select", token)?.Value ?? string.Empty;
            Gear objNewGear = new Gear(CharacterObject);
            try
            {
                try
                {
                    await objNewGear.CreateAsync(objXmlGearNode, intRating, lstWeapons, strForceValue, true, blnCreateChildren, token: token).ConfigureAwait(false);
                    await objNewGear.SetQuantityAsync(decQty, token).ConfigureAwait(false);

                    switch (objParentObject)
                    {
                        case Character objParentCharacter:
                            await objParentCharacter.Gear.AddAsync(objNewGear, token).ConfigureAwait(false);
                            break;

                        case Gear objParentGear:
                            await objParentGear.Children.AddAsync(objNewGear, token).ConfigureAwait(false);
                            break;

                        case Armor objParentArmor:
                            await objParentArmor.GearChildren.AddAsync(objNewGear, token).ConfigureAwait(false);
                            break;

                        case ArmorMod objParentArmorMod:
                            await objParentArmorMod.GearChildren.AddAsync(objNewGear, token).ConfigureAwait(false);
                            break;

                        case WeaponAccessory objParentWeaponAccessory:
                            await objParentWeaponAccessory.GearChildren.AddAsync(objNewGear, token)
                                                          .ConfigureAwait(false);
                            break;

                        case Cyberware objParentCyberware:
                            await objParentCyberware.GearChildren.AddAsync(objNewGear, token).ConfigureAwait(false);
                            break;

                        case Vehicle objParentVehicle:
                            await objParentVehicle.GearChildren.AddAsync(objNewGear, token).ConfigureAwait(false);
                            await objNewGear.SetParentAsync(objParentVehicle, token).ConfigureAwait(false);
                            break;
                    }

                    // Look for child components.
                    using (XmlNodeList xmlChildrenList = objXmlGear.SelectNodes("gears/gear"))
                    {
                        if (xmlChildrenList?.Count > 0)
                        {
                            foreach (XmlNode xmlChild in xmlChildrenList)
                            {
                                await AddPACKSGearAsync(objXmlGearDocument, xmlChild, objNewGear, blnCreateChildren,
                                                        token).ConfigureAwait(false);
                            }
                        }
                    }
                }
                catch
                {
                    await objNewGear.RemoveAsync(false, token).ConfigureAwait(false);
                    throw;
                }
            }
            catch
            {
                if (lstWeapons.Count > 0)
                {
                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await objWeapon.DisposeAsync().ConfigureAwait(false);
                    }
                }
                throw;
            }

            // Add any Weapons created by the Gear.
            if (lstWeapons.Count > 0)
            {
                try
                {
                    foreach (Weapon objWeapon in lstWeapons)
                    {
                        await CharacterObject.Weapons.AddAsync(objWeapon, token).ConfigureAwait(false);
                    }
                }
                catch
                {
                    await objNewGear.RemoveAsync(false, token).ConfigureAwait(false);
                    throw;
                }
            }

            return objNewGear;
        }

        private async Task AddPACKSCyberwareAsync(XmlDocument xmlCyberwareDocument, XmlDocument xmlBiowareDocument,
                                       XmlDocument xmlGearDocument, XmlNode xmlCyberware, object objParentObject,
                                       bool blnCreateChildren, CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            IAsyncDisposable objLocker =
                await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(token).ConfigureAwait(false);
            try
            {
                token.ThrowIfCancellationRequested();
                Grade objGrade = await Grade.ConvertToCyberwareGradeAsync(xmlCyberware["grade"]?.InnerTextViaPool(token),
                    Improvement.ImprovementSource.Cyberware, CharacterObject, token).ConfigureAwait(false);

                int.TryParse(xmlCyberware["rating"]?.InnerTextViaPool(token), NumberStyles.Integer, GlobalSettings.InvariantCultureInfo, out int intRating);

                Improvement.ImprovementSource eSource = Improvement.ImprovementSource.Cyberware;
                string strName = xmlCyberware["name"]?.InnerTextViaPool(token);
                if (string.IsNullOrEmpty(strName))
                    return;

                XmlNode objXmlCyberwareNode = xmlCyberwareDocument.TryGetNodeByNameOrId(
                    "/chummer/cyberwares/cyberware", strName,
                    await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false));
                if (objXmlCyberwareNode == null)
                {
                    eSource = Improvement.ImprovementSource.Bioware;
                    objXmlCyberwareNode = xmlBiowareDocument.TryGetNodeByNameOrId(
                        "/chummer/biowares/bioware", strName,
                        await CharacterObjectSettings.BookXPathAsync(token: token).ConfigureAwait(false));
                    if (objXmlCyberwareNode == null)
                    {
                        return;
                    }
                }

                List<Weapon> lstWeapons = new List<Weapon>(1);
                List<Vehicle> lstVehicles = new List<Vehicle>(1);
                Cyberware objCyberware = new Cyberware(CharacterObject);
                try
                {
                    await objCyberware.CreateAsync(objXmlCyberwareNode, objGrade, eSource, intRating, lstWeapons,
                        lstVehicles,
                        true,
                        blnCreateChildren, token: token).ConfigureAwait(false);

                    switch (objParentObject)
                    {
                        case Character objParentCharacter:
                            await (await objParentCharacter.GetCyberwareAsync(token).ConfigureAwait(false)).AddAsync(objCyberware, token).ConfigureAwait(false);
                            break;

                        case Cyberware objParentCyberware:
                            await (await objParentCyberware.GetChildrenAsync(token).ConfigureAwait(false)).AddAsync(objCyberware, token).ConfigureAwait(false);
                            break;

                        case VehicleMod objParentVehicleMod:
                            await objParentVehicleMod.Cyberware.AddAsync(objCyberware, token).ConfigureAwait(false);
                            break;
                    }

                    // Add any children.
                    using (XmlNodeList xmlCyberwareList = xmlCyberware.SelectNodes("cyberwares/cyberware"))
                    {
                        if (xmlCyberwareList?.Count > 0)
                        {
                            foreach (XmlNode objXmlChild in xmlCyberwareList)
                                await AddPACKSCyberwareAsync(xmlCyberwareDocument, xmlBiowareDocument,
                                    xmlGearDocument,
                                    objXmlChild,
                                    objCyberware, blnCreateChildren, token).ConfigureAwait(false);
                        }
                    }

                    using (XmlNodeList xmlGearList = xmlCyberware.SelectNodes("gears/gear"))
                    {
                        if (xmlGearList?.Count > 0)
                        {
                            foreach (XmlNode objXmlGear in xmlGearList)
                                await AddPACKSGearAsync(xmlGearDocument, objXmlGear, objCyberware,
                                    blnCreateChildren,
                                    token).ConfigureAwait(false);
                        }
                    }

                    if (lstWeapons.Count > 0)
                    {
                        await lstWeapons.ForEachAsync(objWeapon => CharacterObject.Weapons.AddAsync(objWeapon, token),
                            token).ConfigureAwait(false);
                    }

                    if (lstVehicles.Count > 0)
                    {
                        await lstVehicles.ForEachAsync(
                            objVehicle => CharacterObject.Vehicles.AddAsync(objVehicle, token),
                            token).ConfigureAwait(false);
                    }
                }
                catch
                {
                    if (lstWeapons.Count > 0)
                    {
                        foreach (Weapon objWeapon in lstWeapons)
                        {
                            await objWeapon.DeleteWeaponAsync(token: CancellationToken.None).ConfigureAwait(false);
                        }
                    }

                    if (lstVehicles.Count > 0)
                    {
                        foreach (Vehicle objVehicle in lstVehicles)
                        {
                            await objVehicle.DeleteVehicleAsync(token: CancellationToken.None).ConfigureAwait(false);
                        }
                    }

                    await objCyberware.DeleteCyberwareAsync(token: CancellationToken.None).ConfigureAwait(false);
                    throw;
                }
            }
            finally
            {
                await objLocker.DisposeAsync().ConfigureAwait(false);
            }
        }

        #endregion Custom Methods

        private async void tsMetamagicAddMetamagic_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        InitiationGrade objGrade))
                    return;

                using (ThreadSafeForm<SelectMetamagic> frmPickMetamagic
                       = await ThreadSafeForm<SelectMetamagic>.GetAsync(
                           () => new SelectMetamagic(CharacterObject, objGrade), GenericToken).ConfigureAwait(false))
                {
                    // Make sure a value was selected.
                    if (await frmPickMetamagic.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    Metamagic objNewMetamagic = new Metamagic(CharacterObject);

                    XmlNode objXmlMetamagic;
                    Improvement.ImprovementSource objSource;
                    if (await CharacterObject.GetRESEnabledAsync(GenericToken).ConfigureAwait(false))
                    {
                        objXmlMetamagic
                            = (await CharacterObject.LoadDataAsync("echoes.xml", token: GenericToken)
                                                    .ConfigureAwait(false)).TryGetNodeByNameOrId(
                                "/chummer/echoes/echo", frmPickMetamagic.MyForm.SelectedMetamagic);
                        objSource = Improvement.ImprovementSource.Echo;
                    }
                    else
                    {
                        objXmlMetamagic
                            = (await CharacterObject.LoadDataAsync("metamagic.xml", token: GenericToken)
                                                    .ConfigureAwait(false))
                            .TryGetNodeByNameOrId("/chummer/metamagics/metamagic",
                                                  frmPickMetamagic.MyForm.SelectedMetamagic);
                        objSource = Improvement.ImprovementSource.Metamagic;
                    }

                    await objNewMetamagic.CreateAsync(objXmlMetamagic, objSource, token: GenericToken).ConfigureAwait(false);
                    objNewMetamagic.Grade = objGrade.Grade;
                    if (objNewMetamagic.InternalId.IsEmptyGuid())
                        return;

                    await CharacterObject.Metamagics.AddAsync(objNewMetamagic, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicAddArt_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is InitiationGrade objGrade))
                    return;

                using (ThreadSafeForm<SelectArt> frmPickArt
                       = await ThreadSafeForm<SelectArt>.GetAsync(
                                                            () => new SelectArt(CharacterObject, SelectArt.Mode.Art),
                                                            GenericToken)
                                                        .ConfigureAwait(false))
                {
                    // Make sure a value was selected.
                    if (await frmPickArt.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    XmlNode objXmlArt
                        = (await CharacterObject.LoadDataAsync("metamagic.xml", token: GenericToken)
                                                .ConfigureAwait(false))
                        .TryGetNodeByNameOrId("/chummer/arts/art", frmPickArt.MyForm.SelectedItem);

                    Art objArt = new Art(CharacterObject);

                    await objArt.CreateAsync(objXmlArt, Improvement.ImprovementSource.Metamagic, GenericToken).ConfigureAwait(false);
                    objArt.Grade = objGrade.Grade;
                    if (objArt.InternalId.IsEmptyGuid())
                        return;

                    await CharacterObject.Arts.AddAsync(objArt, GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicAddEnchantment_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is InitiationGrade objGrade))
                    return;

                using (ThreadSafeForm<SelectArt> frmPickArt
                       = await ThreadSafeForm<SelectArt>.GetAsync(
                                                            () => new SelectArt(CharacterObject,
                                                                SelectArt.Mode.Enchantment), GenericToken)
                                                        .ConfigureAwait(false))
                {
                    // Make sure a value was selected.
                    if (await frmPickArt.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    XmlNode objXmlArt
                        = (await CharacterObject.LoadDataAsync("spells.xml", token: GenericToken).ConfigureAwait(false))
                        .TryGetNodeByNameOrId("/chummer/spells/spell", frmPickArt.MyForm.SelectedItem);

                    Spell objNewSpell = new Spell(CharacterObject);

                    try
                    {
                        await objNewSpell.CreateAsync(objXmlArt, string.Empty, false, false, false,
                            Improvement.ImprovementSource.Initiation, GenericToken).ConfigureAwait(false);
                        objNewSpell.Grade = objGrade.Grade;
                        if (objNewSpell.InternalId.IsEmptyGuid())
                        {
                            await objNewSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            return;
                        }

                        await CharacterObject.Spells.AddAsync(objNewSpell, GenericToken).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objNewSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicAddRitual_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token: GenericToken)
                                        .ConfigureAwait(false) is InitiationGrade objGrade))
                    return;

                using (ThreadSafeForm<SelectArt> frmPickArt
                       = await ThreadSafeForm<SelectArt>.GetAsync(
                                                            () => new SelectArt(CharacterObject, SelectArt.Mode.Ritual),
                                                            GenericToken)
                                                        .ConfigureAwait(false))
                {
                    // Make sure a value was selected.
                    if (await frmPickArt.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    XmlNode objXmlArt
                        = (await CharacterObject.LoadDataAsync("spells.xml", token: GenericToken).ConfigureAwait(false))
                        .TryGetNodeByNameOrId("/chummer/spells/spell", frmPickArt.MyForm.SelectedItem);

                    Spell objNewSpell = new Spell(CharacterObject);
                    try
                    {
                        await objNewSpell.CreateAsync(objXmlArt, string.Empty, false, false, false,
                            Improvement.ImprovementSource.Initiation, GenericToken).ConfigureAwait(false);
                        objNewSpell.Grade = objGrade.Grade;
                        if (objNewSpell.InternalId.IsEmptyGuid())
                        {
                            await objNewSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                            return;
                        }

                        await CharacterObject.Spells.AddAsync(objNewSpell, GenericToken).ConfigureAwait(false);
                    }
                    catch
                    {
                        await objNewSpell.RemoveAsync(false, CancellationToken.None).ConfigureAwait(false);
                        throw;
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsInitiationNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void tsMetamagicAddEnhancement_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treMetamagic.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is InitiationGrade objGrade))
                    return;

                using (ThreadSafeForm<SelectArt> frmPickArt
                       = await ThreadSafeForm<SelectArt>.GetAsync(
                                                            () => new SelectArt(CharacterObject,
                                                                SelectArt.Mode.Enhancement), GenericToken)
                                                        .ConfigureAwait(false))
                {
                    // Make sure a value was selected.
                    if (await frmPickArt.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;

                    XmlNode objXmlArt
                        = (await CharacterObject.LoadDataAsync("powers.xml", token: GenericToken).ConfigureAwait(false))
                        .TryGetNodeByNameOrId("/chummer/enhancements/enhancement", frmPickArt.MyForm.SelectedItem);
                    if (objXmlArt == null)
                        return;

                    Enhancement objEnhancement = new Enhancement(CharacterObject);
                    await objEnhancement.CreateAsync(objXmlArt, Improvement.ImprovementSource.Initiation, token: GenericToken).ConfigureAwait(false);
                    objEnhancement.Grade = objGrade.Grade;
                    if (objEnhancement.InternalId.IsEmptyGuid())
                        return;

                    // Find the associated Power
                    string strPower = objXmlArt["power"]?.InnerTextViaPool(GenericToken);
                    Power objPower = await CharacterObject.Powers
                                                          .FirstOrDefaultAsync(
                                                              x => x.Name == strPower
                                                                   || string.Equals(
                                                                       x.SourceIDString, strPower,
                                                                       StringComparison.OrdinalIgnoreCase), GenericToken)
                                                          .ConfigureAwait(false);
                    if (objPower != null)
                    {
                        await objPower.Enhancements.AddAsync(objEnhancement, GenericToken).ConfigureAwait(false);
                    }
                    else
                    {
                        // Add it to the character instead
                        await CharacterObject.Enhancements.AddAsync(objEnhancement, GenericToken).ConfigureAwait(false);
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void panContacts_Click(object sender, EventArgs e)
        {
            panContacts.Focus();
        }

        private void panContacts_DragDrop(object sender, DragEventArgs e)
        {
            Point mousePosition = panContacts.PointToClient(new Point(e.X, e.Y));
            Control destination = panContacts.GetChildAtPoint(mousePosition);

            if (destination != null)
            {
                TransportWrapper wrapper = (TransportWrapper)e.Data.GetData(typeof(TransportWrapper));
                Control source = wrapper.Control;

                int indexDestination = panContacts.Controls.IndexOf(destination);
                if (panContacts.Controls.IndexOf(source) < indexDestination)
                    indexDestination--;

                panContacts.Controls.SetChildIndex(source, indexDestination);
            }

            foreach (ContactControl objControl in panContacts.Controls)
            {
                objControl.BackColor = ColorManager.Control;
            }
        }

        private void panContacts_DragOver(object sender, DragEventArgs e)
        {
            Point mousePosition = panContacts.PointToClient(new Point(e.X, e.Y));
            Control destination = panContacts.GetChildAtPoint(mousePosition);

            if (destination == null)
                return;

            destination.BackColor = ColorManager.ControlDarker;
            foreach (ContactControl objControl in panContacts.Controls)
            {
                if (objControl != destination as ContactControl)
                {
                    objControl.BackColor = ColorManager.Control;
                }
            }
            // Highlight the Node that we're currently dragging over, provided it is of the same level or higher.
        }

        private void panContacts_DragEnter(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Move;
        }

        private void panEnemies_Click(object sender, EventArgs e)
        {
            panEnemies.Focus();
        }

        private async void tsAddTechniqueNotes_Click(object sender, EventArgs e)
        {
            try
            {
                await WriteNotes(
                    await treMartialArts.DoThreadSafeFuncAsync(x => x.SelectedNode, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void btnCreateBackstory_Click(object sender, EventArgs e)
        {
            try
            {
                CursorWait objCursorWait
                    = await CursorWait.NewAsync(this, true, token: GenericToken).ConfigureAwait(false);
                try
                {
                    StoryBuilder objBuilder = new StoryBuilder(CharacterObject);
                    if (Interlocked.CompareExchange(ref _objStoryBuilder, objBuilder, null) == null)
                    {
                        await btnCreateBackstory.DoThreadSafeAsync(x => x.Enabled = false, token: GenericToken)
                            .ConfigureAwait(false);
                    }
                    else
                        await objBuilder.DisposeAsync().ConfigureAwait(false);

                    await CharacterObject
                        .SetBackgroundAsync(await _objStoryBuilder.GetStory(token: GenericToken).ConfigureAwait(false),
                            GenericToken).ConfigureAwait(false);
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuSpecialConfirmValidity_Click(object sender, EventArgs e)
        {
            try
            {
                if (await CheckCharacterValidity(token: GenericToken).ConfigureAwait(false))
                {
                    await Program.ShowScrollableMessageBoxAsync(
                        this, await LanguageManager.GetStringAsync("Message_ValidCharacter", token: GenericToken).ConfigureAwait(false),
                        await LanguageManager.GetStringAsync("MessageTitle_ValidCharacter", token: GenericToken).ConfigureAwait(false),
                        MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboPrimaryArm_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsLoading || IsRefreshing)
                return;

            try
            {
                if (await CharacterObject.GetAmbidextrousAsync(GenericToken).ConfigureAwait(false))
                    return;
                await CharacterObject
                    .SetPrimaryArmAsync(
                        await cboPrimaryArm.DoThreadSafeFuncAsync(x => x.SelectedValue.ToString(), GenericToken)
                            .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task AttributeBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshAttributesClearBindings(pnlAttributes, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task AttributeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshAttributes(pnlAttributes, e, lblAttributes,
                    await lblAttributesBase.DoThreadSafeFuncAsync(x => x.PreferredWidth, token)
                        .ConfigureAwait(false),
                    await lblAttributesKarma.DoThreadSafeFuncAsync(x => x.PreferredWidth, token)
                        .ConfigureAwait(false),
                    await lblAttributesAug
                        .DoThreadSafeFuncAsync(x => x.PreferredWidth, token)
                        .ConfigureAwait(false),
                    await lblAttributesMetatype
                        .DoThreadSafeFuncAsync(x => x.PreferredWidth, token)
                        .ConfigureAwait(false), token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task PowersBeforeRemove(object sender, RemovingOldEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshPowerCollectionBeforeRemove(treMetamagic, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task PowersListChanged(object sender, ListChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshPowerCollectionListChanged(treMetamagic, cmsMetamagic, cmsInitiationNotes, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task SpellCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshSpells(treSpells, treMetamagic, cmsSpell, cmsInitiationNotes, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ComplexFormCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshComplexForms(treComplexForms, treMetamagic, cmsComplexForm, cmsInitiationNotes, e,
                                          token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ArtCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshArtCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task EnhancementCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshEnhancementCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task MetamagicCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshMetamagicCollection(treMetamagic, cmsMetamagic, cmsInitiationNotes, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task InitiationGradeCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshInitiationGrades(treMetamagic, cmsMetamagic, cmsInitiationNotes, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task AIProgramCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshAIPrograms(treAIPrograms, cmsAdvancedProgram, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task CritterPowerCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshCritterPowers(treCritterPowers, cmsCritterPowers, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task QualityCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshQualities(treQualities, cmsQuality, _fntNormal, _fntStrikeout, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task MartialArtBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshMartialArtsClearBindings(treMartialArts, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task MartialArtCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshMartialArts(treMartialArts, cmsMartialArts, cmsTechnique, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task LifestylesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshLifestyles(treLifestyles, cmsLifestyleNotes, cmsAdvancedLifestyle, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ContactBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshContactsClearBindings(panContacts, panEnemies, panPets, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ContactCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshContacts(panContacts, panEnemies, panPets, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task SpiritBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshSpiritsClearBindings(panSpirits, panSprites, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task SpiritCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshSpirits(panSpirits, panSprites, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ArmorBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshArmorClearBindings(treArmor, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ArmorCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshArmor(treArmor, cmsArmorLocation, cmsArmor, cmsArmorMod, cmsArmorGear, e,
                                   token: token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ArmorLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshArmorLocations(treArmor, cmsArmorLocation, e, token: token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task WeaponBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshWeaponsClearBindings(treWeapons, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task WeaponCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshWeapons(treWeapons, cmsWeaponLocation, cmsWeapon, cmsWeaponAccessory,
                                     cmsWeaponAccessoryGear, e, token: token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task WeaponLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshWeaponLocations(treWeapons, cmsWeaponLocation, e, token: token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task DrugCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshDrugs(treCustomDrugs, e, token: token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task GearBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshGearsClearBindings(treGear, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task GearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshGears(treGear, cmsGearLocation, cmsGear, cmsGearAllowRename,
                                   await chkCommlinks.DoThreadSafeFuncAsync(x => x.Checked, token)
                                                     .ConfigureAwait(false), false, e, token)
                    .ConfigureAwait(false);
                await RefreshFociFromGear(treFoci, null, e, token: token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task GearLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshGearLocations(treGear, cmsGearLocation, e, token: token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task CyberwareBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshCyberwareClearBindings(treCyberware, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task CyberwareCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshCyberware(treCyberware, cmsCyberware, cmsCyberwareGear, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task VehicleBeforeClearCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshVehiclesClearBindings(treMartialArts, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task VehicleCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshVehicles(treVehicles, cmsVehicleLocation, cmsVehicle, cmsVehicleWeapon,
                                      cmsVehicleWeaponAccessory, cmsVehicleWeaponAccessoryGear, cmsVehicleGear,
                                      cmsWeaponMount, cmsVehicleCyberware, cmsVehicleCyberwareGear, e, token)
                    .ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task VehicleLocationCollectionChanged(object sender, NotifyCollectionChangedEventArgs e, CancellationToken token = default)
        {
            try
            {
                await RefreshVehicleLocations(treVehicles, cmsVehicleLocation, e, token).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void picMugshot_SizeChanged(object sender, EventArgs e)
        {
            try
            {
                await ProcessMugshot(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async Task ProcessMugshot(CancellationToken token = default)
        {
            token.ThrowIfCancellationRequested();
            if (await this.DoThreadSafeFuncAsync(x => x.IsNullOrDisposed(), token).ConfigureAwait(false))
                return;
            await picMugshot.DoThreadSafeAsync(x =>
            {
                if (x.Disposing || x.IsDisposed)
                    return;
                try
                {
                    x.SizeMode = x.Image != null && x.Height >= x.Image.Height
                                                 && x.Width >= x.Image.Width
                        ? PictureBoxSizeMode.CenterImage
                        : PictureBoxSizeMode.Zoom;
                }
                catch (ArgumentException) // No other way to catch when the Image is not null, but is disposed
                {
                    x.SizeMode = PictureBoxSizeMode.Zoom;
                }
            }, token).ConfigureAwait(false);
        }

        private async void mnuSpecialKarmaValue_Click(object sender, EventArgs e)
        {
            try
            {
                string strReturn;
                CursorWait objCursorWait = await CursorWait.NewAsync(this, true, GenericToken).ConfigureAwait(false);
                try
                {
                    strReturn = (await CharacterObject.CalculateKarmaValue(
                        GlobalSettings.Language, GlobalSettings.CultureInfo, GenericToken).ConfigureAwait(false)).Item1;
                }
                finally
                {
                    await objCursorWait.DisposeAsync().ConfigureAwait(false);
                }

                await Program.ShowScrollableMessageBoxAsync(this, strReturn,
                    await LanguageManager
                        .GetStringAsync("MessageTitle_KarmaValue", token: GenericToken)
                        .ConfigureAwait(false),
                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cmdCyberwareChangeMount_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is Cyberware objModularCyberware))
                    return;
                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    string strSelectedParentID;
                    using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                               Utils.ListItemListPool, out List<ListItem> lstModularMounts))
                    {
                        List<ListItem> lstModularCyberlimbList = await CharacterObject
                            .ConstructModularCyberlimbListAsync(
                                objModularCyberware, true, GenericToken).ConfigureAwait(false);
                        try
                        {
                            lstModularMounts.AddRange(lstModularCyberlimbList);
                        }
                        finally
                        {
                            Utils.ListItemListPool.Return(ref lstModularCyberlimbList);
                        }
                        //Mounted cyberware should always be allowed to be dismounted.
                        //Unmounted cyberware requires that a valid mount be present.
                        if (!await objModularCyberware.GetIsModularCurrentlyEquippedAsync(GenericToken)
                                .ConfigureAwait(false)
                            && (lstModularMounts.Count == 0 || lstModularMounts.TrueForAll(
                                x => !string.Equals(x.Value.ToString(), "None", StringComparison.Ordinal))))
                        {
                            await Program.ShowScrollableMessageBoxAsync(this,
                                    await LanguageManager.GetStringAsync("Message_NoValidModularMount",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync("MessageTitle_NoValidModularMount",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken)
                                .ConfigureAwait(false);
                            return;
                        }

                        string strDescription = await LanguageManager
                            .GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken)
                            .ConfigureAwait(false);
                        using (ThreadSafeForm<SelectItem> frmPickMount = await ThreadSafeForm<SelectItem>.GetAsync(
                                   () => new SelectItem(), GenericToken).ConfigureAwait(false))
                        {
                            await frmPickMount.MyForm.DoThreadSafeAsync(x => x.Description = strDescription, GenericToken).ConfigureAwait(false);
                            frmPickMount.MyForm.SetGeneralItemsMode(lstModularMounts);

                            // Make sure the dialogue window was not canceled.
                            if (await frmPickMount.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                            {
                                return;
                            }

                            strSelectedParentID = await frmPickMount.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, GenericToken).ConfigureAwait(false);
                        }
                    }

                    Cyberware objOldParent = await objModularCyberware.GetParentAsync(GenericToken).ConfigureAwait(false);
                    if (objOldParent != null)
                        await objModularCyberware.ChangeModularEquipAsync(false, token: GenericToken)
                            .ConfigureAwait(false);

                    if (strSelectedParentID == "None")
                    {
                        if (objOldParent != null)
                        {
                            await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, token: GenericToken)
                                .ConfigureAwait(false);

                            await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, token: GenericToken)
                                .ConfigureAwait(false);
                        }
                    }
                    else
                    {
                        Cyberware objNewParent = await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false))
                            .DeepFindByIdAsync(strSelectedParentID, GenericToken).ConfigureAwait(false);
                        if (objNewParent != null)
                        {
                            if (objOldParent != null)
                                await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, token: GenericToken)
                                    .ConfigureAwait(false);
                            else
                                await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, token: GenericToken)
                                    .ConfigureAwait(false);

                            await (await objNewParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, token: GenericToken)
                                .ConfigureAwait(false);

                            await objModularCyberware.ChangeModularEquipAsync(true, token: GenericToken)
                                .ConfigureAwait(false);
                        }
                        else
                        {
                            ThreadSafeObservableCollection<Vehicle> lstVehicles
                                = await CharacterObject.GetVehiclesAsync(GenericToken).ConfigureAwait(false);
                            VehicleMod objNewVehicleModParent
                                = (await lstVehicles
                                    .FindVehicleModAsync(x => x.InternalId == strSelectedParentID, GenericToken)
                                    .ConfigureAwait(false)).Item1;
                            if (objNewVehicleModParent == null)
                                (objNewParent, objNewVehicleModParent)
                                    = await lstVehicles
                                        .FindVehicleCyberwareAsync(x => x.InternalId == strSelectedParentID,
                                            GenericToken).ConfigureAwait(false);

                            if (objNewVehicleModParent != null || objNewParent != null)
                            {
                                if (objOldParent != null)
                                    await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, token: GenericToken)
                                        .ConfigureAwait(false);
                                else
                                    await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false))
                                        .RemoveAsync(objModularCyberware, token: GenericToken)
                                        .ConfigureAwait(false);

                                if (objNewParent != null)
                                    await (await objNewParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, token: GenericToken)
                                        .ConfigureAwait(false);
                                else
                                    await objNewVehicleModParent.Cyberware
                                        .AddAsync(objModularCyberware, token: GenericToken)
                                        .ConfigureAwait(false);
                            }
                            else if (objOldParent != null)
                            {
                                await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, token: GenericToken)
                                    .ConfigureAwait(false);

                                await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, token: GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void cmdVehicleCyberwareChangeMount_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Cyberware objModularCyberware))
                    return;
                GenericToken.ThrowIfCancellationRequested();
                IAsyncDisposable objLocker = await CharacterObject.LockObject.EnterUpgradeableReadLockAsync(GenericToken).ConfigureAwait(false);
                try
                {
                    GenericToken.ThrowIfCancellationRequested();
                    string strSelectedParentID;
                    using (new FetchSafelyFromSafeObjectPool<List<ListItem>>(
                               Utils.ListItemListPool, out List<ListItem> lstModularMounts))
                    {
                        List<ListItem> lstModularCyberlimbList = await CharacterObject
                            .ConstructModularCyberlimbListAsync(
                                objModularCyberware, true, GenericToken).ConfigureAwait(false);
                        try
                        {
                            lstModularMounts.AddRange(lstModularCyberlimbList);
                        }
                        finally
                        {
                            Utils.ListItemListPool.Return(ref lstModularCyberlimbList);
                        }
                        //Mounted cyberware should always be allowed to be dismounted.
                        //Unmounted cyberware requires that a valid mount be present.
                        if (!await objModularCyberware.GetIsModularCurrentlyEquippedAsync(GenericToken)
                                .ConfigureAwait(false)
                            && (lstModularMounts.Count == 0 || lstModularMounts.TrueForAll(
                                x => !string.Equals(x.Value.ToString(), "None", StringComparison.OrdinalIgnoreCase))))
                        {
                            await Program.ShowScrollableMessageBoxAsync(this,
                                    await LanguageManager.GetStringAsync("Message_NoValidModularMount",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    await LanguageManager.GetStringAsync("MessageTitle_NoValidModularMount",
                                            token: GenericToken)
                                        .ConfigureAwait(false),
                                    MessageBoxButtons.OK, MessageBoxIcon.Information, token: GenericToken)
                                .ConfigureAwait(false);
                            return;
                        }

                        string strDescription = await LanguageManager
                            .GetStringAsync("MessageTitle_SelectCyberware", token: GenericToken)
                            .ConfigureAwait(false);
                        using (ThreadSafeForm<SelectItem> frmPickMount = await ThreadSafeForm<SelectItem>.GetAsync(
                                   () => new SelectItem(), GenericToken).ConfigureAwait(false))
                        {
                            await frmPickMount.MyForm.DoThreadSafeAsync(x => x.Description = strDescription, GenericToken).ConfigureAwait(false);
                            frmPickMount.MyForm.SetGeneralItemsMode(lstModularMounts);

                            // Make sure the dialogue window was not canceled.
                            if (await frmPickMount.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                                == DialogResult.Cancel)
                            {
                                return;
                            }

                            strSelectedParentID = await frmPickMount.MyForm.DoThreadSafeFuncAsync(x => x.SelectedItem, GenericToken).ConfigureAwait(false);
                        }
                    }

                    VehicleMod objOldParentVehicleMod = (await (await CharacterObject.GetVehiclesAsync(GenericToken).ConfigureAwait(false))
                        .FindVehicleCyberwareAsync(x => x.InternalId == objModularCyberware.InternalId, GenericToken)
                        .ConfigureAwait(false)).Item2;
                    Cyberware objOldParent = await objModularCyberware.GetParentAsync(GenericToken).ConfigureAwait(false);
                    if (objOldParent != null)
                        await objModularCyberware.ChangeModularEquipAsync(false, token: GenericToken)
                            .ConfigureAwait(false);
                    if (strSelectedParentID == "None")
                    {
                        if (objOldParent != null)
                            await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                .ConfigureAwait(false);
                        else
                            await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware, GenericToken)
                                .ConfigureAwait(false);

                        await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                            .ConfigureAwait(false);
                    }
                    else
                    {
                        Cyberware objNewParent = await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false))
                            .DeepFindByIdAsync(strSelectedParentID, GenericToken).ConfigureAwait(false);
                        if (objNewParent != null)
                        {
                            if (objOldParent != null)
                                await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                    .ConfigureAwait(false);
                            else
                                await objOldParentVehicleMod.Cyberware.RemoveAsync(objModularCyberware, GenericToken)
                                    .ConfigureAwait(false);

                            await (await objNewParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                                .ConfigureAwait(false);

                            await objModularCyberware.ChangeModularEquipAsync(true, token: GenericToken)
                                .ConfigureAwait(false);
                        }
                        else
                        {
                            ThreadSafeObservableCollection<Vehicle> lstVehicles
                                = await CharacterObject.GetVehiclesAsync(GenericToken).ConfigureAwait(false);
                            VehicleMod objNewVehicleModParent
                                = (await lstVehicles
                                    .FindVehicleModAsync(x => x.InternalId == strSelectedParentID, GenericToken)
                                    .ConfigureAwait(false)).Item1;
                            if (objNewVehicleModParent == null)
                                (objNewParent, objNewVehicleModParent)
                                    = await lstVehicles.FindVehicleCyberwareAsync(
                                        x => x.InternalId == strSelectedParentID, GenericToken).ConfigureAwait(false);

                            if (objNewVehicleModParent != null || objNewParent != null)
                            {
                                if (objOldParent != null)
                                    await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);
                                else
                                    await objOldParentVehicleMod.Cyberware
                                        .RemoveAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);

                                if (objNewParent != null)
                                    await (await objNewParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);
                                else
                                    await objNewVehicleModParent.Cyberware.AddAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);
                            }
                            else
                            {
                                if (objOldParent != null)
                                    await (await objOldParent.GetChildrenAsync(GenericToken).ConfigureAwait(false)).RemoveAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);
                                else
                                    await objOldParentVehicleMod.Cyberware
                                        .RemoveAsync(objModularCyberware, GenericToken)
                                        .ConfigureAwait(false);

                                await (await CharacterObject.GetCyberwareAsync(GenericToken).ConfigureAwait(false)).AddAsync(objModularCyberware, GenericToken)
                                    .ConfigureAwait(false);
                            }
                        }
                    }
                }
                finally
                {
                    await objLocker.DisposeAsync().ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void cmdContactsExpansionToggle_Click(object sender, EventArgs e)
        {
            try
            {
                Control.ControlCollection lstControls
                    = await panContacts.DoThreadSafeFuncAsync(x => x.Controls, GenericToken).ConfigureAwait(false);
                if (lstControls.Count == 0)
                    return;
                await panContacts.DoThreadSafeAsync(x => x.SuspendLayout(), GenericToken).ConfigureAwait(false);
                try
                {
                    bool toggle = await ((ContactControl)lstControls[0]).GetExpandedAsync(GenericToken)
                                                                         .ConfigureAwait(false);

                    foreach (ContactControl c in lstControls)
                    {
                        await c.SetExpandedAsync(!toggle, GenericToken).ConfigureAwait(false);
                    }
                }
                finally
                {
                    await panContacts.DoThreadSafeAsync(x => x.ResumeLayout(), GenericToken).ConfigureAwait(false);
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void cmdSwapContactOrder_Click(object sender, EventArgs e)
        {
            panContacts.FlowDirection = panContacts.FlowDirection == FlowDirection.LeftToRight
                ? FlowDirection.TopDown
                : FlowDirection.LeftToRight;
        }

        private async void tsWeaponLocationAddWeapon_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is Location
                        objLocation))
                    return;
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddWeapon(objLocation, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void tsVehicleLocationAddVehicle_Click(object sender, EventArgs e)
        {
            try
            {
                bool blnAddAgain;
                do
                {
                    blnAddAgain = await AddVehicle(
                        await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                         .ConfigureAwait(false) as Location, GenericToken).ConfigureAwait(false);
                } while (blnAddAgain);
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void tsEditWeaponMount_Click(object sender, EventArgs e)
        {
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is WeaponMount
                        objWeaponMount))
                    return;
                using (ThreadSafeForm<CreateWeaponMount> frmCreateWeaponMount
                       = await ThreadSafeForm<CreateWeaponMount>.GetAsync(
                           () => new CreateWeaponMount(objWeaponMount.Parent, CharacterObject, objWeaponMount),
                           GenericToken).ConfigureAwait(false))
                {
                    if (await frmCreateWeaponMount.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false)
                        == DialogResult.Cancel)
                        return;
                }

                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void btnCreateCustomDrug_Click_1(object sender, EventArgs e)
        {
            try
            {
                using (ThreadSafeForm<CreateCustomDrug> form
                       = await ThreadSafeForm<CreateCustomDrug>.GetAsync(
                           () => new CreateCustomDrug(CharacterObject), GenericToken).ConfigureAwait(false))
                {
                    if (await form.ShowDialogSafeAsync(this, GenericToken).ConfigureAwait(false) == DialogResult.Cancel)
                        return;

                    Drug objCustomDrug = form.MyForm.CustomDrug;
                    if (objCustomDrug != null)
                    {
                        try
                        {
                            await CharacterObject.Drugs.AddAsync(objCustomDrug, GenericToken).ConfigureAwait(false);
                        }
                        catch
                        {
                            await objCustomDrug.DisposeAsync().ConfigureAwait(false);
                            throw;
                        }
                    }
                }
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void OpenSourceFromLabel(object sender, EventArgs e)
        {
            try
            {
                await CommonFunctions.OpenPdfFromControl(sender, GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private void pnlAttributes_Layout(object sender, LayoutEventArgs e)
        {
            pnlAttributes.SuspendLayout();
            try
            {
                foreach (Control objAttributeControl in pnlAttributes.Controls)
                {
                    if (pnlAttributes.ClientSize.Width < objAttributeControl.MinimumSize.Height)
                        objAttributeControl.MinimumSize
                            = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MinimumSize.Height);
                    if (pnlAttributes.ClientSize.Width != objAttributeControl.MaximumSize.Height)
                        objAttributeControl.MaximumSize
                            = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MaximumSize.Height);
                    if (pnlAttributes.ClientSize.Width > objAttributeControl.MinimumSize.Height)
                        objAttributeControl.MinimumSize
                            = new Size(pnlAttributes.ClientSize.Width, objAttributeControl.MinimumSize.Height);
                }
            }
            finally
            {
                pnlAttributes.ResumeLayout();
            }
        }

        #region Stolen Property Changes

        private async void chkDrugStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                          .ConfigureAwait(false) is IHasStolenProperty loot))
                    return;
                await ProcessStolenChanged(
                    loot, await chkDrugStolen.DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void chkCyberwareStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is IHasStolenProperty loot))
                    return;
                await ProcessStolenChanged(
                    loot,
                    await chkCyberwareStolen.DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void chkGearStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false)
                        is IHasStolenProperty loot))
                    return;
                await ProcessStolenChanged(
                    loot, await chkGearStolen.DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void chkArmorStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken).ConfigureAwait(false)
                        is IHasStolenProperty loot))
                    return;
                await ProcessStolenChanged(
                    loot,
                    await chkArmorStolen.DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void chkWeaponStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                      .ConfigureAwait(false) is IHasStolenProperty loot))
                    return;
                await ProcessStolenChanged(
                    loot,
                    await chkWeaponStolen.DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private async void chkVehicleStolen_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is IHasStolenProperty loot))
                    return;
                await ProcessStolenChanged(
                    loot,
                    await chkVehicleStolen.DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false),
                    GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                // Swallow this
            }
        }

        private Task ProcessStolenChanged(IHasStolenProperty loot, bool state,
                                                     CancellationToken token = default)
        {
            loot.Stolen = state;
            return MakeDirtyWithCharacterUpdate(token);
        }

        #endregion Stolen Property Changes

        private async void btnDeleteCustomDrug_Click(object sender, EventArgs e)
        {
            try
            {
                await RemoveSelectedObject(
                    await treCustomDrugs.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                        .ConfigureAwait(false), GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void cboVehicleWeaponFiringMode_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;

            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is Weapon
                        objWeapon))
                    return;
                objWeapon.FireMode = await cboVehicleWeaponFiringMode.DoThreadSafeFuncAsync(x => x.SelectedIndex >= 0
                    ? (FiringMode)x.SelectedValue
                    : FiringMode.DogBrain, GenericToken).ConfigureAwait(false);
                await RefreshSelectedVehicle(GenericToken).ConfigureAwait(false);

                await SetDirty(true).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkCyberwareBlackMarketDiscount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treCyberware.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                        .ConfigureAwait(false) is
                        ICanBlackMarketDiscount objItem))
                    return;
                objItem.DiscountCost = await chkCyberwareBlackMarketDiscount
                                             .DoThreadSafeFuncAsync(x => x.Checked, GenericToken).ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkGearBlackMarketDiscount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treGear.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token: GenericToken)
                                   .ConfigureAwait(false) is
                        ICanBlackMarketDiscount objItem))
                    return;
                objItem.DiscountCost
                    = await chkGearBlackMarketDiscount.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                      .ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkArmorBlackMarketDiscount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treArmor.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                    .ConfigureAwait(false) is
                        ICanBlackMarketDiscount objItem))
                    return;
                objItem.DiscountCost
                    = await chkArmorBlackMarketDiscount.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                       .ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkWeaponBlackMarketDiscount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treWeapons.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, token: GenericToken)
                                      .ConfigureAwait(false) is
                        ICanBlackMarketDiscount objItem))
                    return;
                objItem.DiscountCost
                    = await chkWeaponBlackMarketDiscount.DoThreadSafeFuncAsync(x => x.Checked, token: GenericToken)
                                                        .ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void chkVehicleBlackMarketDiscount_CheckedChanged(object sender, EventArgs e)
        {
            if (IsRefreshing || SkipUpdate)
                return;
            try
            {
                if (!(await treVehicles.DoThreadSafeFuncAsync(x => x.SelectedNode?.Tag, GenericToken)
                                       .ConfigureAwait(false) is
                        ICanBlackMarketDiscount objItem))
                    return;
                objItem.DiscountCost
                    = await chkVehicleBlackMarketDiscount.DoThreadSafeFuncAsync(x => x.Checked, GenericToken)
                                                         .ConfigureAwait(false);
                await MakeDirtyWithCharacterUpdate(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }

        private async void mnuFileExport_Click(object sender, EventArgs e)
        {
            try
            {
                await DoExport(GenericToken).ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
                //swallow this
            }
        }
    }
}
